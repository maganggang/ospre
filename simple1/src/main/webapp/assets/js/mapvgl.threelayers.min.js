(function(yc, vh) {
	"object" === typeof exports && "undefined" !== typeof module ? vh(exports) : "function" === typeof define && define.amd ?
		define(["exports"], vh) : (yc = yc || self, vh(yc.mapvgl = yc.mapvgl || {}))
})(this, function(yc) {
	function vh() {
		throw Error("Dynamic requires are not currently supported by rollup-plugin-commonjs");
	}

	function fa(f) {
		return f && f.__esModule && Object.prototype.hasOwnProperty.call(f, "default") ? f["default"] : f
	}

	function ta(f, a) {
		return a = {
			exports: {}
		}, f(a, a.exports), a.exports
	}

	function zc() {}

	function Mi(f,
		a) {
		for (var b in a) f[b] = a[b]
	}

	function dc(f, a) {
		this.lng = f;
		this.lat = a
	}

	function mm(f, a) {
		this.x = f;
		this.y = a
	}

	function qp(f, a) {
		return function(b) {
			return a(f(b))
		}
	}

	function rp(f) {
		var a = function(a) {
			if (void 0 === a || null === a) return a;
			1 < arguments.length && (a = Array.prototype.slice.call(arguments));
			return f(a)
		};
		"conversion" in f && (a.conversion = f.conversion);
		return a
	}

	function sp(f) {
		var a = function(a) {
			if (void 0 === a || null === a) return a;
			1 < arguments.length && (a = Array.prototype.slice.call(arguments));
			var b = f(a);
			if ("object" ===
				("undefined" === typeof b ? "undefined" : Ni(b)))
				for (var d = b.length, e = 0; e < d; e++) b[e] = Math.round(b[e]);
			return b
		};
		"conversion" in f && (a.conversion = f.conversion);
		return a
	}

	function mb(f, a) {
		if (!(this instanceof mb)) return new mb(f, a);
		a && a in nm && (a = null);
		if (a && !(a in Nb)) throw Error("Unknown model: " + a);
		if ("undefined" === typeof f) this.model = "rgb", this.color = [0, 0, 0], this.valpha = 1;
		else if (f instanceof mb) this.model = f.model, this.color = f.color.slice(), this.valpha = f.valpha;
		else if ("string" === typeof f) {
			a = wh.get(f);
			if (null === a) throw Error("Unable to parse color from string: " + f);
			this.model = a.model;
			var b = Nb[this.model].channels;
			this.color = a.value.slice(0, b);
			this.valpha = "number" === typeof a.value[b] ? a.value[b] : 1
		} else if (f.length) this.model = a || "rgb", b = Nb[this.model].channels, a = xh.call(f, 0, b), this.color = Yj(a,
			b), this.valpha = "number" === typeof f[b] ? f[b] : 1;
		else if ("number" === typeof f) f &= 16777215, this.model = "rgb", this.color = [f >> 16 & 255, f >> 8 & 255, f &
			255
		], this.valpha = 1;
		else {
			this.valpha = 1;
			a = Ha(f);
			"alpha" in f && (a.splice(a.indexOf("alpha"),
				1), this.valpha = "number" === typeof f.alpha ? f.alpha : 0);
			a = a.sort().join("");
			if (!(a in Zj)) throw Error("Unable to parse color from object: " + Rd(f));
			this.model = Zj[a];
			b = Nb[this.model].labels;
			var c = [];
			for (a = 0; a < b.length; a++) c.push(f[b[a]]);
			this.color = Yj(c)
		}
		if (zg[this.model])
			for (b = Nb[this.model].channels, a = 0; a < b; a++)(f = zg[this.model][a]) && (this.color[a] = f(this.color[a]));
		this.valpha = Math.max(0, Math.min(1, this.valpha));
		Ag && Ag(this)
	}

	function tp(f) {
		return function(a) {
			return Number(a.toFixed(f))
		}
	}

	function qa(f,
		a, b) {
		f = Array.isArray(f) ? f : [f];
		f.forEach(function(c) {
			(zg[c] || (zg[c] = []))[a] = b
		});
		f = f[0];
		return function(c) {
			if (arguments.length) {
				b && (c = b(c));
				var d = this[f]();
				d.color[a] = c;
				return d
			}
			d = this[f]().color[a];
			b && (d = b(d));
			return d
		}
	}

	function Za(f) {
		return function(a) {
			return Math.max(0, Math.min(f, a))
		}
	}

	function Yj(f, a) {
		for (var b = 0; b < a; b++) "number" !== typeof f[b] && (f[b] = 0);
		return f
	}

	function nb() {}

	function B(f, a) {
		this.x = f || 0;
		this.y = a || 0
	}

	function vb(f, a, b, c) {
		this._x = f || 0;
		this._y = a || 0;
		this._z = b || 0;
		this._w = void 0 !== c ? c :
			1
	}

	function u(f, a, b) {
		this.x = f || 0;
		this.y = a || 0;
		this.z = b || 0
	}

	function kb() {
		this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
		0 < arguments.length && console.error(
			"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
	}

	function pa(f, a, b, c, d, e, g, k, l, m) {
		Object.defineProperty(this, "id", {
			value: up++
		});
		this.uuid = ha.generateUUID();
		this.name = "";
		this.image = void 0 !== f ? f : pa.DEFAULT_IMAGE;
		this.mipmaps = [];
		this.mapping = void 0 !== a ? a : pa.DEFAULT_MAPPING;
		this.wrapS = void 0 !== b ? b : 1001;
		this.wrapT = void 0 !== c ? c : 1001;
		this.magFilter =
			void 0 !== d ? d : 1006;
		this.minFilter = void 0 !== e ? e : 1008;
		this.anisotropy = void 0 !== l ? l : 1;
		this.format = void 0 !== g ? g : 1023;
		this.type = void 0 !== k ? k : 1009;
		this.offset = new B(0, 0);
		this.repeat = new B(1, 1);
		this.center = new B(0, 0);
		this.rotation = 0;
		this.matrixAutoUpdate = !0;
		this.matrix = new kb;
		this.generateMipmaps = !0;
		this.premultiplyAlpha = !1;
		this.flipY = !0;
		this.unpackAlignment = 4;
		this.encoding = void 0 !== m ? m : 3E3;
		this.version = 0;
		this.onUpdate = null
	}

	function za(f, a, b, c) {
		this.x = f || 0;
		this.y = a || 0;
		this.z = b || 0;
		this.w = void 0 !== c ? c : 1
	}

	function Oa(f,
		a, b) {
		this.width = f;
		this.height = a;
		this.scissor = new za(0, 0, f, a);
		this.scissorTest = !1;
		this.viewport = new za(0, 0, f, a);
		b = b || {};
		this.texture = new pa(void 0, void 0, b.wrapS, b.wrapT, b.magFilter, b.minFilter, b.format, b.type, b.anisotropy, b.encoding);
		this.texture.image = {};
		this.texture.image.width = f;
		this.texture.image.height = a;
		this.texture.generateMipmaps = void 0 !== b.generateMipmaps ? b.generateMipmaps : !1;
		this.texture.minFilter = void 0 !== b.minFilter ? b.minFilter : 1006;
		this.depthBuffer = void 0 !== b.depthBuffer ? b.depthBuffer :
			!0;
		this.stencilBuffer = void 0 !== b.stencilBuffer ? b.stencilBuffer : !0;
		this.depthTexture = void 0 !== b.depthTexture ? b.depthTexture : null
	}

	function om(f, a, b) {
		Oa.call(this, f, a, b);
		this.samples = 4
	}

	function ua() {
		this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		0 < arguments.length && console.error(
			"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
	}

	function Ac(f, a, b, c) {
		this._x = f || 0;
		this._y = a || 0;
		this._z = b || 0;
		this._order = c || Ac.DefaultOrder
	}

	function pm() {
		this.mask = 1
	}

	function P() {
		Object.defineProperty(this,
			"id", {
				value: vp++
			});
		this.uuid = ha.generateUUID();
		this.name = "";
		this.type = "Object3D";
		this.parent = null;
		this.children = [];
		this.up = P.DefaultUp.clone();
		var f = new u,
			a = new Ac,
			b = new vb,
			c = new u(1, 1, 1);
		a._onChange(function() {
			b.setFromEuler(a, !1)
		});
		b._onChange(function() {
			a.setFromQuaternion(b, void 0, !1)
		});
		ja(this, {
			position: {
				configurable: !0,
				enumerable: !0,
				value: f
			},
			rotation: {
				configurable: !0,
				enumerable: !0,
				value: a
			},
			quaternion: {
				configurable: !0,
				enumerable: !0,
				value: b
			},
			scale: {
				configurable: !0,
				enumerable: !0,
				value: c
			},
			modelViewMatrix: {
				value: new ua
			},
			normalMatrix: {
				value: new kb
			}
		});
		this.matrix = new ua;
		this.matrixWorld = new ua;
		this.matrixAutoUpdate = P.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = !1;
		this.layers = new pm;
		this.visible = !0;
		this.receiveShadow = this.castShadow = !1;
		this.frustumCulled = !0;
		this.renderOrder = 0;
		this.userData = {}
	}

	function Bg() {
		P.call(this);
		this.type = "Scene";
		this.overrideMaterial = this.fog = this.background = null;
		this.autoUpdate = !0;
		"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}

	function Sd(f, a) {
		this.min = void 0 !== f ? f : new u(Infinity, Infinity, Infinity);
		this.max = void 0 !== a ? a : new u(-Infinity, -Infinity, -Infinity)
	}

	function ak(f, a, b, c, d) {
		var e;
		var g = 0;
		for (e = f.length - 3; g <= e; g += 3) {
			Bc.fromArray(f, g);
			var k = d.x * Math.abs(Bc.x) + d.y * Math.abs(Bc.y) + d.z * Math.abs(Bc.z),
				l = a.dot(Bc),
				m = b.dot(Bc),
				n = c.dot(Bc);
			if (Math.max(-Math.max(l, m, n), Math.min(l, m, n)) > k) return !1
		}
		return !0
	}

	function Ne(f, a) {
		this.center = void 0 !== f ? f : new u;
		this.radius = void 0 !== a ? a : 0
	}

	function wf(f, a) {
		this.origin = void 0 !== f ? f : new u;
		this.direction = void 0 !== a ? a : new u
	}

	function ob(f, a, b) {
		this.a = void 0 !== f ? f : new u;
		this.b = void 0 !== a ? a : new u;
		this.c = void 0 !== b ? b : new u
	}

	function S(f, a, b) {
		return void 0 === a && void 0 === b ? this.set(f) : this.setRGB(f, a, b)
	}

	function Oi(f, a, b) {
		0 > b && (b += 1);
		1 < b && --b;
		return b < 1 / 6 ? f + 6 * (a - f) * b : .5 > b ? a : b < 2 / 3 ? f + 6 * (a - f) * (2 / 3 - b) : f
	}

	function yh(f) {
		return .04045 > f ? .0773993808 * f : Math.pow(.9478672986 * f + .0521327014, 2.4)
	}

	function zh(f) {
		return .0031308 > f ? 12.92 * f : 1.055 * Math.pow(f, .41666) - .055
	}

	function Ah(f, a, b, c, d, e) {
		this.a = f;
		this.b =
			a;
		this.c = b;
		this.normal = c && c.isVector3 ? c : new u;
		this.vertexNormals = Array.isArray(c) ? c : [];
		this.color = d && d.isColor ? d : new S;
		this.vertexColors = Array.isArray(d) ? d : [];
		this.materialIndex = void 0 !== e ? e : 0
	}

	function ia() {
		Object.defineProperty(this, "id", {
			value: wp++
		});
		this.uuid = ha.generateUUID();
		this.name = "";
		this.type = "Material";
		this.fog = !0;
		this.blending = 1;
		this.side = 0;
		this.vertexTangents = this.flatShading = !1;
		this.vertexColors = 0;
		this.opacity = 1;
		this.transparent = !1;
		this.blendSrc = 204;
		this.blendDst = 205;
		this.blendEquation =
			100;
		this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
		this.depthFunc = 3;
		this.depthWrite = this.depthTest = !0;
		this.stencilWriteMask = 255;
		this.stencilFunc = 519;
		this.stencilRef = 0;
		this.stencilFuncMask = 255;
		this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
		this.stencilWrite = !1;
		this.clippingPlanes = null;
		this.clipShadows = this.clipIntersection = !1;
		this.shadowSide = null;
		this.colorWrite = !0;
		this.precision = null;
		this.polygonOffset = !1;
		this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
		this.dithering = !1;
		this.alphaTest = 0;
		this.premultipliedAlpha = !1;
		this.toneMapped = this.visible = !0;
		this.userData = {};
		this.needsUpdate = !0
	}

	function Ob(f) {
		ia.call(this);
		this.type = "MeshBasicMaterial";
		this.color = new S(16777215);
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.envMap = this.alphaMap = this.specularMap = null;
		this.combine = 0;
		this.reflectivity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphTargets =
			this.skinning = !1;
		this.setValues(f)
	}

	function F(f, a, b) {
		if (Array.isArray(f)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
		this.name = "";
		this.array = f;
		this.itemSize = a;
		this.count = void 0 !== f ? f.length / a : 0;
		this.normalized = !0 === b;
		this.dynamic = !1;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0
	}

	function Bh(f, a, b) {
		F.call(this, new Int8Array(f), a, b)
	}

	function Ch(f, a, b) {
		F.call(this, new Uint8Array(f), a, b)
	}

	function Dh(f, a, b) {
		F.call(this, new Uint8ClampedArray(f), a, b)
	}

	function Eh(f, a,
		b) {
		F.call(this, new Int16Array(f), a, b)
	}

	function xf(f, a, b) {
		F.call(this, new Uint16Array(f), a, b)
	}

	function bk(f, a, b) {
		F.call(this, new Int32Array(f), a, b)
	}

	function yf(f, a, b) {
		F.call(this, new Uint32Array(f), a, b)
	}

	function N(f, a, b) {
		F.call(this, new Float32Array(f), a, b)
	}

	function Pi(f, a, b) {
		F.call(this, new Float64Array(f), a, b)
	}

	function qm() {
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
		this.groups = [];
		this.morphTargets = {};
		this.skinWeights = [];
		this.skinIndices = [];
		this.boundingSphere = this.boundingBox =
			null;
		this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !
			1
	}

	function rm(f) {
		if (0 === f.length) return -Infinity;
		for (var a = f[0], b = 1, c = f.length; b < c; ++b) f[b] > a && (a = f[b]);
		return a
	}

	function J() {
		Object.defineProperty(this, "id", {
			value: xp += 2
		});
		this.uuid = ha.generateUUID();
		this.name = "";
		this.type = "BufferGeometry";
		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingSphere = this.boundingBox = null;
		this.drawRange = {
			start: 0,
			count: Infinity
		};
		this.userData = {}
	}

	function Wa(f, a) {
		P.call(this);
		this.type = "Mesh";
		this.geometry = void 0 !== f ? f : new J;
		this.material = void 0 !== a ? a : new Ob({
			color: 16777215 * Math.random()
		});
		this.drawMode = 0;
		this.updateMorphTargets()
	}

	function sm(f, a, b, c, d, e, g, k) {
		if (null === (1 === a.side ? c.intersectTriangle(g, e, d, !0, k) : c.intersectTriangle(d, e, g, 2 !== a.side, k)))
			return null;
		Qi.copy(k);
		Qi.applyMatrix4(f.matrixWorld);
		a = b.ray.origin.distanceTo(Qi);
		return a < b.near || a > b.far ? null : {
			distance: a,
			point: Qi.clone(),
			object: f
		}
	}

	function Ri(f, a, b, c,
		d, e, g, k, l, m, n) {
		nd.fromBufferAttribute(d, l);
		Td.fromBufferAttribute(d, m);
		Ud.fromBufferAttribute(d, n);
		d = f.morphTargetInfluences;
		if (a.morphTargets && e && d) {
			Si.set(0, 0, 0);
			Fh.set(0, 0, 0);
			Ti.set(0, 0, 0);
			for (var r = 0, v = e.length; r < v; r++) {
				var A = d[r],
					w = e[r];
				0 !== A && (tm.fromBufferAttribute(w, l), um.fromBufferAttribute(w, m), vm.fromBufferAttribute(w, n), Si.addScaledVector(
					tm.sub(nd), A), Fh.addScaledVector(um.sub(Td), A), Ti.addScaledVector(vm.sub(Ud), A))
			}
			nd.add(Si);
			Td.add(Fh);
			Ud.add(Ti)
		}
		if (f = sm(f, a, b, c, nd, Td, Ud, zf)) g && (od.fromBufferAttribute(g,
				l), pd.fromBufferAttribute(g, m), Cg.fromBufferAttribute(g, n), f.uv = ob.getUV(zf, nd, Td, Ud, od, pd, Cg, new B)),
			k && (od.fromBufferAttribute(k, l), pd.fromBufferAttribute(k, m), Cg.fromBufferAttribute(k, n), f.uv2 = ob.getUV(zf,
				nd, Td, Ud, od, pd, Cg, new B)), g = new Ah(l, m, n), ob.getNormal(nd, Td, Ud, g.normal), f.face = g;
		return f
	}

	function R() {
		Object.defineProperty(this, "id", {
			value: yp += 2
		});
		this.uuid = ha.generateUUID();
		this.name = "";
		this.type = "Geometry";
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [
			[]
		];
		this.morphTargets = [];
		this.morphNormals = [];
		this.skinWeights = [];
		this.skinIndices = [];
		this.lineDistances = [];
		this.boundingSphere = this.boundingBox = null;
		this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate =
			this.verticesNeedUpdate = this.elementsNeedUpdate = !1
	}

	function qd(f) {
		var a = {},
			b;
		for (b in f) {
			a[b] = {};
			for (var c in f[b]) {
				var d = f[b][c];
				d && (d.isColor || d.isMatrix3 || d.isMatrix4 || d.isVector2 || d.isVector3 || d.isVector4 || d.isTexture) ? a[b][
						c
					] = d.clone() : Array.isArray(d) ?
					a[b][c] = d.slice() : a[b][c] = d
			}
		}
		return a
	}

	function Gb(f) {
		for (var a = {}, b = 0; b < f.length; b++) {
			var c = qd(f[b]),
				d;
			for (d in c) a[d] = c[d]
		}
		return a
	}

	function Ia(f) {
		ia.call(this);
		this.type = "ShaderMaterial";
		this.defines = {};
		this.uniforms = {};
		this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
		this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
		this.linewidth = 1;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.morphNormals = this.morphTargets =
			this.skinning = this.clipping = this.lights = this.fog = !1;
		this.extensions = {
			derivatives: !1,
			fragDepth: !1,
			drawBuffers: !1,
			shaderTextureLOD: !1
		};
		this.defaultAttributeValues = {
			color: [1, 1, 1],
			uv: [0, 0],
			uv2: [0, 0]
		};
		this.index0AttributeName = void 0;
		this.uniformsNeedUpdate = !1;
		void 0 !== f && (void 0 !== f.attributes && console.error(
			"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(f))
	}

	function Vd() {
		P.call(this);
		this.type = "Camera";
		this.matrixWorldInverse = new ua;
		this.projectionMatrix =
			new ua;
		this.projectionMatrixInverse = new ua
	}

	function ab(f, a, b, c) {
		Vd.call(this);
		this.type = "PerspectiveCamera";
		this.fov = void 0 !== f ? f : 50;
		this.zoom = 1;
		this.near = void 0 !== b ? b : .1;
		this.far = void 0 !== c ? c : 2E3;
		this.focus = 10;
		this.aspect = void 0 !== a ? a : 1;
		this.view = null;
		this.filmGauge = 35;
		this.filmOffset = 0;
		this.updateProjectionMatrix()
	}

	function Oe(f, a, b, c) {
		P.call(this);
		this.type = "CubeCamera";
		var d = new ab(90, 1, f, a);
		d.up.set(0, -1, 0);
		d.lookAt(new u(1, 0, 0));
		this.add(d);
		var e = new ab(90, 1, f, a);
		e.up.set(0, -1, 0);
		e.lookAt(new u(-1,
			0, 0));
		this.add(e);
		var g = new ab(90, 1, f, a);
		g.up.set(0, 0, 1);
		g.lookAt(new u(0, 1, 0));
		this.add(g);
		var k = new ab(90, 1, f, a);
		k.up.set(0, 0, -1);
		k.lookAt(new u(0, -1, 0));
		this.add(k);
		var l = new ab(90, 1, f, a);
		l.up.set(0, -1, 0);
		l.lookAt(new u(0, 0, 1));
		this.add(l);
		var m = new ab(90, 1, f, a);
		m.up.set(0, -1, 0);
		m.lookAt(new u(0, 0, -1));
		this.add(m);
		c = c || {
			format: 1022,
			magFilter: 1006,
			minFilter: 1006
		};
		this.renderTarget = new ec(b, b, c);
		this.renderTarget.texture.name = "CubeCamera";
		this.update = function(a, b) {
			null === this.parent && this.updateMatrixWorld();
			var c = a.getRenderTarget(),
				f = this.renderTarget,
				n = f.texture.generateMipmaps;
			f.texture.generateMipmaps = !1;
			a.setRenderTarget(f, 0);
			a.render(b, d);
			a.setRenderTarget(f, 1);
			a.render(b, e);
			a.setRenderTarget(f, 2);
			a.render(b, g);
			a.setRenderTarget(f, 3);
			a.render(b, k);
			a.setRenderTarget(f, 4);
			a.render(b, l);
			f.texture.generateMipmaps = n;
			a.setRenderTarget(f, 5);
			a.render(b, m);
			a.setRenderTarget(c)
		};
		this.clear = function(a, b, c, d) {
			for (var e = a.getRenderTarget(), f = this.renderTarget, g = 0; 6 > g; g++) a.setRenderTarget(f, g), a.clear(b, c,
				d);
			a.setRenderTarget(e)
		}
	}

	function ec(f, a, b) {
		Oa.call(this, f, a, b)
	}

	function Dg(f, a, b, c, d, e, g, k, l, m, n, r) {
		pa.call(this, null, e, g, k, l, m, c, d, n, r);
		this.image = {
			data: f || null,
			width: a || 1,
			height: b || 1
		};
		this.magFilter = void 0 !== l ? l : 1003;
		this.minFilter = void 0 !== m ? m : 1003;
		this.flipY = this.generateMipmaps = !1;
		this.unpackAlignment = 1;
		this.needsUpdate = !0
	}

	function Wd(f, a) {
		this.normal = void 0 !== f ? f : new u(1, 0, 0);
		this.constant = void 0 !== a ? a : 0
	}

	function Ui(f, a, b, c, d, e) {
		this.planes = [void 0 !== f ? f : new Wd, void 0 !== a ? a : new Wd, void 0 !==
			b ? b : new Wd, void 0 !== c ? c : new Wd, void 0 !== d ? d : new Wd, void 0 !== e ? e : new Wd
		]
	}

	function Vi() {
		function f(d, e) {
			!1 !== b && (c(d, e), a.requestAnimationFrame(f))
		}
		var a = null,
			b = !1,
			c = null;
		return {
			start: function() {
				!0 !== b && null !== c && (a.requestAnimationFrame(f), b = !0)
			},
			stop: function() {
				b = !1
			},
			setAnimationLoop: function(a) {
				c = a
			},
			setContext: function(b) {
				a = b
			}
		}
	}

	function zp(f) {
		function a(a, b) {
			var c = a.array,
				d = a.dynamic ? 35048 : 35044,
				k = f.createBuffer();
			f.bindBuffer(b, k);
			f.bufferData(b, c, d);
			a.onUploadCallback();
			b = 5126;
			c instanceof Float32Array ?
				b = 5126 : c instanceof Float64Array ? console.warn(
					"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : c instanceof Uint16Array ? b = 5123 : c instanceof Int16Array ?
				b = 5122 : c instanceof Uint32Array ? b = 5125 : c instanceof Int32Array ? b = 5124 : c instanceof Int8Array ? b =
				5120 : c instanceof Uint8Array && (b = 5121);
			return {
				buffer: k,
				type: b,
				bytesPerElement: c.BYTES_PER_ELEMENT,
				version: a.version
			}
		}
		var b = new Fa;
		return {
			get: function(a) {
				a.isInterleavedBufferAttribute && (a = a.data);
				return b.get(a)
			},
			remove: function(a) {
				a.isInterleavedBufferAttribute &&
					(a = a.data);
				var c = b.get(a);
				c && (f.deleteBuffer(c.buffer), b.delete(a))
			},
			update: function(c, d) {
				c.isInterleavedBufferAttribute && (c = c.data);
				var e = b.get(c);
				if (void 0 === e) b.set(c, a(c, d));
				else if (e.version < c.version) {
					var g = c,
						k = g.array,
						l = g.updateRange;
					f.bindBuffer(d, e.buffer);
					!1 === g.dynamic ? f.bufferData(d, k, 35044) : -1 === l.count ? f.bufferSubData(d, 0, k) : 0 === l.count ?
						console.error(
							"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
						) :
						(f.bufferSubData(d, l.offset * k.BYTES_PER_ELEMENT, k.subarray(l.offset, l.offset + l.count)), l.count = -1);
					e.version = c.version
				}
			}
		}
	}

	function Af(f, a, b, c) {
		R.call(this);
		this.type = "PlaneGeometry";
		this.parameters = {
			width: f,
			height: a,
			widthSegments: b,
			heightSegments: c
		};
		this.fromBufferGeometry(new Xd(f, a, b, c));
		this.mergeVertices()
	}

	function Xd(f, a, b, c) {
		J.call(this);
		this.type = "PlaneBufferGeometry";
		this.parameters = {
			width: f,
			height: a,
			widthSegments: b,
			heightSegments: c
		};
		f = f || 1;
		a = a || 1;
		var d = f / 2,
			e = a / 2;
		b = Math.floor(b) || 1;
		c = Math.floor(c) ||
			1;
		var g = b + 1,
			k = c + 1,
			l = f / b,
			m = a / c,
			n = [],
			r = [],
			v = [],
			A = [];
		for (f = 0; f < k; f++) {
			var w = f * m - e;
			for (a = 0; a < g; a++) r.push(a * l - d, -w, 0), v.push(0, 0, 1), A.push(a / b), A.push(1 - f / c)
		}
		for (f = 0; f < c; f++)
			for (a = 0; a < b; a++) d = a + g * (f + 1), e = a + 1 + g * (f + 1), k = a + 1 + g * f, n.push(a + g * f, d, k), n
				.push(d, e, k);
		this.setIndex(n);
		this.addAttribute("position", new N(r, 3));
		this.addAttribute("normal", new N(v, 3));
		this.addAttribute("uv", new N(A, 2))
	}

	function Ap(f, a, b, c) {
		function d(b, d) {
			a.buffers.color.setClear(b.r, b.g, b.b, d, c)
		}
		var e = new S(0),
			g = 0,
			k, l, m = null,
			n = 0;
		return {
			getClearColor: function() {
				return e
			},
			setClearColor: function(a, b) {
				e.set(a);
				g = void 0 !== b ? b : 1;
				d(e, g)
			},
			getClearAlpha: function() {
				return g
			},
			setClearAlpha: function(a) {
				g = a;
				d(e, g)
			},
			render: function(a, c, A, w) {
				c = c.background;
				A = f.vr;
				(A = A.getSession && A.getSession()) && "additive" === A.environmentBlendMode && (c = null);
				null === c ? (d(e, g), m = null, n = 0) : c && c.isColor && (d(c, 1), w = !0, m = null, n = 0);
				(f.autoClear || w) && f.clear(f.autoClearColor, f.autoClearDepth, f.autoClearStencil);
				if (c && (c.isCubeTexture || c.isWebGLRenderTargetCube)) {
					void 0 === l && (l = new Wa(new Gh(1, 1, 1), new Ia({
						type: "BackgroundCubeMaterial",
						uniforms: qd(Yd.cube.uniforms),
						vertexShader: Yd.cube.vertexShader,
						fragmentShader: Yd.cube.fragmentShader,
						side: 1,
						depthTest: !1,
						depthWrite: !1,
						fog: !1
					})), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function(a, b,
						c) {
						this.matrixWorld.copyPosition(c.matrixWorld)
					}, Object.defineProperty(l.material, "map", {
						get: function() {
							return this.uniforms.tCube.value
						}
					}), b.update(l));
					w = c.isWebGLRenderTargetCube ? c.texture : c;
					l.material.uniforms.tCube.value = w;
					l.material.uniforms.tFlip.value =
						c.isWebGLRenderTargetCube ? 1 : -1;
					if (m !== c || n !== w.version) l.material.needsUpdate = !0, m = c, n = w.version;
					a.unshift(l, l.geometry, l.material, 0, 0, null)
				} else if (c && c.isTexture) {
					void 0 === k && (k = new Wa(new Xd(2, 2), new Ia({
							type: "BackgroundMaterial",
							uniforms: qd(Yd.background.uniforms),
							vertexShader: Yd.background.vertexShader,
							fragmentShader: Yd.background.fragmentShader,
							side: 0,
							depthTest: !1,
							depthWrite: !1,
							fog: !1
						})), k.geometry.removeAttribute("normal"), Object.defineProperty(k.material, "map", {
							get: function() {
								return this.uniforms.t2D.value
							}
						}),
						b.update(k));
					k.material.uniforms.t2D.value = c;
					!0 === c.matrixAutoUpdate && c.updateMatrix();
					k.material.uniforms.uvTransform.value.copy(c.matrix);
					if (m !== c || n !== c.version) k.material.needsUpdate = !0, m = c, n = c.version;
					a.unshift(k, k.geometry, k.material, 0, 0, null)
				}
			}
		}
	}

	function Bp(f, a, b, c) {
		var d;
		this.setMode = function(a) {
			d = a
		};
		this.render = function(a, c) {
			f.drawArrays(d, a, c);
			b.update(c, d)
		};
		this.renderInstances = function(e, g, k, l) {
			if (0 !== l) {
				if (c.isWebGL2) {
					e = f;
					var m = "drawArraysInstanced"
				} else if (e = a.get("ANGLE_instanced_arrays"),
					m = "drawArraysInstancedANGLE", null === e) {
					console.error(
						"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
					);
					return
				}
				e[m](d, g, k, l);
				b.update(k, d, l)
			}
		}
	}

	function Cp(f, a, b) {
		function c(a) {
			if ("highp" === a) {
				if (0 < f.getShaderPrecisionFormat(35633, 36338).precision && 0 < f.getShaderPrecisionFormat(35632, 36338).precision)
					return "highp";
				a = "mediump"
			}
			return "mediump" === a && 0 < f.getShaderPrecisionFormat(35633, 36337).precision && 0 < f.getShaderPrecisionFormat(
				35632,
				36337).precision ? "mediump" : "lowp"
		}
		var d, e = "undefined" !== typeof WebGL2RenderingContext && f instanceof WebGL2RenderingContext,
			g = void 0 !== b.precision ? b.precision : "highp",
			k = c(g);
		k !== g && (console.warn("THREE.WebGLRenderer:", g, "not supported, using", k, "instead."), g = k);
		b = !0 === b.logarithmicDepthBuffer;
		k = f.getParameter(34930);
		var l = f.getParameter(35660),
			m = f.getParameter(3379),
			n = f.getParameter(34076),
			r = f.getParameter(34921),
			v = f.getParameter(36347),
			A = f.getParameter(36348),
			w = f.getParameter(36349),
			z = 0 < l,
			p = e || !!a.get("OES_texture_float"),
			q = z && p,
			u = e ? f.getParameter(36183) : 0;
		return {
			isWebGL2: e,
			getMaxAnisotropy: function() {
				if (void 0 !== d) return d;
				var b = a.get("EXT_texture_filter_anisotropic");
				return d = null !== b ? f.getParameter(b.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
			},
			getMaxPrecision: c,
			precision: g,
			logarithmicDepthBuffer: b,
			maxTextures: k,
			maxVertexTextures: l,
			maxTextureSize: m,
			maxCubemapSize: n,
			maxAttributes: r,
			maxVertexUniforms: v,
			maxVaryings: A,
			maxFragmentUniforms: w,
			vertexTextures: z,
			floatFragmentTextures: p,
			floatVertexTextures: q,
			maxSamples: u
		}
	}

	function Dp() {
		function f() {
			m.value !==
				c && (m.value = c, m.needsUpdate = 0 < d);
			b.numPlanes = d;
			b.numIntersection = 0
		}

		function a(a, c, d, e) {
			var f = null !== a ? a.length : 0,
				g = null;
			if (0 !== f) {
				g = m.value;
				if (!0 !== e || null === g) {
					e = d + 4 * f;
					c = c.matrixWorldInverse;
					l.getNormalMatrix(c);
					if (null === g || g.length < e) g = new Float32Array(e);
					for (e = 0; e !== f; ++e, d += 4) k.copy(a[e]).applyMatrix4(c, l), k.normal.toArray(g, d), g[d + 3] = k.constant
				}
				m.value = g;
				m.needsUpdate = !0
			}
			b.numPlanes = f;
			return g
		}
		var b = this,
			c = null,
			d = 0,
			e = !1,
			g = !1,
			k = new Wd,
			l = new kb,
			m = {
				value: null,
				needsUpdate: !1
			};
		this.uniform = m;
		this.numIntersection =
			this.numPlanes = 0;
		this.init = function(b, f, g) {
			var k = 0 !== b.length || f || 0 !== d || e;
			e = f;
			c = a(b, g, 0);
			d = b.length;
			return k
		};
		this.beginShadows = function() {
			g = !0;
			a(null)
		};
		this.endShadows = function() {
			g = !1;
			f()
		};
		this.setState = function(b, k, l, A, w, z) {
			if (!e || null === b || 0 === b.length || g && !l) g ? a(null) : f();
			else {
				l = g ? 0 : d;
				var n = 4 * l,
					r = w.clippingState || null;
				m.value = r;
				r = a(b, A, n, z);
				for (b = 0; b !== n; ++b) r[b] = c[b];
				w.clippingState = r;
				this.numIntersection = k ? this.numPlanes : 0;
				this.numPlanes += l
			}
		}
	}

	function Ep(f) {
		var a = {};
		return {
			get: function(b) {
				if (void 0 !==
					a[b]) return a[b];
				switch (b) {
					case "WEBGL_depth_texture":
						var c = f.getExtension("WEBGL_depth_texture") || f.getExtension("MOZ_WEBGL_depth_texture") || f.getExtension(
							"WEBKIT_WEBGL_depth_texture");
						break;
					case "EXT_texture_filter_anisotropic":
						c = f.getExtension("EXT_texture_filter_anisotropic") || f.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
							f.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
						break;
					case "WEBGL_compressed_texture_s3tc":
						c = f.getExtension("WEBGL_compressed_texture_s3tc") || f.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
							f.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
						break;
					case "WEBGL_compressed_texture_pvrtc":
						c = f.getExtension("WEBGL_compressed_texture_pvrtc") || f.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
						break;
					default:
						c = f.getExtension(b)
				}
				null === c && console.warn("THREE.WebGLRenderer: " + b + " extension not supported.");
				return a[b] = c
			}
		}
	}

	function Fp(f, a, b) {
		function c(d) {
			var f = d.target;
			d = e.get(f);
			null !== d.index && a.remove(d.index);
			for (var k in d.attributes) a.remove(d.attributes[k]);
			f.removeEventListener("dispose",
				c);
			e.delete(f);
			if (k = g.get(d)) a.remove(k), g.delete(d);
			b.memory.geometries--
		}

		function d(b) {
			var c = [],
				d = b.index,
				e = b.attributes.position;
			if (null !== d) {
				var f = d.array;
				d = d.version;
				e = 0;
				for (var k = f.length; e < k; e += 3) {
					var A = f[e + 0],
						w = f[e + 1],
						z = f[e + 2];
					c.push(A, w, w, z, z, A)
				}
			} else
				for (f = e.array, d = e.version, e = 0, k = f.length / 3 - 1; e < k; e += 3) A = e + 0, w = e + 1, z = e + 2, c.push(
					A, w, w, z, z, A);
			c = new(65535 < rm(c) ? yf : xf)(c, 1);
			c.version = d;
			a.update(c, 34963);
			(f = g.get(b)) && a.remove(f);
			g.set(b, c)
		}
		var e = new Fa,
			g = new Fa;
		return {
			get: function(a, d) {
				var f =
					e.get(d);
				if (f) return f;
				d.addEventListener("dispose", c);
				d.isBufferGeometry ? f = d : d.isGeometry && (void 0 === d._bufferGeometry && (d._bufferGeometry = (new J).setFromObject(
					a)), f = d._bufferGeometry);
				e.set(d, f);
				b.memory.geometries++;
				return f
			},
			update: function(b) {
				var c = b.index,
					d = b.attributes;
				null !== c && a.update(c, 34963);
				for (var e in d) a.update(d[e], 34962);
				b = b.morphAttributes;
				for (e in b) {
					c = b[e];
					d = 0;
					for (var f = c.length; d < f; d++) a.update(c[d], 34962)
				}
			},
			getWireframeAttribute: function(a) {
				var b = g.get(a);
				if (b) {
					var c = a.index;
					null !== c && b.version < c.version && d(a)
				} else d(a);
				return g.get(a)
			}
		}
	}

	function Gp(f, a, b, c) {
		var d, e, g;
		this.setMode = function(a) {
			d = a
		};
		this.setIndex = function(a) {
			e = a.type;
			g = a.bytesPerElement
		};
		this.render = function(a, c) {
			f.drawElements(d, c, e, a * g);
			b.update(c, d)
		};
		this.renderInstances = function(k, l, m, n) {
			if (0 !== n) {
				if (c.isWebGL2) {
					k = f;
					var r = "drawElementsInstanced"
				} else if (k = a.get("ANGLE_instanced_arrays"), r = "drawElementsInstancedANGLE", null === k) {
					console.error(
						"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
					);
					return
				}
				k[r](d, m, e, l * g, n);
				b.update(m, d, n)
			}
		}
	}

	function Hp(f) {
		var a = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};
		return {
			memory: {
				geometries: 0,
				textures: 0
			},
			render: a,
			programs: null,
			autoReset: !0,
			reset: function() {
				a.frame++;
				a.calls = 0;
				a.triangles = 0;
				a.points = 0;
				a.lines = 0
			},
			update: function(b, c, d) {
				d = d || 1;
				a.calls++;
				switch (c) {
					case 4:
						a.triangles += b / 3 * d;
						break;
					case 5:
					case 6:
						a.triangles += d * (b - 2);
						break;
					case 1:
						a.lines += b / 2 * d;
						break;
					case 3:
						a.lines += d * (b - 1);
						break;
					case 2:
						a.lines += d * b;
						break;
					case 0:
						a.points += d * b;
						break;
					default:
						console.error("THREE.WebGLInfo: Unknown draw mode:",
							c)
				}
			}
		}
	}

	function Ip(f, a) {
		return Math.abs(a[1]) - Math.abs(f[1])
	}

	function Jp(f) {
		var a = {},
			b = new Float32Array(8);
		return {
			update: function(c, d, e, g) {
				var k = c.morphTargetInfluences,
					l = k.length;
				c = a[d.id];
				if (void 0 === c) {
					c = [];
					for (var m = 0; m < l; m++) c[m] = [m, 0];
					a[d.id] = c
				}
				var n = e.morphTargets && d.morphAttributes.position;
				e = e.morphNormals && d.morphAttributes.normal;
				for (m = 0; m < l; m++) {
					var r = c[m];
					0 !== r[1] && (n && d.removeAttribute("morphTarget" + m), e && d.removeAttribute("morphNormal" + m))
				}
				for (m = 0; m < l; m++) r = c[m], r[0] = m, r[1] = k[m];
				c.sort(Ip);
				for (m = 0; 8 > m; m++) {
					if (r = c[m])
						if (k = r[0], l = r[1]) {
							n && d.addAttribute("morphTarget" + m, n[k]);
							e && d.addAttribute("morphNormal" + m, e[k]);
							b[m] = l;
							continue
						} b[m] = 0
				}
				g.getUniforms().setValue(f, "morphTargetInfluences", b)
			}
		}
	}

	function Kp(f, a, b, c) {
		var d = {};
		return {
			update: function(e) {
				var f = c.render.frame,
					k = e.geometry,
					l = a.get(e, k);
				d[l.id] !== f && (k.isGeometry && l.updateFromObject(e), a.update(l), d[l.id] = f);
				e.isInstancedMesh && b.update(e.instanceMatrix, 34962);
				return l
			},
			dispose: function() {
				d = {}
			}
		}
	}

	function rd(f, a, b, c, d, e, g, k, l, m) {
		f =
			void 0 !== f ? f : [];
		pa.call(this, f, void 0 !== a ? a : 301, b, c, d, e, void 0 !== g ? g : 1022, k, l, m);
		this.flipY = !1
	}

	function Pe(f, a, b, c) {
		pa.call(this, null);
		this.image = {
			data: f || null,
			width: a || 1,
			height: b || 1,
			depth: c || 1
		};
		this.minFilter = this.magFilter = 1003;
		this.wrapR = 1001;
		this.flipY = this.generateMipmaps = !1;
		this.needsUpdate = !0
	}

	function Qe(f, a, b, c) {
		pa.call(this, null);
		this.image = {
			data: f || null,
			width: a || 1,
			height: b || 1,
			depth: c || 1
		};
		this.minFilter = this.magFilter = 1003;
		this.wrapR = 1001;
		this.flipY = this.generateMipmaps = !1;
		this.needsUpdate = !0
	}

	function Eg(f, a, b) {
		var c = f[0];
		if (0 >= c || 0 < c) return f;
		var d = a * b,
			e = wm[d];
		void 0 === e && (e = new Float32Array(d), wm[d] = e);
		if (0 !== a)
			for (c.toArray(e, 0), c = 1, d = 0; c !== a; ++c) d += b, f[c].toArray(e, d);
		return e
	}

	function fc(f, a) {
		if (f.length !== a.length) return !1;
		for (var b = 0, c = f.length; b < c; b++)
			if (f[b] !== a[b]) return !1;
		return !0
	}

	function Pb(f, a) {
		for (var b = 0, c = a.length; b < c; b++) f[b] = a[b]
	}

	function xm(f, a) {
		var b = ym[a];
		void 0 === b && (b = new Int32Array(a), ym[a] = b);
		for (var c = 0; c !== a; ++c) b[c] = f.allocateTextureUnit();
		return b
	}

	function Lp(f,
		a) {
		var b = this.cache;
		b[0] !== a && (f.uniform1f(this.addr, a), b[0] = a)
	}

	function Mp(f, a) {
		var b = this.cache;
		if (void 0 !== a.x) {
			if (b[0] !== a.x || b[1] !== a.y) f.uniform2f(this.addr, a.x, a.y), b[0] = a.x, b[1] = a.y
		} else fc(b, a) || (f.uniform2fv(this.addr, a), Pb(b, a))
	}

	function Np(f, a) {
		var b = this.cache;
		if (void 0 !== a.x) {
			if (b[0] !== a.x || b[1] !== a.y || b[2] !== a.z) f.uniform3f(this.addr, a.x, a.y, a.z), b[0] = a.x, b[1] = a.y, b[
				2] = a.z
		} else if (void 0 !== a.r) {
			if (b[0] !== a.r || b[1] !== a.g || b[2] !== a.b) f.uniform3f(this.addr, a.r, a.g, a.b), b[0] = a.r, b[1] = a.g,
				b[2] = a.b
		} else fc(b, a) || (f.uniform3fv(this.addr, a), Pb(b, a))
	}

	function Op(f, a) {
		var b = this.cache;
		if (void 0 !== a.x) {
			if (b[0] !== a.x || b[1] !== a.y || b[2] !== a.z || b[3] !== a.w) f.uniform4f(this.addr, a.x, a.y, a.z, a.w), b[0] =
				a.x, b[1] = a.y, b[2] = a.z, b[3] = a.w
		} else fc(b, a) || (f.uniform4fv(this.addr, a), Pb(b, a))
	}

	function Pp(f, a) {
		var b = this.cache,
			c = a.elements;
		void 0 === c ? fc(b, a) || (f.uniformMatrix2fv(this.addr, !1, a), Pb(b, a)) : fc(b, c) || (zm.set(c), f.uniformMatrix2fv(
			this.addr, !1, zm), Pb(b, c))
	}

	function Qp(f, a) {
		var b = this.cache,
			c = a.elements;
		void 0 === c ? fc(b, a) || (f.uniformMatrix3fv(this.addr, !1, a), Pb(b, a)) : fc(b, c) || (Am.set(c), f.uniformMatrix3fv(
			this.addr, !1, Am), Pb(b, c))
	}

	function Rp(f, a) {
		var b = this.cache,
			c = a.elements;
		void 0 === c ? fc(b, a) || (f.uniformMatrix4fv(this.addr, !1, a), Pb(b, a)) : fc(b, c) || (Bm.set(c), f.uniformMatrix4fv(
			this.addr, !1, Bm), Pb(b, c))
	}

	function Sp(f, a, b) {
		var c = this.cache,
			d = b.allocateTextureUnit();
		c[0] !== d && (f.uniform1i(this.addr, d), c[0] = d);
		b.safeSetTexture2D(a || Cm, d)
	}

	function Tp(f, a, b) {
		var c = this.cache,
			d = b.allocateTextureUnit();
		c[0] !== d && (f.uniform1i(this.addr, d), c[0] = d);
		b.setTexture2DArray(a || Up, d)
	}

	function Vp(f, a, b) {
		var c = this.cache,
			d = b.allocateTextureUnit();
		c[0] !== d && (f.uniform1i(this.addr, d), c[0] = d);
		b.setTexture3D(a || Wp, d)
	}

	function Xp(f, a, b) {
		var c = this.cache,
			d = b.allocateTextureUnit();
		c[0] !== d && (f.uniform1i(this.addr, d), c[0] = d);
		b.safeSetTextureCube(a || Dm, d)
	}

	function Yp(f, a) {
		var b = this.cache;
		b[0] !== a && (f.uniform1i(this.addr, a), b[0] = a)
	}

	function Zp(f, a) {
		var b = this.cache;
		fc(b, a) || (f.uniform2iv(this.addr, a), Pb(b, a))
	}

	function $p(f,
		a) {
		var b = this.cache;
		fc(b, a) || (f.uniform3iv(this.addr, a), Pb(b, a))
	}

	function aq(f, a) {
		var b = this.cache;
		fc(b, a) || (f.uniform4iv(this.addr, a), Pb(b, a))
	}

	function bq(f) {
		switch (f) {
			case 5126:
				return Lp;
			case 35664:
				return Mp;
			case 35665:
				return Np;
			case 35666:
				return Op;
			case 35674:
				return Pp;
			case 35675:
				return Qp;
			case 35676:
				return Rp;
			case 35678:
			case 36198:
				return Sp;
			case 35679:
				return Vp;
			case 35680:
				return Xp;
			case 36289:
				return Tp;
			case 5124:
			case 35670:
				return Yp;
			case 35667:
			case 35671:
				return Zp;
			case 35668:
			case 35672:
				return $p;
			case 35669:
			case 35673:
				return aq
		}
	}

	function cq(f, a) {
		f.uniform1fv(this.addr, a)
	}

	function dq(f, a) {
		f.uniform1iv(this.addr, a)
	}

	function eq(f, a) {
		f.uniform2iv(this.addr, a)
	}

	function fq(f, a) {
		f.uniform3iv(this.addr, a)
	}

	function gq(f, a) {
		f.uniform4iv(this.addr, a)
	}

	function hq(f, a) {
		a = Eg(a, this.size, 2);
		f.uniform2fv(this.addr, a)
	}

	function iq(f, a) {
		a = Eg(a, this.size, 3);
		f.uniform3fv(this.addr, a)
	}

	function jq(f, a) {
		a = Eg(a, this.size, 4);
		f.uniform4fv(this.addr, a)
	}

	function kq(f, a) {
		a = Eg(a, this.size, 4);
		f.uniformMatrix2fv(this.addr,
			!1, a)
	}

	function lq(f, a) {
		a = Eg(a, this.size, 9);
		f.uniformMatrix3fv(this.addr, !1, a)
	}

	function mq(f, a) {
		a = Eg(a, this.size, 16);
		f.uniformMatrix4fv(this.addr, !1, a)
	}

	function nq(f, a, b) {
		var c = a.length,
			d = xm(b, c);
		f.uniform1iv(this.addr, d);
		for (f = 0; f !== c; ++f) b.safeSetTexture2D(a[f] || Cm, d[f])
	}

	function oq(f, a, b) {
		var c = a.length,
			d = xm(b, c);
		f.uniform1iv(this.addr, d);
		for (f = 0; f !== c; ++f) b.safeSetTextureCube(a[f] || Dm, d[f])
	}

	function pq(f) {
		switch (f) {
			case 5126:
				return cq;
			case 35664:
				return hq;
			case 35665:
				return iq;
			case 35666:
				return jq;
			case 35674:
				return kq;
			case 35675:
				return lq;
			case 35676:
				return mq;
			case 35678:
				return nq;
			case 35680:
				return oq;
			case 5124:
			case 35670:
				return dq;
			case 35667:
			case 35671:
				return eq;
			case 35668:
			case 35672:
				return fq;
			case 35669:
			case 35673:
				return gq
		}
	}

	function qq(f, a, b) {
		this.id = f;
		this.addr = b;
		this.cache = [];
		this.setValue = bq(a.type)
	}

	function Em(f, a, b) {
		this.id = f;
		this.addr = b;
		this.cache = [];
		this.size = a.size;
		this.setValue = pq(a.type)
	}

	function Fm(f) {
		this.id = f;
		this.seq = [];
		this.map = {}
	}

	function Re(f, a) {
		this.seq = [];
		this.map = {};
		for (var b =
				f.getProgramParameter(a, 35718), c = 0; c < b; ++c) {
			var d = f.getActiveUniform(a, c),
				e = f.getUniformLocation(a, d.name),
				g = this,
				k = d.name,
				l = k.length;
			for (Wi.lastIndex = 0;;) {
				var m = Wi.exec(k),
					n = Wi.lastIndex,
					r = m[1],
					v = m[3];
				"]" === m[2] && (r |= 0);
				if (void 0 === v || "[" === v && n + 2 === l) {
					k = g;
					d = void 0 === v ? new qq(r, d, e) : new Em(r, d, e);
					k.seq.push(d);
					k.map[d.id] = d;
					break
				} else v = g.map[r], void 0 === v && (v = new Fm(r), r = g, g = v, r.seq.push(g), r.map[g.id] = g), g = v
			}
		}
	}

	function Gm(f, a, b) {
		a = f.createShader(a);
		f.shaderSource(a, b);
		f.compileShader(a);
		return a
	}

	function Hm(f) {
		switch (f) {
			case 3E3:
				return ["Linear", "( value )"];
			case 3001:
				return ["sRGB", "( value )"];
			case 3002:
				return ["RGBE", "( value )"];
			case 3004:
				return ["RGBM", "( value, 7.0 )"];
			case 3005:
				return ["RGBM", "( value, 16.0 )"];
			case 3006:
				return ["RGBD", "( value, 256.0 )"];
			case 3007:
				return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
			case 3003:
				return ["LogLuv", "( value )"];
			default:
				throw Error("unsupported encoding: " + f);
		}
	}

	function Im(f, a, b) {
		var c = f.getShaderParameter(a, 35713),
			d = f.getShaderInfoLog(a).trim();
		if (c && "" === d) return "";
		f = f.getShaderSource(a).split("\n");
		for (a = 0; a < f.length; a++) f[a] = a + 1 + ": " + f[a];
		f = f.join("\n");
		return "THREE.WebGLShader: gl.getShaderInfoLog() " + b + "\n" + d + f
	}

	function Hh(f, a) {
		a = Hm(a);
		return "vec4 " + f + "( vec4 value ) { return " + a[0] + "ToLinear" + a[1] + "; }"
	}

	function rq(f, a) {
		a = Hm(a);
		return "vec4 " + f + "( vec4 value ) { return LinearTo" + a[0] + a[1] + "; }"
	}

	function sq(f, a) {
		switch (a) {
			case 1:
				a = "Linear";
				break;
			case 2:
				a = "Reinhard";
				break;
			case 3:
				a = "Uncharted2";
				break;
			case 4:
				a = "OptimizedCineon";
				break;
			case 5:
				a =
					"ACESFilmic";
				break;
			default:
				throw Error("unsupported toneMapping: " + a);
		}
		return "vec3 " + f + "( vec3 color ) { return " + a + "ToneMapping( color ); }"
	}

	function tq(f, a, b) {
		f = f || {};
		return [f.derivatives || a.envMapCubeUV || a.bumpMap || a.tangentSpaceNormalMap || a.clearcoatNormalMap || a.flatShading ?
			"#extension GL_OES_standard_derivatives : enable" : "", (f.fragDepth || a.logarithmicDepthBuffer) && b.get(
				"EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", f.drawBuffers && b.get("WEBGL_draw_buffers") ?
			"#extension GL_EXT_draw_buffers : require" :
			"", (f.shaderTextureLOD || a.envMap) && b.get("EXT_shader_texture_lod") ?
			"#extension GL_EXT_shader_texture_lod : enable" : ""
		].filter(Bf).join("\n")
	}

	function uq(f) {
		var a = [],
			b;
		for (b in f) {
			var c = f[b];
			!1 !== c && a.push("#define " + b + " " + c)
		}
		return a.join("\n")
	}

	function Bf(f) {
		return "" !== f
	}

	function Jm(f, a) {
		return f.replace(/NUM_DIR_LIGHTS/g, a.numDirLights).replace(/NUM_SPOT_LIGHTS/g, a.numSpotLights).replace(
				/NUM_RECT_AREA_LIGHTS/g, a.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, a.numPointLights).replace(
				/NUM_HEMI_LIGHTS/g,
				a.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, a.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, a.numSpotLightShadows)
			.replace(/NUM_POINT_LIGHT_SHADOWS/g, a.numPointLightShadows)
	}

	function Km(f, a) {
		return f.replace(/NUM_CLIPPING_PLANES/g, a.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, a.numClippingPlanes -
			a.numClipIntersection)
	}

	function ck(f, a) {
		f = ma[a];
		if (void 0 === f) throw Error("Can not resolve #include <" + a + ">");
		return f.replace(Xi, ck)
	}

	function Lm(f, a, b, c) {
		f = "";
		for (a = parseInt(a); a < parseInt(b); a++) f +=
			c.replace(/\[ i \]/g, "[ " + a + " ]").replace(/UNROLLED_LOOP_INDEX/g, a);
		return f
	}

	function Mm(f) {
		var a = "precision " + f.precision + " float;\nprecision " + f.precision + " int;";
		"highp" === f.precision ? a += "\n#define HIGH_PRECISION" : "mediump" === f.precision ? a +=
			"\n#define MEDIUM_PRECISION" : "lowp" === f.precision && (a += "\n#define LOW_PRECISION");
		return a
	}

	function vq(f) {
		var a = "SHADOWMAP_TYPE_BASIC";
		1 === f.shadowMapType ? a = "SHADOWMAP_TYPE_PCF" : 2 === f.shadowMapType ? a = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === f.shadowMapType &&
			(a = "SHADOWMAP_TYPE_VSM");
		return a
	}

	function wq(f, a) {
		var b = "ENVMAP_TYPE_CUBE";
		if (f.envMap) switch (a.envMap.mapping) {
			case 301:
			case 302:
				b = "ENVMAP_TYPE_CUBE";
				break;
			case 306:
			case 307:
				b = "ENVMAP_TYPE_CUBE_UV";
				break;
			case 303:
			case 304:
				b = "ENVMAP_TYPE_EQUIREC";
				break;
			case 305:
				b = "ENVMAP_TYPE_SPHERE"
		}
		return b
	}

	function xq(f, a) {
		var b = "ENVMAP_MODE_REFLECTION";
		if (f.envMap) switch (a.envMap.mapping) {
			case 302:
			case 304:
				b = "ENVMAP_MODE_REFRACTION"
		}
		return b
	}

	function yq(f, a) {
		var b = "ENVMAP_BLENDING_MULTIPLY";
		if (f.envMap) switch (a.combine) {
			case 0:
				b = "ENVMAP_BLENDING_MULTIPLY";
				break;
			case 1:
				b = "ENVMAP_BLENDING_MIX";
				break;
			case 2:
				b = "ENVMAP_BLENDING_ADD"
		}
		return b
	}

	function zq(f, a, b, c, d, e) {
		var g = f.getContext(),
			k = c.defines,
			l = d.vertexShader,
			m = d.fragmentShader,
			n = vq(e),
			r = wq(e, c),
			v = xq(e, c),
			A = yq(e, c),
			w = 0 < f.gammaFactor ? f.gammaFactor : 1,
			z = e.isWebGL2 ? "" : tq(c.extensions, e, a),
			p = uq(k),
			q = g.createProgram(),
			u = (k = f.getRenderTarget()) && k.isWebGLMultiviewRenderTarget ? k.numViews : 0;
		c.isRawShaderMaterial ? (k = [p].filter(Bf).join("\n"), 0 < k.length && (k += "\n"), a = [z, p].filter(Bf).join("\n"),
			0 < a.length && (a +=
				"\n")) : (k = [Mm(e), "#define SHADER_NAME " + d.name, p, e.instancing ? "#define USE_INSTANCING" : "", e.supportsVertexTextures ?
			"#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + w, "#define MAX_BONES " + e.maxBones, e.useFog && e.fog ?
			"#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ?
			"#define USE_ENVMAP" : "", e.envMap ? "#define " + v : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ?
			"#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" :
			"", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ?
			"#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" :
			"", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.displacementMap && e.supportsVertexTextures ?
			"#define USE_DISPLACEMENTMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.roughnessMap ?
			"#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ?
			"#define USE_ALPHAMAP" : "", e.vertexTangents ?
			"#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexUvs ? "#define USE_UV" : "", e.flatShading ?
			"#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ? "#define BONE_TEXTURE" :
			"", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && !1 === e.flatShading ?
			"#define USE_MORPHNORMALS" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" :
			"", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + n : "", e.sizeAttenuation ?
			"#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer &&
			(e.isWebGL2 || a.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_INSTANCING",
			" attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;",
			"attribute vec2 uv;",
			"#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;",
			"#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;",
			"\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS",
			"\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;",
			"\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;",
			"\t\tattribute vec3 morphTarget5;",
			"\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif",
			"#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
		].filter(Bf).join("\n"), a = [z, Mm(e), "#define SHADER_NAME " + d.name, p, e.alphaTest ? "#define ALPHATEST " + e
			.alphaTest + (e.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + w, e.useFog && e.fog ?
			"#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.matcap ?
			"#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" :
			"", e.envMap ? "#define " + r : "", e.envMap ? "#define " + v : "", e.envMap ? "#define " + A : "", e.lightMap ?
			"#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
			e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ?
			"#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" :
			"", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" :
			"", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ?
			"#define USE_ALPHAMAP" : "", e.sheen ? "#define USE_SHEEN" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e
			.vertexColors ? "#define USE_COLOR" : "", e.vertexUvs ? "#define USE_UV" : "", e.gradientMap ?
			"#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ?
			"#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ?
			"#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " +
			n : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.physicallyCorrectLights ?
			"#define PHYSICALLY_CORRECT_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer &&
			(e.isWebGL2 || a.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (c.extensions && c.extensions.shaderTextureLOD ||
				e.envMap) && (e.isWebGL2 || a.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
			"uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== e.toneMapping ? "#define TONE_MAPPING" :
			"", 0 !== e.toneMapping ? ma.tonemapping_pars_fragment : "", 0 !== e.toneMapping ? sq("toneMapping", e.toneMapping) :
			"", e.dithering ? "#define DITHERING" : "", e.outputEncoding || e.mapEncoding || e.matcapEncoding || e.envMapEncoding ||
			e.emissiveMapEncoding ? ma.encodings_pars_fragment : "", e.mapEncoding ? Hh("mapTexelToLinear", e.mapEncoding) :
			"", e.matcapEncoding ? Hh("matcapTexelToLinear", e.matcapEncoding) : "", e.envMapEncoding ? Hh(
				"envMapTexelToLinear", e.envMapEncoding) : "", e.emissiveMapEncoding ? Hh("emissiveMapTexelToLinear", e.emissiveMapEncoding) :
			"", e.outputEncoding ? rq("linearToOutputTexel", e.outputEncoding) : "", e.depthPacking ?
			"#define DEPTH_PACKING " + c.depthPacking : "", "\n"
		].filter(Bf).join("\n"));
		l = l.replace(Xi, ck);
		l = Jm(l, e);
		l = Km(l, e);
		m = m.replace(Xi, ck);
		m = Jm(m, e);
		m = Km(m, e);
		l = l.replace(Nm, Lm);
		m = m.replace(Nm, Lm);
		e.isWebGL2 && !c.isRawShaderMaterial && (n = !1, r = /^\s*#version\s+300\s+es\s*\n/, c.isShaderMaterial && null !==
			l.match(r) && null !== m.match(r) && (n = !0, l = l.replace(r, ""), m = m.replace(r, "")), k =
			"#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
			k, a = ["#version 300 es\n\n#define varying in", n ? "" : "out highp vec4 pc_fragColor;", n ? "" :
				"#define gl_FragColor pc_fragColor",
				"#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"
			].join("\n") +
			"\n" + a, 0 < u && (k = k.replace("#version 300 es\n", [
					"#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + u + ") in;",
					"#define VIEW_ID gl_ViewID_OVR"
				].join("\n")), k = k.replace(
					"uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;",
					["uniform mat4 modelViewMatrices[" + u + "];", "uniform mat4 projectionMatrices[" + u + "];",
						"uniform mat4 viewMatrices[" + u + "];", "uniform mat3 normalMatrices[" + u + "];",
						"#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"
					].join("\n")),
				a = a.replace("#version 300 es\n",
					"#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"), a = a.replace(
					"uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + u + "];", "#define viewMatrix viewMatrices[VIEW_ID]"]
					.join("\n"))));
		m = a + m;
		l = Gm(g, 35633, k + l);
		m = Gm(g, 35632, m);
		g.attachShader(q, l);
		g.attachShader(q, m);
		void 0 !== c.index0AttributeName ? g.bindAttribLocation(q, 0, c.index0AttributeName) : !0 === e.morphTargets && g.bindAttribLocation(
			q, 0, "position");
		g.linkProgram(q);
		if (f.debug.checkShaderErrors) {
			f =
				g.getProgramInfoLog(q).trim();
			e = g.getShaderInfoLog(l).trim();
			n = g.getShaderInfoLog(m).trim();
			v = r = !0;
			if (!1 === g.getProgramParameter(q, 35714)) r = !1, A = Im(g, l, "vertex"), w = Im(g, m, "fragment"), console.error(
				"THREE.WebGLProgram: shader error: ", g.getError(), "35715", g.getProgramParameter(q, 35715),
				"gl.getProgramInfoLog", f, A, w);
			else if ("" !== f) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", f);
			else if ("" === e || "" === n) v = !1;
			v && (this.diagnostics = {
				runnable: r,
				material: c,
				programLog: f,
				vertexShader: {
					log: e,
					prefix: k
				},
				fragmentShader: {
					log: n,
					prefix: a
				}
			})
		}
		g.deleteShader(l);
		g.deleteShader(m);
		var G;
		this.getUniforms = function() {
			void 0 === G && (G = new Re(g, q));
			return G
		};
		var la;
		this.getAttributes = function() {
			if (void 0 === la) {
				for (var a = {}, b = g.getProgramParameter(q, 35721), c = 0; c < b; c++) {
					var d = g.getActiveAttrib(q, c).name;
					a[d] = g.getAttribLocation(q, d)
				}
				la = a
			}
			return la
		};
		this.destroy = function() {
			g.deleteProgram(q);
			this.program = void 0
		};
		this.name = d.name;
		this.id = Aq++;
		this.code = b;
		this.usedTimes = 1;
		this.program = q;
		this.vertexShader = l;
		this.fragmentShader =
			m;
		this.numMultiviewViews = u;
		return this
	}

	function Bq(f, a, b) {
		function c(a, b) {
			if (a) a.isTexture ? c = a.encoding : a.isWebGLRenderTarget && (console.warn(
				"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
			), c = a.texture.encoding);
			else var c = 3E3;
			3E3 === c && b && (c = 3007);
			return c
		}
		var d = [],
			e = {
				MeshDepthMaterial: "depth",
				MeshDistanceMaterial: "distanceRGBA",
				MeshNormalMaterial: "normal",
				MeshBasicMaterial: "basic",
				MeshLambertMaterial: "lambert",
				MeshPhongMaterial: "phong",
				MeshToonMaterial: "phong",
				MeshStandardMaterial: "physical",
				MeshPhysicalMaterial: "physical",
				MeshMatcapMaterial: "matcap",
				LineBasicMaterial: "basic",
				LineDashedMaterial: "dashed",
				PointsMaterial: "points",
				ShadowMaterial: "shadow",
				SpriteMaterial: "sprite"
			},
			g =
			"precision supportsVertexTextures instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen"
			.split(" ");
		this.getParameters = function(a, d, g, n, r, v, A) {
			var k = e[a.type];
			if (A.isSkinnedMesh) {
				var l = A.skeleton.bones;
				if (b.floatVertexTextures) l = 1024;
				else {
					var m = Math.min(Math.floor((b.maxVertexUniforms - 20) / 4), l.length);
					m < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " + m +
						"."), l = 0) : l = m
				}
			} else l = 0;
			m = b.precision;
			null !== a.precision && (m = b.getMaxPrecision(a.precision), m !== a.precision && console.warn(
				"THREE.WebGLProgram.getParameters:", a.precision, "not supported, using", m, "instead."));
			var p = f.getRenderTarget();
			return {
				isWebGL2: b.isWebGL2,
				shaderID: k,
				precision: m,
				instancing: !0 === A.isInstancedMesh,
				supportsVertexTextures: b.vertexTextures,
				outputEncoding: c(p ? p.texture : null, f.gammaOutput),
				map: !!a.map,
				mapEncoding: c(a.map, f.gammaInput),
				matcap: !!a.matcap,
				matcapEncoding: c(a.matcap, f.gammaInput),
				envMap: !!a.envMap,
				envMapMode: a.envMap && a.envMap.mapping,
				envMapEncoding: c(a.envMap, f.gammaInput),
				envMapCubeUV: !!a.envMap && (306 === a.envMap.mapping || 307 === a.envMap.mapping),
				lightMap: !!a.lightMap,
				aoMap: !!a.aoMap,
				emissiveMap: !!a.emissiveMap,
				emissiveMapEncoding: c(a.emissiveMap, f.gammaInput),
				bumpMap: !!a.bumpMap,
				normalMap: !!a.normalMap,
				objectSpaceNormalMap: 1 === a.normalMapType,
				tangentSpaceNormalMap: 0 === a.normalMapType,
				clearcoatNormalMap: !!a.clearcoatNormalMap,
				displacementMap: !!a.displacementMap,
				roughnessMap: !!a.roughnessMap,
				metalnessMap: !!a.metalnessMap,
				specularMap: !!a.specularMap,
				alphaMap: !!a.alphaMap,
				gradientMap: !!a.gradientMap,
				sheen: !!a.sheen,
				combine: a.combine,
				vertexTangents: a.normalMap && a.vertexTangents,
				vertexColors: a.vertexColors,
				vertexUvs: !!a.map || !!a.bumpMap || !!a.normalMap || !!a.specularMap || !!a.alphaMap || !!a.emissiveMap || !!a.roughnessMap ||
					!!a.metalnessMap || !!a.clearcoatNormalMap,
				fog: !!n,
				useFog: a.fog,
				fogExp2: n && n.isFogExp2,
				flatShading: a.flatShading,
				sizeAttenuation: a.sizeAttenuation,
				logarithmicDepthBuffer: b.logarithmicDepthBuffer,
				skinning: a.skinning && 0 < l,
				maxBones: l,
				useVertexTexture: b.floatVertexTextures,
				morphTargets: a.morphTargets,
				morphNormals: a.morphNormals,
				maxMorphTargets: f.maxMorphTargets,
				maxMorphNormals: f.maxMorphNormals,
				numDirLights: d.directional.length,
				numPointLights: d.point.length,
				numSpotLights: d.spot.length,
				numRectAreaLights: d.rectArea.length,
				numHemiLights: d.hemi.length,
				numDirLightShadows: d.directionalShadowMap.length,
				numPointLightShadows: d.pointShadowMap.length,
				numSpotLightShadows: d.spotShadowMap.length,
				numClippingPlanes: r,
				numClipIntersection: v,
				dithering: a.dithering,
				shadowMapEnabled: f.shadowMap.enabled && 0 < g.length,
				shadowMapType: f.shadowMap.type,
				toneMapping: a.toneMapped ? f.toneMapping : 0,
				physicallyCorrectLights: f.physicallyCorrectLights,
				premultipliedAlpha: a.premultipliedAlpha,
				alphaTest: a.alphaTest,
				doubleSided: 2 === a.side,
				flipSided: 1 === a.side,
				depthPacking: void 0 !== a.depthPacking ? a.depthPacking : !1
			}
		};
		this.getProgramCode = function(a, b) {
			var c = [];
			b.shaderID ? c.push(b.shaderID) : (c.push(a.fragmentShader), c.push(a.vertexShader));
			if (void 0 !== a.defines)
				for (var d in a.defines) c.push(d), c.push(a.defines[d]);
			for (d = 0; d < g.length; d++) c.push(b[g[d]]);
			c.push(a.onBeforeCompile.toString());
			c.push(f.gammaOutput);
			c.push(f.gammaFactor);
			return c.join()
		};
		this.acquireProgram =
			function(b, c, e, g) {
				for (var k, l = 0, m = d.length; l < m; l++) {
					var n = d[l];
					if (n.code === g) {
						k = n;
						++k.usedTimes;
						break
					}
				}
				void 0 === k && (k = new zq(f, a, g, b, c, e), d.push(k));
				return k
			};
		this.releaseProgram = function(a) {
			if (0 === --a.usedTimes) {
				var b = d.indexOf(a);
				d[b] = d[d.length - 1];
				d.pop();
				a.destroy()
			}
		};
		this.programs = d
	}

	function Cq() {
		var f = new Fa;
		return {
			get: function(a) {
				var b = f.get(a);
				void 0 === b && (b = {}, f.set(a, b));
				return b
			},
			remove: function(a) {
				f.delete(a)
			},
			update: function(a, b, c) {
				f.get(a)[b] = c
			},
			dispose: function() {
				f = new Fa
			}
		}
	}

	function Dq(f,
		a) {
		return f.groupOrder !== a.groupOrder ? f.groupOrder - a.groupOrder : f.renderOrder !== a.renderOrder ? f.renderOrder -
			a.renderOrder : f.program !== a.program ? f.program.id - a.program.id : f.material.id !== a.material.id ? f.material
			.id - a.material.id : f.z !== a.z ? f.z - a.z : f.id - a.id
	}

	function Eq(f, a) {
		return f.groupOrder !== a.groupOrder ? f.groupOrder - a.groupOrder : f.renderOrder !== a.renderOrder ? f.renderOrder -
			a.renderOrder : f.z !== a.z ? a.z - f.z : f.id - a.id
	}

	function Om() {
		function f(c, d, f, m, n, r) {
			var g = a[b];
			void 0 === g ? (g = {
				id: c.id,
				object: c,
				geometry: d,
				material: f,
				program: f.program || e,
				groupOrder: m,
				renderOrder: c.renderOrder,
				z: n,
				group: r
			}, a[b] = g) : (g.id = c.id, g.object = c, g.geometry = d, g.material = f, g.program = f.program || e, g.groupOrder =
				m, g.renderOrder = c.renderOrder, g.z = n, g.group = r);
			b++;
			return g
		}
		var a = [],
			b = 0,
			c = [],
			d = [],
			e = {
				id: -1
			};
		return {
			opaque: c,
			transparent: d,
			init: function() {
				b = 0;
				c.length = 0;
				d.length = 0
			},
			push: function(a, b, e, m, n, r) {
				a = f(a, b, e, m, n, r);
				(!0 === e.transparent ? d : c).push(a)
			},
			unshift: function(a, b, e, m, n, r) {
				a = f(a, b, e, m, n, r);
				(!0 === e.transparent ? d : c).unshift(a)
			},
			sort: function() {
				1 < c.length && c.sort(Dq);
				1 < d.length && d.sort(Eq)
			}
		}
	}

	function Fq() {
		function f(b) {
			b = b.target;
			b.removeEventListener("dispose", f);
			a.delete(b)
		}
		var a = new Fa;
		return {
			get: function(b, c) {
				var d = a.get(b);
				if (void 0 === d) {
					var e = new Om;
					a.set(b, new Fa);
					a.get(b).set(c, e);
					b.addEventListener("dispose", f)
				} else e = d.get(c), void 0 === e && (e = new Om, d.set(c, e));
				return e
			},
			dispose: function() {
				a = new Fa
			}
		}
	}

	function Gq() {
		var f = {};
		return {
			get: function(a) {
				if (void 0 !== f[a.id]) return f[a.id];
				switch (a.type) {
					case "DirectionalLight":
						var b = {
							direction: new u,
							color: new S,
							shadow: !1,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new B
						};
						break;
					case "SpotLight":
						b = {
							position: new u,
							direction: new u,
							color: new S,
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,
							shadow: !1,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new B
						};
						break;
					case "PointLight":
						b = {
							position: new u,
							color: new S,
							distance: 0,
							decay: 0,
							shadow: !1,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new B,
							shadowCameraNear: 1,
							shadowCameraFar: 1E3
						};
						break;
					case "HemisphereLight":
						b = {
							direction: new u,
							skyColor: new S,
							groundColor: new S
						};
						break;
					case "RectAreaLight":
						b = {
							color: new S,
							position: new u,
							halfWidth: new u,
							halfHeight: new u
						}
				}
				return f[a.id] = b
			}
		}
	}

	function Hq(f, a) {
		return (a.castShadow ? 1 : 0) - (f.castShadow ? 1 : 0)
	}

	function Iq() {
		for (var f = new Gq, a = {
				version: 0,
				hash: {
					directionalLength: -1,
					pointLength: -1,
					spotLength: -1,
					rectAreaLength: -1,
					hemiLength: -1,
					numDirectionalShadows: -1,
					numPointShadows: -1,
					numSpotShadows: -1
				},
				ambient: [0, 0, 0],
				probe: [],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				rectArea: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
				numDirectionalShadows: -1,
				numPointShadows: -1,
				numSpotShadows: -1
			}, b = 0; 9 > b; b++) a.probe.push(new u);
		var c = new u,
			d = new ua,
			e = new ua;
		return {
			setup: function(b, k, l) {
				for (var g = 0, n = 0, r = 0, v = 0; 9 > v; v++) a.probe[v].set(0, 0, 0);
				var A = k = 0,
					w = 0,
					z = 0,
					p = 0,
					q = 0,
					u = 0,
					G = 0;
				l = l.matrixWorldInverse;
				b.sort(Hq);
				v = 0;
				for (var la = b.length; v < la; v++) {
					var H = b[v],
						Q = H.color,
						wa = H.intensity,
						B = H.distance,
						Va = H.shadow && H.shadow.map ? H.shadow.map.texture : null;
					if (H.isAmbientLight) g +=
						Q.r * wa, n += Q.g * wa, r += Q.b * wa;
					else if (H.isLightProbe)
						for (Va = 0; 9 > Va; Va++) a.probe[Va].addScaledVector(H.sh.coefficients[Va], wa);
					else if (H.isDirectionalLight) {
						var M = f.get(H);
						M.color.copy(H.color).multiplyScalar(H.intensity);
						M.direction.setFromMatrixPosition(H.matrixWorld);
						c.setFromMatrixPosition(H.target.matrixWorld);
						M.direction.sub(c);
						M.direction.transformDirection(l);
						if (M.shadow = H.castShadow) wa = H.shadow, M.shadowBias = wa.bias, M.shadowRadius = wa.radius, M.shadowMapSize =
							wa.mapSize, a.directionalShadowMap[k] =
							Va, a.directionalShadowMatrix[k] = H.shadow.matrix, q++;
						a.directional[k] = M;
						k++
					} else if (H.isSpotLight) {
						M = f.get(H);
						M.position.setFromMatrixPosition(H.matrixWorld);
						M.position.applyMatrix4(l);
						M.color.copy(Q).multiplyScalar(wa);
						M.distance = B;
						M.direction.setFromMatrixPosition(H.matrixWorld);
						c.setFromMatrixPosition(H.target.matrixWorld);
						M.direction.sub(c);
						M.direction.transformDirection(l);
						M.coneCos = Math.cos(H.angle);
						M.penumbraCos = Math.cos(H.angle * (1 - H.penumbra));
						M.decay = H.decay;
						if (M.shadow = H.castShadow) wa = H.shadow,
							M.shadowBias = wa.bias, M.shadowRadius = wa.radius, M.shadowMapSize = wa.mapSize, a.spotShadowMap[w] = Va, a.spotShadowMatrix[
								w] = H.shadow.matrix, G++;
						a.spot[w] = M;
						w++
					} else if (H.isRectAreaLight) M = f.get(H), M.color.copy(Q).multiplyScalar(wa), M.position.setFromMatrixPosition(
							H.matrixWorld), M.position.applyMatrix4(l), e.identity(), d.copy(H.matrixWorld), d.premultiply(l), e.extractRotation(
							d), M.halfWidth.set(.5 * H.width, 0, 0), M.halfHeight.set(0, .5 * H.height, 0), M.halfWidth.applyMatrix4(e), M
						.halfHeight.applyMatrix4(e), a.rectArea[z] =
						M, z++;
					else if (H.isPointLight) {
						M = f.get(H);
						M.position.setFromMatrixPosition(H.matrixWorld);
						M.position.applyMatrix4(l);
						M.color.copy(H.color).multiplyScalar(H.intensity);
						M.distance = H.distance;
						M.decay = H.decay;
						if (M.shadow = H.castShadow) wa = H.shadow, M.shadowBias = wa.bias, M.shadowRadius = wa.radius, M.shadowMapSize =
							wa.mapSize, M.shadowCameraNear = wa.camera.near, M.shadowCameraFar = wa.camera.far, a.pointShadowMap[A] = Va,
							a.pointShadowMatrix[A] = H.shadow.matrix, u++;
						a.point[A] = M;
						A++
					} else H.isHemisphereLight && (M = f.get(H),
						M.direction.setFromMatrixPosition(H.matrixWorld), M.direction.transformDirection(l), M.direction.normalize(),
						M.skyColor.copy(H.color).multiplyScalar(wa), M.groundColor.copy(H.groundColor).multiplyScalar(wa), a.hemi[p] =
						M, p++)
				}
				a.ambient[0] = g;
				a.ambient[1] = n;
				a.ambient[2] = r;
				b = a.hash;
				if (b.directionalLength !== k || b.pointLength !== A || b.spotLength !== w || b.rectAreaLength !== z || b.hemiLength !==
					p || b.numDirectionalShadows !== q || b.numPointShadows !== u || b.numSpotShadows !== G) a.directional.length =
					k, a.spot.length = w, a.rectArea.length =
					z, a.point.length = A, a.hemi.length = p, a.directionalShadowMap.length = q, a.pointShadowMap.length = u, a.spotShadowMap
					.length = G, a.directionalShadowMatrix.length = q, a.pointShadowMatrix.length = u, a.spotShadowMatrix.length = G,
					b.directionalLength = k, b.pointLength = A, b.spotLength = w, b.rectAreaLength = z, b.hemiLength = p, b.numDirectionalShadows =
					q, b.numPointShadows = u, b.numSpotShadows = G, a.version = Jq++
			},
			state: a
		}
	}

	function Pm() {
		var f = new Iq,
			a = [],
			b = [];
		return {
			init: function() {
				a.length = 0;
				b.length = 0
			},
			state: {
				lightsArray: a,
				shadowsArray: b,
				lights: f
			},
			setupLights: function(c) {
				f.setup(a, b, c)
			},
			pushLight: function(b) {
				a.push(b)
			},
			pushShadow: function(a) {
				b.push(a)
			}
		}
	}

	function Kq() {
		function f(b) {
			b = b.target;
			b.removeEventListener("dispose", f);
			a.delete(b)
		}
		var a = new Fa;
		return {
			get: function(b, c) {
				if (!1 === a.has(b)) {
					var d = new Pm;
					a.set(b, new Fa);
					a.get(b).set(c, d);
					b.addEventListener("dispose", f)
				} else !1 === a.get(b).has(c) ? (d = new Pm, a.get(b).set(c, d)) : d = a.get(b).get(c);
				return d
			},
			dispose: function() {
				a = new Fa
			}
		}
	}

	function Zd(f) {
		ia.call(this);
		this.type = "MeshDepthMaterial";
		this.depthPacking = 3200;
		this.morphTargets = this.skinning = !1;
		this.displacementMap = this.alphaMap = this.map = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.fog = !1;
		this.setValues(f)
	}

	function $d(f) {
		ia.call(this);
		this.type = "MeshDistanceMaterial";
		this.referencePosition = new u;
		this.nearDistance = 1;
		this.farDistance = 1E3;
		this.morphTargets = this.skinning = !1;
		this.displacementMap = this.alphaMap = this.map = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.fog = !1;
		this.setValues(f)
	}

	function Qm(f, a, b) {
		function c(a, b, c, d, e, g) {
			var k = a.geometry;
			var l = m;
			var w = a.customDepthMaterial;
			c.isPointLight && (l = n, w = a.customDistanceMaterial);
			w ? l = w : (w = !1, b.morphTargets && (k && k.isBufferGeometry ? w = k.morphAttributes && k.morphAttributes.position &&
					0 < k.morphAttributes.position.length : k && k.isGeometry && (w = k.morphTargets && 0 < k.morphTargets.length)),
				a.isSkinnedMesh && !1 === b.skinning && console.warn(
					"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", a), a = a.isSkinnedMesh &&
				b.skinning, k = 0, w && (k |= 1), a && (k |= 2), l = l[k]);
			f.localClippingEnabled && !0 === b.clipShadows && 0 !== b.clippingPlanes.length && (k = l.uuid, w = b.uuid, a = r[k],
				void 0 === a && (a = {}, r[k] = a), k = a[w], void 0 === k && (k = l.clone(), a[w] = k), l = k);
			l.visible = b.visible;
			l.wireframe = b.wireframe;
			l.side = 3 === g ? null != b.shadowSide ? b.shadowSide : b.side : null != b.shadowSide ? b.shadowSide : v[b.side];
			l.clipShadows = b.clipShadows;
			l.clippingPlanes = b.clippingPlanes;
			l.clipIntersection = b.clipIntersection;
			l.wireframeLinewidth = b.wireframeLinewidth;
			l.linewidth =
				b.linewidth;
			c.isPointLight && l.isMeshDistanceMaterial && (l.referencePosition.setFromMatrixPosition(c.matrixWorld), l.nearDistance =
				d, l.farDistance = e);
			return l
		}

		function d(b, g, k, l, m) {
			if (!1 !== b.visible) {
				if (b.layers.test(g.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && 3 ===
						m) && (!b.frustumCulled || e.intersectsObject(b))) {
					b.modelViewMatrix.multiplyMatrices(k.matrixWorldInverse, b.matrixWorld);
					var n = a.update(b),
						r = b.material;
					if (Array.isArray(r))
						for (var v = n.groups, w = 0, A = v.length; w < A; w++) {
							var z =
								v[w],
								p = r[z.materialIndex];
							p && p.visible && (p = c(b, p, l, k.near, k.far, m), f.renderBufferDirect(k, null, n, p, b, z))
						} else r.visible && (p = c(b, r, l, k.near, k.far, m), f.renderBufferDirect(k, null, n, p, b, null))
				}
				b = b.children;
				n = 0;
				for (r = b.length; n < r; n++) d(b[n], g, k, l, m)
			}
		}
		var e = new Ui,
			g = new B,
			k = new B,
			l = new za,
			m = Array(4),
			n = Array(4),
			r = {},
			v = {
				0: 1,
				1: 0,
				2: 2
			},
			A = new Ia({
				defines: {
					SAMPLE_RATE: .25,
					HALF_SAMPLE_RATE: .125
				},
				uniforms: {
					shadow_pass: {
						value: null
					},
					resolution: {
						value: new B
					},
					radius: {
						value: 4
					}
				},
				vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
				fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}"
			}),
			w = A.clone();
		w.defines.HORIZONAL_PASS = 1;
		var z = new J;
		z.addAttribute("position", new F(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
		var p = new Wa(z, A);
		for (z = 0; 4 !== z; ++z) {
			var q = 0 !== (z & 1),
				u = 0 !== (z & 2),
				G = new Zd({
					depthPacking: 3201,
					morphTargets: q,
					skinning: u
				});
			m[z] = G;
			q = new $d({
				morphTargets: q,
				skinning: u
			});
			n[z] = q
		}
		var la = this;
		this.enabled = !1;
		this.autoUpdate = !0;
		this.needsUpdate = !1;
		this.type = 1;
		this.render = function(c, m, n) {
			if (!1 !== la.enabled && (!1 !== la.autoUpdate || !1 !== la.needsUpdate) && 0 !== c.length) {
				var r = f.getRenderTarget(),
					v = f.getActiveCubeFace(),
					z = f.getActiveMipmapLevel(),
					q = f.state;
				q.setBlending(0);
				q.buffers.color.setClear(1, 1, 1, 1);
				q.buffers.depth.setTest(!0);
				q.setScissorTest(!1);
				for (var u = 0, C = c.length; u < C; u++) {
					var G = c[u],
						ra = G.shadow;
					if (void 0 === ra) console.warn("THREE.WebGLShadowMap:", G, "has no shadow.");
					else {
						g.copy(ra.mapSize);
						var ya = ra.getFrameExtents();
						g.multiply(ya);
						k.copy(ra.mapSize);
						if (g.x > b || g.y > b) console.warn("THREE.WebGLShadowMap:", G,
							"has shadow exceeding max texture size, reducing"), g.x > b && (k.x = Math.floor(b /
							ya.x), g.x = k.x * ya.x, ra.mapSize.x = k.x), g.y > b && (k.y = Math.floor(b / ya.y), g.y = k.y * ya.y, ra.mapSize
							.y = k.y);
						null !== ra.map || ra.isPointLightShadow || 3 !== this.type || (ya = {
							minFilter: 1006,
							magFilter: 1006,
							format: 1023
						}, ra.map = new Oa(g.x, g.y, ya), ra.map.texture.name = G.name + ".shadowMap", ra.mapPass = new Oa(g.x, g.y,
							ya), ra.camera.updateProjectionMatrix());
						null === ra.map && (ya = {
							minFilter: 1003,
							magFilter: 1003,
							format: 1023
						}, ra.map = new Oa(g.x, g.y, ya), ra.map.texture.name = G.name + ".shadowMap", ra.camera.updateProjectionMatrix());
						f.setRenderTarget(ra.map);
						f.clear();
						ya = ra.getViewportCount();
						for (var D = 0; D < ya; D++) {
							var K = ra.getViewport(D);
							l.set(k.x * K.x, k.y * K.y, k.x * K.z, k.y * K.w);
							q.viewport(l);
							ra.updateMatrices(G, n, D);
							e = ra.getFrustum();
							d(m, n, ra.camera, G, this.type)
						}
						ra.isPointLightShadow || 3 !== this.type || (G = ra, ra = n, ya = a.update(p), A.uniforms.shadow_pass.value = G
							.map.texture, A.uniforms.resolution.value = G.mapSize, A.uniforms.radius.value = G.radius, f.setRenderTarget(
								G.mapPass), f.clear(), f.renderBufferDirect(ra, null, ya, A, p, null), w.uniforms.shadow_pass.value = G.mapPass
							.texture,
							w.uniforms.resolution.value = G.mapSize, w.uniforms.radius.value = G.radius, f.setRenderTarget(G.map), f.clear(),
							f.renderBufferDirect(ra, null, ya, w, p, null))
					}
				}
				la.needsUpdate = !1;
				f.setRenderTarget(r, v, z)
			}
		}
	}

	function Lq(f, a, b, c) {
		function d(a, b, c) {
			var d = new Uint8Array(4),
				e = f.createTexture();
			f.bindTexture(a, e);
			f.texParameteri(a, 10241, 9728);
			f.texParameteri(a, 10240, 9728);
			for (a = 0; a < c; a++) f.texImage2D(b + a, 0, 6408, 1, 1, 0, 6408, 5121, d);
			return e
		}

		function e(b, d) {
			q[b] = 1;
			0 === u[b] && (f.enableVertexAttribArray(b), u[b] = 1);
			G[b] !==
				d && ((c.isWebGL2 ? f : a.get("ANGLE_instanced_arrays"))[c.isWebGL2 ? "vertexAttribDivisor" :
					"vertexAttribDivisorANGLE"](b, d), G[b] = d)
		}

		function g(a) {
			!0 !== la[a] && (f.enable(a), la[a] = !0)
		}

		function k(a) {
			!1 !== la[a] && (f.disable(a), la[a] = !1)
		}

		function l(a, c, d, e, l, m, n, r) {
			if (0 === a) wa && (k(3042), wa = !1);
			else if (wa || (g(3042), wa = !0), 5 !== a) {
				if (a !== B || r !== ra) {
					if (100 !== Va || 100 !== Fg) f.blendEquation(32774), Fg = Va = 100;
					if (r) switch (a) {
						case 1:
							f.blendFuncSeparate(1, 771, 1, 771);
							break;
						case 2:
							f.blendFunc(1, 1);
							break;
						case 3:
							f.blendFuncSeparate(0,
								0, 769, 771);
							break;
						case 4:
							f.blendFuncSeparate(0, 768, 0, 770);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", a)
					} else switch (a) {
						case 1:
							f.blendFuncSeparate(770, 771, 1, 771);
							break;
						case 2:
							f.blendFunc(770, 1);
							break;
						case 3:
							f.blendFunc(0, 769);
							break;
						case 4:
							f.blendFunc(0, 768);
							break;
						default:
							console.error("THREE.WebGLState: Invalid blending: ", a)
					}
					N = Ih = La = M = null;
					B = a;
					ra = r
				}
			} else {
				l = l || c;
				m = m || d;
				n = n || e;
				if (c !== Va || l !== Fg) f.blendEquationSeparate(b.convert(c), b.convert(l)), Va = c, Fg = l;
				if (d !== M || e !== La || m !==
					Ih || n !== N) f.blendFuncSeparate(b.convert(d), b.convert(e), b.convert(m), b.convert(n)), M = d, La = e, Ih = m,
					N = n;
				B = a;
				ra = null
			}
		}

		function m(a) {
			ya !== a && (a ? f.frontFace(2304) : f.frontFace(2305), ya = a)
		}

		function n(a) {
			0 !== a ? (g(2884), a !== Pk && (1 === a ? f.cullFace(1029) : 2 === a ? f.cullFace(1028) : f.cullFace(1032))) : k(
				2884);
			Pk = a
		}

		function r(a, b, c) {
			if (a) {
				if (g(32823), Sm !== b || Jh !== c) f.polygonOffset(b, c), Sm = b, Jh = c
			} else k(32823)
		}

		function v(a) {
			void 0 === a && (a = 33984 + L - 1);
			P !== a && (f.activeTexture(a), P = a)
		}
		var A = new function() {
				var a = !1,
					b = new za,
					c = null,
					d = new za(0, 0, 0, 0);
				return {
					setMask: function(b) {
						c === b || a || (f.colorMask(b, b, b, b), c = b)
					},
					setLocked: function(b) {
						a = b
					},
					setClear: function(a, c, e, g, k) {
						!0 === k && (a *= g, c *= g, e *= g);
						b.set(a, c, e, g);
						!1 === d.equals(b) && (f.clearColor(a, c, e, g), d.copy(b))
					},
					reset: function() {
						a = !1;
						c = null;
						d.set(-1, 0, 0, 0)
					}
				}
			},
			w = new function() {
				var a = !1,
					b = null,
					c = null,
					d = null;
				return {
					setTest: function(a) {
						a ? g(2929) : k(2929)
					},
					setMask: function(c) {
						b === c || a || (f.depthMask(c), b = c)
					},
					setFunc: function(a) {
						if (c !== a) {
							if (a) switch (a) {
								case 0:
									f.depthFunc(512);
									break;
								case 1:
									f.depthFunc(519);
									break;
								case 2:
									f.depthFunc(513);
									break;
								case 3:
									f.depthFunc(515);
									break;
								case 4:
									f.depthFunc(514);
									break;
								case 5:
									f.depthFunc(518);
									break;
								case 6:
									f.depthFunc(516);
									break;
								case 7:
									f.depthFunc(517);
									break;
								default:
									f.depthFunc(515)
							} else f.depthFunc(515);
							c = a
						}
					},
					setLocked: function(b) {
						a = b
					},
					setClear: function(a) {
						d !== a && (f.clearDepth(a), d = a)
					},
					reset: function() {
						a = !1;
						d = c = b = null
					}
				}
			},
			z = new function() {
				var a = !1,
					b = null,
					c = null,
					d = null,
					e = null,
					l = null,
					m = null,
					n = null,
					r = null;
				return {
					setTest: function(b) {
						a || (b ? g(2960) :
							k(2960))
					},
					setMask: function(c) {
						b === c || a || (f.stencilMask(c), b = c)
					},
					setFunc: function(a, b, g) {
						if (c !== a || d !== b || e !== g) f.stencilFunc(a, b, g), c = a, d = b, e = g
					},
					setOp: function(a, b, c) {
						if (l !== a || m !== b || n !== c) f.stencilOp(a, b, c), l = a, m = b, n = c
					},
					setLocked: function(b) {
						a = b
					},
					setClear: function(a) {
						r !== a && (f.clearStencil(a), r = a)
					},
					reset: function() {
						a = !1;
						r = n = m = l = e = d = c = b = null
					}
				}
			},
			p = f.getParameter(34921),
			q = new Uint8Array(p),
			u = new Uint8Array(p),
			G = new Uint8Array(p),
			la = {},
			H = null,
			Q = null,
			wa = null,
			B = null,
			Va = null,
			M = null,
			La = null,
			Fg = null,
			Ih =
			null,
			N = null,
			ra = !1,
			ya = null,
			Pk = null,
			Rm = null,
			Sm = null,
			Jh = null,
			L = f.getParameter(35661),
			Rk = !1;
		p = 0;
		p = f.getParameter(7938); - 1 !== p.indexOf("WebGL") ? (p = parseFloat(/^WebGL ([0-9])/.exec(p)[1]), Rk = 1 <= p) :
			-1 !== p.indexOf("OpenGL ES") && (p = parseFloat(/^OpenGL ES ([0-9])/.exec(p)[1]), Rk = 2 <= p);
		var P = null,
			J = {},
			I = new za,
			S = new za,
			Z = {};
		Z[3553] = d(3553, 3553, 1);
		Z[34067] = d(34067, 34069, 6);
		A.setClear(0, 0, 0, 1);
		w.setClear(1);
		z.setClear(0);
		g(2929);
		w.setFunc(3);
		m(!1);
		n(1);
		g(2884);
		l(0);
		return {
			buffers: {
				color: A,
				depth: w,
				stencil: z
			},
			initAttributes: function() {
				for (var a =
						0, b = q.length; a < b; a++) q[a] = 0
			},
			enableAttribute: function(a) {
				e(a, 0)
			},
			enableAttributeAndDivisor: e,
			disableUnusedAttributes: function() {
				for (var a = 0, b = u.length; a !== b; ++a) u[a] !== q[a] && (f.disableVertexAttribArray(a), u[a] = 0)
			},
			enable: g,
			disable: k,
			getCompressedTextureFormats: function() {
				if (null === H && (H = [], a.get("WEBGL_compressed_texture_pvrtc") || a.get("WEBGL_compressed_texture_s3tc") || a
						.get("WEBGL_compressed_texture_etc1") || a.get("WEBGL_compressed_texture_astc")))
					for (var b = f.getParameter(34467), c = 0; c < b.length; c++) H.push(b[c]);
				return H
			},
			useProgram: function(a) {
				return Q !== a ? (f.useProgram(a), Q = a, !0) : !1
			},
			setBlending: l,
			setMaterial: function(a, b) {
				2 === a.side ? k(2884) : g(2884);
				var c = 1 === a.side;
				b && (c = !c);
				m(c);
				1 === a.blending && !1 === a.transparent ? l(0) : l(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha,
					a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha);
				w.setFunc(a.depthFunc);
				w.setTest(a.depthTest);
				w.setMask(a.depthWrite);
				A.setMask(a.colorWrite);
				b = a.stencilWrite;
				z.setTest(b);
				b && (z.setMask(a.stencilWriteMask), z.setFunc(a.stencilFunc,
					a.stencilRef, a.stencilFuncMask), z.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass));
				r(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
			},
			setFlipSided: m,
			setCullFace: n,
			setLineWidth: function(a) {
				a !== Rm && (Rk && f.lineWidth(a), Rm = a)
			},
			setPolygonOffset: r,
			setScissorTest: function(a) {
				a ? g(3089) : k(3089)
			},
			activeTexture: v,
			bindTexture: function(a, b) {
				null === P && v();
				var c = J[P];
				void 0 === c && (c = {
					type: void 0,
					texture: void 0
				}, J[P] = c);
				if (c.type !== a || c.texture !== b) f.bindTexture(a, b || Z[a]), c.type = a, c.texture = b
			},
			compressedTexImage2D: function() {
				try {
					f.compressedTexImage2D.apply(f,
						arguments)
				} catch (xa) {
					console.error("THREE.WebGLState:", xa)
				}
			},
			texImage2D: function() {
				try {
					f.texImage2D.apply(f, arguments)
				} catch (xa) {
					console.error("THREE.WebGLState:", xa)
				}
			},
			texImage3D: function() {
				try {
					f.texImage3D.apply(f, arguments)
				} catch (xa) {
					console.error("THREE.WebGLState:", xa)
				}
			},
			scissor: function(a) {
				!1 === I.equals(a) && (f.scissor(a.x, a.y, a.z, a.w), I.copy(a))
			},
			viewport: function(a) {
				!1 === S.equals(a) && (f.viewport(a.x, a.y, a.z, a.w), S.copy(a))
			},
			reset: function() {
				for (var a = 0; a < u.length; a++) 1 === u[a] && (f.disableVertexAttribArray(a),
					u[a] = 0);
				la = {};
				P = H = null;
				J = {};
				Pk = ya = B = Q = null;
				A.reset();
				w.reset();
				z.reset()
			}
		}
	}

	function Mq(f, a, b, c, d, e, g) {
		function k(a, b) {
			return La ? new OffscreenCanvas(a, b) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
		}

		function l(a, b, c, d) {
			var e = 1;
			if (a.width > d || a.height > d) e = d / Math.max(a.width, a.height);
			if (1 > e || !0 === b) {
				if ("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement &&
					a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap) return d = b ?
					ha.floorPowerOfTwo : Math.floor, b = d(e * a.width), e = d(e * a.height), void 0 === M && (M = k(b, e)), c = c ?
					k(b, e) : M, c.width = b, c.height = e, c.getContext("2d").drawImage(a, 0, 0, b, e), console.warn(
						"THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + b + "x" + e +
						")."), c;
				"data" in a && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height +
					").")
			}
			return a
		}

		function m(a) {
			return ha.isPowerOfTwo(a.width) && ha.isPowerOfTwo(a.height)
		}

		function n(a, b) {
			return a.generateMipmaps &&
				b && 1003 !== a.minFilter && 1006 !== a.minFilter
		}

		function r(a, b, d, e) {
			f.generateMipmap(a);
			c.get(b).__maxMipLevel = Math.log(Math.max(d, e)) * Math.LOG2E
		}

		function v(b, c) {
			if (!d.isWebGL2) return b;
			var e = b;
			6403 === b && (5126 === c && (e = 33326), 5131 === c && (e = 33325), 5121 === c && (e = 33321));
			6407 === b && (5126 === c && (e = 34837), 5131 === c && (e = 34843), 5121 === c && (e = 32849));
			6408 === b && (5126 === c && (e = 34836), 5131 === c && (e = 34842), 5121 === c && (e = 32856));
			33325 === e || 33326 === e || 34842 === e || 34836 === e ? a.get("EXT_color_buffer_float") : (34843 === e || 34837 ===
					e) &&
				console.warn(
					"THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
			return e
		}

		function A(a) {
			return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729
		}

		function w(a) {
			a = a.target;
			a.removeEventListener("dispose", w);
			var b = c.get(a);
			void 0 !== b.__webglInit && (f.deleteTexture(b.__webglTexture), c.remove(a));
			a.isVideoTexture && Va.delete(a);
			g.memory.textures--
		}

		function z(a) {
			a = a.target;
			a.removeEventListener("dispose", z);
			var b = c.get(a),
				d = c.get(a.texture);
			if (a) {
				void 0 !== d.__webglTexture &&
					f.deleteTexture(d.__webglTexture);
				a.depthTexture && a.depthTexture.dispose();
				if (a.isWebGLRenderTargetCube)
					for (d = 0; 6 > d; d++) f.deleteFramebuffer(b.__webglFramebuffer[d]), b.__webglDepthbuffer && f.deleteRenderbuffer(
						b.__webglDepthbuffer[d]);
				else f.deleteFramebuffer(b.__webglFramebuffer), b.__webglDepthbuffer && f.deleteRenderbuffer(b.__webglDepthbuffer);
				if (a.isWebGLMultiviewRenderTarget) {
					f.deleteTexture(b.__webglColorTexture);
					f.deleteTexture(b.__webglDepthStencilTexture);
					g.memory.textures -= 2;
					d = 0;
					for (var e = b.__webglViewFramebuffers.length; d <
						e; d++) f.deleteFramebuffer(b.__webglViewFramebuffers[d])
				}
				c.remove(a.texture);
				c.remove(a)
			}
			g.memory.textures--
		}

		function p(a, d) {
			var e = c.get(a);
			if (a.isVideoTexture) {
				var f = g.render.frame;
				Va.get(a) !== f && (Va.set(a, f), a.update())
			}
			if (0 < a.version && e.__version !== a.version)
				if (f = a.image, void 0 === f) console.warn(
					"THREE.WebGLRenderer: Texture marked for update but image is undefined");
				else if (!1 === f.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
			else {
				H(e, a, d);
				return
			}
			b.activeTexture(33984 +
				d);
			b.bindTexture(3553, e.__webglTexture)
		}

		function q(a, g) {
			if (6 === a.image.length) {
				var k = c.get(a);
				if (0 < a.version && k.__version !== a.version) {
					la(k, a);
					b.activeTexture(33984 + g);
					b.bindTexture(34067, k.__webglTexture);
					f.pixelStorei(37440, a.flipY);
					var w = a && a.isCompressedTexture;
					g = a.image[0] && a.image[0].isDataTexture;
					for (var A = [], z = 0; 6 > z; z++) A[z] = w || g ? g ? a.image[z].image : a.image[z] : l(a.image[z], !1, !0, d.maxCubemapSize);
					var p = A[0],
						q = m(p) || d.isWebGL2,
						u = e.convert(a.format),
						C = e.convert(a.type),
						D = v(u, C);
					G(34067, a, q);
					if (w) {
						for (z = 0; 6 > z; z++) {
							var ra = A[z].mipmaps;
							for (w = 0; w < ra.length; w++) {
								var ya = ra[w];
								1023 !== a.format && 1022 !== a.format ? -1 < b.getCompressedTextureFormats().indexOf(u) ? b.compressedTexImage2D(
									34069 + z, w, D, ya.width, ya.height, 0, ya.data) : console.warn(
									"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : b.texImage2D(
									34069 + z, w, D, ya.width, ya.height, 0, u, C, ya.data)
							}
						}
						k.__maxMipLevel = ra.length - 1
					} else {
						ra = a.mipmaps;
						for (z = 0; 6 > z; z++)
							if (g)
								for (b.texImage2D(34069 + z, 0, D, A[z].width,
										A[z].height, 0, u, C, A[z].data), w = 0; w < ra.length; w++) ya = ra[w], ya = ya.image[z].image, b.texImage2D(
									34069 + z, w + 1, D, ya.width, ya.height, 0, u, C, ya.data);
							else
								for (b.texImage2D(34069 + z, 0, D, u, C, A[z]), w = 0; w < ra.length; w++) ya = ra[w], b.texImage2D(34069 + z,
									w + 1, D, u, C, ya.image[z]);
						k.__maxMipLevel = ra.length
					}
					n(a, q) && r(34067, a, p.width, p.height);
					k.__version = a.version;
					if (a.onUpdate) a.onUpdate(a)
				} else b.activeTexture(33984 + g), b.bindTexture(34067, k.__webglTexture)
			}
		}

		function u(a, d) {
			b.activeTexture(33984 + d);
			b.bindTexture(34067, c.get(a).__webglTexture)
		}

		function G(b, g, k) {
			k ? (f.texParameteri(b, 10242, e.convert(g.wrapS)), f.texParameteri(b, 10243, e.convert(g.wrapT)), 32879 !== b &&
				35866 !== b || f.texParameteri(b, 32882, e.convert(g.wrapR)), f.texParameteri(b, 10240, e.convert(g.magFilter)),
				f.texParameteri(b, 10241, e.convert(g.minFilter))) : (f.texParameteri(b, 10242, 33071), f.texParameteri(b, 10243,
					33071), 32879 !== b && 35866 !== b || f.texParameteri(b, 32882, 33071), 1001 === g.wrapS && 1001 === g.wrapT ||
				console.warn(
					"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
				),
				f.texParameteri(b, 10240, A(g.magFilter)), f.texParameteri(b, 10241, A(g.minFilter)), 1003 !== g.minFilter &&
				1006 !== g.minFilter && console.warn(
					"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
				));
			!(k = a.get("EXT_texture_filter_anisotropic")) || 1015 === g.type && null === a.get("OES_texture_float_linear") ||
				1016 === g.type && null === (d.isWebGL2 || a.get("OES_texture_half_float_linear")) || !(1 < g.anisotropy || c.get(
					g).__currentAnisotropy) || (f.texParameterf(b,
					k.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(g.anisotropy, d.getMaxAnisotropy())), c.get(g).__currentAnisotropy = g.anisotropy)
		}

		function la(a, b) {
			void 0 === a.__webglInit && (a.__webglInit = !0, b.addEventListener("dispose", w), a.__webglTexture = f.createTexture(),
				g.memory.textures++)
		}

		function H(a, c, g) {
			var k = 3553;
			c.isDataTexture2DArray && (k = 35866);
			c.isDataTexture3D && (k = 32879);
			la(a, c);
			b.activeTexture(33984 + g);
			b.bindTexture(k, a.__webglTexture);
			f.pixelStorei(37440, c.flipY);
			f.pixelStorei(37441, c.premultiplyAlpha);
			f.pixelStorei(3317,
				c.unpackAlignment);
			g = d.isWebGL2 ? !1 : 1001 !== c.wrapS || 1001 !== c.wrapT || 1003 !== c.minFilter && 1006 !== c.minFilter;
			g = g && !1 === m(c.image);
			g = l(c.image, g, !1, d.maxTextureSize);
			var w = m(g) || d.isWebGL2,
				z = e.convert(c.format),
				A = e.convert(c.type),
				p = v(z, A);
			G(k, c, w);
			var q = c.mipmaps;
			if (c.isDepthTexture) {
				p = 6402;
				if (1015 === c.type) {
					if (!d.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
					p = 36012
				} else d.isWebGL2 && (p = 33189);
				1026 === c.format && 6402 === p && 1012 !== c.type && 1014 !== c.type && (console.warn(
						"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
					c.type = 1012, A = e.convert(c.type));
				1027 === c.format && (p = 34041, 1020 !== c.type && (console.warn(
					"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), c.type = 1020, A = e.convert(
					c.type)));
				b.texImage2D(3553, 0, p, g.width, g.height, 0, z, A, null)
			} else if (c.isDataTexture)
				if (0 < q.length && w) {
					for (var u = 0, C = q.length; u < C; u++) k = q[u], b.texImage2D(3553, u, p, k.width, k.height, 0, z, A, k.data);
					c.generateMipmaps = !1;
					a.__maxMipLevel = q.length - 1
				} else b.texImage2D(3553, 0, p, g.width, g.height, 0, z, A, g.data), a.__maxMipLevel =
					0;
			else if (c.isCompressedTexture) {
				u = 0;
				for (C = q.length; u < C; u++) k = q[u], 1023 !== c.format && 1022 !== c.format ? -1 < b.getCompressedTextureFormats()
					.indexOf(z) ? b.compressedTexImage2D(3553, u, p, k.width, k.height, 0, k.data) : console.warn(
						"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : b.texImage2D(
						3553, u, p, k.width, k.height, 0, z, A, k.data);
				a.__maxMipLevel = q.length - 1
			} else if (c.isDataTexture2DArray) b.texImage3D(35866, 0, p, g.width, g.height, g.depth, 0, z, A, g.data), a.__maxMipLevel =
				0;
			else if (c.isDataTexture3D) b.texImage3D(32879, 0, p, g.width, g.height, g.depth, 0, z, A, g.data), a.__maxMipLevel =
				0;
			else if (0 < q.length && w) {
				u = 0;
				for (C = q.length; u < C; u++) k = q[u], b.texImage2D(3553, u, p, z, A, k);
				c.generateMipmaps = !1;
				a.__maxMipLevel = q.length - 1
			} else b.texImage2D(3553, 0, p, z, A, g), a.__maxMipLevel = 0;
			n(c, w) && r(3553, c, g.width, g.height);
			a.__version = c.version;
			if (c.onUpdate) c.onUpdate(c)
		}

		function Q(a, d, g, k) {
			var l = e.convert(d.texture.format),
				m = e.convert(d.texture.type),
				n = v(l, m);
			b.texImage2D(k, 0, n, d.width, d.height,
				0, l, m, null);
			f.bindFramebuffer(36160, a);
			f.framebufferTexture2D(36160, g, k, c.get(d.texture).__webglTexture, 0);
			f.bindFramebuffer(36160, null)
		}

		function B(a, b, c) {
			f.bindRenderbuffer(36161, a);
			if (b.depthBuffer && !b.stencilBuffer) c ? (c = N(b), f.renderbufferStorageMultisample(36161, c, 33189, b.width, b.height)) :
				f.renderbufferStorage(36161, 33189, b.width, b.height), f.framebufferRenderbuffer(36160, 36096, 36161, a);
			else if (b.depthBuffer && b.stencilBuffer) c ? (c = N(b), f.renderbufferStorageMultisample(36161, c, 35056, b.width,
					b.height)) :
				f.renderbufferStorage(36161, 34041, b.width, b.height), f.framebufferRenderbuffer(36160, 33306, 36161, a);
			else {
				a = e.convert(b.texture.format);
				var d = e.convert(b.texture.type);
				a = v(a, d);
				c ? (c = N(b), f.renderbufferStorageMultisample(36161, c, a, b.width, b.height)) : f.renderbufferStorage(36161, a,
					b.width, b.height)
			}
			f.bindRenderbuffer(36161, null)
		}

		function N(a) {
			return d.isWebGL2 && a.isWebGLMultisampleRenderTarget ? Math.min(d.maxSamples, a.samples) : 0
		}
		var Va = new Fa,
			M, La = "undefined" !== typeof OffscreenCanvas && null !== (new OffscreenCanvas(1,
				1)).getContext("2d"),
			Fg = 0,
			P = !1,
			J = !1;
		this.allocateTextureUnit = function() {
			var a = Fg;
			a >= d.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + a +
				" texture units while this GPU supports only " + d.maxTextures);
			Fg += 1;
			return a
		};
		this.resetTextureUnits = function() {
			Fg = 0
		};
		this.setTexture2D = p;
		this.setTexture2DArray = function(a, d) {
			var e = c.get(a);
			0 < a.version && e.__version !== a.version ? H(e, a, d) : (b.activeTexture(33984 + d), b.bindTexture(35866, e.__webglTexture))
		};
		this.setTexture3D = function(a, d) {
			var e = c.get(a);
			0 < a.version && e.__version !== a.version ? H(e, a, d) : (b.activeTexture(33984 + d), b.bindTexture(32879, e.__webglTexture))
		};
		this.setTextureCube = q;
		this.setTextureCubeDynamic = u;
		this.setupRenderTarget = function(k) {
			var l = c.get(k),
				w = c.get(k.texture);
			k.addEventListener("dispose", z);
			w.__webglTexture = f.createTexture();
			g.memory.textures++;
			var A = !0 === k.isWebGLRenderTargetCube,
				q = !0 === k.isWebGLMultisampleRenderTarget,
				u = !0 === k.isWebGLMultiviewRenderTarget,
				C = m(k) || d.isWebGL2;
			if (A) {
				l.__webglFramebuffer = [];
				for (var D = 0; 6 > D; D++) l.__webglFramebuffer[D] =
					f.createFramebuffer()
			} else if (l.__webglFramebuffer = f.createFramebuffer(), q)
				if (d.isWebGL2) {
					l.__webglMultisampledFramebuffer = f.createFramebuffer();
					l.__webglColorRenderbuffer = f.createRenderbuffer();
					f.bindRenderbuffer(36161, l.__webglColorRenderbuffer);
					q = e.convert(k.texture.format);
					var K = e.convert(k.texture.type);
					q = v(q, K);
					K = N(k);
					f.renderbufferStorageMultisample(36161, K, q, k.width, k.height);
					f.bindFramebuffer(36160, l.__webglMultisampledFramebuffer);
					f.framebufferRenderbuffer(36160, 36064, 36161, l.__webglColorRenderbuffer);
					f.bindRenderbuffer(36161, null);
					k.depthBuffer && (l.__webglDepthRenderbuffer = f.createRenderbuffer(), B(l.__webglDepthRenderbuffer, k, !0));
					f.bindFramebuffer(36160, null)
				} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
			else if (u) {
				D = k.width;
				var H = k.height;
				q = k.numViews;
				f.bindFramebuffer(36160, l.__webglFramebuffer);
				var la = a.get("OVR_multiview2");
				g.memory.textures += 2;
				K = f.createTexture();
				f.bindTexture(35866, K);
				f.texParameteri(35866, 10240, 9728);
				f.texParameteri(35866,
					10241, 9728);
				f.texImage3D(35866, 0, 32856, D, H, q, 0, 6408, 5121, null);
				la.framebufferTextureMultiviewOVR(36160, 36064, K, 0, 0, q);
				var M = f.createTexture();
				f.bindTexture(35866, M);
				f.texParameteri(35866, 10240, 9728);
				f.texParameteri(35866, 10241, 9728);
				f.texImage3D(35866, 0, 35056, D, H, q, 0, 34041, 34042, null);
				la.framebufferTextureMultiviewOVR(36160, 33306, M, 0, 0, q);
				H = Array(q);
				for (D = 0; D < q; ++D) H[D] = f.createFramebuffer(), f.bindFramebuffer(36160, H[D]), f.framebufferTextureLayer(
					36160, 36064, K, 0, D);
				l.__webglColorTexture = K;
				l.__webglDepthStencilTexture =
					M;
				l.__webglViewFramebuffers = H;
				f.bindFramebuffer(36160, null);
				f.bindTexture(35866, null)
			}
			if (A) {
				b.bindTexture(34067, w.__webglTexture);
				G(34067, k.texture, C);
				for (D = 0; 6 > D; D++) Q(l.__webglFramebuffer[D], k, 36064, 34069 + D);
				n(k.texture, C) && r(34067, k.texture, k.width, k.height);
				b.bindTexture(34067, null)
			} else u || (b.bindTexture(3553, w.__webglTexture), G(3553, k.texture, C), Q(l.__webglFramebuffer, k, 36064, 3553),
				n(k.texture, C) && r(3553, k.texture, k.width, k.height), b.bindTexture(3553, null));
			if (k.depthBuffer) {
				l = c.get(k);
				w = !0 ===
					k.isWebGLRenderTargetCube;
				if (k.depthTexture) {
					if (w) throw Error("target.depthTexture not supported in Cube render targets");
					if (k && k.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
					f.bindFramebuffer(36160, l.__webglFramebuffer);
					if (!k.depthTexture || !k.depthTexture.isDepthTexture) throw Error(
						"renderTarget.depthTexture must be an instance of THREE.DepthTexture");
					c.get(k.depthTexture).__webglTexture && k.depthTexture.image.width === k.width && k.depthTexture.image.height ===
						k.height || (k.depthTexture.image.width = k.width, k.depthTexture.image.height = k.height, k.depthTexture.needsUpdate = !
							0);
					p(k.depthTexture, 0);
					l = c.get(k.depthTexture).__webglTexture;
					if (1026 === k.depthTexture.format) f.framebufferTexture2D(36160, 36096, 3553, l, 0);
					else if (1027 === k.depthTexture.format) f.framebufferTexture2D(36160, 33306, 3553, l, 0);
					else throw Error("Unknown depthTexture format");
				} else if (w)
					for (l.__webglDepthbuffer = [], w = 0; 6 > w; w++) f.bindFramebuffer(36160, l.__webglFramebuffer[w]), l.__webglDepthbuffer[
							w] =
						f.createRenderbuffer(), B(l.__webglDepthbuffer[w], k);
				else f.bindFramebuffer(36160, l.__webglFramebuffer), l.__webglDepthbuffer = f.createRenderbuffer(), B(l.__webglDepthbuffer,
					k);
				f.bindFramebuffer(36160, null)
			}
		};
		this.updateRenderTargetMipmap = function(a) {
			var e = a.texture,
				f = m(a) || d.isWebGL2;
			if (n(e, f)) {
				f = a.isWebGLRenderTargetCube ? 34067 : 3553;
				var g = c.get(e).__webglTexture;
				b.bindTexture(f, g);
				r(f, e, a.width, a.height);
				b.bindTexture(f, null)
			}
		};
		this.updateMultisampleRenderTarget = function(a) {
			if (a.isWebGLMultisampleRenderTarget)
				if (d.isWebGL2) {
					var b =
						c.get(a);
					f.bindFramebuffer(36008, b.__webglMultisampledFramebuffer);
					f.bindFramebuffer(36009, b.__webglFramebuffer);
					b = a.width;
					var e = a.height,
						g = 16384;
					a.depthBuffer && (g |= 256);
					a.stencilBuffer && (g |= 1024);
					f.blitFramebuffer(0, 0, b, e, 0, 0, b, e, g, 9728)
				} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
		};
		this.safeSetTexture2D = function(a, b) {
			a && a.isWebGLRenderTarget && (!1 === P && (console.warn(
					"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
				),
				P = !0), a = a.texture);
			p(a, b)
		};
		this.safeSetTextureCube = function(a, b) {
			a && a.isWebGLRenderTargetCube && (!1 === J && (console.warn(
				"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
			), J = !0), a = a.texture);
			a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? q(a, b) : u(a, b)
		}
	}

	function Nq(f, a, b) {
		return {
			convert: function(c) {
				if (1E3 === c) return 10497;
				if (1001 === c) return 33071;
				if (1002 === c) return 33648;
				if (1003 === c) return 9728;
				if (1004 === c) return 9984;
				if (1005 === c) return 9986;
				if (1006 === c) return 9729;
				if (1007 === c) return 9985;
				if (1008 === c) return 9987;
				if (1009 === c) return 5121;
				if (1017 === c) return 32819;
				if (1018 === c) return 32820;
				if (1019 === c) return 33635;
				if (1010 === c) return 5120;
				if (1011 === c) return 5122;
				if (1012 === c) return 5123;
				if (1013 === c) return 5124;
				if (1014 === c) return 5125;
				if (1015 === c) return 5126;
				if (1016 === c) {
					if (b.isWebGL2) return 5131;
					var d = a.get("OES_texture_half_float");
					if (null !== d) return d.HALF_FLOAT_OES
				}
				if (1021 === c) return 6406;
				if (1022 === c) return 6407;
				if (1023 ===
					c) return 6408;
				if (1024 === c) return 6409;
				if (1025 === c) return 6410;
				if (1026 === c) return 6402;
				if (1027 === c) return 34041;
				if (1028 === c) return 6403;
				if (100 === c) return 32774;
				if (101 === c) return 32778;
				if (102 === c) return 32779;
				if (200 === c) return 0;
				if (201 === c) return 1;
				if (202 === c) return 768;
				if (203 === c) return 769;
				if (204 === c) return 770;
				if (205 === c) return 771;
				if (206 === c) return 772;
				if (207 === c) return 773;
				if (208 === c) return 774;
				if (209 === c) return 775;
				if (210 === c) return 776;
				if (33776 === c || 33777 === c || 33778 === c || 33779 === c)
					if (d = a.get("WEBGL_compressed_texture_s3tc"),
						null !== d) {
						if (33776 === c) return d.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if (33777 === c) return d.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if (33778 === c) return d.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if (33779 === c) return d.COMPRESSED_RGBA_S3TC_DXT5_EXT
					} if (35840 === c || 35841 === c || 35842 === c || 35843 === c)
					if (d = a.get("WEBGL_compressed_texture_pvrtc"), null !== d) {
						if (35840 === c) return d.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if (35841 === c) return d.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if (35842 === c) return d.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if (35843 === c) return d.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
					} if (36196 ===
					c && (d = a.get("WEBGL_compressed_texture_etc1"), null !== d)) return d.COMPRESSED_RGB_ETC1_WEBGL;
				if (37808 === c || 37809 === c || 37810 === c || 37811 === c || 37812 === c || 37813 === c || 37814 === c ||
					37815 === c || 37816 === c || 37817 === c || 37818 === c || 37819 === c || 37820 === c || 37821 === c)
					if (d = a.get("WEBGL_compressed_texture_astc"), null !== d) return c;
				if (103 === c || 104 === c) {
					if (b.isWebGL2) {
						if (103 === c) return 32775;
						if (104 === c) return 32776
					}
					d = a.get("EXT_blend_minmax");
					if (null !== d) {
						if (103 === c) return d.MIN_EXT;
						if (104 === c) return d.MAX_EXT
					}
				}
				if (1020 === c) {
					if (b.isWebGL2) return 34042;
					d = a.get("WEBGL_depth_texture");
					if (null !== d) return d.UNSIGNED_INT_24_8_WEBGL
				}
				return 0
			}
		}
	}

	function ek(f, a, b, c) {
		Oa.call(this, f, a, c);
		this.stencilBuffer = this.depthBuffer = !1;
		this.numViews = b
	}

	function Oq(f, a) {
		function b(a) {
			if (a.isArrayCamera) return a.cameras;
			n[0] = a;
			return n
		}

		function c(a) {
			if (void 0 === a.isArrayCamera) return !0;
			a = a.cameras;
			if (a.length > A) return !1;
			for (var b = 1, c = a.length; b < c; b++)
				if (a[0].viewport.z !== a[b].viewport.z || a[0].viewport.w !== a[b].viewport.w) return !1;
			return !0
		}
		var d = f.extensions,
			e = f.properties,
			g, k, l, m, n, r, v, A = 0;
		this.isAvailable = function() {
			if (void 0 === v) {
				var b = d.get("OVR_multiview2");
				if (v = null !== b && !1 === a.getContextAttributes().antialias)
					for (A = a.getParameter(b.MAX_VIEWS_OVR), g = new ek(0, 0, 2), r = new B, m = [], l = [], n = [], b = 0; b < A; b++)
						m[b] = new ua, l[b] = new kb
			}
			return v
		};
		this.attachCamera = function(a) {
			if (!1 !== c(a)) {
				(k = f.getRenderTarget()) ? r.set(k.width, k.height): f.getDrawingBufferSize(r);
				if (a.isArrayCamera) {
					var b = a.cameras[0].viewport;
					g.setSize(b.z, b.w);
					g.setNumViews(a.cameras.length)
				} else g.setSize(r.x,
					r.y), g.setNumViews(2);
				f.setRenderTarget(g)
			}
		};
		this.detachCamera = function(b) {
			if (g === f.getRenderTarget()) {
				f.setRenderTarget(k);
				var c = g,
					d = c.numViews,
					l = e.get(c).__webglViewFramebuffers,
					m = c.width;
				c = c.height;
				if (b.isArrayCamera)
					for (var n = 0; n < d; n++) {
						var v = b.cameras[n].viewport,
							w = v.x,
							A = v.y,
							p = w + v.z;
						v = A + v.w;
						a.bindFramebuffer(36008, l[n]);
						a.blitFramebuffer(0, 0, m, c, w, A, p, v, 16384, 9728)
					} else a.bindFramebuffer(36008, l[0]), a.blitFramebuffer(0, 0, m, c, 0, 0, r.x, r.y, 16384, 9728)
			}
		};
		this.updateCameraProjectionMatricesUniform =
			function(c, d) {
				c = b(c);
				for (var e = 0; e < c.length; e++) m[e].copy(c[e].projectionMatrix);
				d.setValue(a, "projectionMatrices", m)
			};
		this.updateCameraViewMatricesUniform = function(c, d) {
			c = b(c);
			for (var e = 0; e < c.length; e++) m[e].copy(c[e].matrixWorldInverse);
			d.setValue(a, "viewMatrices", m)
		};
		this.updateObjectMatricesUniforms = function(c, d, e) {
			d = b(d);
			for (var f = 0; f < d.length; f++) m[f].multiplyMatrices(d[f].matrixWorldInverse, c.matrixWorld), l[f].getNormalMatrix(
				m[f]);
			e.setValue(a, "modelViewMatrices", m);
			e.setValue(a, "normalMatrices",
				l)
		}
	}

	function Hg() {
		P.call(this);
		this.type = "Group"
	}

	function Yi(f) {
		ab.call(this);
		this.cameras = f || []
	}

	function Tm(f, a, b) {
		Um.setFromMatrixPosition(a.matrixWorld);
		Vm.setFromMatrixPosition(b.matrixWorld);
		var c = Um.distanceTo(Vm),
			d = a.projectionMatrix.elements,
			e = b.projectionMatrix.elements,
			g = d[14] / (d[10] - 1);
		b = d[14] / (d[10] + 1);
		var k = (d[9] + 1) / d[5],
			l = (d[9] - 1) / d[5],
			m = (d[8] - 1) / d[0],
			n = (e[8] + 1) / e[0];
		d = g * m;
		e = g * n;
		n = c / (-m + n);
		m = n * -m;
		a.matrixWorld.decompose(f.position, f.quaternion, f.scale);
		f.translateX(m);
		f.translateZ(n);
		f.matrixWorld.compose(f.position, f.quaternion, f.scale);
		f.matrixWorldInverse.getInverse(f.matrixWorld);
		a = g + n;
		g = b + n;
		f.projectionMatrix.makePerspective(d - m, e + (c - m), k * b / g * a, l * b / g * a, a, g)
	}

	function fk(f) {
		function a() {
			return null !== k && !0 === k.isPresenting
		}

		function b() {
			if (a()) {
				var b = k.getEyeParameters("left");
				d = 2 * b.renderWidth * A;
				e = b.renderHeight * A;
				Q = f.getPixelRatio();
				f.getSize(H);
				f.setDrawingBufferSize(d, e, 1);
				K.viewport.set(0, 0, d / 2, e);
				G.viewport.set(d / 2, 0, d / 2, e);
				N.start();
				g.dispatchEvent({
					type: "sessionstart"
				})
			} else g.enabled &&
				f.setDrawingBufferSize(H.width, H.height, Q), N.stop(), g.dispatchEvent({
					type: "sessionend"
				})
		}

		function c(a, b) {
			null !== b && 4 === b.length && a.set(b[0] * d, b[1] * e, b[2] * d, b[3] * e)
		}
		var d, e, g = this,
			k = null,
			l = null,
			m = null,
			n = [],
			r = new ua,
			v = new ua,
			A = 1,
			w = "local-floor";
		"undefined" !== typeof window && "VRFrameData" in window && (l = new window.VRFrameData, window.addEventListener(
			"vrdisplaypresentchange", b, !1));
		var z = new ua,
			p = new vb,
			q = new u,
			K = new ab;
		K.viewport = new za;
		K.layers.enable(1);
		var G = new ab;
		G.viewport = new za;
		G.layers.enable(2);
		var la = new Yi([K, G]);
		la.layers.enable(1);
		la.layers.enable(2);
		var H = new B,
			Q, wa = [];
		this.enabled = !1;
		this.getController = function(a) {
			var b = n[a];
			void 0 === b && (b = new Hg, b.matrixAutoUpdate = !1, b.visible = !1, n[a] = b);
			return b
		};
		this.getDevice = function() {
			return k
		};
		this.setDevice = function(a) {
			void 0 !== a && (k = a);
			N.setContext(a)
		};
		this.setFramebufferScaleFactor = function(a) {
			A = a
		};
		this.setReferenceSpaceType = function(a) {
			w = a
		};
		this.setPoseTarget = function(a) {
			void 0 !== a && (m = a)
		};
		this.getCamera = function(b) {
			var d = "local-floor" ===
				w ? 1.6 : 0;
			if (!1 === a()) return b.position.set(0, d, 0), b.rotation.set(0, 0, 0), b;
			k.depthNear = b.near;
			k.depthFar = b.far;
			k.getFrameData(l);
			if ("local-floor" === w) {
				var e = k.stageParameters;
				e ? r.fromArray(e.sittingToStandingTransform) : r.makeTranslation(0, d, 0)
			}
			d = l.pose;
			e = null !== m ? m : b;
			e.matrix.copy(r);
			e.matrix.decompose(e.position, e.quaternion, e.scale);
			null !== d.orientation && (p.fromArray(d.orientation), e.quaternion.multiply(p));
			null !== d.position && (p.setFromRotationMatrix(r), q.fromArray(d.position), q.applyQuaternion(p),
				e.position.add(q));
			e.updateMatrixWorld();
			K.near = b.near;
			G.near = b.near;
			K.far = b.far;
			G.far = b.far;
			K.matrixWorldInverse.fromArray(l.leftViewMatrix);
			G.matrixWorldInverse.fromArray(l.rightViewMatrix);
			v.getInverse(r);
			"local-floor" === w && (K.matrixWorldInverse.multiply(v), G.matrixWorldInverse.multiply(v));
			b = e.parent;
			null !== b && (z.getInverse(b.matrixWorld), K.matrixWorldInverse.multiply(z), G.matrixWorldInverse.multiply(z));
			K.matrixWorld.getInverse(K.matrixWorldInverse);
			G.matrixWorld.getInverse(G.matrixWorldInverse);
			K.projectionMatrix.fromArray(l.leftProjectionMatrix);
			G.projectionMatrix.fromArray(l.rightProjectionMatrix);
			Tm(la, K, G);
			b = k.getLayers();
			b.length && (b = b[0], c(K.viewport, b.leftBounds), c(G.viewport, b.rightBounds));
			a: for (b = 0; b < n.length; b++) {
				d = n[b];
				b: {
					e = b;
					for (var f = navigator.getGamepads && navigator.getGamepads(), g = 0, A = 0, u = f.length; g < u; g++) {
						var C = f[g];
						if (C && ("Daydream Controller" === C.id || "Gear VR Controller" === C.id || "Oculus Go Controller" === C.id ||
								"OpenVR Gamepad" === C.id || C.id.startsWith("Oculus Touch") || C.id.startsWith("HTC Vive Focus") ||
								C.id.startsWith("Spatial Controller"))) {
							if (A === e) {
								e = C;
								break b
							}
							A++
						}
					}
					e = void 0
				}
				if (void 0 !== e && void 0 !== e.pose) {
					if (null === e.pose) break a;
					f = e.pose;
					!1 === f.hasPosition && d.position.set(.2, -.6, -.05);
					null !== f.position && d.position.fromArray(f.position);
					null !== f.orientation && d.quaternion.fromArray(f.orientation);
					d.matrix.compose(d.position, d.quaternion, d.scale);
					d.matrix.premultiply(r);
					d.matrix.decompose(d.position, d.quaternion, d.scale);
					d.matrixWorldNeedsUpdate = !0;
					d.visible = !0;
					f = "Daydream Controller" === e.id ? 0 :
						1;
					void 0 === wa[b] && (wa[b] = !1);
					wa[b] !== e.buttons[f].pressed && (wa[b] = e.buttons[f].pressed, !0 === wa[b] ? d.dispatchEvent({
						type: "selectstart"
					}) : (d.dispatchEvent({
						type: "selectend"
					}), d.dispatchEvent({
						type: "select"
					})))
				} else d.visible = !1
			}
			return la
		};
		this.getStandingMatrix = function() {
			return r
		};
		this.isPresenting = a;
		var N = new Vi;
		this.setAnimationLoop = function(b) {
			N.setAnimationLoop(b);
			a() && N.start()
		};
		this.submitFrame = function() {
			a() && k.submitFrame()
		};
		this.dispose = function() {
			"undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange",
				b)
		};
		this.setFrameOfReferenceType = function() {
			console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
		}
	}

	function Wm(f, a) {
		function b() {
			return null !== l && null !== m
		}

		function c(a) {
			for (var b = 0; b < v.length; b++) A[b] === a.inputSource && v[b].dispatchEvent({
				type: a.type
			})
		}

		function d() {
			f.setFramebuffer(null);
			f.setRenderTarget(f.getRenderTarget());
			u.stop();
			k.dispatchEvent({
				type: "sessionend"
			})
		}

		function e(a) {
			m = a;
			u.setContext(l);
			u.start();
			k.dispatchEvent({
				type: "sessionstart"
			})
		}

		function g(a, b) {
			null ===
				b ? a.matrixWorld.copy(a.matrix) : a.matrixWorld.multiplyMatrices(b.matrixWorld, a.matrix);
			a.matrixWorldInverse.getInverse(a.matrixWorld)
		}
		var k = this,
			l = null,
			m = null,
			n = "local-floor",
			r = null,
			v = [],
			A = [],
			w = new ab;
		w.layers.enable(1);
		w.viewport = new za;
		var z = new ab;
		z.layers.enable(2);
		z.viewport = new za;
		var p = new Yi([w, z]);
		p.layers.enable(1);
		p.layers.enable(2);
		this.enabled = !1;
		this.getController = function(a) {
			var b = v[a];
			void 0 === b && (b = new Hg, b.matrixAutoUpdate = !1, b.visible = !1, v[a] = b);
			return b
		};
		this.setFramebufferScaleFactor =
			function() {};
		this.setReferenceSpaceType = function(a) {
			n = a
		};
		this.getSession = function() {
			return l
		};
		this.setSession = function(b) {
			l = b;
			null !== l && (l.addEventListener("select", c), l.addEventListener("selectstart", c), l.addEventListener(
				"selectend", c), l.addEventListener("end", d), l.updateRenderState({
				baseLayer: new XRWebGLLayer(l, a)
			}), l.requestReferenceSpace(n).then(e), A = l.inputSources, l.addEventListener("inputsourceschange", function() {
				A = l.inputSources;
				for (var a = 0; a < v.length; a++) v[a].userData.inputSource = A[a]
			}))
		};
		this.getCamera = function(a) {
			if (b()) {
				var c = a.parent,
					d = p.cameras;
				g(p, c);
				for (var e = 0; e < d.length; e++) g(d[e], c);
				a.matrixWorld.copy(p.matrixWorld);
				a = a.children;
				e = 0;
				for (c = a.length; e < c; e++) a[e].updateMatrixWorld(!0);
				Tm(p, w, z);
				return p
			}
			return a
		};
		this.isPresenting = b;
		var q = null,
			u = new Vi;
		u.setAnimationLoop(function(a, b) {
			r = b.getViewerPose(m);
			if (null !== r) {
				var c = r.views,
					d = l.renderState.baseLayer;
				f.setFramebuffer(d.framebuffer);
				for (var e = 0; e < c.length; e++) {
					var g = c[e],
						k = d.getViewport(g),
						n = p.cameras[e];
					n.matrix.fromArray(g.transform.inverse.matrix).getInverse(n.matrix);
					n.projectionMatrix.fromArray(g.projectionMatrix);
					n.viewport.set(k.x, k.y, k.width, k.height);
					0 === e && p.matrix.copy(n.matrix)
				}
			}
			for (e = 0; e < v.length; e++) {
				c = v[e];
				if (d = A[e])
					if (d = b.getPose(d.targetRaySpace, m), null !== d) {
						c.matrix.fromArray(d.transform.matrix);
						c.matrix.decompose(c.position, c.rotation, c.scale);
						c.visible = !0;
						continue
					} c.visible = !1
			}
			q && q(a)
		});
		this.setAnimationLoop = function(a) {
			q = a
		};
		this.dispose = function() {};
		this.getStandingMatrix = function() {
			console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
			return new ua
		};
		this.getDevice = function() {
			console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
		};
		this.setDevice = function() {
			console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
		};
		this.setFrameOfReferenceType = function() {
			console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
		};
		this.submitFrame = function() {}
	}

	function Xm(f) {
		var a;

		function b() {
			bb = new Ep(U);
			Qb = new Cp(U, bb, f);
			!1 === Qb.isWebGL2 && (bb.get("WEBGL_depth_texture"), bb.get("OES_texture_float"),
				bb.get("OES_texture_half_float"), bb.get("OES_texture_half_float_linear"), bb.get("OES_standard_derivatives"), bb
				.get("OES_element_index_uint"), bb.get("ANGLE_instanced_arrays"));
			bb.get("OES_texture_float_linear");
			Da = new Nq(U, bb, Qb);
			aa = new Lq(U, bb, Da, Qb);
			aa.scissor(I.copy(ma).multiplyScalar(T).floor());
			aa.viewport(F.copy(da).multiplyScalar(T).floor());
			ba = new Hp(U);
			fa = new Cq;
			Aa = new Mq(U, bb, aa, fa, Qb, Da, ba);
			va = new zp(U);
			Ba = new Fp(U, va, ba);
			Ia = new Kp(U, Ba, va, ba);
			Wa = new Jp(U);
			Fa = new Bq(J, bb, Qb);
			Ra = new Fq;
			Na =
				new Kq;
			qa = new Ap(J, aa, Ia, Q);
			Xa = new Bp(U, bb, ba, Qb);
			Ya = new Gp(U, bb, ba, Qb);
			ba.programs = Fa.programs;
			J.capabilities = Qb;
			J.extensions = bb;
			J.properties = fa;
			J.renderLists = Ra;
			J.state = aa;
			J.info = ba
		}

		function c(a) {
			a.preventDefault();
			Ih = !0
		}

		function d() {
			Ih = !1;
			b()
		}

		function e(a) {
			a = a.target;
			a.removeEventListener("dispose", e);
			g(a);
			fa.remove(a)
		}

		function g(a) {
			var b = fa.get(a).program;
			a.program = void 0;
			void 0 !== b && Fa.releaseProgram(b)
		}

		function k(a, b) {
			a.render(function(a) {
				J.renderBufferImmediate(a, b)
			})
		}

		function l(a, b, c, d) {
			if (!1 !==
				a.visible) {
				if (a.layers.test(b.layers))
					if (a.isGroup) c = a.renderOrder;
					else if (a.isLOD) !0 === a.autoUpdate && a.update(b);
				else if (a.isLight) La.pushLight(a), a.castShadow && La.pushShadow(a);
				else if (a.isSprite) {
					if (!a.frustumCulled || Qk.intersectsSprite(a)) {
						d && Gg.setFromMatrixPosition(a.matrixWorld).applyMatrix4(dk);
						var e = Ia.update(a),
							f = a.material;
						f.visible && M.push(a, e, f, c, Gg.z, null)
					}
				} else if (a.isImmediateRenderObject) d && Gg.setFromMatrixPosition(a.matrixWorld).applyMatrix4(dk), M.push(a,
					null, a.material, c, Gg.z, null);
				else if (a.isMesh || a.isLine || a.isPoints)
					if (a.isSkinnedMesh && a.skeleton.frame !== ba.render.frame && (a.skeleton.update(), a.skeleton.frame = ba.render
							.frame), !a.frustumCulled || Qk.intersectsObject(a))
						if (d && Gg.setFromMatrixPosition(a.matrixWorld).applyMatrix4(dk), e = Ia.update(a), f = a.material, Array.isArray(
								f))
							for (var g = e.groups, k = 0, m = g.length; k < m; k++) {
								var n = g[k],
									r = f[n.materialIndex];
								r && r.visible && M.push(a, e, r, c, Gg.z, n)
							} else f.visible && M.push(a, e, f, c, Gg.z, null);
				a = a.children;
				k = 0;
				for (m = a.length; k < m; k++) l(a[k], b,
					c, d)
			}
		}

		function m(a, b, c, d) {
			for (var e = 0, f = a.length; e < f; e++) {
				var g = a[e],
					k = g.object,
					l = g.geometry,
					m = void 0 === d ? g.material : d;
				g = g.group;
				if (c.isArrayCamera)
					if (ia = c, Ha.enabled && Oa.isAvailable()) n(k, b, c, l, m, g);
					else
						for (var r = c.cameras, v = 0, w = r.length; v < w; v++) {
							var A = r[v];
							k.layers.test(A.layers) && (aa.viewport(F.copy(A.viewport)), La.setupLights(A), n(k, b, A, l, m, g))
						} else ia = null, n(k, b, c, l, m, g)
			}
		}

		function n(b, c, d, e, f, g) {
			b.onBeforeRender(J, c, d, e, f, g);
			La = Na.get(c, ia || d);
			b.modelViewMatrix.multiplyMatrices(d.matrixWorldInverse,
				b.matrixWorld);
			b.normalMatrix.getNormalMatrix(b.modelViewMatrix);
			if (b.isImmediateRenderObject) {
				aa.setMaterial(f);
				var l = v(d, c.fog, f, b);
				Jh = a = null;
				L = !1;
				k(b, l)
			} else J.renderBufferDirect(d, c.fog, e, f, b, g);
			b.onAfterRender(J, c, d, e, f, g);
			La = Na.get(c, ia || d)
		}

		function r(a, b, c) {
			var d = fa.get(a),
				f = La.state.lights,
				k = f.state.version;
			c = Fa.getParameters(a, f.state, La.state.shadowsArray, b, Ja.numPlanes, Ja.numIntersection, c);
			var l = Fa.getProgramCode(a, c),
				m = d.program,
				n = !0;
			if (void 0 === m) a.addEventListener("dispose", e);
			else if (m.code !==
				l) g(a);
			else {
				if (d.lightsStateVersion !== k) d.lightsStateVersion = k;
				else if (void 0 !== c.shaderID) return;
				n = !1
			}
			n && (c.shaderID ? (l = Yd[c.shaderID], d.shader = {
					name: a.type,
					uniforms: qd(l.uniforms),
					vertexShader: l.vertexShader,
					fragmentShader: l.fragmentShader
				}) : d.shader = {
					name: a.type,
					uniforms: a.uniforms,
					vertexShader: a.vertexShader,
					fragmentShader: a.fragmentShader
				}, a.onBeforeCompile(d.shader, J), l = Fa.getProgramCode(a, c), m = Fa.acquireProgram(a, d.shader, c, l), d.program =
				m, a.program = m);
			c = m.getAttributes();
			if (a.morphTargets)
				for (l =
					a.numSupportedMorphTargets = 0; l < J.maxMorphTargets; l++) 0 <= c["morphTarget" + l] && a.numSupportedMorphTargets++;
			if (a.morphNormals)
				for (l = a.numSupportedMorphNormals = 0; l < J.maxMorphNormals; l++) 0 <= c["morphNormal" + l] && a.numSupportedMorphNormals++;
			c = d.shader.uniforms;
			if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) d.numClippingPlanes = Ja.numPlanes, d.numIntersection =
				Ja.numIntersection, c.clippingPlanes = Ja.uniform;
			d.fog = b;
			d.needsLights = a.isMeshLambertMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial ||
				a.isShadowMaterial || a.isShaderMaterial && !0 === a.lights;
			d.lightsStateVersion = k;
			d.needsLights && (c.ambientLightColor.value = f.state.ambient, c.lightProbe.value = f.state.probe, c.directionalLights
				.value = f.state.directional, c.spotLights.value = f.state.spot, c.rectAreaLights.value = f.state.rectArea, c.pointLights
				.value = f.state.point, c.hemisphereLights.value = f.state.hemi, c.directionalShadowMap.value = f.state.directionalShadowMap,
				c.directionalShadowMatrix.value = f.state.directionalShadowMatrix, c.spotShadowMap.value =
				f.state.spotShadowMap, c.spotShadowMatrix.value = f.state.spotShadowMatrix, c.pointShadowMap.value = f.state.pointShadowMap,
				c.pointShadowMatrix.value = f.state.pointShadowMatrix);
			a = d.program.getUniforms();
			a = Re.seqWithValue(a.seq, c);
			d.uniformsList = a
		}

		function v(a, b, c, d) {
			Aa.resetTextureUnits();
			var e = fa.get(c),
				f = La.state.lights;
			Bk && (sa || a !== ja) && Ja.setState(c.clippingPlanes, c.clipIntersection, c.clipShadows, a, e, a === ja && c.id ===
				R);
			!1 === c.needsUpdate && (void 0 === e.program ? c.needsUpdate = !0 : c.fog && e.fog !== b ? c.needsUpdate = !0 : e.needsLights &&
				e.lightsStateVersion !== f.state.version ? c.needsUpdate = !0 : void 0 === e.numClippingPlanes || e.numClippingPlanes ===
				Ja.numPlanes && e.numIntersection === Ja.numIntersection || (c.needsUpdate = !0));
			c.needsUpdate && (r(c, b, d), c.needsUpdate = !1);
			var g = !1,
				k = !1,
				l = !1;
			f = e.program;
			var m = f.getUniforms(),
				n = e.shader.uniforms;
			aa.useProgram(f.program) && (l = k = g = !0);
			c.id !== R && (R = c.id, k = !0);
			if (g || ja !== a) {
				0 < f.numMultiviewViews ? Oa.updateCameraProjectionMatricesUniform(a, m) : m.setValue(U, "projectionMatrix", a.projectionMatrix);
				Qb.logarithmicDepthBuffer && m.setValue(U, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
				ja !== a && (ja = a, l = k = !0);
				if (c.isShaderMaterial || c.isMeshPhongMaterial || c.isMeshStandardMaterial || c.envMap) g = m.map.cameraPosition,
					void 0 !== g && g.setValue(U, Gg.setFromMatrixPosition(a.matrixWorld));
				if (c.isMeshPhongMaterial || c.isMeshLambertMaterial || c.isMeshBasicMaterial || c.isMeshStandardMaterial || c.isShaderMaterial ||
					c.skinning) 0 < f.numMultiviewViews ? Oa.updateCameraViewMatricesUniform(a, m) : m.setValue(U, "viewMatrix", a.matrixWorldInverse)
			}
			if (c.skinning &&
				(m.setOptional(U, d, "bindMatrix"), m.setOptional(U, d, "bindMatrixInverse"), g = d.skeleton)) {
				var v = g.bones;
				if (Qb.floatVertexTextures) {
					if (void 0 === g.boneTexture) {
						v = Math.sqrt(4 * v.length);
						v = ha.ceilPowerOfTwo(v);
						v = Math.max(v, 4);
						var p = new Float32Array(v * v * 4);
						p.set(g.boneMatrices);
						var q = new Dg(p, v, v, 1023, 1015);
						g.boneMatrices = p;
						g.boneTexture = q;
						g.boneTextureSize = v
					}
					m.setValue(U, "boneTexture", g.boneTexture, Aa);
					m.setValue(U, "boneTextureSize", g.boneTextureSize)
				} else m.setOptional(U, g, "boneMatrices")
			}
			if (k || e.receiveShadow !==
				d.receiveShadow) e.receiveShadow = d.receiveShadow, m.setValue(U, "receiveShadow", d.receiveShadow);
			k && (m.setValue(U, "toneMappingExposure", J.toneMappingExposure), m.setValue(U, "toneMappingWhitePoint", J.toneMappingWhitePoint),
				e.needsLights && (k = l, n.ambientLightColor.needsUpdate = k, n.lightProbe.needsUpdate = k, n.directionalLights.needsUpdate =
					k, n.pointLights.needsUpdate = k, n.spotLights.needsUpdate = k, n.rectAreaLights.needsUpdate = k, n.hemisphereLights
					.needsUpdate = k), b && c.fog && (n.fogColor.value.copy(b.color), b.isFog ?
					(n.fogNear.value = b.near, n.fogFar.value = b.far) : b.isFogExp2 && (n.fogDensity.value = b.density)), c.isMeshBasicMaterial ?
				A(n, c) : c.isMeshLambertMaterial ? (A(n, c), c.emissiveMap && (n.emissiveMap.value = c.emissiveMap)) : c.isMeshPhongMaterial ?
				(A(n, c), c.isMeshToonMaterial ? (w(n, c), c.gradientMap && (n.gradientMap.value = c.gradientMap)) : w(n, c)) : c
				.isMeshStandardMaterial ? (A(n, c), c.isMeshPhysicalMaterial ? (z(n, c), n.reflectivity.value = c.reflectivity, n
					.clearcoat.value = c.clearcoat, n.clearcoatRoughness.value = c.clearcoatRoughness,
					c.sheen && n.sheen.value.copy(c.sheen), c.clearcoatNormalMap && (n.clearcoatNormalScale.value.copy(c.clearcoatNormalScale),
						n.clearcoatNormalMap.value = c.clearcoatNormalMap, 1 === c.side && n.clearcoatNormalScale.value.negate()), n.transparency
					.value = c.transparency) : z(n, c)) : c.isMeshMatcapMaterial ? (A(n, c), c.matcap && (n.matcap.value = c.matcap),
					c.bumpMap && (n.bumpMap.value = c.bumpMap, n.bumpScale.value = c.bumpScale, 1 === c.side && (n.bumpScale.value *=
						-1)), c.normalMap && (n.normalMap.value = c.normalMap, n.normalScale.value.copy(c.normalScale),
						1 === c.side && n.normalScale.value.negate()), c.displacementMap && (n.displacementMap.value = c.displacementMap,
						n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias)) : c.isMeshDepthMaterial ?
				(A(n, c), c.displacementMap && (n.displacementMap.value = c.displacementMap, n.displacementScale.value = c.displacementScale,
					n.displacementBias.value = c.displacementBias)) : c.isMeshDistanceMaterial ? (A(n, c), c.displacementMap && (n.displacementMap
						.value = c.displacementMap, n.displacementScale.value =
						c.displacementScale, n.displacementBias.value = c.displacementBias), n.referencePosition.value.copy(c.referencePosition),
					n.nearDistance.value = c.nearDistance, n.farDistance.value = c.farDistance) : c.isMeshNormalMaterial ? (A(n, c),
					c.bumpMap && (n.bumpMap.value = c.bumpMap, n.bumpScale.value = c.bumpScale, 1 === c.side && (n.bumpScale.value *=
						-1)), c.normalMap && (n.normalMap.value = c.normalMap, n.normalScale.value.copy(c.normalScale), 1 === c.side &&
						n.normalScale.value.negate()), c.displacementMap && (n.displacementMap.value = c.displacementMap,
						n.displacementScale.value = c.displacementScale, n.displacementBias.value = c.displacementBias)) : c.isLineBasicMaterial ?
				(n.diffuse.value.copy(c.color), n.opacity.value = c.opacity, c.isLineDashedMaterial && (n.dashSize.value = c.dashSize,
					n.totalSize.value = c.dashSize + c.gapSize, n.scale.value = c.scale)) : c.isPointsMaterial ? (n.diffuse.value.copy(
						c.color), n.opacity.value = c.opacity, n.size.value = c.size * T, n.scale.value = .5 * xa, n.map.value = c.map,
					null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), n.uvTransform.value.copy(c.map.matrix))
				) :
				c.isSpriteMaterial ? (n.diffuse.value.copy(c.color), n.opacity.value = c.opacity, n.rotation.value = c.rotation,
					n.map.value = c.map, null !== c.map && (!0 === c.map.matrixAutoUpdate && c.map.updateMatrix(), n.uvTransform.value
						.copy(c.map.matrix))) : c.isShadowMaterial && (n.color.value.copy(c.color), n.opacity.value = c.opacity), void 0 !==
				n.ltc_1 && (n.ltc_1.value = V.LTC_1), void 0 !== n.ltc_2 && (n.ltc_2.value = V.LTC_2), Re.upload(U, e.uniformsList,
					n, Aa));
			c.isShaderMaterial && !0 === c.uniformsNeedUpdate && (Re.upload(U, e.uniformsList, n, Aa),
				c.uniformsNeedUpdate = !1);
			c.isSpriteMaterial && m.setValue(U, "center", d.center);
			0 < f.numMultiviewViews ? Oa.updateObjectMatricesUniforms(d, a, m) : (m.setValue(U, "modelViewMatrix", d.modelViewMatrix),
				m.setValue(U, "normalMatrix", d.normalMatrix));
			m.setValue(U, "modelMatrix", d.matrixWorld);
			return f
		}

		function A(a, b) {
			a.opacity.value = b.opacity;
			b.color && a.diffuse.value.copy(b.color);
			b.emissive && a.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity);
			b.map && (a.map.value = b.map);
			b.alphaMap && (a.alphaMap.value =
				b.alphaMap);
			b.specularMap && (a.specularMap.value = b.specularMap);
			b.envMap && (a.envMap.value = b.envMap, a.flipEnvMap.value = b.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value =
				b.reflectivity, a.refractionRatio.value = b.refractionRatio, a.maxMipLevel.value = fa.get(b.envMap).__maxMipLevel
			);
			b.lightMap && (a.lightMap.value = b.lightMap, a.lightMapIntensity.value = b.lightMapIntensity);
			b.aoMap && (a.aoMap.value = b.aoMap, a.aoMapIntensity.value = b.aoMapIntensity);
			if (b.map) var c = b.map;
			else b.specularMap ? c = b.specularMap : b.displacementMap ?
				c = b.displacementMap : b.normalMap ? c = b.normalMap : b.bumpMap ? c = b.bumpMap : b.roughnessMap ? c = b.roughnessMap :
				b.metalnessMap ? c = b.metalnessMap : b.alphaMap ? c = b.alphaMap : b.emissiveMap && (c = b.emissiveMap);
			void 0 !== c && (c.isWebGLRenderTarget && (c = c.texture), !0 === c.matrixAutoUpdate && c.updateMatrix(), a.uvTransform
				.value.copy(c.matrix))
		}

		function w(a, b) {
			a.specular.value.copy(b.specular);
			a.shininess.value = Math.max(b.shininess, 1E-4);
			b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
			b.bumpMap && (a.bumpMap.value = b.bumpMap,
				a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -1));
			b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale
				.value.negate());
			b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale,
				a.displacementBias.value = b.displacementBias)
		}

		function z(a, b) {
			a.roughness.value = b.roughness;
			a.metalness.value = b.metalness;
			b.roughnessMap && (a.roughnessMap.value = b.roughnessMap);
			b.metalnessMap && (a.metalnessMap.value =
				b.metalnessMap);
			b.emissiveMap && (a.emissiveMap.value = b.emissiveMap);
			b.bumpMap && (a.bumpMap.value = b.bumpMap, a.bumpScale.value = b.bumpScale, 1 === b.side && (a.bumpScale.value *= -
				1));
			b.normalMap && (a.normalMap.value = b.normalMap, a.normalScale.value.copy(b.normalScale), 1 === b.side && a.normalScale
				.value.negate());
			b.displacementMap && (a.displacementMap.value = b.displacementMap, a.displacementScale.value = b.displacementScale,
				a.displacementBias.value = b.displacementBias);
			b.envMap && (a.envMapIntensity.value = b.envMapIntensity)
		}
		f = f || {};
		var p = void 0 !== f.canvas ? f.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
			q = void 0 !== f.context ? f.context : null,
			K = void 0 !== f.alpha ? f.alpha : !1,
			G = void 0 !== f.depth ? f.depth : !0,
			la = void 0 !== f.stencil ? f.stencil : !0,
			H = void 0 !== f.antialias ? f.antialias : !1,
			Q = void 0 !== f.premultipliedAlpha ? f.premultipliedAlpha : !0,
			wa = void 0 !== f.preserveDrawingBuffer ? f.preserveDrawingBuffer : !1,
			N = void 0 !== f.powerPreference ? f.powerPreference : "default",
			P = void 0 !== f.failIfMajorPerformanceCaveat ? f.failIfMajorPerformanceCaveat :
			!1,
			M = null,
			La = null;
		this.domElement = p;
		this.debug = {
			checkShaderErrors: !0
		};
		this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
		this.clippingPlanes = [];
		this.localClippingEnabled = !1;
		this.gammaFactor = 2;
		this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
		this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
		var J = this,
			Ih = !1,
			S = null,
			ra = 0,
			ya = 0,
			X = null,
			W = null,
			R = -1;
		var Jh = a = null;
		var L = !1;
		var ja =
			null,
			ia = null,
			F = new za,
			I = new za,
			ta = null,
			Z = p.width,
			xa = p.height,
			T = 1,
			da = new za(0, 0, Z, xa),
			ma = new za(0, 0, Z, xa),
			pa = !1,
			Qk = new Ui,
			Ja = new Dp,
			Bk = !1,
			sa = !1,
			dk = new ua,
			Gg = new u;
		try {
			K = {
				alpha: K,
				depth: G,
				stencil: la,
				antialias: H,
				premultipliedAlpha: Q,
				preserveDrawingBuffer: wa,
				powerPreference: N,
				failIfMajorPerformanceCaveat: P,
				xrCompatible: !0
			};
			p.addEventListener("webglcontextlost", c, !1);
			p.addEventListener("webglcontextrestored", d, !1);
			var U = q || p.getContext("webgl", K) || p.getContext("experimental-webgl", K);
			if (null === U) {
				if (null !==
					p.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
				throw Error("Error creating WebGL context.");
			}
			void 0 === U.getShaderPrecisionFormat && (U.getShaderPrecisionFormat = function() {
				return {
					rangeMin: 1,
					rangeMax: 1,
					precision: 1
				}
			})
		} catch (Ym) {
			throw console.error("THREE.WebGLRenderer: " + Ym.message), Ym;
		}
		var bb, Qb, aa, ba, fa, Aa, va, Ba, Ia, Fa, Ra, Na, qa, Wa, Xa, Ya, Da;
		b();
		var Ha = "undefined" !== typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Wm(J, U) :
			new fk(J);
		this.vr = Ha;
		var Oa = new Oq(J, U),
			ab = new Qm(J, Ia, Qb.maxTextureSize);
		this.shadowMap = ab;
		this.getContext = function() {
			return U
		};
		this.getContextAttributes = function() {
			return U.getContextAttributes()
		};
		this.forceContextLoss = function() {
			var a = bb.get("WEBGL_lose_context");
			a && a.loseContext()
		};
		this.forceContextRestore = function() {
			var a = bb.get("WEBGL_lose_context");
			a && a.restoreContext()
		};
		this.getPixelRatio = function() {
			return T
		};
		this.setPixelRatio = function(a) {
			void 0 !== a && (T = a, this.setSize(Z, xa, !1))
		};
		this.getSize = function(a) {
			void 0 ===
				a && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), a = new B);
			return a.set(Z, xa)
		};
		this.setSize = function(a, b, c) {
			Ha.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Z = a,
				xa = b, p.width = Math.floor(a * T), p.height = Math.floor(b * T), !1 !== c && (p.style.width = a + "px", p.style
					.height = b + "px"), this.setViewport(0, 0, a, b))
		};
		this.getDrawingBufferSize = function(a) {
			void 0 === a && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
				a = new B);
			return a.set(Z * T, xa * T).floor()
		};
		this.setDrawingBufferSize = function(a, b, c) {
			Z = a;
			xa = b;
			T = c;
			p.width = Math.floor(a * c);
			p.height = Math.floor(b * c);
			this.setViewport(0, 0, a, b)
		};
		this.getCurrentViewport = function(a) {
			void 0 === a && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), a =
				new za);
			return a.copy(F)
		};
		this.getViewport = function(a) {
			return a.copy(da)
		};
		this.setViewport = function(a, b, c, d) {
			a.isVector4 ? da.set(a.x, a.y, a.z, a.w) : da.set(a, b, c, d);
			aa.viewport(F.copy(da).multiplyScalar(T).floor())
		};
		this.getScissor = function(a) {
			return a.copy(ma)
		};
		this.setScissor = function(a, b, c, d) {
			a.isVector4 ? ma.set(a.x, a.y, a.z, a.w) : ma.set(a, b, c, d);
			aa.scissor(I.copy(ma).multiplyScalar(T).floor())
		};
		this.getScissorTest = function() {
			return pa
		};
		this.setScissorTest = function(a) {
			aa.setScissorTest(pa = a)
		};
		this.getClearColor = function() {
			return qa.getClearColor()
		};
		this.setClearColor = function() {
			qa.setClearColor.apply(qa, arguments)
		};
		this.getClearAlpha = function() {
			return qa.getClearAlpha()
		};
		this.setClearAlpha = function() {
			qa.setClearAlpha.apply(qa,
				arguments)
		};
		this.clear = function(a, b, c) {
			var d = 0;
			if (void 0 === a || a) d |= 16384;
			if (void 0 === b || b) d |= 256;
			if (void 0 === c || c) d |= 1024;
			U.clear(d)
		};
		this.clearColor = function() {
			this.clear(!0, !1, !1)
		};
		this.clearDepth = function() {
			this.clear(!1, !0, !1)
		};
		this.clearStencil = function() {
			this.clear(!1, !1, !0)
		};
		this.dispose = function() {
			p.removeEventListener("webglcontextlost", c, !1);
			p.removeEventListener("webglcontextrestored", d, !1);
			Ra.dispose();
			Na.dispose();
			fa.dispose();
			Ia.dispose();
			Ha.dispose();
			Za.stop()
		};
		this.renderBufferImmediate =
			function(a, b) {
				aa.initAttributes();
				var c = fa.get(a);
				a.hasPositions && !c.position && (c.position = U.createBuffer());
				a.hasNormals && !c.normal && (c.normal = U.createBuffer());
				a.hasUvs && !c.uv && (c.uv = U.createBuffer());
				a.hasColors && !c.color && (c.color = U.createBuffer());
				b = b.getAttributes();
				a.hasPositions && (U.bindBuffer(34962, c.position), U.bufferData(34962, a.positionArray, 35048), aa.enableAttribute(
					b.position), U.vertexAttribPointer(b.position, 3, 5126, !1, 0, 0));
				a.hasNormals && (U.bindBuffer(34962, c.normal), U.bufferData(34962,
					a.normalArray, 35048), aa.enableAttribute(b.normal), U.vertexAttribPointer(b.normal, 3, 5126, !1, 0, 0));
				a.hasUvs && (U.bindBuffer(34962, c.uv), U.bufferData(34962, a.uvArray, 35048), aa.enableAttribute(b.uv), U.vertexAttribPointer(
					b.uv, 2, 5126, !1, 0, 0));
				a.hasColors && (U.bindBuffer(34962, c.color), U.bufferData(34962, a.colorArray, 35048), aa.enableAttribute(b.color),
					U.vertexAttribPointer(b.color, 3, 5126, !1, 0, 0));
				aa.disableUnusedAttributes();
				U.drawArrays(4, 0, a.count);
				a.count = 0
			};
		this.renderBufferDirect = function(b, c, d, e, f,
			g) {
			var k = f.isMesh && 0 > f.matrixWorld.determinant();
			aa.setMaterial(e, k);
			var l = v(b, c, e, f),
				m = !1;
			if (a !== d.id || Jh !== l.id || L !== (!0 === e.wireframe)) a = d.id, Jh = l.id, L = !0 === e.wireframe, m = !0;
			f.morphTargetInfluences && (Wa.update(f, d, e, l), m = !0);
			k = d.index;
			var n = d.attributes.position;
			c = 1;
			!0 === e.wireframe && (k = Ba.getWireframeAttribute(d), c = 2);
			b = Xa;
			if (null !== k) {
				var r = va.get(k);
				b = Ya;
				b.setIndex(r)
			}
			if (m) {
				if (!1 !== Qb.isWebGL2 || !f.isInstancedMesh && !d.isInstancedBufferGeometry || null !== bb.get(
						"ANGLE_instanced_arrays")) {
					aa.initAttributes();
					m = d.attributes;
					l = l.getAttributes();
					var A = e.defaultAttributeValues;
					for (H in l) {
						var w = l[H];
						if (0 <= w) {
							var p = m[H];
							if (void 0 !== p) {
								var z = p.normalized,
									q = p.itemSize,
									u = va.get(p);
								if (void 0 !== u) {
									var G = u.buffer,
										C = u.type;
									u = u.bytesPerElement;
									if (p.isInterleavedBufferAttribute) {
										var D = p.data,
											K = D.stride;
										p = p.offset;
										D && D.isInstancedInterleavedBuffer ? (aa.enableAttributeAndDivisor(w, D.meshPerAttribute), void 0 === d.maxInstancedCount &&
											(d.maxInstancedCount = D.meshPerAttribute * D.count)) : aa.enableAttribute(w);
										U.bindBuffer(34962,
											G);
										U.vertexAttribPointer(w, q, C, z, K * u, p * u)
									} else p.isInstancedBufferAttribute ? (aa.enableAttributeAndDivisor(w, p.meshPerAttribute), void 0 === d.maxInstancedCount &&
										(d.maxInstancedCount = p.meshPerAttribute * p.count)) : aa.enableAttribute(w), U.bindBuffer(34962, G), U.vertexAttribPointer(
										w, q, C, z, 0, 0)
								}
							} else if ("instanceMatrix" === H) u = va.get(f.instanceMatrix), void 0 !== u && (G = u.buffer, C = u.type, aa
								.enableAttributeAndDivisor(w + 0, 1), aa.enableAttributeAndDivisor(w + 1, 1), aa.enableAttributeAndDivisor(w +
									2, 1), aa.enableAttributeAndDivisor(w +
									3, 1), U.bindBuffer(34962, G), U.vertexAttribPointer(w + 0, 4, C, !1, 64, 0), U.vertexAttribPointer(w + 1,
									4, C, !1, 64, 16), U.vertexAttribPointer(w + 2, 4, C, !1, 64, 32), U.vertexAttribPointer(w + 3, 4, C, !1,
									64, 48));
							else if (void 0 !== A && (z = A[H], void 0 !== z)) switch (z.length) {
								case 2:
									U.vertexAttrib2fv(w, z);
									break;
								case 3:
									U.vertexAttrib3fv(w, z);
									break;
								case 4:
									U.vertexAttrib4fv(w, z);
									break;
								default:
									U.vertexAttrib1fv(w, z)
							}
						}
					}
					aa.disableUnusedAttributes()
				}
				null !== k && U.bindBuffer(34963, r.buffer)
			}
			r = Infinity;
			null !== k ? r = k.count : void 0 !== n && (r = n.count);
			k = d.drawRange.start * c;
			n = null !== g ? g.start * c : 0;
			var H = Math.max(k, n);
			g = Math.max(0, Math.min(r, k + d.drawRange.count * c, n + (null !== g ? g.count * c : Infinity)) - 1 - H + 1);
			if (0 !== g) {
				if (f.isMesh)
					if (!0 === e.wireframe) aa.setLineWidth(e.wireframeLinewidth * (null === X ? T : 1)), b.setMode(1);
					else switch (f.drawMode) {
						case 0:
							b.setMode(4);
							break;
						case 1:
							b.setMode(5);
							break;
						case 2:
							b.setMode(6)
					} else f.isLine ? (e = e.linewidth, void 0 === e && (e = 1), aa.setLineWidth(e * (null === X ? T : 1)), f.isLineSegments ?
							b.setMode(1) : f.isLineLoop ? b.setMode(2) : b.setMode(3)) :
						f.isPoints ? b.setMode(0) : f.isSprite && b.setMode(4);
				f.isInstancedMesh ? b.renderInstances(d, H, g, f.count) : d.isInstancedBufferGeometry ? b.renderInstances(d, H, g,
					d.maxInstancedCount) : b.render(H, g)
			}
		};
		this.compile = function(a, b) {
			La = Na.get(a, b);
			La.init();
			a.traverse(function(a) {
				a.isLight && (La.pushLight(a), a.castShadow && La.pushShadow(a))
			});
			La.setupLights(b);
			a.traverse(function(b) {
				if (b.material)
					if (Array.isArray(b.material))
						for (var c = 0; c < b.material.length; c++) r(b.material[c], a.fog, b);
					else r(b.material, a.fog, b)
			})
		};
		var $a = null,
			Za = new Vi;
		Za.setAnimationLoop(function(a) {
			Ha.isPresenting() || $a && $a(a)
		});
		"undefined" !== typeof window && Za.setContext(window);
		this.setAnimationLoop = function(a) {
			$a = a;
			Ha.setAnimationLoop(a);
			Za.start()
		};
		this.render = function(b, c, d, e) {
			if (void 0 !== d) {
				console.warn(
					"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
				var f = d
			}
			if (void 0 !== e) {
				console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
				var g = e
			}
			c && c.isCamera ? Ih || (Jh = a = null, L = !1, R = -1, ja = null, !0 === b.autoUpdate && b.updateMatrixWorld(),
				null === c.parent && c.updateMatrixWorld(), Ha.enabled && (c = Ha.getCamera(c)), La = Na.get(b, c), La.init(), b
				.onBeforeRender(J, b, c, f || X), dk.multiplyMatrices(c.projectionMatrix, c.matrixWorldInverse), Qk.setFromMatrix(
					dk), sa = this.localClippingEnabled, Bk = Ja.init(this.clippingPlanes, sa, c), M = Ra.get(b, c), M.init(), l(b,
					c, 0, J.sortObjects), !0 === J.sortObjects && M.sort(), Bk && Ja.beginShadows(), ab.render(La.state.shadowsArray,
					b, c),
				La.setupLights(c), Bk && Ja.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== f && this.setRenderTarget(
					f), Ha.enabled && Oa.isAvailable() && Oa.attachCamera(c), qa.render(M, b, c, g), d = M.opaque, e = M.transparent,
				b.overrideMaterial ? (f = b.overrideMaterial, d.length && m(d, b, c, f), e.length && m(e, b, c, f)) : (d.length &&
					m(d, b, c), e.length && m(e, b, c)), b.onAfterRender(J, b, c), null !== X && (Aa.updateRenderTargetMipmap(X),
					Aa.updateMultisampleRenderTarget(X)), aa.buffers.depth.setTest(!0), aa.buffers.depth.setMask(!0), aa.buffers.color
				.setMask(!0),
				aa.setPolygonOffset(!1), Ha.enabled && (Oa.isAvailable() && Oa.detachCamera(c), Ha.submitFrame()), La = M = null
			) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
		};
		this.setFramebuffer = function(a) {
			S !== a && U.bindFramebuffer(36160, a);
			S = a
		};
		this.getActiveCubeFace = function() {
			return ra
		};
		this.getActiveMipmapLevel = function() {
			return ya
		};
		this.getRenderTarget = function() {
			return X
		};
		this.setRenderTarget = function(a, b, c) {
			X = a;
			ra = b;
			ya = c;
			a && void 0 === fa.get(a).__webglFramebuffer && Aa.setupRenderTarget(a);
			var d = S,
				e = !1;
			a ? (d = fa.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube ? (d = d[b || 0], e = !0) : d = a.isWebGLMultisampleRenderTarget ?
				fa.get(a).__webglMultisampledFramebuffer : d, F.copy(a.viewport), I.copy(a.scissor), ta = a.scissorTest) : (F.copy(
				da).multiplyScalar(T).floor(), I.copy(ma).multiplyScalar(T).floor(), ta = pa);
			W !== d && (U.bindFramebuffer(36160, d), W = d);
			aa.viewport(F);
			aa.scissor(I);
			aa.setScissorTest(ta);
			e && (a = fa.get(a.texture), U.framebufferTexture2D(36160, 36064, 34069 + (b || 0), a.__webglTexture, c || 0))
		};
		this.readRenderTargetPixels =
			function(a, b, c, d, e, f, g) {
				if (a && a.isWebGLRenderTarget) {
					var k = fa.get(a).__webglFramebuffer;
					a.isWebGLRenderTargetCube && void 0 !== g && (k = k[g]);
					if (k) {
						g = !1;
						k !== W && (U.bindFramebuffer(36160, k), g = !0);
						try {
							var l = a.texture,
								m = l.format,
								n = l.type;
							1023 !== m && Da.convert(m) !== U.getParameter(35739) ? console.error(
									"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") :
								1009 === n || Da.convert(n) === U.getParameter(35738) || 1015 === n && (Qb.isWebGL2 || bb.get(
										"OES_texture_float") ||
									bb.get("WEBGL_color_buffer_float")) || 1016 === n && (Qb.isWebGL2 ? bb.get("EXT_color_buffer_float") : bb.get(
									"EXT_color_buffer_half_float")) ? 36053 === U.checkFramebufferStatus(36160) ? 0 <= b && b <= a.width - d && 0 <=
								c && c <= a.height - e && U.readPixels(b, c, d, e, Da.convert(m), Da.convert(n), f) : console.error(
									"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") :
								console.error(
									"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
								)
						} finally {
							g &&
								U.bindFramebuffer(36160, W)
						}
					}
				} else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
			};
		this.copyFramebufferToTexture = function(a, b, c) {
			var d = b.image.width,
				e = b.image.height,
				f = Da.convert(b.format);
			Aa.setTexture2D(b, 0);
			U.copyTexImage2D(3553, c || 0, f, a.x, a.y, d, e, 0)
		};
		this.copyTextureToTexture = function(a, b, c, d) {
			var e = b.image.width,
				f = b.image.height,
				g = Da.convert(c.format),
				k = Da.convert(c.type);
			Aa.setTexture2D(c, 0);
			b.isDataTexture ? U.texSubImage2D(3553, d || 0,
				a.x, a.y, e, f, g, k, b.image.data) : U.texSubImage2D(3553, d || 0, a.x, a.y, g, k, b.image)
		};
		"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
			detail: this
		}))
	}

	function gk(f, a) {
		this.name = "";
		this.color = new S(f);
		this.density = void 0 !== a ? a : 2.5E-4
	}

	function hk(f, a, b) {
		this.name = "";
		this.color = new S(f);
		this.near = void 0 !== a ? a : 1;
		this.far = void 0 !== b ? b : 1E3
	}

	function gc(f, a) {
		this.array = f;
		this.stride = a;
		this.count = void 0 !== f ? f.length / a : 0;
		this.dynamic = !1;
		this.updateRange = {
			offset: 0,
			count: -1
		};
		this.version = 0
	}

	function Kh(f, a, b, c) {
		this.data = f;
		this.itemSize = a;
		this.offset = b;
		this.normalized = !0 === c
	}

	function Cc(f) {
		ia.call(this);
		this.type = "SpriteMaterial";
		this.color = new S(16777215);
		this.map = null;
		this.rotation = 0;
		this.transparent = this.sizeAttenuation = !0;
		this.setValues(f)
	}

	function ik(f) {
		P.call(this);
		this.type = "Sprite";
		if (void 0 === Se) {
			Se = new J;
			var a = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
			a = new gc(a, 5);
			Se.setIndex([0, 1, 2, 0, 2, 3]);
			Se.addAttribute("position",
				new Kh(a, 3, 0, !1));
			Se.addAttribute("uv", new Kh(a, 2, 3, !1))
		}
		this.geometry = Se;
		this.material = void 0 !== f ? f : new Cc;
		this.center = new B(.5, .5)
	}

	function Cf(f, a, b, c, d, e) {
		Ig.subVectors(f, b).addScalar(.5).multiply(c);
		void 0 !== d ? (ae.x = e * Ig.x - d * Ig.y, ae.y = d * Ig.x + e * Ig.y) : ae.copy(Ig);
		f.copy(a);
		f.x += ae.x;
		f.y += ae.y;
		f.applyMatrix4(Zm)
	}

	function Zi() {
		P.call(this);
		this.type = "LOD";
		ja(this, {
			levels: {
				enumerable: !0,
				value: []
			}
		});
		this.autoUpdate = !0
	}

	function $i(f, a) {
		f && f.isGeometry && console.error(
			"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
		Wa.call(this, f, a);
		this.type = "SkinnedMesh";
		this.bindMode = "attached";
		this.bindMatrix = new ua;
		this.bindMatrixInverse = new ua
	}

	function jk(f, a) {
		f = f || [];
		this.bones = f.slice(0);
		this.boneMatrices = new Float32Array(16 * this.bones.length);
		this.frame = -1;
		if (void 0 === a) this.calculateInverses();
		else if (this.bones.length === a.length) this.boneInverses = a.slice(0);
		else
			for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], f = 0, a = this.bones
				.length; f < a; f++) this.boneInverses.push(new ua)
	}

	function $m() {
		P.call(this);
		this.type = "Bone"
	}

	function an(f, a, b) {
		Wa.call(this, f, a);
		this.instanceMatrix = new F(new Float32Array(16 * b), 16);
		this.count = b
	}

	function Aa(f) {
		ia.call(this);
		this.type = "LineBasicMaterial";
		this.color = new S(16777215);
		this.linewidth = 1;
		this.linejoin = this.linecap = "round";
		this.setValues(f)
	}

	function Pa(f, a, b) {
		1 === b && console.error(
			"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
		P.call(this);
		this.type = "Line";
		this.geometry = void 0 !== f ? f : new J;
		this.material = void 0 !== a ? a : new Aa({
			color: 16777215 * Math.random()
		})
	}

	function Ra(f, a) {
		Pa.call(this, f, a);
		this.type = "LineSegments"
	}

	function kk(f, a) {
		Pa.call(this, f, a);
		this.type = "LineLoop"
	}

	function Dc(f) {
		ia.call(this);
		this.type = "PointsMaterial";
		this.color = new S(16777215);
		this.map = null;
		this.size = 1;
		this.sizeAttenuation = !0;
		this.morphTargets = !1;
		this.setValues(f)
	}

	function lk(f, a) {
		P.call(this);
		this.type = "Points";
		this.geometry = void 0 !== f ? f : new J;
		this.material = void 0 !== a ? a : new Dc({
			color: 16777215 * Math.random()
		});
		this.updateMorphTargets()
	}

	function mk(f, a, b, c, d, e, g) {
		var k = aj.distanceSqToPoint(f);
		k < b && (b = new u, aj.closestPointToPoint(f, b), b.applyMatrix4(c), f = d.ray.origin.distanceTo(b), f < d.near ||
			f > d.far || e.push({
				distance: f,
				distanceToRay: Math.sqrt(k),
				point: b,
				index: a,
				face: null,
				object: g
			}))
	}

	function bn(f, a, b, c, d, e, g, k, l) {
		pa.call(this, f, a, b, c, d, e, g, k, l);
		this.format = void 0 !== g ? g : 1022;
		this.minFilter = void 0 !== e ? e : 1006;
		this.magFilter = void 0 !== d ? d : 1006;
		this.generateMipmaps = !1
	}

	function be(f, a, b, c, d, e, g, k, l, m, n, r) {
		pa.call(this,
			null, e, g, k, l, m, c, d, n, r);
		this.image = {
			width: a,
			height: b
		};
		this.mipmaps = f;
		this.generateMipmaps = this.flipY = !1
	}

	function Lh(f, a, b, c, d, e, g, k, l) {
		pa.call(this, f, a, b, c, d, e, g, k, l);
		this.needsUpdate = !0
	}

	function Mh(f, a, b, c, d, e, g, k, l, m) {
		m = void 0 !== m ? m : 1026;
		if (1026 !== m && 1027 !== m) throw Error(
			"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
		void 0 === b && 1026 === m && (b = 1012);
		void 0 === b && 1027 === m && (b = 1020);
		pa.call(this, null, c, d, e, g, k, m, b, l);
		this.image = {
			width: f,
			height: a
		};
		this.magFilter = void 0 !==
			g ? g : 1003;
		this.minFilter = void 0 !== k ? k : 1003;
		this.generateMipmaps = this.flipY = !1
	}

	function Nh(f) {
		J.call(this);
		this.type = "WireframeGeometry";
		var a = [],
			b, c, d, e = [0, 0],
			g = {},
			k = ["a", "b", "c"];
		if (f && f.isGeometry) {
			var l = f.faces;
			var m = 0;
			for (c = l.length; m < c; m++) {
				var n = l[m];
				for (b = 0; 3 > b; b++) {
					var r = n[k[b]];
					var v = n[k[(b + 1) % 3]];
					e[0] = Math.min(r, v);
					e[1] = Math.max(r, v);
					r = e[0] + "," + e[1];
					void 0 === g[r] && (g[r] = {
						index1: e[0],
						index2: e[1]
					})
				}
			}
			for (r in g) m = g[r], k = f.vertices[m.index1], a.push(k.x, k.y, k.z), k = f.vertices[m.index2], a.push(k.x,
				k.y, k.z)
		} else if (f && f.isBufferGeometry)
			if (k = new u, null !== f.index) {
				l = f.attributes.position;
				n = f.index;
				var A = f.groups;
				0 === A.length && (A = [{
					start: 0,
					count: n.count,
					materialIndex: 0
				}]);
				f = 0;
				for (d = A.length; f < d; ++f)
					for (m = A[f], b = m.start, c = m.count, m = b, c = b + c; m < c; m += 3)
						for (b = 0; 3 > b; b++) r = n.getX(m + b), v = n.getX(m + (b + 1) % 3), e[0] = Math.min(r, v), e[1] = Math.max(r,
							v), r = e[0] + "," + e[1], void 0 === g[r] && (g[r] = {
							index1: e[0],
							index2: e[1]
						});
				for (r in g) m = g[r], k.fromBufferAttribute(l, m.index1), a.push(k.x, k.y, k.z), k.fromBufferAttribute(l, m.index2),
					a.push(k.x, k.y, k.z)
			} else
				for (l = f.attributes.position, m = 0, c = l.count / 3; m < c; m++)
					for (b = 0; 3 > b; b++) g = 3 * m + b, k.fromBufferAttribute(l, g), a.push(k.x, k.y, k.z), g = 3 * m + (b + 1) %
						3, k.fromBufferAttribute(l, g), a.push(k.x, k.y, k.z);
		this.addAttribute("position", new N(a, 3))
	}

	function bj(f, a, b) {
		R.call(this);
		this.type = "ParametricGeometry";
		this.parameters = {
			func: f,
			slices: a,
			stacks: b
		};
		this.fromBufferGeometry(new Te(f, a, b));
		this.mergeVertices()
	}

	function Te(f, a, b) {
		J.call(this);
		this.type = "ParametricBufferGeometry";
		this.parameters = {
			func: f,
			slices: a,
			stacks: b
		};
		var c = [],
			d = [],
			e = [],
			g = [],
			k = new u,
			l = new u,
			m = new u,
			n = new u,
			r = new u,
			v, A;
		3 > f.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
		var w = a + 1;
		for (v = 0; v <= b; v++) {
			var p = v / b;
			for (A = 0; A <= a; A++) {
				var q = A / a;
				f(q, p, l);
				d.push(l.x, l.y, l.z);
				0 <= q - 1E-5 ? (f(q - 1E-5, p, m), n.subVectors(l, m)) : (f(q + 1E-5, p, m), n.subVectors(m, l));
				0 <= p - 1E-5 ? (f(q, p - 1E-5, m), r.subVectors(l, m)) : (f(q, p + 1E-5, m), r.subVectors(m, l));
				k.crossVectors(n, r).normalize();
				e.push(k.x, k.y,
					k.z);
				g.push(q, p)
			}
		}
		for (v = 0; v < b; v++)
			for (A = 0; A < a; A++) f = v * w + A + 1, k = (v + 1) * w + A + 1, l = (v + 1) * w + A, c.push(v * w + A, f, l), c
				.push(f, k, l);
		this.setIndex(c);
		this.addAttribute("position", new N(d, 3));
		this.addAttribute("normal", new N(e, 3));
		this.addAttribute("uv", new N(g, 2))
	}

	function cj(f, a, b, c) {
		R.call(this);
		this.type = "PolyhedronGeometry";
		this.parameters = {
			vertices: f,
			indices: a,
			radius: b,
			detail: c
		};
		this.fromBufferGeometry(new Rb(f, a, b, c));
		this.mergeVertices()
	}

	function Rb(f, a, b, c) {
		function d(a) {
			k.push(a.x, a.y, a.z)
		}

		function e(a,
			b) {
			a *= 3;
			b.x = f[a + 0];
			b.y = f[a + 1];
			b.z = f[a + 2]
		}

		function g(a, b, c, d) {
			0 > d && 1 === a.x && (l[b] = a.x - 1);
			0 === c.x && 0 === c.z && (l[b] = d / 2 / Math.PI + .5)
		}
		J.call(this);
		this.type = "PolyhedronBufferGeometry";
		this.parameters = {
			vertices: f,
			indices: a,
			radius: b,
			detail: c
		};
		b = b || 1;
		c = c || 0;
		var k = [],
			l = [];
		(function(b) {
			for (var c = new u, f = new u, g = new u, k = 0; k < a.length; k += 3) {
				e(a[k + 0], c);
				e(a[k + 1], f);
				e(a[k + 2], g);
				var l, m, p = c,
					q = f,
					K = g,
					G = Math.pow(2, b),
					B = [];
				for (m = 0; m <= G; m++) {
					B[m] = [];
					var H = p.clone().lerp(K, m / G),
						Q = q.clone().lerp(K, m / G),
						wa = G - m;
					for (l = 0; l <=
						wa; l++) B[m][l] = 0 === l && m === G ? H : H.clone().lerp(Q, l / wa)
				}
				for (m = 0; m < G; m++)
					for (l = 0; l < 2 * (G - m) - 1; l++) p = Math.floor(l / 2), 0 === l % 2 ? (d(B[m][p + 1]), d(B[m + 1][p]), d(B[
						m][p])) : (d(B[m][p + 1]), d(B[m + 1][p + 1]), d(B[m + 1][p]))
			}
		})(c);
		(function(a) {
			for (var b = new u, c = 0; c < k.length; c += 3) b.x = k[c + 0], b.y = k[c + 1], b.z = k[c + 2], b.normalize().multiplyScalar(
				a), k[c + 0] = b.x, k[c + 1] = b.y, k[c + 2] = b.z
		})(b);
		(function() {
			for (var a = new u, b = 0; b < k.length; b += 3) a.x = k[b + 0], a.y = k[b + 1], a.z = k[b + 2], l.push(Math.atan2(
				a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x *
				a.x + a.z * a.z)) / Math.PI + .5));
			a = new u;
			b = new u;
			for (var c = new u, d = new u, e = new B, f = new B, p = new B, q = 0, D = 0; q < k.length; q += 9, D += 6) {
				a.set(k[q + 0], k[q + 1], k[q + 2]);
				b.set(k[q + 3], k[q + 4], k[q + 5]);
				c.set(k[q + 6], k[q + 7], k[q + 8]);
				e.set(l[D + 0], l[D + 1]);
				f.set(l[D + 2], l[D + 3]);
				p.set(l[D + 4], l[D + 5]);
				d.copy(a).add(b).add(c).divideScalar(3);
				var K = Math.atan2(d.z, -d.x);
				g(e, D + 0, a, K);
				g(f, D + 2, b, K);
				g(p, D + 4, c, K)
			}
			for (a = 0; a < l.length; a += 6) b = l[a + 0], c = l[a + 2], d = l[a + 4], e = Math.min(b, c, d), .9 < Math.max(b,
				c, d) && .1 > e && (.2 > b && (l[a + 0] += 1), .2 > c && (l[a + 2] +=
				1), .2 > d && (l[a + 4] += 1))
		})();
		this.addAttribute("position", new N(k, 3));
		this.addAttribute("normal", new N(k.slice(), 3));
		this.addAttribute("uv", new N(l, 2));
		0 === c ? this.computeVertexNormals() : this.normalizeNormals()
	}

	function Df(f, a) {
		R.call(this);
		this.type = "TetrahedronGeometry";
		this.parameters = {
			radius: f,
			detail: a
		};
		this.fromBufferGeometry(new Ue(f, a));
		this.mergeVertices()
	}

	function Ue(f, a) {
		Rb.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], f, a);
		this.type = "TetrahedronBufferGeometry";
		this.parameters = {
			radius: f,
			detail: a
		}
	}

	function Ef(f, a) {
		R.call(this);
		this.type = "OctahedronGeometry";
		this.parameters = {
			radius: f,
			detail: a
		};
		this.fromBufferGeometry(new Ec(f, a));
		this.mergeVertices()
	}

	function Ec(f, a) {
		Rb.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2,
			5, 1, 5, 3, 1, 3, 4, 1, 4, 2
		], f, a);
		this.type = "OctahedronBufferGeometry";
		this.parameters = {
			radius: f,
			detail: a
		}
	}

	function dj(f, a) {
		R.call(this);
		this.type = "IcosahedronGeometry";
		this.parameters = {
			radius: f,
			detail: a
		};
		this.fromBufferGeometry(new Ve(f,
			a));
		this.mergeVertices()
	}

	function Ve(f, a) {
		var b = (1 + Math.sqrt(5)) / 2;
		Rb.call(this, [-1, b, 0, 1, b, 0, -1, -b, 0, 1, -b, 0, 0, -1, b, 0, 1, b, 0, -1, -b, 0, 1, -b, b, 0, -1, b, 0, 1, -b,
			0, -1, -b, 0, 1
		], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3,
			4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
		], f, a);
		this.type = "IcosahedronBufferGeometry";
		this.parameters = {
			radius: f,
			detail: a
		}
	}

	function Jg(f, a) {
		R.call(this);
		this.type = "DodecahedronGeometry";
		this.parameters = {
			radius: f,
			detail: a
		};
		this.fromBufferGeometry(new Ff(f,
			a));
		this.mergeVertices()
	}

	function Ff(f, a) {
		var b = (1 + Math.sqrt(5)) / 2,
			c = 1 / b;
		Rb.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -c, -b, 0, -c,
				b, 0, c, -b, 0, c, b, -c, -b, 0, -c, b, 0, c, -b, 0, c, b, 0, -b, 0, -c, b, 0, -c, -b, 0, c, b, 0, c
			], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16,
				2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1,
				9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19,
				4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
			], f,
			a);
		this.type = "DodecahedronBufferGeometry";
		this.parameters = {
			radius: f,
			detail: a
		}
	}

	function Gf(f, a, b, c, d, e) {
		R.call(this);
		this.type = "TubeGeometry";
		this.parameters = {
			path: f,
			tubularSegments: a,
			radius: b,
			radialSegments: c,
			closed: d
		};
		void 0 !== e && console.warn("THREE.TubeGeometry: taper has been removed.");
		f = new Hf(f, a, b, c, d);
		this.tangents = f.tangents;
		this.normals = f.normals;
		this.binormals = f.binormals;
		this.fromBufferGeometry(f);
		this.mergeVertices()
	}

	function Hf(f, a, b, c, d) {
		function e(d) {
			n = f.getPointAt(d / a, n);
			var e = g.normals[d];
			d = g.binormals[d];
			for (v = 0; v <= c; v++) {
				var m = v / c * Math.PI * 2,
					r = Math.sin(m);
				m = -Math.cos(m);
				l.x = m * e.x + r * d.x;
				l.y = m * e.y + r * d.y;
				l.z = m * e.z + r * d.z;
				l.normalize();
				w.push(l.x, l.y, l.z);
				k.x = n.x + b * l.x;
				k.y = n.y + b * l.y;
				k.z = n.z + b * l.z;
				p.push(k.x, k.y, k.z)
			}
		}
		J.call(this);
		this.type = "TubeBufferGeometry";
		this.parameters = {
			path: f,
			tubularSegments: a,
			radius: b,
			radialSegments: c,
			closed: d
		};
		a = a || 64;
		b = b || 1;
		c = c || 8;
		d = d || !1;
		var g = f.computeFrenetFrames(a, d);
		this.tangents = g.tangents;
		this.normals = g.normals;
		this.binormals = g.binormals;
		var k = new u,
			l = new u,
			m = new B,
			n = new u,
			r, v, p = [],
			w = [],
			q = [],
			C = [];
		for (r = 0; r < a; r++) e(r);
		e(!1 === d ? a : 0);
		for (r = 0; r <= a; r++)
			for (v = 0; v <= c; v++) m.x = r / a, m.y = v / c, q.push(m.x, m.y);
		(function() {
			for (v = 1; v <= a; v++)
				for (r = 1; r <= c; r++) {
					var b = (c + 1) * v + (r - 1),
						d = (c + 1) * v + r,
						e = (c + 1) * (v - 1) + r;
					C.push((c + 1) * (v - 1) + (r - 1), b, e);
					C.push(b, d, e)
				}
		})();
		this.setIndex(C);
		this.addAttribute("position", new N(p, 3));
		this.addAttribute("normal", new N(w, 3));
		this.addAttribute("uv", new N(q, 2))
	}

	function Kg(f, a, b, c, d, e, g) {
		R.call(this);
		this.type = "TorusKnotGeometry";
		this.parameters = {
			radius: f,
			tube: a,
			tubularSegments: b,
			radialSegments: c,
			p: d,
			q: e
		};
		void 0 !== g && console.warn(
			"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
		this.fromBufferGeometry(new We(f, a, b, c, d, e));
		this.mergeVertices()
	}

	function We(f, a, b, c, d, e) {
		function g(a, b, c, d, e) {
			var f = Math.sin(a);
			b = c / b * a;
			c = Math.cos(b);
			e.x = d * (2 + c) * .5 * Math.cos(a);
			e.y = d * (2 + c) * f * .5;
			e.z = d * Math.sin(b) * .5
		}
		J.call(this);
		this.type = "TorusKnotBufferGeometry";
		this.parameters = {
			radius: f,
			tube: a,
			tubularSegments: b,
			radialSegments: c,
			p: d,
			q: e
		};
		f = f || 1;
		a = a || .4;
		b = Math.floor(b) || 64;
		c = Math.floor(c) || 8;
		d = d || 2;
		e = e || 3;
		var k = [],
			l = [],
			m = [],
			n = [],
			r, v = new u,
			p = new u,
			w = new u,
			q = new u,
			C = new u,
			D = new u,
			K = new u;
		for (r = 0; r <= b; ++r) {
			var G = r / b * d * Math.PI * 2;
			g(G, d, e, f, w);
			g(G + .01, d, e, f, q);
			D.subVectors(q, w);
			K.addVectors(q, w);
			C.crossVectors(D, K);
			K.crossVectors(C, D);
			C.normalize();
			K.normalize();
			for (G = 0; G <= c; ++G) {
				var B = G / c * Math.PI * 2,
					H = -a * Math.cos(B);
				B = a * Math.sin(B);
				v.x = w.x + (H * K.x + B * C.x);
				v.y = w.y + (H * K.y + B * C.y);
				v.z = w.z + (H * K.z + B * C.z);
				l.push(v.x, v.y, v.z);
				p.subVectors(v,
					w).normalize();
				m.push(p.x, p.y, p.z);
				n.push(r / b);
				n.push(G / c)
			}
		}
		for (G = 1; G <= b; G++)
			for (r = 1; r <= c; r++) f = (c + 1) * G + (r - 1), a = (c + 1) * G + r, d = (c + 1) * (G - 1) + r, k.push((c + 1) *
				(G - 1) + (r - 1), f, d), k.push(f, a, d);
		this.setIndex(k);
		this.addAttribute("position", new N(l, 3));
		this.addAttribute("normal", new N(m, 3));
		this.addAttribute("uv", new N(n, 2))
	}

	function If(f, a, b, c, d) {
		R.call(this);
		this.type = "TorusGeometry";
		this.parameters = {
			radius: f,
			tube: a,
			radialSegments: b,
			tubularSegments: c,
			arc: d
		};
		this.fromBufferGeometry(new ce(f, a, b, c, d));
		this.mergeVertices()
	}

	function ce(f, a, b, c, d) {
		J.call(this);
		this.type = "TorusBufferGeometry";
		this.parameters = {
			radius: f,
			tube: a,
			radialSegments: b,
			tubularSegments: c,
			arc: d
		};
		f = f || 1;
		a = a || .4;
		b = Math.floor(b) || 8;
		c = Math.floor(c) || 6;
		d = d || 2 * Math.PI;
		var e = [],
			g = [],
			k = [],
			l = [],
			m = new u,
			n = new u,
			r = new u,
			v, p;
		for (v = 0; v <= b; v++)
			for (p = 0; p <= c; p++) {
				var w = p / c * d,
					q = v / b * Math.PI * 2;
				n.x = (f + a * Math.cos(q)) * Math.cos(w);
				n.y = (f + a * Math.cos(q)) * Math.sin(w);
				n.z = a * Math.sin(q);
				g.push(n.x, n.y, n.z);
				m.x = f * Math.cos(w);
				m.y = f * Math.sin(w);
				r.subVectors(n, m).normalize();
				k.push(r.x,
					r.y, r.z);
				l.push(p / c);
				l.push(v / b)
			}
		for (v = 1; v <= b; v++)
			for (p = 1; p <= c; p++) f = (c + 1) * (v - 1) + p - 1, a = (c + 1) * (v - 1) + p, d = (c + 1) * v + p, e.push((c +
				1) * v + p - 1, f, d), e.push(f, a, d);
		this.setIndex(e);
		this.addAttribute("position", new N(g, 3));
		this.addAttribute("normal", new N(k, 3));
		this.addAttribute("uv", new N(l, 2))
	}

	function cn(f, a, b, c, d) {
		for (var e, g = 0, k = a, l = b - c; k < b; k += c) g += (f[l] - f[k]) * (f[k + 1] + f[l + 1]), l = k;
		if (d === 0 < g)
			for (d = a; d < b; d += c) e = dn(d, f[d], f[d + 1], e);
		else
			for (d = b - c; d >= a; d -= c) e = dn(d, f[d], f[d + 1], e);
		e && hc(e, e.next) && (Xe(e), e = e.next);
		return e
	}

	function Ye(f, a) {
		if (!f) return f;
		a || (a = f);
		do {
			var b = !1;
			if (f.steiner || !hc(f, f.next) && 0 !== Ua(f.prev, f, f.next)) f = f.next;
			else {
				Xe(f);
				f = a = f.prev;
				if (f === f.next) break;
				b = !0
			}
		} while (b || f !== a);
		return a
	}

	function Ze(f, a, b, c, d, e, g) {
		if (f) {
			if (!g && e) {
				var k = f,
					l = k;
				do null === l.z && (l.z = ej(l.x, l.y, c, d, e)), l.prevZ = l.prev, l = l.nextZ = l.next; while (l !== k);
				l.prevZ.nextZ = null;
				l.prevZ = null;
				k = l;
				var m, n, r, v, p = 1;
				do {
					l = k;
					var w = k = null;
					for (n = 0; l;) {
						n++;
						var q = l;
						for (m = r = 0; m < p && (r++, q = q.nextZ, q); m++);
						for (v = p; 0 < r || 0 < v && q;) 0 !== r && (0 ===
								v || !q || l.z <= q.z) ? (m = l, l = l.nextZ, r--) : (m = q, q = q.nextZ, v--), w ? w.nextZ = m : k = m, m.prevZ =
							w, w = m;
						l = q
					}
					w.nextZ = null;
					p *= 2
				} while (1 < n)
			}
			for (k = f; f.prev !== f.next;) {
				l = f.prev;
				q = f.next;
				if (e) w = Pq(f, c, d, e);
				else a: if (w = f, n = w.prev, r = w, p = w.next, 0 <= Ua(n, r, p)) w = !1;
					else {
						for (m = w.next.next; m !== w.prev;) {
							if (sd(n.x, n.y, r.x, r.y, p.x, p.y, m.x, m.y) && 0 <= Ua(m.prev, m, m.next)) {
								w = !1;
								break a
							}
							m = m.next
						}
						w = !0
					} if (w) a.push(l.i / b), a.push(f.i / b), a.push(q.i / b), Xe(f), k = f = q.next;
				else if (f = q, f === k) {
					if (!g) Ze(Ye(f), a, b, c, d, e, 1);
					else if (1 === g) {
						g = a;
						k = b;
						l = f;
						do q = l.prev, w = l.next.next, !hc(q, w) && en(q, l, l.next, w) && $e(q, w) && $e(w, q) && (g.push(q.i / k), g.push(
							l.i / k), g.push(w.i / k), Xe(l), Xe(l.next), l = f = w), l = l.next; while (l !== f);
						f = l;
						Ze(f, a, b, c, d, e, 2)
					} else if (2 === g) a: {
						g = f;do {
							for (k = g.next.next; k !== g.prev;) {
								if (l = g.i !== k.i) {
									l = g;
									q = k;
									if (w = l.next.i !== q.i && l.prev.i !== q.i) {
										b: {
											w = l;do {
												if (w.i !== l.i && w.next.i !== l.i && w.i !== q.i && w.next.i !== q.i && en(w, w.next, l, q)) {
													w = !0;
													break b
												}
												w = w.next
											} while (w !== l);w = !1
										}
										w = !w
									}
									if (w = w && $e(l, q) && $e(q, l)) {
										w = l;
										n = !1;
										r = (l.x + q.x) / 2;
										q = (l.y + q.y) / 2;
										do w.y > q !==
											w.next.y > q && w.next.y !== w.y && r < (w.next.x - w.x) * (q - w.y) / (w.next.y - w.y) + w.x && (n = !n),
											w = w.next; while (w !== l);
										w = n
									}
									l = w
								}
								if (l) {
									f = fn(g, k);
									g = Ye(g, g.next);
									f = Ye(f, f.next);
									Ze(g, a, b, c, d, e);
									Ze(f, a, b, c, d, e);
									break a
								}
								k = k.next
							}
							g = g.next
						} while (g !== f)
					}
					break
				}
			}
		}
	}

	function Pq(f, a, b, c) {
		var d = f.prev,
			e = f.next;
		if (0 <= Ua(d, f, e)) return !1;
		var g = d.x > f.x ? d.x > e.x ? d.x : e.x : f.x > e.x ? f.x : e.x,
			k = d.y > f.y ? d.y > e.y ? d.y : e.y : f.y > e.y ? f.y : e.y,
			l = ej(d.x < f.x ? d.x < e.x ? d.x : e.x : f.x < e.x ? f.x : e.x, d.y < f.y ? d.y < e.y ? d.y : e.y : f.y < e.y ? f
				.y : e.y, a, b, c);
		a = ej(g, k, a, b, c);
		b =
			f.prevZ;
		for (c = f.nextZ; b && b.z >= l && c && c.z <= a;) {
			if (b !== f.prev && b !== f.next && sd(d.x, d.y, f.x, f.y, e.x, e.y, b.x, b.y) && 0 <= Ua(b.prev, b, b.next)) return !
				1;
			b = b.prevZ;
			if (c !== f.prev && c !== f.next && sd(d.x, d.y, f.x, f.y, e.x, e.y, c.x, c.y) && 0 <= Ua(c.prev, c, c.next)) return !
				1;
			c = c.nextZ
		}
		for (; b && b.z >= l;) {
			if (b !== f.prev && b !== f.next && sd(d.x, d.y, f.x, f.y, e.x, e.y, b.x, b.y) && 0 <= Ua(b.prev, b, b.next)) return !
				1;
			b = b.prevZ
		}
		for (; c && c.z <= a;) {
			if (c !== f.prev && c !== f.next && sd(d.x, d.y, f.x, f.y, e.x, e.y, c.x, c.y) && 0 <= Ua(c.prev, c, c.next)) return !
				1;
			c = c.nextZ
		}
		return !0
	}

	function Qq(f, a) {
		return f.x - a.x
	}

	function Rq(f, a) {
		var b = a,
			c = f.x,
			d = f.y,
			e = -Infinity;
		do {
			if (d <= b.y && d >= b.next.y && b.next.y !== b.y) {
				var g = b.x + (d - b.y) * (b.next.x - b.x) / (b.next.y - b.y);
				if (g <= c && g > e) {
					e = g;
					if (g === c) {
						if (d === b.y) return b;
						if (d === b.next.y) return b.next
					}
					var k = b.x < b.next.x ? b : b.next
				}
			}
			b = b.next
		} while (b !== a);
		if (!k) return null;
		if (c === e) return k.prev;
		a = k;
		g = k.x;
		var l = k.y,
			m = Infinity;
		for (b = k.next; b !== a;) {
			if (c >= b.x && b.x >= g && c !== b.x && sd(d < l ? c : e, d, g, l, d < l ? e : c, d, b.x, b.y)) {
				var n = Math.abs(d - b.y) / (c - b.x);
				(n < m || n === m &&
					b.x > k.x) && $e(b, f) && (k = b, m = n)
			}
			b = b.next
		}
		return k
	}

	function ej(f, a, b, c, d) {
		f = 32767 * (f - b) * d;
		a = 32767 * (a - c) * d;
		f = (f | f << 8) & 16711935;
		f = (f | f << 4) & 252645135;
		f = (f | f << 2) & 858993459;
		a = (a | a << 8) & 16711935;
		a = (a | a << 4) & 252645135;
		a = (a | a << 2) & 858993459;
		return (f | f << 1) & 1431655765 | ((a | a << 1) & 1431655765) << 1
	}

	function Sq(f) {
		var a = f,
			b = f;
		do {
			if (a.x < b.x || a.x === b.x && a.y < b.y) b = a;
			a = a.next
		} while (a !== f);
		return b
	}

	function sd(f, a, b, c, d, e, g, k) {
		return 0 <= (d - g) * (a - k) - (f - g) * (e - k) && 0 <= (f - g) * (c - k) - (b - g) * (a - k) && 0 <= (b - g) * (e -
			k) - (d - g) * (c - k)
	}

	function Ua(f,
		a, b) {
		return (a.y - f.y) * (b.x - a.x) - (a.x - f.x) * (b.y - a.y)
	}

	function hc(f, a) {
		return f.x === a.x && f.y === a.y
	}

	function en(f, a, b, c) {
		return hc(f, b) && hc(a, c) || hc(f, c) && hc(b, a) ? !0 : 0 < Ua(f, a, b) !== 0 < Ua(f, a, c) && 0 < Ua(b, c, f) !==
			0 < Ua(b, c, a)
	}

	function $e(f, a) {
		return 0 > Ua(f.prev, f, f.next) ? 0 <= Ua(f, a, f.next) && 0 <= Ua(f, f.prev, a) : 0 > Ua(f, a, f.prev) || 0 > Ua(f,
			f.next, a)
	}

	function fn(f, a) {
		var b = new Oh(f.i, f.x, f.y),
			c = new Oh(a.i, a.x, a.y),
			d = f.next,
			e = a.prev;
		f.next = a;
		a.prev = f;
		b.next = d;
		d.prev = b;
		c.next = b;
		b.prev = c;
		e.next = c;
		c.prev = e;
		return c
	}

	function dn(f,
		a, b, c) {
		f = new Oh(f, a, b);
		c ? (f.next = c.next, f.prev = c, c.next.prev = f, c.next = f) : (f.prev = f, f.next = f);
		return f
	}

	function Xe(f) {
		f.next.prev = f.prev;
		f.prev.next = f.next;
		f.prevZ && (f.prevZ.nextZ = f.nextZ);
		f.nextZ && (f.nextZ.prevZ = f.prevZ)
	}

	function Oh(f, a, b) {
		this.i = f;
		this.x = a;
		this.y = b;
		this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
		this.steiner = !1
	}

	function gn(f) {
		var a = f.length;
		2 < a && f[a - 1].equals(f[0]) && f.pop()
	}

	function hn(f, a) {
		for (var b = 0; b < a.length; b++) f.push(a[b].x), f.push(a[b].y)
	}

	function Jf(f, a) {
		R.call(this);
		this.type = "ExtrudeGeometry";
		this.parameters = {
			shapes: f,
			options: a
		};
		this.fromBufferGeometry(new de(f, a));
		this.mergeVertices()
	}

	function de(f, a) {
		function b(b) {
			function f(a, b, c) {
				b || console.error("THREE.ExtrudeGeometry: vec does not exist");
				return b.clone().multiplyScalar(c).add(a)
			}

			function g(a, b, c) {
				var d = a.x - b.x;
				var e = a.y - b.y;
				var f = c.x - a.x;
				var g = c.y - a.y,
					k = d * d + e * e;
				if (Math.abs(d * g - e * f) > Na) {
					var l = Math.sqrt(k),
						m = Math.sqrt(f * f + g * g);
					k = b.x - e / l;
					b = b.y + d / l;
					g = ((c.x - g / m - k) * g - (c.y + f / m - b) * f) / (d * g - e * f);
					f = k + d * g - a.x;
					d =
						b + e * g - a.y;
					e = f * f + d * d;
					if (2 >= e) return new B(f, d);
					e = Math.sqrt(e / 2)
				} else a = !1, d > Na ? f > Na && (a = !0) : d < -Na ? f < -Na && (a = !0) : Lg(e) === Lg(g) && (a = !0), a ? (f = -
					e, e = Math.sqrt(k)) : (f = d, d = e, e = Math.sqrt(k / 2));
				return new B(f / e, d / e)
			}

			function k(a, b) {
				for (Z = a.length; 0 <= --Z;) {
					var e = Z;
					var f = Z - 1;
					0 > f && (f = a.length - 1);
					var g, k = K + 2 * J;
					for (g = 0; g < k; g++) {
						var l = da * g,
							m = da * (g + 1),
							n = b + f + l,
							r = b + f + m;
						m = b + e + m;
						w(b + e + l);
						w(n);
						w(m);
						w(n);
						w(r);
						w(m);
						l = d.length / 3;
						l = M.generateSideWallUV(c, d, l - 6, l - 3, l - 2, l - 1);
						q(l[0]);
						q(l[1]);
						q(l[3]);
						q(l[1]);
						q(l[2]);
						q(l[3])
					}
				}
			}

			function l(a, b, c) {
				C.push(a);
				C.push(b);
				C.push(c)
			}

			function p(a, b, e) {
				w(a);
				w(b);
				w(e);
				a = d.length / 3;
				a = M.generateTopUV(c, d, a - 3, a - 2, a - 1);
				q(a[0]);
				q(a[1]);
				q(a[2])
			}

			function w(a) {
				d.push(C[3 * a]);
				d.push(C[3 * a + 1]);
				d.push(C[3 * a + 2])
			}

			function q(a) {
				e.push(a.x);
				e.push(a.y)
			}
			var C = [],
				D = void 0 !== a.curveSegments ? a.curveSegments : 12,
				K = void 0 !== a.steps ? a.steps : 1,
				G = void 0 !== a.depth ? a.depth : 100,
				la = void 0 !== a.bevelEnabled ? a.bevelEnabled : !0,
				H = void 0 !== a.bevelThickness ? a.bevelThickness : 6,
				Q = void 0 !== a.bevelSize ? a.bevelSize : H - 2,
				wa =
				void 0 !== a.bevelOffset ? a.bevelOffset : 0,
				J = void 0 !== a.bevelSegments ? a.bevelSegments : 3,
				N = a.extrudePath,
				M = void 0 !== a.UVGenerator ? a.UVGenerator : Tq;
			void 0 !== a.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), G = a.amount);
			var La = !1;
			if (N) {
				var P = N.getSpacedPoints(K);
				La = !0;
				la = !1;
				var S = N.computeFrenetFrames(K, !1);
				var X = new u;
				var ra = new u;
				var V = new u
			}
			la || (wa = Q = H = J = 0);
			var W;
			D = b.extractPoints(D);
			b = D.shape;
			var ja = D.holes;
			if (!Sb.isClockWise(b)) {
				b = b.reverse();
				var F = 0;
				for (W = ja.length; F <
					W; F++) {
					var R = ja[F];
					Sb.isClockWise(R) && (ja[F] = R.reverse())
				}
			}
			var L = Sb.triangulateShape(b, ja),
				ia = b;
			F = 0;
			for (W = ja.length; F < W; F++) R = ja[F], b = b.concat(R);
			var fa, da = b.length,
				I, ta = L.length;
			D = [];
			var Z = 0;
			var xa = ia.length;
			var T = xa - 1;
			for (fa = Z + 1; Z < xa; Z++, T++, fa++) T === xa && (T = 0), fa === xa && (fa = 0), D[Z] = g(ia[Z], ia[T], ia[fa]);
			N = [];
			var ha = D.concat();
			F = 0;
			for (W = ja.length; F < W; F++) {
				R = ja[F];
				var ma = [];
				Z = 0;
				xa = R.length;
				T = xa - 1;
				for (fa = Z + 1; Z < xa; Z++, T++, fa++) T === xa && (T = 0), fa === xa && (fa = 0), ma[Z] = g(R[Z], R[T], R[fa]);
				N.push(ma);
				ha = ha.concat(ma)
			}
			for (T =
				0; T < J; T++) {
				xa = T / J;
				var ua = H * Math.cos(xa * Math.PI / 2);
				fa = Q * Math.sin(xa * Math.PI / 2) + wa;
				Z = 0;
				for (xa = ia.length; Z < xa; Z++) {
					var ba = f(ia[Z], D[Z], fa);
					l(ba.x, ba.y, -ua)
				}
				F = 0;
				for (W = ja.length; F < W; F++)
					for (R = ja[F], ma = N[F], Z = 0, xa = R.length; Z < xa; Z++) ba = f(R[Z], ma[Z], fa), l(ba.x, ba.y, -ua)
			}
			fa = Q + wa;
			for (Z = 0; Z < da; Z++) ba = la ? f(b[Z], ha[Z], fa) : b[Z], La ? (ra.copy(S.normals[0]).multiplyScalar(ba.x), X.copy(
				S.binormals[0]).multiplyScalar(ba.y), V.copy(P[0]).add(ra).add(X), l(V.x, V.y, V.z)) : l(ba.x, ba.y, 0);
			for (xa = 1; xa <= K; xa++)
				for (Z = 0; Z < da; Z++) ba =
					la ? f(b[Z], ha[Z], fa) : b[Z], La ? (ra.copy(S.normals[xa]).multiplyScalar(ba.x), X.copy(S.binormals[xa]).multiplyScalar(
						ba.y), V.copy(P[xa]).add(ra).add(X), l(V.x, V.y, V.z)) : l(ba.x, ba.y, G / K * xa);
			for (T = J - 1; 0 <= T; T--) {
				xa = T / J;
				ua = H * Math.cos(xa * Math.PI / 2);
				fa = Q * Math.sin(xa * Math.PI / 2) + wa;
				Z = 0;
				for (xa = ia.length; Z < xa; Z++) ba = f(ia[Z], D[Z], fa), l(ba.x, ba.y, G + ua);
				F = 0;
				for (W = ja.length; F < W; F++)
					for (R = ja[F], ma = N[F], Z = 0, xa = R.length; Z < xa; Z++) ba = f(R[Z], ma[Z], fa), La ? l(ba.x, ba.y + P[K -
						1].y, P[K - 1].x + ua) : l(ba.x, ba.y, G + ua)
			}(function() {
				var a =
					d.length / 3;
				if (la) {
					var b = 0 * da;
					for (Z = 0; Z < ta; Z++) I = L[Z], p(I[2] + b, I[1] + b, I[0] + b);
					b = da * (K + 2 * J);
					for (Z = 0; Z < ta; Z++) I = L[Z], p(I[0] + b, I[1] + b, I[2] + b)
				} else {
					for (Z = 0; Z < ta; Z++) I = L[Z], p(I[2], I[1], I[0]);
					for (Z = 0; Z < ta; Z++) I = L[Z], p(I[0] + da * K, I[1] + da * K, I[2] + da * K)
				}
				c.addGroup(a, d.length / 3 - a, 0)
			})();
			(function() {
				var a = d.length / 3,
					b = 0;
				k(ia, b);
				b += ia.length;
				F = 0;
				for (W = ja.length; F < W; F++) R = ja[F], k(R, b), b += R.length;
				c.addGroup(a, d.length / 3 - a, 1)
			})()
		}
		J.call(this);
		this.type = "ExtrudeBufferGeometry";
		this.parameters = {
			shapes: f,
			options: a
		};
		f = Array.isArray(f) ? f : [f];
		for (var c = this, d = [], e = [], g = 0, k = f.length; g < k; g++) b(f[g]);
		this.addAttribute("position", new N(d, 3));
		this.addAttribute("uv", new N(e, 2));
		this.computeVertexNormals()
	}

	function jn(f, a, b) {
		b.shapes = [];
		if (Array.isArray(f))
			for (var c = 0, d = f.length; c < d; c++) b.shapes.push(f[c].uuid);
		else b.shapes.push(f.uuid);
		void 0 !== a.extrudePath && (b.options.extrudePath = a.extrudePath.toJSON());
		return b
	}

	function Mg(f, a) {
		R.call(this);
		this.type = "TextGeometry";
		this.parameters = {
			text: f,
			parameters: a
		};
		this.fromBufferGeometry(new af(f,
			a));
		this.mergeVertices()
	}

	function af(f, a) {
		a = a || {};
		var b = a.font;
		if (!b || !b.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
			new R;
		f = b.generateShapes(f, a.size);
		a.depth = void 0 !== a.height ? a.height : 50;
		void 0 === a.bevelThickness && (a.bevelThickness = 10);
		void 0 === a.bevelSize && (a.bevelSize = 8);
		void 0 === a.bevelEnabled && (a.bevelEnabled = !1);
		de.call(this, f, a);
		this.type = "TextBufferGeometry"
	}

	function Ng(f, a, b, c, d, e, g) {
		R.call(this);
		this.type = "SphereGeometry";
		this.parameters = {
			radius: f,
			widthSegments: a,
			heightSegments: b,
			phiStart: c,
			phiLength: d,
			thetaStart: e,
			thetaLength: g
		};
		this.fromBufferGeometry(new Fc(f, a, b, c, d, e, g));
		this.mergeVertices()
	}

	function Fc(f, a, b, c, d, e, g) {
		J.call(this);
		this.type = "SphereBufferGeometry";
		this.parameters = {
			radius: f,
			widthSegments: a,
			heightSegments: b,
			phiStart: c,
			phiLength: d,
			thetaStart: e,
			thetaLength: g
		};
		f = f || 1;
		a = Math.max(3, Math.floor(a) || 8);
		b = Math.max(2, Math.floor(b) || 6);
		c = void 0 !== c ? c : 0;
		d = void 0 !== d ? d : 2 * Math.PI;
		e = void 0 !== e ? e : 0;
		g = void 0 !== g ? g : Math.PI;
		var k =
			Math.min(e + g, Math.PI),
			l, m, n = 0,
			r = [],
			v = new u,
			p = new u,
			w = [],
			q = [],
			C = [],
			D = [];
		for (m = 0; m <= b; m++) {
			var K = [],
				G = m / b,
				B = 0;
			0 == m && 0 == e ? B = .5 / a : m == b && k == Math.PI && (B = -.5 / a);
			for (l = 0; l <= a; l++) {
				var H = l / a;
				v.x = -f * Math.cos(c + H * d) * Math.sin(e + G * g);
				v.y = f * Math.cos(e + G * g);
				v.z = f * Math.sin(c + H * d) * Math.sin(e + G * g);
				q.push(v.x, v.y, v.z);
				p.copy(v).normalize();
				C.push(p.x, p.y, p.z);
				D.push(H + B, 1 - G);
				K.push(n++)
			}
			r.push(K)
		}
		for (m = 0; m < b; m++)
			for (l = 0; l < a; l++) f = r[m][l + 1], c = r[m][l], d = r[m + 1][l], g = r[m + 1][l + 1], (0 !== m || 0 < e) && w
				.push(f, c, g), (m !== b - 1 || k <
					Math.PI) && w.push(c, d, g);
		this.setIndex(w);
		this.addAttribute("position", new N(q, 3));
		this.addAttribute("normal", new N(C, 3));
		this.addAttribute("uv", new N(D, 2))
	}

	function Ph(f, a, b, c, d, e) {
		R.call(this);
		this.type = "RingGeometry";
		this.parameters = {
			innerRadius: f,
			outerRadius: a,
			thetaSegments: b,
			phiSegments: c,
			thetaStart: d,
			thetaLength: e
		};
		this.fromBufferGeometry(new bf(f, a, b, c, d, e));
		this.mergeVertices()
	}

	function bf(f, a, b, c, d, e) {
		J.call(this);
		this.type = "RingBufferGeometry";
		this.parameters = {
			innerRadius: f,
			outerRadius: a,
			thetaSegments: b,
			phiSegments: c,
			thetaStart: d,
			thetaLength: e
		};
		f = f || .5;
		a = a || 1;
		d = void 0 !== d ? d : 0;
		e = void 0 !== e ? e : 2 * Math.PI;
		b = void 0 !== b ? Math.max(3, b) : 8;
		c = void 0 !== c ? Math.max(1, c) : 1;
		var g = [],
			k = [],
			l = [],
			m = [],
			n = f,
			r = (a - f) / c,
			v = new u,
			p = new B,
			w, q;
		for (w = 0; w <= c; w++) {
			for (q = 0; q <= b; q++) f = d + q / b * e, v.x = n * Math.cos(f), v.y = n * Math.sin(f), k.push(v.x, v.y, v.z), l.push(
				0, 0, 1), p.x = (v.x / a + 1) / 2, p.y = (v.y / a + 1) / 2, m.push(p.x, p.y);
			n += r
		}
		for (w = 0; w < c; w++)
			for (a = w * (b + 1), q = 0; q < b; q++) f = q + a, d = f + b + 1, e = f + b + 2, n = f + 1, g.push(f, d, n), g.push(
				d, e, n);
		this.setIndex(g);
		this.addAttribute("position", new N(k, 3));
		this.addAttribute("normal", new N(l, 3));
		this.addAttribute("uv", new N(m, 2))
	}

	function Og(f, a, b, c) {
		R.call(this);
		this.type = "LatheGeometry";
		this.parameters = {
			points: f,
			segments: a,
			phiStart: b,
			phiLength: c
		};
		this.fromBufferGeometry(new cf(f, a, b, c));
		this.mergeVertices()
	}

	function cf(f, a, b, c) {
		J.call(this);
		this.type = "LatheBufferGeometry";
		this.parameters = {
			points: f,
			segments: a,
			phiStart: b,
			phiLength: c
		};
		a = Math.floor(a) || 12;
		b = b || 0;
		c = c || 2 * Math.PI;
		c = ha.clamp(c, 0, 2 * Math.PI);
		var d = [],
			e = [],
			g = [],
			k = 1 / a,
			l = new u,
			m = new B,
			n;
		for (n = 0; n <= a; n++) {
			var r = b + n * k * c;
			var v = Math.sin(r),
				p = Math.cos(r);
			for (r = 0; r <= f.length - 1; r++) l.x = f[r].x * v, l.y = f[r].y, l.z = f[r].x * p, e.push(l.x, l.y, l.z), m.x =
				n / a, m.y = r / (f.length - 1), g.push(m.x, m.y)
		}
		for (n = 0; n < a; n++)
			for (r = 0; r < f.length - 1; r++) b = r + n * f.length, k = b + f.length, l = b + f.length + 1, m = b + 1, d.push(
				b, k, m), d.push(k, l, m);
		this.setIndex(d);
		this.addAttribute("position", new N(e, 3));
		this.addAttribute("uv", new N(g, 2));
		this.computeVertexNormals();
		if (c === 2 * Math.PI)
			for (c = this.attributes.normal.array,
				d = new u, e = new u, g = new u, b = a * f.length * 3, r = n = 0; n < f.length; n++, r += 3) d.x = c[r + 0], d.y =
				c[r + 1], d.z = c[r + 2], e.x = c[b + r + 0], e.y = c[b + r + 1], e.z = c[b + r + 2], g.addVectors(d, e).normalize(),
				c[r + 0] = c[b + r + 0] = g.x, c[r + 1] = c[b + r + 1] = g.y, c[r + 2] = c[b + r + 2] = g.z
	}

	function Kf(f, a) {
		R.call(this);
		this.type = "ShapeGeometry";
		"object" === ("undefined" === typeof a ? "undefined" : Ni(a)) && (console.warn(
			"THREE.ShapeGeometry: Options parameter has been removed."), a = a.curveSegments);
		this.parameters = {
			shapes: f,
			curveSegments: a
		};
		this.fromBufferGeometry(new td(f,
			a));
		this.mergeVertices()
	}

	function td(f, a) {
		function b(b) {
			var f, k = d.length / 3;
			b = b.extractPoints(a);
			var m = b.shape,
				n = b.holes;
			!1 === Sb.isClockWise(m) && (m = m.reverse());
			b = 0;
			for (f = n.length; b < f; b++) {
				var p = n[b];
				!0 === Sb.isClockWise(p) && (n[b] = p.reverse())
			}
			var q = Sb.triangulateShape(m, n);
			b = 0;
			for (f = n.length; b < f; b++) p = n[b], m = m.concat(p);
			b = 0;
			for (f = m.length; b < f; b++) p = m[b], d.push(p.x, p.y, 0), e.push(0, 0, 1), g.push(p.x, p.y);
			b = 0;
			for (f = q.length; b < f; b++) m = q[b], c.push(m[0] + k, m[1] + k, m[2] + k), l += 3
		}
		J.call(this);
		this.type = "ShapeBufferGeometry";
		this.parameters = {
			shapes: f,
			curveSegments: a
		};
		a = a || 12;
		var c = [],
			d = [],
			e = [],
			g = [],
			k = 0,
			l = 0;
		if (!1 === Array.isArray(f)) b(f);
		else
			for (var m = 0; m < f.length; m++) b(f[m]), this.addGroup(k, l, m), k += l, l = 0;
		this.setIndex(c);
		this.addAttribute("position", new N(d, 3));
		this.addAttribute("normal", new N(e, 3));
		this.addAttribute("uv", new N(g, 2))
	}

	function kn(f, a) {
		a.shapes = [];
		if (Array.isArray(f))
			for (var b = 0, c = f.length; b < c; b++) a.shapes.push(f[b].uuid);
		else a.shapes.push(f.uuid);
		return a
	}

	function Pg(f, a) {
		J.call(this);
		this.type = "EdgesGeometry";
		this.parameters = {
			thresholdAngle: a
		};
		var b = [];
		a = Math.cos(ha.DEG2RAD * (void 0 !== a ? a : 1));
		var c = [0, 0],
			d = {},
			e = ["a", "b", "c"];
		if (f.isBufferGeometry) {
			var g = new R;
			g.fromBufferGeometry(f)
		} else g = f.clone();
		g.mergeVertices();
		g.computeFaceNormals();
		f = g.vertices;
		g = g.faces;
		for (var k = 0, l = g.length; k < l; k++)
			for (var m = g[k], n = 0; 3 > n; n++) {
				var r = m[e[n]];
				var v = m[e[(n + 1) % 3]];
				c[0] = Math.min(r, v);
				c[1] = Math.max(r, v);
				r = c[0] + "," + c[1];
				void 0 === d[r] ? d[r] = {
					index1: c[0],
					index2: c[1],
					face1: k,
					face2: void 0
				} : d[r].face2 = k
			}
		for (r in d)
			if (c = d[r],
				void 0 === c.face2 || g[c.face1].normal.dot(g[c.face2].normal) <= a) e = f[c.index1], b.push(e.x, e.y, e.z), e = f[
				c.index2], b.push(e.x, e.y, e.z);
		this.addAttribute("position", new N(b, 3))
	}

	function df(f, a, b, c, d, e, g, k) {
		R.call(this);
		this.type = "CylinderGeometry";
		this.parameters = {
			radiusTop: f,
			radiusBottom: a,
			height: b,
			radialSegments: c,
			heightSegments: d,
			openEnded: e,
			thetaStart: g,
			thetaLength: k
		};
		this.fromBufferGeometry(new ic(f, a, b, c, d, e, g, k));
		this.mergeVertices()
	}

	function ic(f, a, b, c, d, e, g, k) {
		function l(b) {
			var d, e = new B,
				l = new u,
				w = 0,
				A = !0 === b ? f : a,
				z = !0 === b ? 1 : -1;
			var K = q;
			for (d = 1; d <= c; d++) r.push(0, C * z, 0), v.push(0, z, 0), p.push(.5, .5), q++;
			var J = q;
			for (d = 0; d <= c; d++) {
				var N = d / c * k + g,
					P = Math.cos(N);
				N = Math.sin(N);
				l.x = A * N;
				l.y = C * z;
				l.z = A * P;
				r.push(l.x, l.y, l.z);
				v.push(0, z, 0);
				e.x = .5 * P + .5;
				e.y = .5 * N * z + .5;
				p.push(e.x, e.y);
				q++
			}
			for (d = 0; d < c; d++) e = K + d, l = J + d, !0 === b ? n.push(l, l + 1, e) : n.push(l + 1, l, e), w += 3;
			m.addGroup(D, w, !0 === b ? 1 : 2);
			D += w
		}
		J.call(this);
		this.type = "CylinderBufferGeometry";
		this.parameters = {
			radiusTop: f,
			radiusBottom: a,
			height: b,
			radialSegments: c,
			heightSegments: d,
			openEnded: e,
			thetaStart: g,
			thetaLength: k
		};
		var m = this;
		f = void 0 !== f ? f : 1;
		a = void 0 !== a ? a : 1;
		b = b || 1;
		c = Math.floor(c) || 8;
		d = Math.floor(d) || 1;
		e = void 0 !== e ? e : !1;
		g = void 0 !== g ? g : 0;
		k = void 0 !== k ? k : 2 * Math.PI;
		var n = [],
			r = [],
			v = [],
			p = [],
			q = 0,
			z = [],
			C = b / 2,
			D = 0;
		(function() {
			var e, l, w = new u,
				A = new u,
				Q = 0,
				B = (a - f) / b;
			for (l = 0; l <= d; l++) {
				var J = [],
					N = l / d,
					M = N * (a - f) + f;
				for (e = 0; e <= c; e++) {
					var P = e / c,
						F = P * k + g,
						S = Math.sin(F);
					F = Math.cos(F);
					A.x = M * S;
					A.y = -N * b + C;
					A.z = M * F;
					r.push(A.x, A.y, A.z);
					w.set(S, B, F).normalize();
					v.push(w.x, w.y, w.z);
					p.push(P, 1 - N);
					J.push(q++)
				}
				z.push(J)
			}
			for (e =
				0; e < c; e++)
				for (l = 0; l < d; l++) w = z[l + 1][e], A = z[l + 1][e + 1], B = z[l][e + 1], n.push(z[l][e], w, B), n.push(w, A,
					B), Q += 6;
			m.addGroup(D, Q, 0);
			D += Q
		})();
		!1 === e && (0 < f && l(!0), 0 < a && l(!1));
		this.setIndex(n);
		this.addAttribute("position", new N(r, 3));
		this.addAttribute("normal", new N(v, 3));
		this.addAttribute("uv", new N(p, 2))
	}

	function Qg(f, a, b, c, d, e, g) {
		df.call(this, 0, f, a, b, c, d, e, g);
		this.type = "ConeGeometry";
		this.parameters = {
			radius: f,
			height: a,
			radialSegments: b,
			heightSegments: c,
			openEnded: d,
			thetaStart: e,
			thetaLength: g
		}
	}

	function fj(f, a,
		b, c, d, e, g) {
		ic.call(this, 0, f, a, b, c, d, e, g);
		this.type = "ConeBufferGeometry";
		this.parameters = {
			radius: f,
			height: a,
			radialSegments: b,
			heightSegments: c,
			openEnded: d,
			thetaStart: e,
			thetaLength: g
		}
	}

	function Lf(f, a, b, c) {
		R.call(this);
		this.type = "CircleGeometry";
		this.parameters = {
			radius: f,
			segments: a,
			thetaStart: b,
			thetaLength: c
		};
		this.fromBufferGeometry(new ef(f, a, b, c));
		this.mergeVertices()
	}

	function ef(f, a, b, c) {
		J.call(this);
		this.type = "CircleBufferGeometry";
		this.parameters = {
			radius: f,
			segments: a,
			thetaStart: b,
			thetaLength: c
		};
		f = f || 1;
		a = void 0 !== a ? Math.max(3, a) : 8;
		b = void 0 !== b ? b : 0;
		c = void 0 !== c ? c : 2 * Math.PI;
		var d = [],
			e = [],
			g = [],
			k = [],
			l, m = new u,
			n = new B;
		e.push(0, 0, 0);
		g.push(0, 0, 1);
		k.push(.5, .5);
		var r = 0;
		for (l = 3; r <= a; r++, l += 3) {
			var v = b + r / a * c;
			m.x = f * Math.cos(v);
			m.y = f * Math.sin(v);
			e.push(m.x, m.y, m.z);
			g.push(0, 0, 1);
			n.x = (e[l] / f + 1) / 2;
			n.y = (e[l + 1] / f + 1) / 2;
			k.push(n.x, n.y)
		}
		for (l = 1; l <= a; l++) d.push(l, l + 1, 0);
		this.setIndex(d);
		this.addAttribute("position", new N(e, 3));
		this.addAttribute("normal", new N(g, 3));
		this.addAttribute("uv", new N(k, 2))
	}

	function Mf(f) {
		ia.call(this);
		this.type = "ShadowMaterial";
		this.color = new S(0);
		this.transparent = !0;
		this.setValues(f)
	}

	function ff(f) {
		Ia.call(this, f);
		this.type = "RawShaderMaterial"
	}

	function ee(f) {
		ia.call(this);
		this.defines = {
			STANDARD: ""
		};
		this.type = "MeshStandardMaterial";
		this.color = new S(16777215);
		this.metalness = this.roughness = .5;
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.emissive = new S(0);
		this.emissiveIntensity = 1;
		this.bumpMap = this.emissiveMap = null;
		this.bumpScale = 1;
		this.normalMap =
			null;
		this.normalMapType = 0;
		this.normalScale = new B(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
		this.envMapIntensity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(f)
	}

	function Nf(f) {
		ee.call(this);
		this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		};
		this.type = "MeshPhysicalMaterial";
		this.reflectivity = .5;
		this.clearcoatRoughness = this.clearcoat = 0;
		this.sheen = null;
		this.clearcoatNormalScale = new B(1, 1);
		this.clearcoatNormalMap = null;
		this.transparency = 0;
		this.setValues(f)
	}

	function Gc(f) {
		ia.call(this);
		this.type = "MeshPhongMaterial";
		this.color = new S(16777215);
		this.specular = new S(1118481);
		this.shininess = 30;
		this.lightMap = this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.emissive = new S(0);
		this.emissiveIntensity = 1;
		this.bumpMap = this.emissiveMap = null;
		this.bumpScale =
			1;
		this.normalMap = null;
		this.normalMapType = 0;
		this.normalScale = new B(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.envMap = this.alphaMap = this.specularMap = null;
		this.combine = 0;
		this.reflectivity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(f)
	}

	function Of(f) {
		Gc.call(this);
		this.defines = {
			TOON: ""
		};
		this.type = "MeshToonMaterial";
		this.gradientMap = null;
		this.setValues(f)
	}

	function ud(f) {
		ia.call(this);
		this.type = "MeshNormalMaterial";
		this.bumpMap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = 0;
		this.normalScale = new B(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.morphNormals = this.morphTargets = this.skinning = this.fog = !1;
		this.setValues(f)
	}

	function Hc(f) {
		ia.call(this);
		this.type = "MeshLambertMaterial";
		this.color = new S(16777215);
		this.lightMap =
			this.map = null;
		this.lightMapIntensity = 1;
		this.aoMap = null;
		this.aoMapIntensity = 1;
		this.emissive = new S(0);
		this.emissiveIntensity = 1;
		this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null;
		this.combine = 0;
		this.reflectivity = 1;
		this.refractionRatio = .98;
		this.wireframe = !1;
		this.wireframeLinewidth = 1;
		this.wireframeLinejoin = this.wireframeLinecap = "round";
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(f)
	}

	function vd(f) {
		ia.call(this);
		this.defines = {
			MATCAP: ""
		};
		this.type = "MeshMatcapMaterial";
		this.color = new S(16777215);
		this.bumpMap = this.map = this.matcap = null;
		this.bumpScale = 1;
		this.normalMap = null;
		this.normalMapType = 0;
		this.normalScale = new B(1, 1);
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
		this.alphaMap = null;
		this.morphNormals = this.morphTargets = this.skinning = !1;
		this.setValues(f)
	}

	function wd(f) {
		Aa.call(this);
		this.type = "LineDashedMaterial";
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
		this.setValues(f)
	}

	function jc(f, a, b, c) {
		this.parameterPositions = f;
		this._cachedIndex =
			0;
		this.resultBuffer = void 0 !== c ? c : new a.constructor(b);
		this.sampleValues = a;
		this.valueSize = b
	}

	function nk(f, a, b, c) {
		jc.call(this, f, a, b, c);
		this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
	}

	function gj(f, a, b, c) {
		jc.call(this, f, a, b, c)
	}

	function hj(f, a, b, c) {
		jc.call(this, f, a, b, c)
	}

	function pb(f, a, b, c) {
		if (void 0 === f) throw Error("THREE.KeyframeTrack: track name is undefined");
		if (void 0 === a || 0 === a.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + f);
		this.name = f;
		this.times =
			cb.convertArray(a, this.TimeBufferType);
		this.values = cb.convertArray(b, this.ValueBufferType);
		this.setInterpolation(c || this.DefaultInterpolation)
	}

	function Qh(f, a, b) {
		pb.call(this, f, a, b)
	}

	function ok(f, a, b, c) {
		pb.call(this, f, a, b, c)
	}

	function Pf(f, a, b, c) {
		pb.call(this, f, a, b, c)
	}

	function ij(f, a, b, c) {
		jc.call(this, f, a, b, c)
	}

	function jj(f, a, b, c) {
		pb.call(this, f, a, b, c)
	}

	function kj(f, a, b, c) {
		pb.call(this, f, a, b, c)
	}

	function Qf(f, a, b, c) {
		pb.call(this, f, a, b, c)
	}

	function Ic(f, a, b) {
		this.name = f;
		this.tracks = b;
		this.duration = void 0 !==
			a ? a : -1;
		this.uuid = ha.generateUUID();
		0 > this.duration && this.resetDuration()
	}

	function Uq(f) {
		switch (f.toLowerCase()) {
			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":
				return Pf;
			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":
				return Qf;
			case "color":
				return ok;
			case "quaternion":
				return jj;
			case "bool":
			case "boolean":
				return Qh;
			case "string":
				return kj
		}
		throw Error("THREE.KeyframeTrack: Unsupported typeName: " + f);
	}

	function Vq(f) {
		if (void 0 === f.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
		var a = Uq(f.type);
		if (void 0 === f.times) {
			var b = [],
				c = [];
			cb.flattenJSON(f.keys, b, c, "value");
			f.times = b;
			f.values = c
		}
		return void 0 !== a.parse ? a.parse(f) : new a(f.name, f.times, f.values, f.interpolation)
	}

	function ln(f, a, b) {
		var c = this,
			d = !1,
			e = 0,
			g = 0,
			k = void 0,
			l = [];
		this.onStart = void 0;
		this.onLoad = f;
		this.onProgress = a;
		this.onError = b;
		this.itemStart = function(a) {
			g++;
			if (!1 === d && void 0 !== c.onStart) c.onStart(a, e, g);
			d = !0
		};
		this.itemEnd = function(a) {
			e++;
			if (void 0 !== c.onProgress) c.onProgress(a, e, g);
			if (e === g && (d = !1, void 0 !== c.onLoad)) c.onLoad()
		};
		this.itemError = function(a) {
			if (void 0 !== c.onError) c.onError(a)
		};
		this.resolveURL = function(a) {
			return k ? k(a) : a
		};
		this.setURLModifier = function(a) {
			k = a;
			return this
		};
		this.addHandler = function(a, b) {
			l.push(a, b);
			return this
		};
		this.removeHandler = function(a) {
			a = l.indexOf(a); - 1 !== a && l.splice(a, 2);
			return this
		};
		this.getHandler = function(a) {
			for (var b = 0, c = l.length; b < c; b += 2) {
				var d = l[b + 1];
				if (l[b].test(a)) return d
			}
			return null
		}
	}

	function sa(f) {
		this.manager = void 0 !== f ? f : Wq;
		this.crossOrigin = "anonymous";
		this.resourcePath = this.path =
			""
	}

	function Jc(f) {
		sa.call(this, f)
	}

	function mn(f) {
		sa.call(this, f)
	}

	function nn(f) {
		sa.call(this, f)
	}

	function on(f) {
		sa.call(this, f)
	}

	function Rf(f) {
		sa.call(this, f)
	}

	function lj(f) {
		sa.call(this, f)
	}

	function mj(f) {
		sa.call(this, f)
	}

	function X() {
		this.type = "Curve";
		this.arcLengthDivisions = 200
	}

	function kc(f, a, b, c, d, e, g, k) {
		X.call(this);
		this.type = "EllipseCurve";
		this.aX = f || 0;
		this.aY = a || 0;
		this.xRadius = b || 1;
		this.yRadius = c || 1;
		this.aStartAngle = d || 0;
		this.aEndAngle = e || 2 * Math.PI;
		this.aClockwise = g || !1;
		this.aRotation = k || 0
	}

	function Sf(f,
		a, b, c, d, e) {
		kc.call(this, f, a, b, b, c, d, e);
		this.type = "ArcCurve"
	}

	function nj() {
		var f = 0,
			a = 0,
			b = 0,
			c = 0;
		return {
			initCatmullRom: function(d, e, g, k, l) {
				d = l * (g - d);
				k = l * (k - e);
				f = e;
				a = d;
				b = -3 * e + 3 * g - 2 * d - k;
				c = 2 * e - 2 * g + d + k
			},
			initNonuniformCatmullRom: function(d, e, g, k, l, m, n) {
				d = ((e - d) / l - (g - d) / (l + m) + (g - e) / m) * m;
				k = ((g - e) / m - (k - e) / (m + n) + (k - g) / n) * m;
				f = e;
				a = d;
				b = -3 * e + 3 * g - 2 * d - k;
				c = 2 * e - 2 * g + d + k
			},
			calc: function(d) {
				var e = d * d;
				return f + a * d + b * e + c * e * d
			}
		}
	}

	function wb(f, a, b, c) {
		X.call(this);
		this.type = "CatmullRomCurve3";
		this.points = f || [];
		this.closed = a ||
			!1;
		this.curveType = b || "centripetal";
		this.tension = c || .5
	}

	function pn(f, a, b, c, d) {
		a = .5 * (c - a);
		d = .5 * (d - b);
		var e = f * f;
		return (2 * b - 2 * c + a + d) * f * e + (-3 * b + 3 * c - 2 * a - d) * e + a * f + b
	}

	function gf(f, a, b, c) {
		var d = 1 - f;
		return d * d * a + 2 * (1 - f) * f * b + f * f * c
	}

	function hf(f, a, b, c, d) {
		var e = 1 - f,
			g = 1 - f;
		return e * e * e * a + 3 * g * g * f * b + 3 * (1 - f) * f * f * c + f * f * f * d
	}

	function Kc(f, a, b, c) {
		X.call(this);
		this.type = "CubicBezierCurve";
		this.v0 = f || new B;
		this.v1 = a || new B;
		this.v2 = b || new B;
		this.v3 = c || new B
	}

	function xd(f, a, b, c) {
		X.call(this);
		this.type = "CubicBezierCurve3";
		this.v0 = f || new u;
		this.v1 = a || new u;
		this.v2 = b || new u;
		this.v3 = c || new u
	}

	function Tb(f, a) {
		X.call(this);
		this.type = "LineCurve";
		this.v1 = f || new B;
		this.v2 = a || new B
	}

	function Ub(f, a) {
		X.call(this);
		this.type = "LineCurve3";
		this.v1 = f || new u;
		this.v2 = a || new u
	}

	function yd(f, a, b) {
		X.call(this);
		this.type = "QuadraticBezierCurve";
		this.v0 = f || new B;
		this.v1 = a || new B;
		this.v2 = b || new B
	}

	function fe(f, a, b) {
		X.call(this);
		this.type = "QuadraticBezierCurve3";
		this.v0 = f || new u;
		this.v1 = a || new u;
		this.v2 = b || new u
	}

	function zd(f) {
		X.call(this);
		this.type = "SplineCurve";
		this.points = f || []
	}

	function ge() {
		X.call(this);
		this.type = "CurvePath";
		this.curves = [];
		this.autoClose = !1
	}

	function Ad(f) {
		ge.call(this);
		this.type = "Path";
		this.currentPoint = new B;
		f && this.setFromPoints(f)
	}

	function lc(f) {
		Ad.call(this, f);
		this.uuid = ha.generateUUID();
		this.type = "Shape";
		this.holes = []
	}

	function Ba(f, a) {
		P.call(this);
		this.type = "Light";
		this.color = new S(f);
		this.intensity = void 0 !== a ? a : 1;
		this.receiveShadow = void 0
	}

	function oj(f, a, b) {
		Ba.call(this, f, b);
		this.type = "HemisphereLight";
		this.castShadow =
			void 0;
		this.position.copy(P.DefaultUp);
		this.updateMatrix();
		this.groundColor = new S(a)
	}

	function he(f) {
		this.camera = f;
		this.bias = 0;
		this.radius = 1;
		this.mapSize = new B(512, 512);
		this.mapPass = this.map = null;
		this.matrix = new ua;
		this._frustum = new Ui;
		this._frameExtents = new B(1, 1);
		this._viewportCount = 1;
		this._viewports = [new za(0, 0, 1, 1)]
	}

	function Rh() {
		he.call(this, new ab(50, 1, .5, 500))
	}

	function Sk(f, a, b, c, d, e) {
		Ba.call(this, f, a);
		this.type = "SpotLight";
		this.position.copy(P.DefaultUp);
		this.updateMatrix();
		this.target = new P;
		Object.defineProperty(this, "power", {
			get: function() {
				return this.intensity * Math.PI
			},
			set: function(a) {
				this.intensity = a / Math.PI
			}
		});
		this.distance = void 0 !== b ? b : 0;
		this.angle = void 0 !== c ? c : Math.PI / 3;
		this.penumbra = void 0 !== d ? d : 0;
		this.decay = void 0 !== e ? e : 1;
		this.shadow = new Rh
	}

	function Tk() {
		he.call(this, new ab(90, 1, .5, 500));
		this._frameExtents = new B(4, 2);
		this._viewportCount = 6;
		this._viewports = [new za(2, 1, 1, 1), new za(0, 1, 1, 1), new za(3, 1, 1, 1), new za(1, 1, 1, 1), new za(3, 0, 1, 1),
			new za(1, 0, 1, 1)
		];
		this._cubeDirections = [new u(1,
			0, 0), new u(-1, 0, 0), new u(0, 0, 1), new u(0, 0, -1), new u(0, 1, 0), new u(0, -1, 0)];
		this._cubeUps = [new u(0, 1, 0), new u(0, 1, 0), new u(0, 1, 0), new u(0, 1, 0), new u(0, 0, 1), new u(0, 0, -1)]
	}

	function Uk(f, a, b, c) {
		Ba.call(this, f, a);
		this.type = "PointLight";
		Object.defineProperty(this, "power", {
			get: function() {
				return 4 * this.intensity * Math.PI
			},
			set: function(a) {
				this.intensity = a / (4 * Math.PI)
			}
		});
		this.distance = void 0 !== b ? b : 0;
		this.decay = void 0 !== c ? c : 1;
		this.shadow = new Tk
	}

	function Lc(f, a, b, c, d, e) {
		Vd.call(this);
		this.type = "OrthographicCamera";
		this.zoom = 1;
		this.view = null;
		this.left = void 0 !== f ? f : -1;
		this.right = void 0 !== a ? a : 1;
		this.top = void 0 !== b ? b : 1;
		this.bottom = void 0 !== c ? c : -1;
		this.near = void 0 !== d ? d : .1;
		this.far = void 0 !== e ? e : 2E3;
		this.updateProjectionMatrix()
	}

	function Vk() {
		he.call(this, new Lc(-5, 5, 5, -5, .5, 500))
	}

	function Wk(f, a) {
		Ba.call(this, f, a);
		this.type = "DirectionalLight";
		this.position.copy(P.DefaultUp);
		this.updateMatrix();
		this.target = new P;
		this.shadow = new Vk
	}

	function Xk(f, a) {
		Ba.call(this, f, a);
		this.type = "AmbientLight";
		this.castShadow = void 0
	}

	function Yk(f, a, b, c) {
		Ba.call(this, f, a);
		this.type = "RectAreaLight";
		this.width = void 0 !== b ? b : 10;
		this.height = void 0 !== c ? c : 10
	}

	function Zk(f) {
		sa.call(this, f);
		this.textures = {}
	}

	function $k() {
		J.call(this);
		this.type = "InstancedBufferGeometry";
		this.maxInstancedCount = void 0
	}

	function al(f, a, b, c) {
		"number" === typeof b && (c = b, b = !1, console.error(
			"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));
		F.call(this, f, a, b);
		this.meshPerAttribute = c || 1
	}

	function bl(f) {
		sa.call(this, f)
	}

	function cl(f) {
		sa.call(this, f)
	}

	function qn(f) {
		"undefined" === typeof createImageBitmap && console.warn(
			"THREE.ImageBitmapLoader: createImageBitmap() not supported.");
		"undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
		sa.call(this, f);
		this.options = void 0
	}

	function rn() {
		this.type = "ShapePath";
		this.color = new S;
		this.subPaths = [];
		this.currentPath = null
	}

	function sn(f) {
		this.type = "Font";
		this.data = f
	}

	function tn(f) {
		sa.call(this, f)
	}

	function dl(f) {
		sa.call(this, f)
	}

	function el() {
		this.coefficients = [];
		for (var f = 0; 9 > f; f++) this.coefficients.push(new u)
	}

	function Bd(f, a) {
		Ba.call(this, void 0, a);
		this.sh = void 0 !== f ? f : new el
	}

	function un(f, a, b) {
		Bd.call(this, void 0, b);
		f = (new S).set(f);
		b = (new S).set(a);
		a = new u(f.r, f.g, f.b);
		f = new u(b.r, b.g, b.b);
		b = Math.sqrt(Math.PI);
		var c = b * Math.sqrt(.75);
		this.sh.coefficients[0].copy(a).add(f).multiplyScalar(b);
		this.sh.coefficients[1].copy(a).sub(f).multiplyScalar(c)
	}

	function vn(f, a) {
		Bd.call(this, void 0, a);
		f = (new S).set(f);
		this.sh.coefficients[0].set(f.r, f.g, f.b).multiplyScalar(2 *
			Math.sqrt(Math.PI))
	}

	function fl(f) {
		this.autoStart = void 0 !== f ? f : !0;
		this.elapsedTime = this.oldTime = this.startTime = 0;
		this.running = !1
	}

	function wn() {
		P.call(this);
		this.type = "AudioListener";
		this.context = xn.getContext();
		this.gain = this.context.createGain();
		this.gain.connect(this.context.destination);
		this.filter = null;
		this.timeDelta = 0;
		this._clock = new fl
	}

	function Tf(f) {
		P.call(this);
		this.type = "Audio";
		this.listener = f;
		this.context = f.context;
		this.gain = this.context.createGain();
		this.gain.connect(f.getInput());
		this.autoplay = !1;
		this.buffer = null;
		this.detune = 0;
		this.loop = !1;
		this.offset = this.startTime = 0;
		this.duration = void 0;
		this.playbackRate = 1;
		this.isPlaying = !1;
		this.hasPlaybackControl = !0;
		this.sourceType = "empty";
		this.filters = []
	}

	function yn(f) {
		Tf.call(this, f);
		this.panner = this.context.createPanner();
		this.panner.panningModel = "HRTF";
		this.panner.connect(this.gain)
	}

	function zn(f, a) {
		this.analyser = f.context.createAnalyser();
		this.analyser.fftSize = void 0 !== a ? a : 2048;
		this.data = new Uint8Array(this.analyser.frequencyBinCount);
		f.getOutput().connect(this.analyser)
	}

	function An(f, a, b) {
		this.binding = f;
		this.valueSize = b;
		f = Float64Array;
		switch (a) {
			case "quaternion":
				a = this._slerp;
				break;
			case "string":
			case "bool":
				f = Array;
				a = this._select;
				break;
			default:
				a = this._lerp
		}
		this.buffer = new f(4 * b);
		this._mixBufferRegion = a;
		this.referenceCount = this.useCount = this.cumulativeWeight = 0
	}

	function Bn(f, a, b) {
		b = b || xb.parseTrackName(a);
		this._targetGroup = f;
		this._bindings = f.subscribe_(a, b)
	}

	function xb(f, a, b) {
		this.path = a;
		this.parsedPath = b || xb.parseTrackName(a);
		this.node = xb.findNode(f, this.parsedPath.nodeName) ||
			f;
		this.rootNode = f
	}

	function Cn(f, a, b) {
		this._mixer = f;
		this._clip = a;
		this._localRoot = b || null;
		f = a.tracks;
		a = f.length;
		b = Array(a);
		for (var c = {
				endingStart: 2400,
				endingEnd: 2400
			}, d = 0; d !== a; ++d) {
			var e = f[d].createInterpolant(null);
			b[d] = e;
			e.settings = c
		}
		this._interpolantSettings = c;
		this._interpolants = b;
		this._propertyBindings = Array(a);
		this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null;
		this.loop = 2201;
		this._loopCount = -1;
		this._startTime = null;
		this.time = 0;
		this._effectiveWeight =
			this.weight = this._effectiveTimeScale = this.timeScale = 1;
		this.repetitions = Infinity;
		this.paused = !1;
		this.enabled = !0;
		this.clampWhenFinished = !1;
		this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
	}

	function Dn(f) {
		this._root = f;
		this._initMemoryManager();
		this.time = this._accuIndex = 0;
		this.timeScale = 1
	}

	function gl(f, a) {
		"string" === typeof f && (console.warn("THREE.Uniform: Type parameter is no longer needed."), f = a);
		this.value = f
	}

	function En(f, a, b) {
		gc.call(this, f, a);
		this.meshPerAttribute = b || 1
	}

	function Fn(f, a) {
		return f.distance -
			a.distance
	}

	function hl(f, a, b, c) {
		if (!1 !== f.visible && (f.raycast(a, b), !0 === c)) {
			f = f.children;
			c = 0;
			for (var d = f.length; c < d; c++) hl(f[c], a, b, !0)
		}
	}

	function Gn(f, a) {
		this.min = void 0 !== f ? f : new B(Infinity, Infinity);
		this.max = void 0 !== a ? a : new B(-Infinity, -Infinity)
	}

	function Hn(f, a) {
		this.start = void 0 !== f ? f : new u;
		this.end = void 0 !== a ? a : new u
	}

	function Rg(f) {
		P.call(this);
		this.material = f;
		this.render = function() {}
	}

	function Uf(f, a, b, c) {
		this.object = f;
		this.size = void 0 !== a ? a : 1;
		f = void 0 !== b ? b : 16711680;
		c = void 0 !== c ? c : 1;
		a = 0;
		(b =
			this.object.geometry) && b.isGeometry ? a = 3 * b.faces.length : b && b.isBufferGeometry && (a = b.attributes.normal
			.count);
		b = new J;
		a = new N(6 * a, 3);
		b.addAttribute("position", a);
		Ra.call(this, b, new Aa({
			color: f,
			linewidth: c
		}));
		this.matrixAutoUpdate = !1;
		this.update()
	}

	function Vf(f, a) {
		P.call(this);
		this.light = f;
		this.light.updateMatrixWorld();
		this.matrix = f.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.color = a;
		f = new J;
		a = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
		for (var b = 0, c = 1; 32 > b; b++, c++) {
			var d = b / 32 * Math.PI *
				2,
				e = c / 32 * Math.PI * 2;
			a.push(Math.cos(d), Math.sin(d), 1, Math.cos(e), Math.sin(e), 1)
		}
		f.addAttribute("position", new N(a, 3));
		a = new Aa({
			fog: !1
		});
		this.cone = new Ra(f, a);
		this.add(this.cone);
		this.update()
	}

	function In(f) {
		var a = [];
		f && f.isBone && a.push(f);
		for (var b = 0; b < f.children.length; b++) a.push.apply(a, In(f.children[b]));
		return a
	}

	function Sg(f) {
		for (var a = In(f), b = new J, c = [], d = [], e = new S(0, 0, 1), g = new S(0, 1, 0), k = 0; k < a.length; k++) {
			var l = a[k];
			l.parent && l.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), d.push(e.r, e.g, e.b),
				d.push(g.r, g.g, g.b))
		}
		b.addAttribute("position", new N(c, 3));
		b.addAttribute("color", new N(d, 3));
		c = new Aa({
			vertexColors: 2,
			depthTest: !1,
			depthWrite: !1,
			transparent: !0
		});
		Ra.call(this, b, c);
		this.root = f;
		this.bones = a;
		this.matrix = f.matrixWorld;
		this.matrixAutoUpdate = !1
	}

	function Wf(f, a, b) {
		this.light = f;
		this.light.updateMatrixWorld();
		this.color = b;
		f = new Fc(a, 4, 2);
		a = new Ob({
			wireframe: !0,
			fog: !1
		});
		Wa.call(this, f, a);
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.update()
	}

	function Xf(f, a) {
		this.type = "RectAreaLightHelper";
		this.light = f;
		this.color = a;
		f = new J;
		f.addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3));
		f.computeBoundingSphere();
		a = new Aa({
			fog: !1
		});
		Pa.call(this, f, a);
		f = new J;
		f.addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3));
		f.computeBoundingSphere();
		this.add(new Wa(f, new Ob({
			side: 1,
			fog: !1
		})));
		this.update()
	}

	function Yf(f, a, b) {
		P.call(this);
		this.light = f;
		this.light.updateMatrixWorld();
		this.matrix = f.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.color = b;
		f = new Ec(a);
		f.rotateY(.5 *
			Math.PI);
		this.material = new Ob({
			wireframe: !0,
			fog: !1
		});
		void 0 === this.color && (this.material.vertexColors = 2);
		a = f.getAttribute("position");
		a = new Float32Array(3 * a.count);
		f.addAttribute("color", new F(a, 3));
		this.add(new Wa(f, this.material));
		this.update()
	}

	function Zf(f, a) {
		this.lightProbe = f;
		this.size = a;
		f = new Ia({
			defines: {
				GAMMA_OUTPUT: ""
			},
			uniforms: {
				sh: {
					value: this.lightProbe.sh.coefficients
				},
				intensity: {
					value: this.lightProbe.intensity
				}
			},
			vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
		});
		a = new Fc(1, 32, 16);
		Wa.call(this, a, f);
		this.onBeforeRender()
	}

	function il(f, a, b, c) {
		f = f || 10;
		a = a || 10;
		b = new S(void 0 !== b ? b : 4473924);
		c = new S(void 0 !== c ? c : 8947848);
		var d = a / 2,
			e = f / a,
			g = f / 2;
		f = [];
		for (var k = [], l = 0, m = 0, n = -g; l <= a; l++, n += e) {
			f.push(-g, 0, n, g, 0, n);
			f.push(n, 0, -g, n, 0, g);
			var r = l === d ? b : c;
			r.toArray(k, m);
			m += 3;
			r.toArray(k, m);
			m += 3;
			r.toArray(k, m);
			m += 3;
			r.toArray(k, m);
			m += 3
		}
		a = new J;
		a.addAttribute("position", new N(f, 3));
		a.addAttribute("color", new N(k, 3));
		b = new Aa({
			vertexColors: 2
		});
		Ra.call(this, a, b)
	}

	function jl(f,
		a, b, c, d, e) {
		f = f || 10;
		a = a || 16;
		b = b || 8;
		c = c || 64;
		d = new S(void 0 !== d ? d : 4473924);
		e = new S(void 0 !== e ? e : 8947848);
		var g = [],
			k = [],
			l;
		for (l = 0; l <= a; l++) {
			var m = l / a * 2 * Math.PI;
			var n = Math.sin(m) * f;
			m = Math.cos(m) * f;
			g.push(0, 0, 0);
			g.push(n, 0, m);
			var r = l & 1 ? d : e;
			k.push(r.r, r.g, r.b);
			k.push(r.r, r.g, r.b)
		}
		for (l = 0; l <= b; l++) {
			r = l & 1 ? d : e;
			var v = f - f / b * l;
			for (a = 0; a < c; a++) m = a / c * 2 * Math.PI, n = Math.sin(m) * v, m = Math.cos(m) * v, g.push(n, 0, m), k.push(
				r.r, r.g, r.b), m = (a + 1) / c * 2 * Math.PI, n = Math.sin(m) * v, m = Math.cos(m) * v, g.push(n, 0, m), k.push(
				r.r, r.g, r.b)
		}
		f =
			new J;
		f.addAttribute("position", new N(g, 3));
		f.addAttribute("color", new N(k, 3));
		g = new Aa({
			vertexColors: 2
		});
		Ra.call(this, f, g)
	}

	function $f(f, a, b, c) {
		this.audio = f;
		this.range = a || 1;
		this.divisionsInnerAngle = b || 16;
		this.divisionsOuterAngle = c || 2;
		f = new J;
		a = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3));
		f.addAttribute("position", new F(a, 3));
		a = new Aa({
			color: 65280
		});
		b = new Aa({
			color: 16776960
		});
		Pa.call(this, f, [b, a]);
		this.update()
	}

	function Tg(f, a, b, c) {
		this.object = f;
		this.size = void 0 !==
			a ? a : 1;
		f = void 0 !== b ? b : 16776960;
		c = void 0 !== c ? c : 1;
		a = 0;
		(b = this.object.geometry) && b.isGeometry ? a = b.faces.length : console.warn(
			"THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
		b = new J;
		a = new N(6 * a, 3);
		b.addAttribute("position", a);
		Ra.call(this, b, new Aa({
			color: f,
			linewidth: c
		}));
		this.matrixAutoUpdate = !1;
		this.update()
	}

	function Ug(f, a, b) {
		P.call(this);
		this.light = f;
		this.light.updateMatrixWorld();
		this.matrix = f.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.color = b;
		void 0 ===
			a && (a = 1);
		f = new J;
		f.addAttribute("position", new N([-a, a, 0, a, a, 0, a, -a, 0, -a, -a, 0, -a, a, 0], 3));
		a = new Aa({
			fog: !1
		});
		this.lightPlane = new Pa(f, a);
		this.add(this.lightPlane);
		f = new J;
		f.addAttribute("position", new N([0, 0, 0, 0, 0, 1], 3));
		this.targetLine = new Pa(f, a);
		this.add(this.targetLine);
		this.update()
	}

	function Sh(f) {
		function a(a, c, d) {
			b(a, d);
			b(c, d)
		}

		function b(a, b) {
			e.push(0, 0, 0);
			g.push(b.r, b.g, b.b);
			void 0 === k[a] && (k[a] = []);
			k[a].push(e.length / 3 - 1)
		}
		var c = new J,
			d = new Aa({
				color: 16777215,
				vertexColors: 1
			}),
			e = [],
			g = [],
			k = {},
			l = new S(16755200),
			m = new S(16711680),
			n = new S(43775),
			r = new S(16777215),
			v = new S(3355443);
		a("n1", "n2", l);
		a("n2", "n4", l);
		a("n4", "n3", l);
		a("n3", "n1", l);
		a("f1", "f2", l);
		a("f2", "f4", l);
		a("f4", "f3", l);
		a("f3", "f1", l);
		a("n1", "f1", l);
		a("n2", "f2", l);
		a("n3", "f3", l);
		a("n4", "f4", l);
		a("p", "n1", m);
		a("p", "n2", m);
		a("p", "n3", m);
		a("p", "n4", m);
		a("u1", "u2", n);
		a("u2", "u3", n);
		a("u3", "u1", n);
		a("c", "t", r);
		a("p", "c", v);
		a("cn1", "cn2", v);
		a("cn3", "cn4", v);
		a("cf1", "cf2", v);
		a("cf3", "cf4", v);
		c.addAttribute("position", new N(e, 3));
		c.addAttribute("color", new N(g, 3));
		Ra.call(this, c, d);
		this.camera = f;
		this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
		this.matrix = f.matrixWorld;
		this.matrixAutoUpdate = !1;
		this.pointMap = k;
		this.update()
	}

	function Da(f, a, b, c, d, e, g) {
		Vg.set(d, e, g).unproject(c);
		f = a[f];
		if (void 0 !== f)
			for (b = b.getAttribute("position"), a = 0, c = f.length; a < c; a++) b.setXYZ(f[a], Vg.x, Vg.y, Vg.z)
	}

	function Mc(f, a) {
		this.object = f;
		void 0 === a && (a = 16776960);
		f = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
			3, 7
		]);
		var b = new Float32Array(24),
			c = new J;
		c.setIndex(new F(f, 1));
		c.addAttribute("position", new F(b, 3));
		Ra.call(this, c, new Aa({
			color: a
		}));
		this.matrixAutoUpdate = !1;
		this.update()
	}

	function Th(f, a) {
		this.type = "Box3Helper";
		this.box = f;
		a = a || 16776960;
		f = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
		var b = new J;
		b.setIndex(new F(f, 1));
		b.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
			3));
		Ra.call(this, b, new Aa({
			color: a
		}));
		this.geometry.computeBoundingSphere()
	}

	function Uh(f, a, b) {
		this.type = "PlaneHelper";
		this.plane = f;
		this.size = void 0 === a ? 1 : a;
		f = void 0 !== b ? b : 16776960;
		a = new J;
		a.addAttribute("position", new N([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0,
			0, 1, 0, 0, 0
		], 3));
		a.computeBoundingSphere();
		Pa.call(this, a, new Aa({
			color: f
		}));
		a = new J;
		a.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
		a.computeBoundingSphere();
		this.add(new Wa(a, new Ob({
			color: f,
			opacity: .2,
			transparent: !0,
			depthWrite: !1
		})))
	}

	function Cd(f, a, b, c, d, e) {
		P.call(this);
		void 0 === f && (f = new u(0, 0, 1));
		void 0 === a && (a = new u(0, 0, 0));
		void 0 === b && (b = 1);
		void 0 === c && (c = 16776960);
		void 0 === d && (d = .2 * b);
		void 0 === e && (e = .2 * d);
		void 0 === Vh && (Vh = new J, Vh.addAttribute("position", new N([0, 0, 0, 0, 1, 0], 3)), kl = new ic(0, .5, 1, 5, 1),
			kl.translate(0, -.5, 0));
		this.position.copy(a);
		this.line = new Pa(Vh, new Aa({
			color: c
		}));
		this.line.matrixAutoUpdate = !1;
		this.add(this.line);
		this.cone = new Wa(kl, new Ob({
			color: c
		}));
		this.cone.matrixAutoUpdate = !1;
		this.add(this.cone);
		this.setDirection(f);
		this.setLength(b, d,
			e)
	}

	function ll(f) {
		f = f || 1;
		var a = [0, 0, 0, f, 0, 0, 0, 0, 0, 0, f, 0, 0, 0, 0, 0, 0, f];
		f = new J;
		f.addAttribute("position", new N(a, 3));
		f.addAttribute("color", new N([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
		a = new Aa({
			vertexColors: 2
		});
		Ra.call(this, f, a)
	}

	function Jn(f) {
		console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
		wb.call(this, f);
		this.type = "catmullrom"
	}

	function db() {
		this.needsSwap = this.enabled = !0;
		this.renderToScreen = this.clear = !1
	}
	var Kn = "undefined" !== typeof globalThis ? globalThis : "undefined" !==
		typeof window ? window : "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : {},
		Xq = Math.ceil,
		Yq = Math.floor,
		ml = function(f) {
			return isNaN(f = +f) ? 0 : (0 < f ? Yq : Xq)(f)
		},
		ie = function(f) {
			if (void 0 == f) throw TypeError("Can't call method on  " + f);
			return f
		},
		eb = ta(function(f) {
			f = f.exports = "undefined" != typeof window && Math == Math ? window : "undefined" != typeof self && self.Math ==
				Math ? self : Function("return this")();
			"number" == typeof __g && (__g = f)
		}),
		va = ta(function(f) {
			f = f.exports = {
				version: "2.6.5"
			};
			"number" == typeof __e &&
				(__e = f)
		}),
		nl = function(f) {
			if ("function" != typeof f) throw TypeError(f + " is not a function!");
			return f
		},
		Nc = function(f, a, b) {
			nl(f);
			if (void 0 === a) return f;
			switch (b) {
				case 1:
					return function(b) {
						return f.call(a, b)
					};
				case 2:
					return function(b, d) {
						return f.call(a, b, d)
					};
				case 3:
					return function(b, d, e) {
						return f.call(a, b, d, e)
					}
			}
			return function() {
				return f.apply(a, arguments)
			}
		},
		hb = function(f) {
			return "object" === typeof f ? null !== f : "function" === typeof f
		},
		Vb = function(f) {
			if (!hb(f)) throw TypeError(f + " is not an object!");
			return f
		},
		Dd = function(f) {
			try {
				return !!f()
			} catch (a) {
				return !0
			}
		},
		Hb = !Dd(function() {
			return 7 != Object.defineProperty({}, "a", {
				get: function() {
					return 7
				}
			}).a
		}),
		Wg = eb.document,
		Ln = hb(Wg) && hb(Wg.createElement),
		Mn = !Hb && !Dd(function() {
			return 7 != Object.defineProperty(Ln ? Wg.createElement("div") : {}, "a", {
				get: function() {
					return 7
				}
			}).a
		}),
		Xg = function(f, a) {
			if (!hb(f)) return f;
			var b, c;
			if (a && "function" == typeof(b = f.toString) && !hb(c = b.call(f)) || "function" == typeof(b = f.valueOf) && !hb(c =
					b.call(f)) || !a && "function" == typeof(b = f.toString) && !hb(c =
					b.call(f))) return c;
			throw TypeError("Can't convert object to primitive value");
		},
		Zq = Object.defineProperty,
		Oc = {
			f: Hb ? Object.defineProperty : function(f, a, b) {
				Vb(f);
				a = Xg(a, !0);
				Vb(b);
				if (Mn) try {
					return Zq(f, a, b)
				} catch (c) {}
				if ("get" in b || "set" in b) throw TypeError("Accessors not supported!");
				"value" in b && (f[a] = b.value);
				return f
			}
		},
		Pc = function(f, a) {
			return {
				enumerable: !(f & 1),
				configurable: !(f & 2),
				writable: !(f & 4),
				value: a
			}
		},
		Qc = Hb ? function(f, a, b) {
			return Oc.f(f, a, Pc(1, b))
		} : function(f, a, b) {
			f[a] = b;
			return f
		},
		$q = {}.hasOwnProperty,
		ba = function(f, a) {
			return $q.call(f, a)
		},
		qb = function(f, a, b) {
			var c = f & qb.F,
				d = f & qb.G,
				e = f & qb.S,
				g = f & qb.P,
				k = f & qb.B,
				l = f & qb.W,
				m = d ? va : va[a] || (va[a] = {}),
				n = m.prototype;
			e = d ? eb : e ? eb[a] : (eb[a] || {}).prototype;
			var r;
			d && (b = a);
			for (r in b)
				if (a = !c && e && void 0 !== e[r], !a || !ba(m, r)) {
					var v = a ? e[r] : b[r];
					m[r] = d && "function" != typeof e[r] ? b[r] : k && a ? Nc(v, eb) : l && e[r] == v ? function(a) {
						var b = function(b, c, d) {
							if (this instanceof a) {
								switch (arguments.length) {
									case 0:
										return new a;
									case 1:
										return new a(b);
									case 2:
										return new a(b, c)
								}
								return new a(b,
									c, d)
							}
							return a.apply(this, arguments)
						};
						b.prototype = a.prototype;
						return b
					}(v) : g && "function" == typeof v ? Nc(Function.call, v) : v;
					g && ((m.virtual || (m.virtual = {}))[r] = v, f & qb.R && n && !n[r] && Qc(n, r, v))
				}
		};
	qb.F = 1;
	qb.G = 2;
	qb.S = 4;
	qb.P = 8;
	qb.B = 16;
	qb.W = 32;
	qb.U = 64;
	qb.R = 128;
	var W = qb,
		Rc = {},
		ar = {}.toString,
		Yg = function(f) {
			return ar.call(f).slice(8, -1)
		},
		ol = Object("z").propertyIsEnumerable(0) ? Object : function(f) {
			return "String" == Yg(f) ? f.split("") : Object(f)
		},
		mc = function(f) {
			return ol(ie(f))
		},
		br = Math.min,
		Zg = function(f) {
			return 0 < f ? br(ml(f),
				9007199254740991) : 0
		},
		cr = Math.max,
		dr = Math.min,
		ag = ta(function(f) {
			var a = eb["__core-js_shared__"] || (eb["__core-js_shared__"] = {});
			(f.exports = function(b, c) {
				return a[b] || (a[b] = void 0 !== c ? c : {})
			})("versions", []).push({
				version: va.version,
				mode: "pure",
				copyright: "\u00a9 2019 Denis Pushkarev (zloirock.ru)"
			})
		}),
		er = 0,
		fr = Math.random(),
		$g = function(f) {
			return "Symbol(".concat(void 0 === f ? "" : f, ")_", (++er + fr).toString(36))
		},
		Nn = ag("keys"),
		pl = function(f) {
			return Nn[f] || (Nn[f] = $g(f))
		},
		gr = function(f) {
			return function(a, b, c) {
				a =
					mc(a);
				var d = Zg(a.length);
				c = ml(c);
				c = 0 > c ? cr(c + d, 0) : dr(c, d);
				if (f && b != b)
					for (; d > c;) {
						if (b = a[c++], b != b) return !0
					} else
						for (; d > c; c++)
							if ((f || c in a) && a[c] === b) return f || c || 0;
				return !f && -1
			}
		}(!1),
		hr = pl("IE_PROTO"),
		On = function(f, a) {
			f = mc(f);
			var b = 0,
				c = [],
				d;
			for (d in f) d != hr && ba(f, d) && c.push(d);
			for (; a.length > b;) ba(f, d = a[b++]) && (~gr(c, d) || c.push(d));
			return c
		},
		bg = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "),
		Ed = Object.keys || function(f) {
			return On(f, bg)
		},
		Pn = Hb ?
		Object.defineProperties : function(f, a) {
			Vb(f);
			for (var b = Ed(a), c = b.length, d = 0, e; c > d;) Oc.f(f, e = b[d++], a[e]);
			return f
		},
		Qn = eb.document,
		ir = Qn && Qn.documentElement,
		jr = pl("IE_PROTO"),
		ql = function() {},
		pj = function() {
			var f = Ln ? Wg.createElement("iframe") : {},
				a = bg.length;
			f.style.display = "none";
			ir.appendChild(f);
			f.src = "javascript:";
			f = f.contentWindow.document;
			f.open();
			f.write("<script>document.F=Object\x3c/script>");
			f.close();
			for (pj = f.F; a--;) delete pj.prototype[bg[a]];
			return pj()
		},
		nc = Object.create || function(f, a) {
			if (null !==
				f) {
				ql.prototype = Vb(f);
				var b = new ql;
				ql.prototype = null;
				b[jr] = f
			} else b = pj();
			return void 0 === a ? b : Pn(b, a)
		},
		rb = ta(function(f) {
			var a = ag("wks"),
				b = eb.Symbol,
				c = "function" == typeof b;
			(f.exports = function(d) {
				return a[d] || (a[d] = c && b[d] || (c ? b : $g)("Symbol." + d))
			}).store = a
		}),
		kr = Oc.f,
		Rn = rb("toStringTag"),
		Sc = function(f, a, b) {
			f && !ba(f = b ? f : f.prototype, Rn) && kr(f, Rn, {
				configurable: !0,
				value: a
			})
		},
		Sn = {};
	Qc(Sn, rb("iterator"), function() {
		return this
	});
	var lr = function(f, a, b) {
			f.prototype = nc(Sn, {
				next: Pc(1, b)
			});
			Sc(f, a + " Iterator")
		},
		Tn = pl("IE_PROTO"),
		mr = Object.prototype,
		Un = Object.getPrototypeOf || function(f) {
			f = Object(ie(f));
			return ba(f, Tn) ? f[Tn] : "function" == typeof f.constructor && f instanceof f.constructor ? f.constructor.prototype :
				f instanceof Object ? mr : null
		},
		rl = rb("iterator"),
		sl = !([].keys && "next" in [].keys()),
		nr = function() {
			return this
		},
		Vn = function(f, a, b, c, d, e, g) {
			lr(b, a, c);
			c = function(a) {
				return !sl && a in n ? n[a] : function() {
					return new b(this, a)
				}
			};
			var k = a + " Iterator",
				l = "values" == d,
				m = !1,
				n = f.prototype,
				r = n[rl] || n["@@iterator"] || d && n[d],
				v = r || c(d),
				p = d ? l ? c("entries") : v : void 0,
				q = "Array" == a ? n.entries || r : r,
				z;
			q && (f = Un(q.call(new f)), f !== Object.prototype && f.next && Sc(f, k, !0));
			l && r && "values" !== r.name && (m = !0, v = function() {
				return r.call(this)
			});
			g && (sl || m || !n[rl]) && Qc(n, rl, v);
			Rc[a] = v;
			Rc[k] = nr;
			if (d) {
				var u = {
					values: l ? v : c("values"),
					keys: e ? v : c("keys"),
					entries: p
				};
				if (g)
					for (z in u) z in n || Qc(n, z, u[z]);
				else W(W.P + W.F * (sl || m), a, u)
			}
			return u
		},
		or = function(f) {
			return function(a, b) {
				a = String(ie(a));
				b = ml(b);
				var c = a.length,
					d;
				if (0 > b || b >= c) return f ? "" : void 0;
				var e =
					a.charCodeAt(b);
				return 55296 > e || 56319 < e || b + 1 === c || 56320 > (d = a.charCodeAt(b + 1)) || 57343 < d ? f ? a.charAt(b) :
					e : f ? a.slice(b, b + 2) : (e - 55296 << 10) + (d - 56320) + 65536
			}
		}(!0);
	Vn(String, "String", function(f) {
		this._t = String(f);
		this._i = 0
	}, function() {
		var f = this._t,
			a = this._i;
		if (a >= f.length) return {
			value: void 0,
			done: !0
		};
		f = or(f, a);
		this._i += f.length;
		return {
			value: f,
			done: !1
		}
	});
	var Wn = function(f, a, b, c) {
			try {
				return c ? a(Vb(b)[0], b[1]) : a(b)
			} catch (d) {
				throw a = f["return"], void 0 !== a && Vb(a.call(f)), d;
			}
		},
		Xn = rb("iterator"),
		Yn = Array.prototype,
		pr = rb("toStringTag"),
		qr = "Arguments" == Yg(function() {
			return arguments
		}()),
		Zn = function(f) {
			var a;
			if (void 0 === f) var b = "Undefined";
			else {
				if (null === f) var c = "Null";
				else {
					a: {
						var d = f = Object(f);
						try {
							c = d[pr];
							break a
						} catch (e) {}
						c = void 0
					}
					c = "string" == typeof(b = c) ? b : qr ? Yg(f) : "Object" == (a = Yg(f)) && "function" == typeof f.callee ?
						"Arguments" : a
				}
				b = c
			}
			return b
		},
		rr = rb("iterator"),
		tl = va.getIteratorMethod = function(f) {
			if (void 0 != f) return f[rr] || f["@@iterator"] || Rc[Zn(f)]
		},
		ul = rb("iterator"),
		$n = !1;
	try {
		[7][ul]()["return"] = function() {
			$n = !0
		}
	} catch (f) {}
	W(W.S + W.F * ! function(f, a) {
		if (!a && !$n) return !1;
		var b = !1;
		try {
			a = [7];
			var c = a[ul]();
			c.next = function() {
				return {
					done: b = !0
				}
			};
			a[ul] = function() {
				return c
			};
			f(a)
		} catch (d) {}
		return b
	}(function(f) {}), "Array", {
		from: function(f) {
			var a = Object(ie(f)),
				b = "function" == typeof this ? this : Array,
				c = arguments.length,
				d = 1 < c ? arguments[1] : void 0,
				e = void 0 !== d,
				g = 0,
				k = tl(a),
				l;
			e && (d = Nc(d, 2 < c ? arguments[2] : void 0, 2));
			if (void 0 != k && (b != Array || void 0 === k || Rc.Array !== k && Yn[Xn] !== k))
				for (a = k.call(a), b = new b; !(l = a.next()).done; g++) c =
					b, k = g, l = e ? Wn(a, d, [l.value, g], !0) : l.value, k in c ? Oc.f(c, k, Pc(0, l)) : c[k] = l;
			else
				for (c = Zg(a.length), b = new b(c); c > g; g++) {
					k = b;
					l = g;
					var m = e ? d(a[g], g) : a[g];
					l in k ? Oc.f(k, l, Pc(0, m)) : k[l] = m
				}
			b.length = g;
			return b
		}
	});
	var sr = va.Array.from,
		jf = ta(function(f) {
			f.exports = {
				"default": sr,
				__esModule: !0
			}
		}),
		Ck = fa(jf),
		cg = ta(function(f) {
			var a = $g("meta"),
				b = Oc.f,
				c = 0,
				d = Object.isExtensible || function() {
					return !0
				},
				e = !Dd(function() {
					return d(Object.preventExtensions({}))
				}),
				g = function(d) {
					b(d, a, {
						value: {
							i: "O" + ++c,
							w: {}
						}
					})
				},
				k = f.exports = {
					KEY: a,
					NEED: !1,
					fastKey: function(b, c) {
						if (!hb(b)) return "symbol" == typeof b ? b : ("string" == typeof b ? "S" : "P") + b;
						if (!ba(b, a)) {
							if (!d(b)) return "F";
							if (!c) return "E";
							g(b)
						}
						return b[a].i
					},
					getWeak: function(b, c) {
						if (!ba(b, a)) {
							if (!d(b)) return !0;
							if (!c) return !1;
							g(b)
						}
						return b[a].w
					},
					onFreeze: function(b) {
						e && k.NEED && d(b) && !ba(b, a) && g(b);
						return b
					}
				}
		}),
		ah = function(f, a) {
			var b = (va.Object || {})[f] || Object[f],
				c = {};
			c[f] = a(b);
			W(W.S + W.F * Dd(function() {
				b(1)
			}), "Object", c)
		},
		tr = cg.onFreeze;
	ah("freeze", function(f) {
		return function(a) {
			return f &&
				hb(a) ? f(tr(a)) : a
		}
	});
	var ur = va.Object.freeze,
		vr = ta(function(f) {
			f.exports = {
				"default": ur,
				__esModule: !0
			}
		}),
		Ag = fa(vr),
		dg = function(f, a) {
			return {
				value: a,
				done: !!f
			}
		};
	Vn(Array, "Array", function(f, a) {
		this._t = mc(f);
		this._i = 0;
		this._k = a
	}, function() {
		var f = this._t,
			a = this._k,
			b = this._i++;
		return !f || b >= f.length ? (this._t = void 0, dg(1)) : "keys" == a ? dg(0, b) : "values" == a ? dg(0, f[b]) : dg(
			0, [b, f[b]])
	}, "values");
	Rc.Arguments = Rc.Array;
	for (var ao = rb("toStringTag"), bo =
			"CSSRuleList CSSStyleDeclaration CSSValueList ClientRectList DOMRectList DOMStringList DOMTokenList DataTransferItemList FileList HTMLAllCollection HTMLCollection HTMLFormElement HTMLSelectElement MediaList MimeTypeArray NamedNodeMap NodeList PaintRequestList Plugin PluginArray SVGLengthList SVGNumberList SVGPathSegList SVGPointList SVGStringList SVGTransformList SourceBufferList StyleSheetList TextTrackCueList TextTrackList TouchList"
			.split(" "),
			vl = 0; vl < bo.length; vl++) {
		var wl = bo[vl],
			co = eb[wl],
			xl = co && co.prototype;
		xl && !xl[ao] && Qc(xl, ao, wl);
		Rc[wl] = Rc.Array
	}
	var yl = {
			f: rb
		},
		wr = yl.f("iterator"),
		eg = ta(function(f) {
			f.exports = {
				"default": wr,
				__esModule: !0
			}
		});
	fa(eg);
	var xr = Oc.f,
		zl = function(f) {
			var a = va.Symbol || (va.Symbol = {});
			"_" == f.charAt(0) || f in a || xr(a, f, {
				value: yl.f(f)
			})
		},
		Al = Object.getOwnPropertySymbols,
		bh = {}.propertyIsEnumerable,
		Bl = Array.isArray || function(f) {
			return "Array" == Yg(f)
		},
		yr = bg.concat("length", "prototype"),
		eo = Object.getOwnPropertyNames || function(f) {
			return On(f,
				yr)
		},
		fo = eo,
		zr = {}.toString,
		go = "object" == typeof window && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [],
		ho = function(f) {
			if (go && "[object Window]" == zr.call(f)) try {
				var a = fo(f)
			} catch (b) {
				a = go.slice()
			} else a = fo(mc(f));
			return a
		},
		io = Object.getOwnPropertyDescriptor,
		qj = {
			f: Hb ? io : function(f, a) {
				f = mc(f);
				a = Xg(a, !0);
				if (Mn) try {
					return io(f, a)
				} catch (b) {}
				if (ba(f, a)) return Pc(!bh.call(f, a), f[a])
			}
		},
		Ar = cg.KEY,
		jo = qj.f,
		Tc = Oc.f,
		ko = ho,
		Ib = eb.Symbol,
		ch = eb.JSON,
		rj = ch && ch.stringify,
		Jb = rb("_hidden"),
		lo = rb("toPrimitive"),
		Br = {}.propertyIsEnumerable,
		dh = ag("symbol-registry"),
		je = ag("symbols"),
		eh = ag("op-symbols"),
		Uc = Object.prototype,
		Vc = "function" == typeof Ib,
		Cl = eb.QObject,
		Dl = !Cl || !Cl.prototype || !Cl.prototype.findChild,
		El = Hb && Dd(function() {
			return 7 != nc(Tc({}, "a", {
				get: function() {
					return Tc(this, "a", {
						value: 7
					}).a
				}
			})).a
		}) ? function(f, a, b) {
			var c = jo(Uc, a);
			c && delete Uc[a];
			Tc(f, a, b);
			c && f !== Uc && Tc(Uc, a, c)
		} : Tc,
		mo = function(f) {
			var a = je[f] = nc(Ib.prototype);
			a._k = f;
			return a
		},
		Fl = Vc && "symbol" == typeof Ib.iterator ? function(f) {
			return "symbol" ==
				typeof f
		} : function(f) {
			return f instanceof Ib
		},
		sj = function(f, a, b) {
			f === Uc && sj(eh, a, b);
			Vb(f);
			a = Xg(a, !0);
			Vb(b);
			return ba(je, a) ? (b.enumerable ? (ba(f, Jb) && f[Jb][a] && (f[Jb][a] = !1), b = nc(b, {
				enumerable: Pc(0, !1)
			})) : (ba(f, Jb) || Tc(f, Jb, Pc(1, {})), f[Jb][a] = !0), El(f, a, b)) : Tc(f, a, b)
		},
		no = function(f, a) {
			Vb(f);
			var b = a = mc(a),
				c = Ed(b),
				d = Al;
			if (d) {
				d = d(b);
				for (var e = bh, g = 0, k; d.length > g;) e.call(b, k = d[g++]) && c.push(k)
			}
			b = 0;
			k = c.length;
			for (var l; k > b;) sj(f, l = c[b++], a[l]);
			return f
		},
		Cr = function(f) {
			var a = Br.call(this, f = Xg(f, !0));
			return this ===
				Uc && ba(je, f) && !ba(eh, f) ? !1 : a || !ba(this, f) || !ba(je, f) || ba(this, Jb) && this[Jb][f] ? a : !0
		},
		oo = function(f, a) {
			f = mc(f);
			a = Xg(a, !0);
			if (f !== Uc || !ba(je, a) || ba(eh, a)) {
				var b = jo(f, a);
				!b || !ba(je, a) || ba(f, Jb) && f[Jb][a] || (b.enumerable = !0);
				return b
			}
		},
		po = function(f) {
			f = ko(mc(f));
			for (var a = [], b = 0, c; f.length > b;) ba(je, c = f[b++]) || c == Jb || c == Ar || a.push(c);
			return a
		},
		qo = function(f) {
			var a = f === Uc;
			f = ko(a ? eh : mc(f));
			for (var b = [], c = 0, d; f.length > c;) ba(je, d = f[c++]) && (a ? ba(Uc, d) : 1) && b.push(je[d]);
			return b
		};
	Vc || (Ib = function() {
		if (this instanceof Ib) throw TypeError("Symbol is not a constructor!");
		var f = $g(0 < arguments.length ? arguments[0] : void 0),
			a = function(b) {
				this === Uc && a.call(eh, b);
				ba(this, Jb) && ba(this[Jb], f) && (this[Jb][f] = !1);
				El(this, f, Pc(1, b))
			};
		Hb && Dl && El(Uc, f, {
			configurable: !0,
			set: a
		});
		return mo(f)
	}, Qc(Ib.prototype, "toString", function() {
		return this._k
	}), qj.f = oo, Oc.f = sj, eo = ho = po, bh = Cr, Al = qo, yl.f = function(f) {
		return mo(rb(f))
	});
	W(W.G + W.W + W.F * !Vc, {
		Symbol: Ib
	});
	for (var ro =
			"hasInstance isConcatSpreadable iterator match replace search species split toPrimitive toStringTag unscopables".split(
				" "),
			so = 0; ro.length > so;) rb(ro[so++]);
	for (var to = Ed(rb.store), uo = 0; to.length > uo;) zl(to[uo++]);
	W(W.S + W.F * !Vc, "Symbol", {
		"for": function(f) {
			return ba(dh, f += "") ? dh[f] : dh[f] = Ib(f)
		},
		keyFor: function(f) {
			if (!Fl(f)) throw TypeError(f + " is not a symbol!");
			for (var a in dh)
				if (dh[a] === f) return a
		},
		useSetter: function() {
			Dl = !0
		},
		useSimple: function() {
			Dl = !1
		}
	});
	W(W.S + W.F * !Vc, "Object", {
		create: function(f, a) {
			return void 0 === a ? nc(f) : no(nc(f), a)
		},
		defineProperty: sj,
		defineProperties: no,
		getOwnPropertyDescriptor: oo,
		getOwnPropertyNames: po,
		getOwnPropertySymbols: qo
	});
	ch && W(W.S + W.F * (!Vc || Dd(function() {
		var f = Ib();
		return "[null]" != rj([f]) || "{}" != rj({
			a: f
		}) || "{}" != rj(Object(f))
	})), "JSON", {
		stringify: function(f) {
			for (var a = [f], b = 1, c; arguments.length > b;) a.push(arguments[b++]);
			c = b = a[1];
			if ((hb(b) || void 0 !== f) && !Fl(f)) return Bl(b) || (b = function(a, b) {
				"function" == typeof c && (b = c.call(this, a, b));
				if (!Fl(b)) return b
			}), a[1] = b, rj.apply(ch, a)
		}
	});
	Ib.prototype[lo] || Qc(Ib.prototype, lo, Ib.prototype.valueOf);
	Sc(Ib, "Symbol");
	Sc(Math, "Math", !0);
	Sc(eb.JSON, "JSON",
		!0);
	zl("asyncIterator");
	zl("observable");
	var Dr = va.Symbol,
		fg = ta(function(f) {
			f.exports = {
				"default": Dr,
				__esModule: !0
			}
		});
	fa(fg);
	var Fd = ta(function(f, a) {
			a.__esModule = !0;
			f = eg && eg.__esModule ? eg : {
				default: eg
			};
			var b = fg && fg.__esModule ? fg : {
					default: fg
				},
				c = "function" === typeof b.default && "symbol" === typeof f.default ? function(a) {
					return typeof a
				} : function(a) {
					return a && "function" === typeof b.default && a.constructor === b.default && a !== b.default.prototype ?
						"symbol" : typeof a
				};
			a.default = "function" === typeof b.default && "symbol" ===
				c(f.default) ? function(a) {
					return "undefined" === typeof a ? "undefined" : c(a)
				} : function(a) {
					return a && "function" === typeof b.default && a.constructor === b.default && a !== b.default.prototype ?
						"symbol" : "undefined" === typeof a ? "undefined" : c(a)
				}
		}),
		Ni = fa(Fd),
		Er = rb("species"),
		Fr = function(f, a) {
			if (Bl(f)) {
				var b = f.constructor;
				"function" != typeof b || b !== Array && !Bl(b.prototype) || (b = void 0);
				hb(b) && (b = b[Er], null === b && (b = void 0))
			}
			return new(void 0 === b ? Array : b)(a)
		},
		gg = function(f, a) {
			var b = 1 == f,
				c = 2 == f,
				d = 3 == f,
				e = 4 == f,
				g = 6 == f,
				k = 5 == f ||
				g,
				l = a || Fr;
			return function(a, n, r) {
				var m = Object(ie(a)),
					p = ol(m);
				n = Nc(n, r, 3);
				r = Zg(p.length);
				var q = 0;
				a = b ? l(a, r) : c ? l(a, 0) : void 0;
				for (var z, u; r > q; q++)
					if (k || q in p)
						if (z = p[q], u = n(z, q, m), f)
							if (b) a[q] = u;
							else if (u) switch (f) {
					case 3:
						return !0;
					case 5:
						return z;
					case 6:
						return q;
					case 2:
						a.push(z)
				} else if (e) return !1;
				return g ? -1 : d || e ? e : a
			}
		},
		Wh = Object.assign,
		vo = !Wh || Dd(function() {
			var f = {},
				a = {},
				b = Symbol();
			f[b] = 7;
			"abcdefghijklmnopqrst".split("").forEach(function(b) {
				a[b] = b
			});
			return 7 != Wh({}, f)[b] || "abcdefghijklmnopqrst" != Object.keys(Wh({},
				a)).join("")
		}) ? function(f, a) {
			for (var b = Object(ie(f)), c = arguments.length, d = 1, e = Al, g = bh; c > d;)
				for (var k = ol(arguments[d++]), l = e ? Ed(k).concat(e(k)) : Ed(k), m = l.length, n = 0, r; m > n;) g.call(k, r =
					l[n++]) && (b[r] = k[r]);
			return b
		} : Wh,
		wo = function(f, a, b) {
			for (var c in a) b && f[c] ? f[c] = a[c] : Qc(f, c, a[c]);
			return f
		},
		Gl = function(f, a, b, c) {
			if (!(f instanceof a) || void 0 !== c && c in f) throw TypeError(b + ": incorrect invocation!");
			return f
		},
		tj = ta(function(f) {
			var a = {},
				b = {};
			f = f.exports = function(c, d, e, f, k) {
				k = k ? function() {
					return c
				} : tl(c);
				e = Nc(e, f, d ? 2 : 1);
				f = 0;
				var g, m;
				if ("function" != typeof k) throw TypeError(c + " is not iterable!");
				if (void 0 === k || Rc.Array !== k && Yn[Xn] !== k)
					for (f = k.call(c); !(m = f.next()).done;) {
						if (k = Wn(f, e, m.value, d), k === a || k === b) return k
					} else
						for (g = Zg(c.length); g > f; f++)
							if (k = d ? e(Vb(m = c[f])[0], m[1]) : e(c[f]), k === a || k === b) return k
			};
			f.BREAK = a;
			f.RETURN = b
		}),
		fh = function(f, a) {
			if (!hb(f) || f._t !== a) throw TypeError("Incompatible receiver, " + a + " required!");
			return f
		},
		Hl = cg.getWeak,
		Gr = gg(5),
		Hr = gg(6),
		Ir = 0,
		uj = function(f) {
			return f._l || (f._l =
				new xo)
		},
		xo = function() {
			this.a = []
		},
		Il = function(f, a) {
			return Gr(f.a, function(b) {
				return b[0] === a
			})
		};
	xo.prototype = {
		get: function(f) {
			if (f = Il(this, f)) return f[1]
		},
		has: function(f) {
			return !!Il(this, f)
		},
		set: function(f, a) {
			var b = Il(this, f);
			b ? b[1] = a : this.a.push([f, a])
		},
		"delete": function(f) {
			var a = Hr(this.a, function(a) {
				return a[0] === f
			});
			~a && this.a.splice(a, 1);
			return !!~a
		}
	};
	var Xh = {
			getConstructor: function(f, a, b, c) {
				var d = f(function(e, f) {
					Gl(e, d, a, "_i");
					e._t = a;
					e._i = Ir++;
					e._l = void 0;
					void 0 != f && tj(f, b, e[c], e)
				});
				wo(d.prototype, {
					"delete": function(b) {
						if (!hb(b)) return !1;
						var c = Hl(b);
						return !0 === c ? uj(fh(this, a))["delete"](b) : c && ba(c, this._i) && delete c[this._i]
					},
					has: function(b) {
						if (!hb(b)) return !1;
						var c = Hl(b);
						return !0 === c ? uj(fh(this, a)).has(b) : c && ba(c, this._i)
					}
				});
				return d
			},
			def: function(f, a, b) {
				var c = Hl(Vb(a), !0);
				!0 === c ? uj(f).set(a, b) : c[f._i] = b;
				return f
			},
			ufstore: uj
		},
		Jr = Oc.f,
		Kr = gg(0),
		Lr = function(f, a, b, c, d, e) {
			var g = eb[f],
				k = g,
				l = d ? "set" : "add",
				m = k && k.prototype,
				n = {};
			Hb && "function" == typeof k && (e || m.forEach && !Dd(function() {
					(new k).entries().next()
				})) ?
				(k = a(function(a, b) {
					Gl(a, k, f, "_c");
					a._c = new g;
					void 0 != b && tj(b, d, a[l], a)
				}), Kr("add clear delete forEach get has set keys values entries toJSON".split(" "), function(a) {
					var b = "add" == a || "set" == a;
					a in m && (!e || "clear" != a) && Qc(k.prototype, a, function(c, d) {
						Gl(this, k, a);
						if (!b && e && !hb(c)) return "get" == a ? void 0 : !1;
						c = this._c[a](0 === c ? 0 : c, d);
						return b ? this : c
					})
				}), e || Jr(k.prototype, "size", {
					get: function() {
						return this._c.size
					}
				})) : (k = c.getConstructor(a, f, d, l), wo(k.prototype, b), cg.NEED = !0);
			Sc(k, f);
			n[f] = k;
			W(W.G + W.W + W.F,
				n);
			e || c.setStrong(k, f, d);
			return k
		};
	ta(function(f) {
		var a = gg(0),
			b = !eb.ActiveXObject && "ActiveXObject" in eb,
			c = cg.getWeak,
			d = Object.isExtensible,
			e = Xh.ufstore,
			g = function(a) {
				return function() {
					return a(this, 0 < arguments.length ? arguments[0] : void 0)
				}
			},
			k = {
				get: function(a) {
					if (hb(a)) {
						var b = c(a);
						return !0 === b ? e(fh(this, "WeakMap")).get(a) : b ? b[this._i] : void 0
					}
				},
				set: function(a, b) {
					return Xh.def(fh(this, "WeakMap"), a, b)
				}
			},
			l = f.exports = Lr("WeakMap", g, k, Xh, !0, !0);
		if (fh && b) {
			var m = Xh.getConstructor(g, "WeakMap");
			vo(m.prototype,
				k);
			cg.NEED = !0;
			a(["delete", "has", "get", "set"], function(a) {
				var b = l.prototype,
					c = b[a];
				Qc(b, a, function(b, e) {
					return hb(b) && !d(b) ? (this._f || (this._f = new m), b = this._f[a](b, e), "set" == a ? this : b) : c.call(
						this, b, e)
				})
			})
		}
	});
	(function(f) {
		W(W.S, f, { of: function() {
				for (var a = arguments.length, b = Array(a); a--;) b[a] = arguments[a];
				return new this(b)
			}
		})
	})("WeakMap");
	(function(f) {
		W(W.S, f, {
			from: function(a, b, c) {
				var d;
				nl(this);
				(d = void 0 !== b) && nl(b);
				if (void 0 == a) return new this;
				var e = [];
				if (d) {
					var f = 0;
					var k = Nc(b, c, 2);
					tj(a, !1, function(a) {
						e.push(k(a,
							f++))
					})
				} else tj(a, !1, e.push, e);
				return new this(e)
			}
		})
	})("WeakMap");
	var Mr = va.WeakMap,
		Nr = ta(function(f) {
			f.exports = {
				"default": Mr,
				__esModule: !0
			}
		}),
		Fa = fa(Nr);
	ah("keys", function() {
		return function(f) {
			return Ed(Object(ie(f)))
		}
	});
	var Or = va.Object.keys,
		Pr = ta(function(f) {
			f.exports = {
				"default": Or,
				__esModule: !0
			}
		}),
		Ha = fa(Pr),
		yo = va.JSON || (va.JSON = {
			stringify: JSON.stringify
		}),
		Qr = function(f) {
			return yo.stringify.apply(yo, arguments)
		},
		Rr = ta(function(f) {
			f.exports = {
				"default": Qr,
				__esModule: !0
			}
		}),
		Rd = fa(Rr);
	W(W.S, "Object", {
		create: nc
	});
	var Sr = va.Object,
		Tr = function(f, a) {
			return Sr.create(f, a)
		},
		zo = ta(function(f) {
			f.exports = {
				"default": Tr,
				__esModule: !0
			}
		}),
		p = fa(zo);
	W(W.S + W.F * !Hb, "Object", {
		defineProperties: Pn
	});
	var Ur = va.Object,
		Vr = function(f, a) {
			return Ur.defineProperties(f, a)
		},
		Wr = ta(function(f) {
			f.exports = {
				"default": Vr,
				__esModule: !0
			}
		}),
		ja = fa(Wr);
	W(W.S + W.F, "Object", {
		assign: vo
	});
	var Xr = va.Object.assign,
		Yr = ta(function(f) {
			f.exports = {
				"default": Xr,
				__esModule: !0
			}
		}),
		q = fa(Yr);
	W(W.S, "Math", {
		sign: Math.sign || function(f) {
			return 0 == (f = +f) ||
				f != f ? f : 0 > f ? -1 : 1
		}
	});
	var Zr = va.Math.sign,
		$r = ta(function(f) {
			f.exports = {
				"default": Zr,
				__esModule: !0
			}
		}),
		Lg = fa($r),
		as = Math.floor;
	W(W.S, "Number", {
		isInteger: function(f) {
			return !hb(f) && isFinite(f) && as(f) === f
		}
	});
	var bs = va.Number.isInteger,
		cs = ta(function(f) {
			f.exports = {
				"default": bs,
				__esModule: !0
			}
		}),
		Dk = fa(cs);
	W(W.S, "Number", {
		EPSILON: Math.pow(2, -52)
	});
	var ds = Math.pow(2, -52),
		es = ta(function(f) {
			f.exports = {
				"default": ds,
				__esModule: !0
			}
		}),
		Na = fa(es),
		Bo = ta(function(f, a) {
			(function(b, c) {
				c(a)
			})(Kn, function(a) {
				function b() {}

				function d(a, b) {
					this.x = a || 0;
					this.y = b || 0
				}

				function e(a, b, c, d) {
					this._x = a || 0;
					this._y = b || 0;
					this._z = c || 0;
					this._w = void 0 !== d ? d : 1
				}

				function f(a, b, c) {
					this.x = a || 0;
					this.y = b || 0;
					this.z = c || 0
				}

				function k() {
					this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
					0 < arguments.length && console.error(
						"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}

				function l(a, b, c, f, e, g, ka, m, n, Ma) {
					Object.defineProperty(this, "id", {
						value: Qi++
					});
					this.uuid = Ea.generateUUID();
					this.name = "";
					this.image = void 0 !== a ? a : l.DEFAULT_IMAGE;
					this.mipmaps = [];
					this.mapping = void 0 !== b ? b : l.DEFAULT_MAPPING;
					this.wrapS = void 0 !== c ? c : 1001;
					this.wrapT = void 0 !== f ? f : 1001;
					this.magFilter = void 0 !== e ? e : 1006;
					this.minFilter = void 0 !== g ? g : 1008;
					this.anisotropy = void 0 !== n ? n : 1;
					this.format = void 0 !== ka ? ka : 1023;
					this.type = void 0 !== m ? m : 1009;
					this.offset = new d(0, 0);
					this.repeat = new d(1, 1);
					this.center = new d(0, 0);
					this.rotation = 0;
					this.matrixAutoUpdate = !0;
					this.matrix = new k;
					this.generateMipmaps = !0;
					this.premultiplyAlpha = !1;
					this.flipY = !0;
					this.unpackAlignment = 4;
					this.encoding = void 0 !== Ma ?
						Ma : 3E3;
					this.version = 0;
					this.onUpdate = null
				}

				function m(a, b, c, d) {
					this.x = a || 0;
					this.y = b || 0;
					this.z = c || 0;
					this.w = void 0 !== d ? d : 1
				}

				function n(a, b, c) {
					this.width = a;
					this.height = b;
					this.scissor = new m(0, 0, a, b);
					this.scissorTest = !1;
					this.viewport = new m(0, 0, a, b);
					c = c || {};
					this.texture = new l(void 0, void 0, c.wrapS, c.wrapT, c.magFilter, c.minFilter, c.format, c.type, c.anisotropy,
						c.encoding);
					this.texture.image = {};
					this.texture.image.width = a;
					this.texture.image.height = b;
					this.texture.generateMipmaps = void 0 !== c.generateMipmaps ? c.generateMipmaps :
						!1;
					this.texture.minFilter = void 0 !== c.minFilter ? c.minFilter : 1006;
					this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
					this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
					this.depthTexture = void 0 !== c.depthTexture ? c.depthTexture : null
				}

				function r(a, b, c) {
					n.call(this, a, b, c);
					this.samples = 4
				}

				function v() {
					this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
					0 < arguments.length && console.error(
						"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}

				function A(a, b, c, d) {
					this._x =
						a || 0;
					this._y = b || 0;
					this._z = c || 0;
					this._order = d || A.DefaultOrder
				}

				function w() {
					this.mask = 1
				}

				function u() {
					Object.defineProperty(this, "id", {
						value: Yi++
					});
					this.uuid = Ea.generateUUID();
					this.name = "";
					this.type = "Object3D";
					this.parent = null;
					this.children = [];
					this.up = u.DefaultUp.clone();
					var a = new f,
						b = new A,
						c = new e,
						d = new f(1, 1, 1);
					b._onChange(function() {
						c.setFromEuler(b, !1)
					});
					c._onChange(function() {
						b.setFromQuaternion(c, void 0, !1)
					});
					ja(this, {
						position: {
							configurable: !0,
							enumerable: !0,
							value: a
						},
						rotation: {
							configurable: !0,
							enumerable: !0,
							value: b
						},
						quaternion: {
							configurable: !0,
							enumerable: !0,
							value: c
						},
						scale: {
							configurable: !0,
							enumerable: !0,
							value: d
						},
						modelViewMatrix: {
							value: new v
						},
						normalMatrix: {
							value: new k
						}
					});
					this.matrix = new v;
					this.matrixWorld = new v;
					this.matrixAutoUpdate = u.DefaultMatrixAutoUpdate;
					this.matrixWorldNeedsUpdate = !1;
					this.layers = new w;
					this.visible = !0;
					this.receiveShadow = this.castShadow = !1;
					this.frustumCulled = !0;
					this.renderOrder = 0;
					this.userData = {}
				}

				function C() {
					u.call(this);
					this.type = "Scene";
					this.overrideMaterial = this.fog = this.background =
						null;
					this.autoUpdate = !0;
					"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
						detail: this
					}))
				}

				function D(a, b) {
					this.min = void 0 !== a ? a : new f(Infinity, Infinity, Infinity);
					this.max = void 0 !== b ? b : new f(-Infinity, -Infinity, -Infinity)
				}

				function K(a, b, c, d, f) {
					var h;
					var t = 0;
					for (h = a.length - 3; t <= h; t += 3) {
						Yh.fromArray(a, t);
						var x = f.x * Math.abs(Yh.x) + f.y * Math.abs(Yh.y) + f.z * Math.abs(Yh.z),
							e = b.dot(Yh),
							y = c.dot(Yh),
							g = d.dot(Yh);
						if (Math.max(-Math.max(e, y, g), Math.min(e, y, g)) > x) return !1
					}
					return !0
				}

				function G(a, b) {
					this.center = void 0 !== a ? a : new f;
					this.radius = void 0 !== b ? b : 0
				}

				function B(a, b) {
					this.origin = void 0 !== a ? a : new f;
					this.direction = void 0 !== b ? b : new f
				}

				function H(a, b, c) {
					this.a = void 0 !== a ? a : new f;
					this.b = void 0 !== b ? b : new f;
					this.c = void 0 !== c ? c : new f
				}

				function Q(a, b, c) {
					return void 0 === b && void 0 === c ? this.set(a) : this.setRGB(a, b, c)
				}

				function J(a, b, c) {
					0 > c && (c += 1);
					1 < c && --c;
					return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - c) : a
				}

				function N(a) {
					return .04045 > a ? .0773993808 * a : Math.pow(.9478672986 * a + .0521327014,
						2.4)
				}

				function P(a) {
					return .0031308 > a ? 12.92 * a : 1.055 * Math.pow(a, .41666) - .055
				}

				function M(a, b, c, d, e, g) {
					this.a = a;
					this.b = b;
					this.c = c;
					this.normal = d && d.isVector3 ? d : new f;
					this.vertexNormals = Array.isArray(d) ? d : [];
					this.color = e && e.isColor ? e : new Q;
					this.vertexColors = Array.isArray(e) ? e : [];
					this.materialIndex = void 0 !== g ? g : 0
				}

				function F() {
					Object.defineProperty(this, "id", {
						value: gj++
					});
					this.uuid = Ea.generateUUID();
					this.name = "";
					this.type = "Material";
					this.fog = !0;
					this.blending = 1;
					this.side = 0;
					this.vertexTangents = this.flatShading = !1;
					this.vertexColors = 0;
					this.opacity = 1;
					this.transparent = !1;
					this.blendSrc = 204;
					this.blendDst = 205;
					this.blendEquation = 100;
					this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
					this.depthFunc = 3;
					this.depthWrite = this.depthTest = !0;
					this.stencilWriteMask = 255;
					this.stencilFunc = 519;
					this.stencilRef = 0;
					this.stencilFuncMask = 255;
					this.stencilZPass = this.stencilZFail = this.stencilFail = 7680;
					this.stencilWrite = !1;
					this.clippingPlanes = null;
					this.clipShadows = this.clipIntersection = !1;
					this.shadowSide = null;
					this.colorWrite = !0;
					this.precision = null;
					this.polygonOffset = !1;
					this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
					this.dithering = !1;
					this.alphaTest = 0;
					this.premultipliedAlpha = !1;
					this.toneMapped = this.visible = !0;
					this.userData = {};
					this.needsUpdate = !0
				}

				function S(a) {
					F.call(this);
					this.type = "MeshBasicMaterial";
					this.color = new Q(16777215);
					this.lightMap = this.map = null;
					this.lightMapIntensity = 1;
					this.aoMap = null;
					this.aoMapIntensity = 1;
					this.envMap = this.alphaMap = this.specularMap = null;
					this.combine = 0;
					this.reflectivity = 1;
					this.refractionRatio =
						.98;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.wireframeLinejoin = this.wireframeLinecap = "round";
					this.morphTargets = this.skinning = !1;
					this.setValues(a)
				}

				function R(a, b, c) {
					if (Array.isArray(a)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.name = "";
					this.array = a;
					this.itemSize = b;
					this.count = void 0 !== a ? a.length / b : 0;
					this.normalized = !0 === c;
					this.dynamic = !1;
					this.updateRange = {
						offset: 0,
						count: -1
					};
					this.version = 0
				}

				function V(a, b, c) {
					R.call(this, new Int8Array(a), b, c)
				}

				function X(a,
					b, c) {
					R.call(this, new Uint8Array(a), b, c)
				}

				function W(a, b, c) {
					R.call(this, new Uint8ClampedArray(a), b, c)
				}

				function ba(a, b, c) {
					R.call(this, new Int16Array(a), b, c)
				}

				function fa(a, b, c) {
					R.call(this, new Uint16Array(a), b, c)
				}

				function ia(a, b, c) {
					R.call(this, new Int32Array(a), b, c)
				}

				function da(a, b, c) {
					R.call(this, new Uint32Array(a), b, c)
				}

				function L(a, b, c) {
					R.call(this, new Float32Array(a), b, c)
				}

				function ma(a, b, c) {
					R.call(this, new Float64Array(a), b, c)
				}

				function ua() {
					this.vertices = [];
					this.normals = [];
					this.colors = [];
					this.uvs = [];
					this.uvs2 = [];
					this.groups = [];
					this.morphTargets = {};
					this.skinWeights = [];
					this.skinIndices = [];
					this.boundingSphere = this.boundingBox = null;
					this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !
						1
				}

				function ta(a) {
					if (0 === a.length) return -Infinity;
					for (var h = a[0], b = 1, c = a.length; b < c; ++b) a[b] > h && (h = a[b]);
					return h
				}

				function I() {
					Object.defineProperty(this, "id", {
						value: jj += 2
					});
					this.uuid = Ea.generateUUID();
					this.name = "";
					this.type = "BufferGeometry";
					this.index = null;
					this.attributes = {};
					this.morphAttributes = {};
					this.groups = [];
					this.boundingSphere = this.boundingBox = null;
					this.drawRange = {
						start: 0,
						count: Infinity
					};
					this.userData = {}
				}

				function ha(a, b) {
					u.call(this);
					this.type = "Mesh";
					this.geometry = void 0 !== a ? a : new I;
					this.material = void 0 !== b ? b : new S({
						color: 16777215 * Math.random()
					});
					this.drawMode = 0;
					this.updateMorphTargets()
				}

				function Z(a, b, c, d, f, e, g, k) {
					if (null === (1 === b.side ? d.intersectTriangle(g, e, f, !0, k) : d.intersectTriangle(f, e, g, 2 !== b.side, k)))
						return null;
					bg.copy(k);
					bg.applyMatrix4(a.matrixWorld);
					b = c.ray.origin.distanceTo(bg);
					return b < c.near || b > c.far ? null : {
						distance: b,
						point: bg.clone(),
						object: a
					}
				}

				function xa(a, b, c, f, e, g, k, l, m, n, r) {
					Zh.fromBufferAttribute(e, m);
					$h.fromBufferAttribute(e, n);
					ai.fromBufferAttribute(e, r);
					e = a.morphTargetInfluences;
					if (b.morphTargets && g && e) {
						Wg.set(0, 0, 0);
						Zg.set(0, 0, 0);
						$g.set(0, 0, 0);
						for (var h = 0, t = g.length; h < t; h++) {
							var x = e[h],
								y = g[h];
							0 !== x && (Th.fromBufferAttribute(y, m), Uh.fromBufferAttribute(y, n), Vh.fromBufferAttribute(y, r), Wg.addScaledVector(
								Th.sub(Zh), x), Zg.addScaledVector(Uh.sub($h),
								x), $g.addScaledVector(Vh.sub(ai), x))
						}
						Zh.add(Wg);
						$h.add(Zg);
						ai.add($g)
					}
					if (a = Z(a, b, c, f, Zh, $h, ai, pk)) k && (vj.fromBufferAttribute(k, m), wj.fromBufferAttribute(k, n), xj.fromBufferAttribute(
							k, r), a.uv = H.getUV(pk, Zh, $h, ai, vj, wj, xj, new d)), l && (vj.fromBufferAttribute(l, m), wj.fromBufferAttribute(
							l, n), xj.fromBufferAttribute(l, r), a.uv2 = H.getUV(pk, Zh, $h, ai, vj, wj, xj, new d)), k = new M(m, n, r),
						H.getNormal(Zh, $h, ai, k.normal), a.face = k;
					return a
				}

				function T() {
					Object.defineProperty(this, "id", {
						value: pj += 2
					});
					this.uuid = Ea.generateUUID();
					this.name = "";
					this.type = "Geometry";
					this.vertices = [];
					this.colors = [];
					this.faces = [];
					this.faceVertexUvs = [
						[]
					];
					this.morphTargets = [];
					this.morphNormals = [];
					this.skinWeights = [];
					this.skinIndices = [];
					this.lineDistances = [];
					this.boundingSphere = this.boundingBox = null;
					this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate =
						this.verticesNeedUpdate = this.elementsNeedUpdate = !1
				}

				function Aa(a) {
					var h = {},
						b;
					for (b in a) {
						h[b] = {};
						for (var c in a[b]) {
							var d = a[b][c];
							d && (d.isColor ||
									d.isMatrix3 || d.isMatrix4 || d.isVector2 || d.isVector3 || d.isVector4 || d.isTexture) ? h[b][c] = d.clone() :
								Array.isArray(d) ? h[b][c] = d.slice() : h[b][c] = d
						}
					}
					return h
				}

				function pa(a) {
					for (var h = {}, b = 0; b < a.length; b++) {
						var c = Aa(a[b]),
							d;
						for (d in c) h[d] = c[d]
					}
					return h
				}

				function sa(a) {
					F.call(this);
					this.type = "ShaderMaterial";
					this.defines = {};
					this.uniforms = {};
					this.vertexShader =
						"void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
					this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
					this.linewidth = 1;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1;
					this.extensions = {
						derivatives: !1,
						fragDepth: !1,
						drawBuffers: !1,
						shaderTextureLOD: !1
					};
					this.defaultAttributeValues = {
						color: [1, 1, 1],
						uv: [0, 0],
						uv2: [0, 0]
					};
					this.index0AttributeName = void 0;
					this.uniformsNeedUpdate = !1;
					void 0 !== a && (void 0 !== a.attributes && console.error(
						"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(a))
				}

				function va() {
					u.call(this);
					this.type = "Camera";
					this.matrixWorldInverse = new v;
					this.projectionMatrix = new v;
					this.projectionMatrixInverse = new v
				}

				function Ja(a, b, c, d) {
					va.call(this);
					this.type = "PerspectiveCamera";
					this.fov = void 0 !== a ? a : 50;
					this.zoom = 1;
					this.near = void 0 !== c ? c : .1;
					this.far = void 0 !== d ? d : 2E3;
					this.focus = 10;
					this.aspect = void 0 !== b ? b : 1;
					this.view = null;
					this.filmGauge = 35;
					this.filmOffset = 0;
					this.updateProjectionMatrix()
				}

				function Da(a, b, c, d) {
					u.call(this);
					this.type = "CubeCamera";
					var h = new Ja(90, 1, a, b);
					h.up.set(0,
						-1, 0);
					h.lookAt(new f(1, 0, 0));
					this.add(h);
					var t = new Ja(90, 1, a, b);
					t.up.set(0, -1, 0);
					t.lookAt(new f(-1, 0, 0));
					this.add(t);
					var x = new Ja(90, 1, a, b);
					x.up.set(0, 0, 1);
					x.lookAt(new f(0, 1, 0));
					this.add(x);
					var e = new Ja(90, 1, a, b);
					e.up.set(0, 0, -1);
					e.lookAt(new f(0, -1, 0));
					this.add(e);
					var y = new Ja(90, 1, a, b);
					y.up.set(0, -1, 0);
					y.lookAt(new f(0, 0, 1));
					this.add(y);
					var g = new Ja(90, 1, a, b);
					g.up.set(0, -1, 0);
					g.lookAt(new f(0, 0, -1));
					this.add(g);
					d = d || {
						format: 1022,
						magFilter: 1006,
						minFilter: 1006
					};
					this.renderTarget = new qa(c, c, d);
					this.renderTarget.texture.name =
						"CubeCamera";
					this.update = function(a, b) {
						null === this.parent && this.updateMatrixWorld();
						var c = a.getRenderTarget(),
							d = this.renderTarget,
							f = d.texture.generateMipmaps;
						d.texture.generateMipmaps = !1;
						a.setRenderTarget(d, 0);
						a.render(b, h);
						a.setRenderTarget(d, 1);
						a.render(b, t);
						a.setRenderTarget(d, 2);
						a.render(b, x);
						a.setRenderTarget(d, 3);
						a.render(b, e);
						a.setRenderTarget(d, 4);
						a.render(b, y);
						d.texture.generateMipmaps = f;
						a.setRenderTarget(d, 5);
						a.render(b, g);
						a.setRenderTarget(c)
					};
					this.clear = function(a, h, b, c) {
						for (var t = a.getRenderTarget(),
								d = this.renderTarget, x = 0; 6 > x; x++) a.setRenderTarget(d, x), a.clear(h, b, c);
						a.setRenderTarget(t)
					}
				}

				function qa(a, b, c) {
					n.call(this, a, b, c)
				}

				function Ia(a, b, c, d, f, e, g, k, m, n, r, p) {
					l.call(this, null, e, g, k, m, n, d, f, r, p);
					this.image = {
						data: a || null,
						width: b || 1,
						height: c || 1
					};
					this.magFilter = void 0 !== m ? m : 1003;
					this.minFilter = void 0 !== n ? n : 1003;
					this.flipY = this.generateMipmaps = !1;
					this.unpackAlignment = 1;
					this.needsUpdate = !0
				}

				function za(a, b) {
					this.normal = void 0 !== a ? a : new f(1, 0, 0);
					this.constant = void 0 !== b ? b : 0
				}

				function U(a, b, c, d, f,
					e) {
					this.planes = [void 0 !== a ? a : new za, void 0 !== b ? b : new za, void 0 !== c ? c : new za, void 0 !== d ?
						d : new za, void 0 !== f ? f : new za, void 0 !== e ? e : new za
					]
				}

				function Oa() {
					function a(h, t) {
						!1 !== c && (d(h, t), b.requestAnimationFrame(a))
					}
					var b = null,
						c = !1,
						d = null;
					return {
						start: function() {
							!0 !== c && null !== d && (b.requestAnimationFrame(a), c = !0)
						},
						stop: function() {
							c = !1
						},
						setAnimationLoop: function(a) {
							d = a
						},
						setContext: function(a) {
							b = a
						}
					}
				}

				function Ra(a) {
					function h(h, b) {
						var c = h.array,
							t = h.dynamic ? 35048 : 35044,
							d = a.createBuffer();
						a.bindBuffer(b, d);
						a.bufferData(b, c, t);
						h.onUploadCallback();
						b = 5126;
						c instanceof Float32Array ? b = 5126 : c instanceof Float64Array ? console.warn(
								"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : c instanceof Uint16Array ? b =
							5123 : c instanceof Int16Array ? b = 5122 : c instanceof Uint32Array ? b = 5125 : c instanceof Int32Array ? b =
							5124 : c instanceof Int8Array ? b = 5120 : c instanceof Uint8Array && (b = 5121);
						return {
							buffer: d,
							type: b,
							bytesPerElement: c.BYTES_PER_ELEMENT,
							version: h.version
						}
					}
					var b = new Fa;
					return {
						get: function(a) {
							a.isInterleavedBufferAttribute &&
								(a = a.data);
							return b.get(a)
						},
						remove: function(h) {
							h.isInterleavedBufferAttribute && (h = h.data);
							var c = b.get(h);
							c && (a.deleteBuffer(c.buffer), b.delete(h))
						},
						update: function(c, t) {
							c.isInterleavedBufferAttribute && (c = c.data);
							var d = b.get(c);
							if (void 0 === d) b.set(c, h(c, t));
							else if (d.version < c.version) {
								var x = c,
									f = x.array,
									e = x.updateRange;
								a.bindBuffer(t, d.buffer);
								!1 === x.dynamic ? a.bufferData(t, f, 35044) : -1 === e.count ? a.bufferSubData(t, 0, f) : 0 === e.count ?
									console.error(
										"THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually."
									) :
									(a.bufferSubData(t, e.offset * f.BYTES_PER_ELEMENT, f.subarray(e.offset, e.offset + e.count)), e.count = -
										1);
								d.version = c.version
							}
						}
					}
				}

				function aa(a, b, c, d) {
					T.call(this);
					this.type = "PlaneGeometry";
					this.parameters = {
						width: a,
						height: b,
						widthSegments: c,
						heightSegments: d
					};
					this.fromBufferGeometry(new Ba(a, b, c, d));
					this.mergeVertices()
				}

				function Ba(a, b, c, d) {
					I.call(this);
					this.type = "PlaneBufferGeometry";
					this.parameters = {
						width: a,
						height: b,
						widthSegments: c,
						heightSegments: d
					};
					a = a || 1;
					b = b || 1;
					var h = a / 2,
						t = b / 2;
					c = Math.floor(c) || 1;
					d = Math.floor(d) ||
						1;
					var x = c + 1,
						f = d + 1,
						e = a / c,
						y = b / d,
						g = [],
						k = [],
						l = [],
						m = [];
					for (a = 0; a < f; a++) {
						var n = a * y - t;
						for (b = 0; b < x; b++) k.push(b * e - h, -n, 0), l.push(0, 0, 1), m.push(b / c), m.push(1 - a / d)
					}
					for (a = 0; a < d; a++)
						for (b = 0; b < c; b++) h = b + x * (a + 1), t = b + 1 + x * (a + 1), f = b + 1 + x * a, g.push(b + x * a, h,
							f), g.push(h, t, f);
					this.setIndex(g);
					this.addAttribute("position", new L(k, 3));
					this.addAttribute("normal", new L(l, 3));
					this.addAttribute("uv", new L(m, 2))
				}

				function Wa(a, b, c, d) {
					function h(a, h) {
						b.buffers.color.setClear(a.r, a.g, a.b, h, d)
					}
					var t = new Q(0),
						x = 0,
						f, e, y = null,
						g = 0;
					return {
						getClearColor: function() {
							return t
						},
						setClearColor: function(a, b) {
							t.set(a);
							x = void 0 !== b ? b : 1;
							h(t, x)
						},
						getClearAlpha: function() {
							return x
						},
						setClearAlpha: function(a) {
							x = a;
							h(t, x)
						},
						render: function(b, d, k, E) {
							d = d.background;
							k = a.vr;
							(k = k.getSession && k.getSession()) && "additive" === k.environmentBlendMode && (d = null);
							null === d ? (h(t, x), y = null, g = 0) : d && d.isColor && (h(d, 1), E = !0, y = null, g = 0);
							(a.autoClear || E) && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
							if (d && (d.isCubeTexture || d.isWebGLRenderTargetCube)) {
								void 0 === e && (e = new ha(new qk(1, 1, 1), new sa({
									type: "BackgroundCubeMaterial",
									uniforms: Aa(kf.cube.uniforms),
									vertexShader: kf.cube.vertexShader,
									fragmentShader: kf.cube.fragmentShader,
									side: 1,
									depthTest: !1,
									depthWrite: !1,
									fog: !1
								})), e.geometry.removeAttribute("normal"), e.geometry.removeAttribute("uv"), e.onBeforeRender = function(
									a, h, b) {
									this.matrixWorld.copyPosition(b.matrixWorld)
								}, Object.defineProperty(e.material, "map", {
									get: function() {
										return this.uniforms.tCube.value
									}
								}), c.update(e));
								E = d.isWebGLRenderTargetCube ? d.texture : d;
								e.material.uniforms.tCube.value = E;
								e.material.uniforms.tFlip.value =
									d.isWebGLRenderTargetCube ? 1 : -1;
								if (y !== d || g !== E.version) e.material.needsUpdate = !0, y = d, g = E.version;
								b.unshift(e, e.geometry, e.material, 0, 0, null)
							} else if (d && d.isTexture) {
								void 0 === f && (f = new ha(new Ba(2, 2), new sa({
										type: "BackgroundMaterial",
										uniforms: Aa(kf.background.uniforms),
										vertexShader: kf.background.vertexShader,
										fragmentShader: kf.background.fragmentShader,
										side: 0,
										depthTest: !1,
										depthWrite: !1,
										fog: !1
									})), f.geometry.removeAttribute("normal"), Object.defineProperty(f.material, "map", {
										get: function() {
											return this.uniforms.t2D.value
										}
									}),
									c.update(f));
								f.material.uniforms.t2D.value = d;
								!0 === d.matrixAutoUpdate && d.updateMatrix();
								f.material.uniforms.uvTransform.value.copy(d.matrix);
								if (y !== d || g !== d.version) f.material.needsUpdate = !0, y = d, g = d.version;
								b.unshift(f, f.geometry, f.material, 0, 0, null)
							}
						}
					}
				}

				function Xa(a, b, c, d) {
					var h;
					this.setMode = function(a) {
						h = a
					};
					this.render = function(b, t) {
						a.drawArrays(h, b, t);
						c.update(t, h)
					};
					this.renderInstances = function(t, x, f, e) {
						if (0 !== e) {
							if (d.isWebGL2) {
								t = a;
								var y = "drawArraysInstanced"
							} else if (t = b.get("ANGLE_instanced_arrays"),
								y = "drawArraysInstancedANGLE", null === t) {
								console.error(
									"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
								);
								return
							}
							t[y](h, x, f, e);
							c.update(f, h, e)
						}
					}
				}

				function Ya(a, b, c) {
					function h(h) {
						if ("highp" === h) {
							if (0 < a.getShaderPrecisionFormat(35633, 36338).precision && 0 < a.getShaderPrecisionFormat(35632, 36338).precision)
								return "highp";
							h = "mediump"
						}
						return "mediump" === h && 0 < a.getShaderPrecisionFormat(35633, 36337).precision && 0 < a.getShaderPrecisionFormat(
							35632,
							36337).precision ? "mediump" : "lowp"
					}
					var t, d = "undefined" !== typeof WebGL2RenderingContext && a instanceof WebGL2RenderingContext,
						x = void 0 !== c.precision ? c.precision : "highp",
						f = h(x);
					f !== x && (console.warn("THREE.WebGLRenderer:", x, "not supported, using", f, "instead."), x = f);
					c = !0 === c.logarithmicDepthBuffer;
					f = a.getParameter(34930);
					var e = a.getParameter(35660),
						g = a.getParameter(3379),
						k = a.getParameter(34076),
						l = a.getParameter(34921),
						m = a.getParameter(36347),
						n = a.getParameter(36348),
						r = a.getParameter(36349),
						p = 0 < e,
						v = d || !!b.get("OES_texture_float"),
						q = p && v,
						w = d ? a.getParameter(36183) : 0;
					return {
						isWebGL2: d,
						getMaxAnisotropy: function() {
							if (void 0 !== t) return t;
							var h = b.get("EXT_texture_filter_anisotropic");
							return t = null !== h ? a.getParameter(h.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
						},
						getMaxPrecision: h,
						precision: x,
						logarithmicDepthBuffer: c,
						maxTextures: f,
						maxVertexTextures: e,
						maxTextureSize: g,
						maxCubemapSize: k,
						maxAttributes: l,
						maxVertexUniforms: m,
						maxVaryings: n,
						maxFragmentUniforms: r,
						vertexTextures: p,
						floatFragmentTextures: v,
						floatVertexTextures: q,
						maxSamples: w
					}
				}

				function Za() {
					function a() {
						n.value !==
							d && (n.value = d, n.needsUpdate = 0 < f);
						c.numPlanes = f;
						c.numIntersection = 0
					}

					function b(a, h, b, t) {
						var d = null !== a ? a.length : 0,
							x = null;
						if (0 !== d) {
							x = n.value;
							if (!0 !== t || null === x) {
								t = b + 4 * d;
								h = h.matrixWorldInverse;
								m.getNormalMatrix(h);
								if (null === x || x.length < t) x = new Float32Array(t);
								for (t = 0; t !== d; ++t, b += 4) l.copy(a[t]).applyMatrix4(h, m), l.normal.toArray(x, b), x[b + 3] = l.constant
							}
							n.value = x;
							n.needsUpdate = !0
						}
						c.numPlanes = d;
						return x
					}
					var c = this,
						d = null,
						f = 0,
						e = !1,
						g = !1,
						l = new za,
						m = new k,
						n = {
							value: null,
							needsUpdate: !1
						};
					this.uniform = n;
					this.numIntersection =
						this.numPlanes = 0;
					this.init = function(a, h, c) {
						var t = 0 !== a.length || h || 0 !== f || e;
						e = h;
						d = b(a, c, 0);
						f = a.length;
						return t
					};
					this.beginShadows = function() {
						g = !0;
						b(null)
					};
					this.endShadows = function() {
						g = !1;
						a()
					};
					this.setState = function(h, c, t, x, y, k) {
						if (!e || null === h || 0 === h.length || g && !t) g ? b(null) : a();
						else {
							t = g ? 0 : f;
							var E = 4 * t,
								l = y.clippingState || null;
							n.value = l;
							l = b(h, x, E, k);
							for (h = 0; h !== E; ++h) l[h] = d[h];
							y.clippingState = l;
							this.numIntersection = c ? this.numPlanes : 0;
							this.numPlanes += t
						}
					}
				}

				function $a(a) {
					var h = {};
					return {
						get: function(b) {
							if (void 0 !==
								h[b]) return h[b];
							switch (b) {
								case "WEBGL_depth_texture":
									var c = a.getExtension("WEBGL_depth_texture") || a.getExtension("MOZ_WEBGL_depth_texture") || a.getExtension(
										"WEBKIT_WEBGL_depth_texture");
									break;
								case "EXT_texture_filter_anisotropic":
									c = a.getExtension("EXT_texture_filter_anisotropic") || a.getExtension(
										"MOZ_EXT_texture_filter_anisotropic") || a.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
									break;
								case "WEBGL_compressed_texture_s3tc":
									c = a.getExtension("WEBGL_compressed_texture_s3tc") || a.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
										a.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
									break;
								case "WEBGL_compressed_texture_pvrtc":
									c = a.getExtension("WEBGL_compressed_texture_pvrtc") || a.getExtension(
										"WEBKIT_WEBGL_compressed_texture_pvrtc");
									break;
								default:
									c = a.getExtension(b)
							}
							null === c && console.warn("THREE.WebGLRenderer: " + b + " extension not supported.");
							return h[b] = c
						}
					}
				}

				function ab(a, b, c) {
					function h(a) {
						var t = a.target;
						a = d.get(t);
						null !== a.index && b.remove(a.index);
						for (var f in a.attributes) b.remove(a.attributes[f]);
						t.removeEventListener("dispose",
							h);
						d.delete(t);
						if (f = x.get(a)) b.remove(f), x.delete(a);
						c.memory.geometries--
					}

					function t(a) {
						var h = [],
							c = a.index,
							t = a.attributes.position;
						if (null !== c) {
							var d = c.array;
							c = c.version;
							t = 0;
							for (var f = d.length; t < f; t += 3) {
								var e = d[t + 0],
									y = d[t + 1],
									g = d[t + 2];
								h.push(e, y, y, g, g, e)
							}
						} else
							for (d = t.array, c = t.version, t = 0, f = d.length / 3 - 1; t < f; t += 3) e = t + 0, y = t + 1, g = t + 2,
								h.push(e, y, y, g, g, e);
						h = new(65535 < ta(h) ? da : fa)(h, 1);
						h.version = c;
						b.update(h, 34963);
						(d = x.get(a)) && b.remove(d);
						x.set(a, h)
					}
					var d = new Fa,
						x = new Fa;
					return {
						get: function(a, b) {
							var t =
								d.get(b);
							if (t) return t;
							b.addEventListener("dispose", h);
							b.isBufferGeometry ? t = b : b.isGeometry && (void 0 === b._bufferGeometry && (b._bufferGeometry = (new I).setFromObject(
								a)), t = b._bufferGeometry);
							d.set(b, t);
							c.memory.geometries++;
							return t
						},
						update: function(a) {
							var h = a.index,
								c = a.attributes;
							null !== h && b.update(h, 34963);
							for (var t in c) b.update(c[t], 34962);
							a = a.morphAttributes;
							for (t in a) {
								h = a[t];
								c = 0;
								for (var d = h.length; c < d; c++) b.update(h[c], 34962)
							}
						},
						getWireframeAttribute: function(a) {
							var h = x.get(a);
							if (h) {
								var b = a.index;
								null !== b && h.version < b.version && t(a)
							} else t(a);
							return x.get(a)
						}
					}
				}

				function hb(a, b, c, d) {
					var h, t, x;
					this.setMode = function(a) {
						h = a
					};
					this.setIndex = function(a) {
						t = a.type;
						x = a.bytesPerElement
					};
					this.render = function(b, d) {
						a.drawElements(h, d, t, b * x);
						c.update(d, h)
					};
					this.renderInstances = function(f, e, y, g) {
						if (0 !== g) {
							if (d.isWebGL2) {
								f = a;
								var k = "drawElementsInstanced"
							} else if (f = b.get("ANGLE_instanced_arrays"), k = "drawElementsInstancedANGLE", null === f) {
								console.error(
									"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
								);
								return
							}
							f[k](h, y, t, e * x, g);
							c.update(y, h, g)
						}
					}
				}

				function jb(a) {
					var h = {
						frame: 0,
						calls: 0,
						triangles: 0,
						points: 0,
						lines: 0
					};
					return {
						memory: {
							geometries: 0,
							textures: 0
						},
						render: h,
						programs: null,
						autoReset: !0,
						reset: function() {
							h.frame++;
							h.calls = 0;
							h.triangles = 0;
							h.points = 0;
							h.lines = 0
						},
						update: function(a, b, c) {
							c = c || 1;
							h.calls++;
							switch (b) {
								case 4:
									h.triangles += a / 3 * c;
									break;
								case 5:
								case 6:
									h.triangles += c * (a - 2);
									break;
								case 1:
									h.lines += a / 2 * c;
									break;
								case 3:
									h.lines += c * (a - 1);
									break;
								case 2:
									h.lines += c * a;
									break;
								case 0:
									h.points += c * a;
									break;
								default:
									console.error("THREE.WebGLInfo: Unknown draw mode:",
										b)
							}
						}
					}
				}

				function kb(a, b) {
					return Math.abs(b[1]) - Math.abs(a[1])
				}

				function mb(a) {
					var h = {},
						b = new Float32Array(8);
					return {
						update: function(c, t, d, x) {
							var f = c.morphTargetInfluences,
								e = f.length;
							c = h[t.id];
							if (void 0 === c) {
								c = [];
								for (var y = 0; y < e; y++) c[y] = [y, 0];
								h[t.id] = c
							}
							var g = d.morphTargets && t.morphAttributes.position;
							d = d.morphNormals && t.morphAttributes.normal;
							for (y = 0; y < e; y++) {
								var k = c[y];
								0 !== k[1] && (g && t.removeAttribute("morphTarget" + y), d && t.removeAttribute("morphNormal" + y))
							}
							for (y = 0; y < e; y++) k = c[y], k[0] = y, k[1] = f[y];
							c.sort(kb);
							for (y = 0; 8 > y; y++) {
								if (k = c[y])
									if (f = k[0], e = k[1]) {
										g && t.addAttribute("morphTarget" + y, g[f]);
										d && t.addAttribute("morphNormal" + y, d[f]);
										b[y] = e;
										continue
									} b[y] = 0
							}
							x.getUniforms().setValue(a, "morphTargetInfluences", b)
						}
					}
				}

				function ob(a, b, c, d) {
					var h = {};
					return {
						update: function(a) {
							var t = d.render.frame,
								x = a.geometry,
								f = b.get(a, x);
							h[f.id] !== t && (x.isGeometry && f.updateFromObject(a), b.update(f), h[f.id] = t);
							a.isInstancedMesh && c.update(a.instanceMatrix, 34962);
							return f
						},
						dispose: function() {
							h = {}
						}
					}
				}

				function Ua(a, b, c, d, f, e, g, k, m, n) {
					a =
						void 0 !== a ? a : [];
					l.call(this, a, void 0 !== b ? b : 301, c, d, f, e, void 0 !== g ? g : 1022, k, m, n);
					this.flipY = !1
				}

				function cb(a, b, c, d) {
					l.call(this, null);
					this.image = {
						data: a || null,
						width: b || 1,
						height: c || 1,
						depth: d || 1
					};
					this.minFilter = this.magFilter = 1003;
					this.wrapR = 1001;
					this.flipY = this.generateMipmaps = !1;
					this.needsUpdate = !0
				}

				function db(a, b, c, d) {
					l.call(this, null);
					this.image = {
						data: a || null,
						width: b || 1,
						height: c || 1,
						depth: d || 1
					};
					this.minFilter = this.magFilter = 1003;
					this.wrapR = 1001;
					this.flipY = this.generateMipmaps = !1;
					this.needsUpdate = !0
				}

				function eb(a, b, c) {
					var h = a[0];
					if (0 >= h || 0 < h) return a;
					var t = b * c,
						d = wi[t];
					void 0 === d && (d = new Float32Array(t), wi[t] = d);
					if (0 !== b)
						for (h.toArray(d, 0), h = 1, t = 0; h !== b; ++h) t += c, a[h].toArray(d, t);
					return d
				}

				function Ga(a, b) {
					if (a.length !== b.length) return !1;
					for (var h = 0, c = a.length; h < c; h++)
						if (a[h] !== b[h]) return !1;
					return !0
				}

				function Pa(a, b) {
					for (var h = 0, c = b.length; h < c; h++) a[h] = b[h]
				}

				function pb(a, b) {
					var h = xi[b];
					void 0 === h && (h = new Int32Array(b), xi[b] = h);
					for (var c = 0; c !== b; ++c) h[c] = a.allocateTextureUnit();
					return h
				}

				function qb(a,
					b) {
					var h = this.cache;
					h[0] !== b && (a.uniform1f(this.addr, b), h[0] = b)
				}

				function rb(a, b) {
					var h = this.cache;
					if (void 0 !== b.x) {
						if (h[0] !== b.x || h[1] !== b.y) a.uniform2f(this.addr, b.x, b.y), h[0] = b.x, h[1] = b.y
					} else Ga(h, b) || (a.uniform2fv(this.addr, b), Pa(h, b))
				}

				function vb(a, b) {
					var h = this.cache;
					if (void 0 !== b.x) {
						if (h[0] !== b.x || h[1] !== b.y || h[2] !== b.z) a.uniform3f(this.addr, b.x, b.y, b.z), h[0] = b.x, h[1] = b.y,
							h[2] = b.z
					} else if (void 0 !== b.r) {
						if (h[0] !== b.r || h[1] !== b.g || h[2] !== b.b) a.uniform3f(this.addr, b.r, b.g, b.b), h[0] = b.r, h[1] = b.g,
							h[2] = b.b
					} else Ga(h, b) || (a.uniform3fv(this.addr, b), Pa(h, b))
				}

				function wb(a, b) {
					var h = this.cache;
					if (void 0 !== b.x) {
						if (h[0] !== b.x || h[1] !== b.y || h[2] !== b.z || h[3] !== b.w) a.uniform4f(this.addr, b.x, b.y, b.z, b.w),
							h[0] = b.x, h[1] = b.y, h[2] = b.z, h[3] = b.w
					} else Ga(h, b) || (a.uniform4fv(this.addr, b), Pa(h, b))
				}

				function xb(a, b) {
					var h = this.cache,
						c = b.elements;
					void 0 === c ? Ga(h, b) || (a.uniformMatrix2fv(this.addr, !1, b), Pa(h, b)) : Ga(h, c) || (Ai.set(c), a.uniformMatrix2fv(
						this.addr, !1, Ai), Pa(h, c))
				}

				function Cb(a, b) {
					var h = this.cache,
						c = b.elements;
					void 0 === c ? Ga(h, b) || (a.uniformMatrix3fv(this.addr, !1, b), Pa(h, b)) : Ga(h, c) || (zi.set(c), a.uniformMatrix3fv(
						this.addr, !1, zi), Pa(h, c))
				}

				function Fb(a, b) {
					var h = this.cache,
						c = b.elements;
					void 0 === c ? Ga(h, b) || (a.uniformMatrix4fv(this.addr, !1, b), Pa(h, b)) : Ga(h, c) || (yi.set(c), a.uniformMatrix4fv(
						this.addr, !1, yi), Pa(h, c))
				}

				function Gb(a, b, c) {
					var h = this.cache,
						t = c.allocateTextureUnit();
					h[0] !== t && (a.uniform1i(this.addr, t), h[0] = t);
					c.safeSetTexture2D(b || Wh, t)
				}

				function Ib(a, b, c) {
					var h = this.cache,
						t = c.allocateTextureUnit();
					h[0] !== t && (a.uniform1i(this.addr, t), h[0] = t);
					c.setTexture2DArray(b || tj, t)
				}

				function Jb(a, b, c) {
					var h = this.cache,
						t = c.allocateTextureUnit();
					h[0] !== t && (a.uniform1i(this.addr, t), h[0] = t);
					c.setTexture3D(b || uj, t)
				}

				function Mb(a, b, c) {
					var h = this.cache,
						t = c.allocateTextureUnit();
					h[0] !== t && (a.uniform1i(this.addr, t), h[0] = t);
					c.safeSetTextureCube(b || Xh, t)
				}

				function Nb(a, b) {
					var h = this.cache;
					h[0] !== b && (a.uniform1i(this.addr, b), h[0] = b)
				}

				function Ob(a, b) {
					var h = this.cache;
					Ga(h, b) || (a.uniform2iv(this.addr, b), Pa(h, b))
				}

				function Pb(a,
					b) {
					var h = this.cache;
					Ga(h, b) || (a.uniform3iv(this.addr, b), Pa(h, b))
				}

				function Rb(a, b) {
					var h = this.cache;
					Ga(h, b) || (a.uniform4iv(this.addr, b), Pa(h, b))
				}

				function Tb(a) {
					switch (a) {
						case 5126:
							return qb;
						case 35664:
							return rb;
						case 35665:
							return vb;
						case 35666:
							return wb;
						case 35674:
							return xb;
						case 35675:
							return Cb;
						case 35676:
							return Fb;
						case 35678:
						case 36198:
							return Gb;
						case 35679:
							return Jb;
						case 35680:
							return Mb;
						case 36289:
							return Ib;
						case 5124:
						case 35670:
							return Nb;
						case 35667:
						case 35671:
							return Ob;
						case 35668:
						case 35672:
							return Pb;
						case 35669:
						case 35673:
							return Rb
					}
				}

				function Vb(a, b) {
					a.uniform1fv(this.addr, b)
				}

				function Yb(a, b) {
					a.uniform1iv(this.addr, b)
				}

				function Zb(a, b) {
					a.uniform2iv(this.addr, b)
				}

				function $b(a, b) {
					a.uniform3iv(this.addr, b)
				}

				function bc(a, b) {
					a.uniform4iv(this.addr, b)
				}

				function dc(a, b) {
					b = eb(b, this.size, 2);
					a.uniform2fv(this.addr, b)
				}

				function fc(a, b) {
					b = eb(b, this.size, 3);
					a.uniform3fv(this.addr, b)
				}

				function jc(a, b) {
					b = eb(b, this.size, 4);
					a.uniform4fv(this.addr, b)
				}

				function kc(a, b) {
					b = eb(b, this.size, 4);
					a.uniformMatrix2fv(this.addr,
						!1, b)
				}

				function yc(a, b) {
					b = eb(b, this.size, 9);
					a.uniformMatrix3fv(this.addr, !1, b)
				}

				function Ic(a, b) {
					b = eb(b, this.size, 16);
					a.uniformMatrix4fv(this.addr, !1, b)
				}

				function Oc(a, b, c) {
					var h = b.length,
						t = pb(c, h);
					a.uniform1iv(this.addr, t);
					for (a = 0; a !== h; ++a) c.safeSetTexture2D(b[a] || Wh, t[a])
				}

				function Uc(a, b, c) {
					var h = b.length,
						t = pb(c, h);
					a.uniform1iv(this.addr, t);
					for (a = 0; a !== h; ++a) c.safeSetTextureCube(b[a] || Xh, t[a])
				}

				function Zc(a) {
					switch (a) {
						case 5126:
							return Vb;
						case 35664:
							return dc;
						case 35665:
							return fc;
						case 35666:
							return jc;
						case 35674:
							return kc;
						case 35675:
							return yc;
						case 35676:
							return Ic;
						case 35678:
							return Oc;
						case 35680:
							return Uc;
						case 5124:
						case 35670:
							return Yb;
						case 35667:
						case 35671:
							return Zb;
						case 35668:
						case 35672:
							return $b;
						case 35669:
						case 35673:
							return bc
					}
				}

				function gd(a, b, c) {
					this.id = a;
					this.addr = c;
					this.cache = [];
					this.setValue = Tb(b.type)
				}

				function uc(a, b, c) {
					this.id = a;
					this.addr = c;
					this.cache = [];
					this.size = b.size;
					this.setValue = Zc(b.type)
				}

				function vc(a) {
					this.id = a;
					this.seq = [];
					this.map = {}
				}

				function nb(a, b) {
					this.seq = [];
					this.map = {};
					for (var h =
							a.getProgramParameter(b, 35718), c = 0; c < h; ++c) {
						var t = a.getActiveUniform(b, c),
							d = a.getUniformLocation(b, t.name),
							f = this,
							e = t.name,
							g = e.length;
						for (qh.lastIndex = 0;;) {
							var k = qh.exec(e),
								l = qh.lastIndex,
								m = k[1],
								n = k[3];
							"]" === k[2] && (m |= 0);
							if (void 0 === n || "[" === n && l + 2 === g) {
								e = f;
								t = void 0 === n ? new gd(m, t, d) : new uc(m, t, d);
								e.seq.push(t);
								e.map[t.id] = t;
								break
							} else n = f.map[m], void 0 === n && (n = new vc(m), m = f, f = n, m.seq.push(f), m.map[f.id] = f), f = n
						}
					}
				}

				function Gc(a, b, c) {
					b = a.createShader(b);
					a.shaderSource(b, c);
					a.compileShader(b);
					return b
				}

				function Jc(a) {
					switch (a) {
						case 3E3:
							return ["Linear", "( value )"];
						case 3001:
							return ["sRGB", "( value )"];
						case 3002:
							return ["RGBE", "( value )"];
						case 3004:
							return ["RGBM", "( value, 7.0 )"];
						case 3005:
							return ["RGBM", "( value, 16.0 )"];
						case 3006:
							return ["RGBD", "( value, 256.0 )"];
						case 3007:
							return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
						case 3003:
							return ["LogLuv", "( value )"];
						default:
							throw Error("unsupported encoding: " + a);
					}
				}

				function Kc(a, b, c) {
					var h = a.getShaderParameter(b, 35713),
						t = a.getShaderInfoLog(b).trim();
					if (h && "" === t) return "";
					a = a.getShaderSource(b).split("\n");
					for (b = 0; b < a.length; b++) a[b] = b + 1 + ": " + a[b];
					a = a.join("\n");
					return "THREE.WebGLShader: gl.getShaderInfoLog() " + c + "\n" + t + a
				}

				function Ub(a, b) {
					b = Jc(b);
					return "vec4 " + a + "( vec4 value ) { return " + b[0] + "ToLinear" + b[1] + "; }"
				}

				function yd(a, b) {
					b = Jc(b);
					return "vec4 " + a + "( vec4 value ) { return LinearTo" + b[0] + b[1] + "; }"
				}

				function zd(a, b) {
					switch (b) {
						case 1:
							b = "Linear";
							break;
						case 2:
							b = "Reinhard";
							break;
						case 3:
							b = "Uncharted2";
							break;
						case 4:
							b = "OptimizedCineon";
							break;
						case 5:
							b =
								"ACESFilmic";
							break;
						default:
							throw Error("unsupported toneMapping: " + b);
					}
					return "vec3 " + a + "( vec3 color ) { return " + b + "ToneMapping( color ); }"
				}

				function Ad(a, b, c) {
					a = a || {};
					return [a.derivatives || b.envMapCubeUV || b.bumpMap || b.tangentSpaceNormalMap || b.clearcoatNormalMap || b.flatShading ?
						"#extension GL_OES_standard_derivatives : enable" : "", (a.fragDepth || b.logarithmicDepthBuffer) && c.get(
							"EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", a.drawBuffers && c.get(
							"WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" :
						"", (a.shaderTextureLOD || b.envMap) && c.get("EXT_shader_texture_lod") ?
						"#extension GL_EXT_shader_texture_lod : enable" : ""
					].filter(Hb).join("\n")
				}

				function Bd(a) {
					var h = [],
						b;
					for (b in a) {
						var c = a[b];
						!1 !== c && h.push("#define " + b + " " + c)
					}
					return h.join("\n")
				}

				function Hb(a) {
					return "" !== a
				}

				function Qc(a, b) {
					return a.replace(/NUM_DIR_LIGHTS/g, b.numDirLights).replace(/NUM_SPOT_LIGHTS/g, b.numSpotLights).replace(
						/NUM_RECT_AREA_LIGHTS/g, b.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, b.numPointLights).replace(
						/NUM_HEMI_LIGHTS/g,
						b.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, b.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, b
						.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, b.numPointLightShadows)
				}

				function Rc(a, b) {
					return a.replace(/NUM_CLIPPING_PLANES/g, b.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, b.numClippingPlanes -
						b.numClipIntersection)
				}

				function mc(a, b) {
					a = Ca[b];
					if (void 0 === a) throw Error("Can not resolve #include <" + b + ">");
					return a.replace(rh, mc)
				}

				function $c(a, b, c, d) {
					a = "";
					for (b = parseInt(b); b < parseInt(c); b++) a +=
						d.replace(/\[ i \]/g, "[ " + b + " ]").replace(/UNROLLED_LOOP_INDEX/g, b);
					return a
				}

				function dd(a) {
					var h = "precision " + a.precision + " float;\nprecision " + a.precision + " int;";
					"highp" === a.precision ? h += "\n#define HIGH_PRECISION" : "mediump" === a.precision ? h +=
						"\n#define MEDIUM_PRECISION" : "lowp" === a.precision && (h += "\n#define LOW_PRECISION");
					return h
				}

				function Nd(a) {
					var h = "SHADOWMAP_TYPE_BASIC";
					1 === a.shadowMapType ? h = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType ? h = "SHADOWMAP_TYPE_PCF_SOFT" : 3 ===
						a.shadowMapType && (h = "SHADOWMAP_TYPE_VSM");
					return h
				}

				function Od(a, b) {
					var h = "ENVMAP_TYPE_CUBE";
					if (a.envMap) switch (b.envMap.mapping) {
						case 301:
						case 302:
							h = "ENVMAP_TYPE_CUBE";
							break;
						case 306:
						case 307:
							h = "ENVMAP_TYPE_CUBE_UV";
							break;
						case 303:
						case 304:
							h = "ENVMAP_TYPE_EQUIREC";
							break;
						case 305:
							h = "ENVMAP_TYPE_SPHERE"
					}
					return h
				}

				function Qd(a, b) {
					var h = "ENVMAP_MODE_REFLECTION";
					if (a.envMap) switch (b.envMap.mapping) {
						case 302:
						case 304:
							h = "ENVMAP_MODE_REFRACTION"
					}
					return h
				}

				function Sd(a, b) {
					var h = "ENVMAP_BLENDING_MULTIPLY";
					if (a.envMap) switch (b.combine) {
						case 0:
							h = "ENVMAP_BLENDING_MULTIPLY";
							break;
						case 1:
							h = "ENVMAP_BLENDING_MIX";
							break;
						case 2:
							h = "ENVMAP_BLENDING_ADD"
					}
					return h
				}

				function Vd(a, b, c, d, f, e) {
					var h = a.getContext(),
						t = d.defines,
						x = f.vertexShader,
						y = f.fragmentShader,
						g = Nd(e),
						k = Od(e, d),
						l = Qd(e, d),
						E = Sd(e, d),
						O = 0 < a.gammaFactor ? a.gammaFactor : 1,
						m = e.isWebGL2 ? "" : Ad(d.extensions, e, b),
						n = Bd(t),
						r = h.createProgram(),
						p = (t = a.getRenderTarget()) && t.isWebGLMultiviewRenderTarget ? t.numViews : 0;
					d.isRawShaderMaterial ? (t = [n].filter(Hb).join("\n"), 0 < t.length && (t += "\n"), b = [m, n].filter(Hb).join(
						"\n"), 0 < b.length && (b +=
						"\n")) : (t = [dd(e), "#define SHADER_NAME " + f.name, n, e.instancing ? "#define USE_INSTANCING" : "", e.supportsVertexTextures ?
						"#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + O, "#define MAX_BONES " + e.maxBones, e.useFog &&
						e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" :
						"", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + l : "", e.lightMap ?
						"#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" :
						"", e.bumpMap ? "#define USE_BUMPMAP" :
						"", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ?
						"#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ?
						"#define TANGENTSPACE_NORMALMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.displacementMap &&
						e.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" :
						"", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ?
						"#define USE_ALPHAMAP" : "", e.vertexTangents ?
						"#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexUvs ? "#define USE_UV" : "",
						e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.useVertexTexture ?
						"#define BONE_TEXTURE" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && !1 === e.flatShading ?
						"#define USE_MORPHNORMALS" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ?
						"#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ?
						"#define " + g : "", e.sizeAttenuation ?
						"#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer &&
						(e.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;",
						"uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;",
						"uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "#ifdef USE_INSTANCING",
						" attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;",
						"attribute vec2 uv;",
						"#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;",
						"#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;",
						"\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS",
						"\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;",
						"\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;",
						"\t\tattribute vec3 morphTarget5;",
						"\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif",
						"#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"
					].filter(Hb).join("\n"), b = [m, dd(e), "#define SHADER_NAME " + f.name, n, e.alphaTest ?
						"#define ALPHATEST " + e.alphaTest + (e.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + O, e.useFog &&
						e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" :
						"", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" :
						"", e.envMap ? "#define " + k : "", e.envMap ? "#define " + l : "", e.envMap ? "#define " + E : "", e.lightMap ?
						"#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" :
						"", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ?
						"#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ?
						"#define TANGENTSPACE_NORMALMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.specularMap ?
						"#define USE_SPECULARMAP" :
						"", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ?
						"#define USE_ALPHAMAP" : "", e.sheen ? "#define USE_SHEEN" : "", e.vertexTangents ? "#define USE_TANGENT" :
						"", e.vertexColors ? "#define USE_COLOR" : "", e.vertexUvs ? "#define USE_UV" : "", e.gradientMap ?
						"#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ?
						"#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ?
						"#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " +
						g : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.physicallyCorrectLights ?
						"#define PHYSICALLY_CORRECT_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer &&
						(e.isWebGL2 || b.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", (d.extensions && d.extensions.shaderTextureLOD ||
							e.envMap) && (e.isWebGL2 || b.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "",
						"uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== e.toneMapping ? "#define TONE_MAPPING" :
						"", 0 !== e.toneMapping ? Ca.tonemapping_pars_fragment : "", 0 !== e.toneMapping ? zd("toneMapping", e.toneMapping) :
						"", e.dithering ? "#define DITHERING" : "", e.outputEncoding || e.mapEncoding || e.matcapEncoding || e.envMapEncoding ||
						e.emissiveMapEncoding ? Ca.encodings_pars_fragment : "", e.mapEncoding ? Ub("mapTexelToLinear", e.mapEncoding) :
						"", e.matcapEncoding ? Ub("matcapTexelToLinear", e.matcapEncoding) : "", e.envMapEncoding ? Ub(
							"envMapTexelToLinear", e.envMapEncoding) : "", e.emissiveMapEncoding ? Ub("emissiveMapTexelToLinear", e.emissiveMapEncoding) :
						"", e.outputEncoding ? yd("linearToOutputTexel", e.outputEncoding) : "", e.depthPacking ?
						"#define DEPTH_PACKING " + d.depthPacking : "", "\n"
					].filter(Hb).join("\n"));
					x = x.replace(rh, mc);
					x = Qc(x, e);
					x = Rc(x, e);
					y = y.replace(rh, mc);
					y = Qc(y, e);
					y = Rc(y, e);
					x = x.replace(Bi, $c);
					y = y.replace(Bi, $c);
					e.isWebGL2 && !d.isRawShaderMaterial && (g = !1, k = /^\s*#version\s+300\s+es\s*\n/, d.isShaderMaterial && null !==
						x.match(k) && null !== y.match(k) && (g = !0, x = x.replace(k, ""), y = y.replace(k, "")), t =
						"#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" +
						t, b = ["#version 300 es\n\n#define varying in", g ? "" : "out highp vec4 pc_fragColor;", g ? "" :
							"#define gl_FragColor pc_fragColor",
							"#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"
						].join("\n") +
						"\n" + b, 0 < p && (t = t.replace("#version 300 es\n", [
								"#version 300 es\n\n#extension GL_OVR_multiview2 : require", "layout(num_views = " + p + ") in;",
								"#define VIEW_ID gl_ViewID_OVR"
							].join("\n")), t = t.replace(
								"uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;",
								["uniform mat4 modelViewMatrices[" + p + "];", "uniform mat4 projectionMatrices[" + p + "];",
									"uniform mat4 viewMatrices[" + p + "];", "uniform mat3 normalMatrices[" + p + "];",
									"#define modelViewMatrix modelViewMatrices[VIEW_ID]\n#define projectionMatrix projectionMatrices[VIEW_ID]\n#define viewMatrix viewMatrices[VIEW_ID]\n#define normalMatrix normalMatrices[VIEW_ID]"
								].join("\n")),
							b = b.replace("#version 300 es\n",
								"#version 300 es\n\n#extension GL_OVR_multiview2 : require\n#define VIEW_ID gl_ViewID_OVR"), b = b.replace(
								"uniform mat4 viewMatrix;", ["uniform mat4 viewMatrices[" + p + "];",
									"#define viewMatrix viewMatrices[VIEW_ID]"
								].join("\n"))));
					y = b + y;
					x = Gc(h, 35633, t + x);
					y = Gc(h, 35632, y);
					h.attachShader(r, x);
					h.attachShader(r, y);
					void 0 !== d.index0AttributeName ? h.bindAttribLocation(r, 0, d.index0AttributeName) : !0 === e.morphTargets &&
						h.bindAttribLocation(r, 0, "position");
					h.linkProgram(r);
					if (a.debug.checkShaderErrors) {
						a =
							h.getProgramInfoLog(r).trim();
						e = h.getShaderInfoLog(x).trim();
						g = h.getShaderInfoLog(y).trim();
						l = k = !0;
						if (!1 === h.getProgramParameter(r, 35714)) k = !1, E = Kc(h, x, "vertex"), O = Kc(h, y, "fragment"), console.error(
							"THREE.WebGLProgram: shader error: ", h.getError(), "35715", h.getProgramParameter(r, 35715),
							"gl.getProgramInfoLog", a, E, O);
						else if ("" !== a) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a);
						else if ("" === e || "" === g) l = !1;
						l && (this.diagnostics = {
							runnable: k,
							material: d,
							programLog: a,
							vertexShader: {
								log: e,
								prefix: t
							},
							fragmentShader: {
								log: g,
								prefix: b
							}
						})
					}
					h.deleteShader(x);
					h.deleteShader(y);
					var v;
					this.getUniforms = function() {
						void 0 === v && (v = new nb(h, r));
						return v
					};
					var q;
					this.getAttributes = function() {
						if (void 0 === q) {
							for (var a = {}, b = h.getProgramParameter(r, 35721), c = 0; c < b; c++) {
								var t = h.getActiveAttrib(r, c).name;
								a[t] = h.getAttribLocation(r, t)
							}
							q = a
						}
						return q
					};
					this.destroy = function() {
						h.deleteProgram(r);
						this.program = void 0
					};
					this.name = f.name;
					this.id = Vj++;
					this.code = c;
					this.usedTimes = 1;
					this.program = r;
					this.vertexShader = x;
					this.fragmentShader =
						y;
					this.numMultiviewViews = p;
					return this
				}

				function Wd(a, b, c) {
					function h(a, h) {
						if (a) a.isTexture ? b = a.encoding : a.isWebGLRenderTarget && (console.warn(
							"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
						), b = a.texture.encoding);
						else var b = 3E3;
						3E3 === b && h && (b = 3007);
						return b
					}
					var t = [],
						d = {
							MeshDepthMaterial: "depth",
							MeshDistanceMaterial: "distanceRGBA",
							MeshNormalMaterial: "normal",
							MeshBasicMaterial: "basic",
							MeshLambertMaterial: "lambert",
							MeshPhongMaterial: "phong",
							MeshToonMaterial: "phong",
							MeshStandardMaterial: "physical",
							MeshPhysicalMaterial: "physical",
							MeshMatcapMaterial: "matcap",
							LineBasicMaterial: "basic",
							LineDashedMaterial: "dashed",
							PointsMaterial: "points",
							ShadowMaterial: "shadow",
							SpriteMaterial: "sprite"
						},
						f =
						"precision supportsVertexTextures instancing map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap tangentSpaceNormalMap clearcoatNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp2 flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering sheen"
						.split(" ");
					this.getParameters = function(b, t, f, e, x, y, g) {
						var k = d[b.type];
						if (g.isSkinnedMesh) {
							var l = g.skeleton.bones;
							if (c.floatVertexTextures) l = 1024;
							else {
								var E = Math.min(Math.floor((c.maxVertexUniforms - 20) / 4), l.length);
								E < l.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + l.length + " bones. This GPU supports " +
									E + "."), l = 0) : l = E
							}
						} else l = 0;
						E = c.precision;
						null !== b.precision && (E = c.getMaxPrecision(b.precision), E !== b.precision && console.warn(
							"THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", E, "instead."));
						var O = a.getRenderTarget();
						return {
							isWebGL2: c.isWebGL2,
							shaderID: k,
							precision: E,
							instancing: !0 === g.isInstancedMesh,
							supportsVertexTextures: c.vertexTextures,
							outputEncoding: h(O ? O.texture : null, a.gammaOutput),
							map: !!b.map,
							mapEncoding: h(b.map, a.gammaInput),
							matcap: !!b.matcap,
							matcapEncoding: h(b.matcap, a.gammaInput),
							envMap: !!b.envMap,
							envMapMode: b.envMap && b.envMap.mapping,
							envMapEncoding: h(b.envMap, a.gammaInput),
							envMapCubeUV: !!b.envMap && (306 === b.envMap.mapping || 307 === b.envMap.mapping),
							lightMap: !!b.lightMap,
							aoMap: !!b.aoMap,
							emissiveMap: !!b.emissiveMap,
							emissiveMapEncoding: h(b.emissiveMap, a.gammaInput),
							bumpMap: !!b.bumpMap,
							normalMap: !!b.normalMap,
							objectSpaceNormalMap: 1 === b.normalMapType,
							tangentSpaceNormalMap: 0 === b.normalMapType,
							clearcoatNormalMap: !!b.clearcoatNormalMap,
							displacementMap: !!b.displacementMap,
							roughnessMap: !!b.roughnessMap,
							metalnessMap: !!b.metalnessMap,
							specularMap: !!b.specularMap,
							alphaMap: !!b.alphaMap,
							gradientMap: !!b.gradientMap,
							sheen: !!b.sheen,
							combine: b.combine,
							vertexTangents: b.normalMap && b.vertexTangents,
							vertexColors: b.vertexColors,
							vertexUvs: !!b.map || !!b.bumpMap || !!b.normalMap || !!b.specularMap || !!b.alphaMap || !!b.emissiveMap ||
								!!b.roughnessMap || !!b.metalnessMap || !!b.clearcoatNormalMap,
							fog: !!e,
							useFog: b.fog,
							fogExp2: e && e.isFogExp2,
							flatShading: b.flatShading,
							sizeAttenuation: b.sizeAttenuation,
							logarithmicDepthBuffer: c.logarithmicDepthBuffer,
							skinning: b.skinning && 0 < l,
							maxBones: l,
							useVertexTexture: c.floatVertexTextures,
							morphTargets: b.morphTargets,
							morphNormals: b.morphNormals,
							maxMorphTargets: a.maxMorphTargets,
							maxMorphNormals: a.maxMorphNormals,
							numDirLights: t.directional.length,
							numPointLights: t.point.length,
							numSpotLights: t.spot.length,
							numRectAreaLights: t.rectArea.length,
							numHemiLights: t.hemi.length,
							numDirLightShadows: t.directionalShadowMap.length,
							numPointLightShadows: t.pointShadowMap.length,
							numSpotLightShadows: t.spotShadowMap.length,
							numClippingPlanes: x,
							numClipIntersection: y,
							dithering: b.dithering,
							shadowMapEnabled: a.shadowMap.enabled && 0 < f.length,
							shadowMapType: a.shadowMap.type,
							toneMapping: b.toneMapped ? a.toneMapping : 0,
							physicallyCorrectLights: a.physicallyCorrectLights,
							premultipliedAlpha: b.premultipliedAlpha,
							alphaTest: b.alphaTest,
							doubleSided: 2 === b.side,
							flipSided: 1 === b.side,
							depthPacking: void 0 !== b.depthPacking ? b.depthPacking : !1
						}
					};
					this.getProgramCode = function(h, b) {
						var c = [];
						b.shaderID ? c.push(b.shaderID) : (c.push(h.fragmentShader), c.push(h.vertexShader));
						if (void 0 !== h.defines)
							for (var t in h.defines) c.push(t), c.push(h.defines[t]);
						for (t = 0; t < f.length; t++) c.push(b[f[t]]);
						c.push(h.onBeforeCompile.toString());
						c.push(a.gammaOutput);
						c.push(a.gammaFactor);
						return c.join()
					};
					this.acquireProgram =
						function(h, c, d, f) {
							for (var e, x = 0, y = t.length; x < y; x++) {
								var g = t[x];
								if (g.code === f) {
									e = g;
									++e.usedTimes;
									break
								}
							}
							void 0 === e && (e = new Vd(a, b, f, h, c, d), t.push(e));
							return e
						};
					this.releaseProgram = function(a) {
						if (0 === --a.usedTimes) {
							var h = t.indexOf(a);
							t[h] = t[t.length - 1];
							t.pop();
							a.destroy()
						}
					};
					this.programs = t
				}

				function Yd() {
					var a = new Fa;
					return {
						get: function(h) {
							var b = a.get(h);
							void 0 === b && (b = {}, a.set(h, b));
							return b
						},
						remove: function(h) {
							a.delete(h)
						},
						update: function(h, b, c) {
							a.get(h)[b] = c
						},
						dispose: function() {
							a = new Fa
						}
					}
				}

				function de(a,
					b) {
					return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder -
						b.renderOrder : a.program !== b.program ? a.program.id - b.program.id : a.material.id !== b.material.id ? a.material
						.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
				}

				function ee(a, b) {
					return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder -
						b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
				}

				function xd() {
					function a(a, h, t, d, f, x) {
						var y = b[c];
						void 0 === y ? (y = {
							id: a.id,
							object: a,
							geometry: h,
							material: t,
							program: t.program || e,
							groupOrder: d,
							renderOrder: a.renderOrder,
							z: f,
							group: x
						}, b[c] = y) : (y.id = a.id, y.object = a, y.geometry = h, y.material = t, y.program = t.program || e, y.groupOrder =
							d, y.renderOrder = a.renderOrder, y.z = f, y.group = x);
						c++;
						return y
					}
					var b = [],
						c = 0,
						d = [],
						f = [],
						e = {
							id: -1
						};
					return {
						opaque: d,
						transparent: f,
						init: function() {
							c = 0;
							d.length = 0;
							f.length = 0
						},
						push: function(h, b, c, t, e, x) {
							h = a(h, b, c, t, e, x);
							(!0 === c.transparent ? f : d).push(h)
						},
						unshift: function(h, b, c, t, e, x) {
							h = a(h, b, c, t, e, x);
							(!0 === c.transparent ? f : d).unshift(h)
						},
						sort: function() {
							1 < d.length && d.sort(de);
							1 < f.length && f.sort(ee)
						}
					}
				}

				function fe() {
					function a(h) {
						h = h.target;
						h.removeEventListener("dispose", a);
						b.delete(h)
					}
					var b = new Fa;
					return {
						get: function(h, c) {
							var t = b.get(h);
							if (void 0 === t) {
								var d = new xd;
								b.set(h, new Fa);
								b.get(h).set(c, d);
								h.addEventListener("dispose", a)
							} else d = t.get(c), void 0 === d && (d = new xd, t.set(c, d));
							return d
						},
						dispose: function() {
							b = new Fa
						}
					}
				}

				function he() {
					var a = {};
					return {
						get: function(h) {
							if (void 0 !== a[h.id]) return a[h.id];
							switch (h.type) {
								case "DirectionalLight":
									var b = {
										direction: new f,
										color: new Q,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new d
									};
									break;
								case "SpotLight":
									b = {
										position: new f,
										direction: new f,
										color: new Q,
										distance: 0,
										coneCos: 0,
										penumbraCos: 0,
										decay: 0,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new d
									};
									break;
								case "PointLight":
									b = {
										position: new f,
										color: new Q,
										distance: 0,
										decay: 0,
										shadow: !1,
										shadowBias: 0,
										shadowRadius: 1,
										shadowMapSize: new d,
										shadowCameraNear: 1,
										shadowCameraFar: 1E3
									};
									break;
								case "HemisphereLight":
									b = {
										direction: new f,
										skyColor: new Q,
										groundColor: new Q
									};
									break;
								case "RectAreaLight":
									b = {
										color: new Q,
										position: new f,
										halfWidth: new f,
										halfHeight: new f
									}
							}
							return a[h.id] = b
						}
					}
				}

				function je(a, b) {
					return (b.castShadow ? 1 : 0) - (a.castShadow ? 1 : 0)
				}

				function ye() {
					for (var a = new he, b = {
							version: 0,
							hash: {
								directionalLength: -1,
								pointLength: -1,
								spotLength: -1,
								rectAreaLength: -1,
								hemiLength: -1,
								numDirectionalShadows: -1,
								numPointShadows: -1,
								numSpotShadows: -1
							},
							ambient: [0, 0, 0],
							probe: [],
							directional: [],
							directionalShadowMap: [],
							directionalShadowMatrix: [],
							spot: [],
							spotShadowMap: [],
							spotShadowMatrix: [],
							rectArea: [],
							point: [],
							pointShadowMap: [],
							pointShadowMatrix: [],
							hemi: [],
							numDirectionalShadows: -1,
							numPointShadows: -1,
							numSpotShadows: -1
						}, c = 0; 9 > c; c++) b.probe.push(new f);
					var d = new f,
						e = new v,
						g = new v;
					return {
						setup: function(h, c, t) {
							for (var f = 0, x = 0, y = 0, k = 0; 9 > k; k++) b.probe[k].set(0, 0, 0);
							var l = c = 0,
								E = 0,
								O = 0,
								m = 0,
								ka = 0,
								n = 0,
								ea = 0;
							t = t.matrixWorldInverse;
							h.sort(je);
							k = 0;
							for (var Y = h.length; k < Y; k++) {
								var r = h[k],
									p = r.color,
									v = r.intensity,
									q = r.distance,
									w = r.shadow && r.shadow.map ? r.shadow.map.texture : null;
								if (r.isAmbientLight) f += p.r *
									v, x += p.g * v, y += p.b * v;
								else if (r.isLightProbe)
									for (w = 0; 9 > w; w++) b.probe[w].addScaledVector(r.sh.coefficients[w], v);
								else if (r.isDirectionalLight) {
									var u = a.get(r);
									u.color.copy(r.color).multiplyScalar(r.intensity);
									u.direction.setFromMatrixPosition(r.matrixWorld);
									d.setFromMatrixPosition(r.target.matrixWorld);
									u.direction.sub(d);
									u.direction.transformDirection(t);
									if (u.shadow = r.castShadow) v = r.shadow, u.shadowBias = v.bias, u.shadowRadius = v.radius, u.shadowMapSize =
										v.mapSize, b.directionalShadowMap[c] = w, b.directionalShadowMatrix[c] =
										r.shadow.matrix, ka++;
									b.directional[c] = u;
									c++
								} else if (r.isSpotLight) {
									u = a.get(r);
									u.position.setFromMatrixPosition(r.matrixWorld);
									u.position.applyMatrix4(t);
									u.color.copy(p).multiplyScalar(v);
									u.distance = q;
									u.direction.setFromMatrixPosition(r.matrixWorld);
									d.setFromMatrixPosition(r.target.matrixWorld);
									u.direction.sub(d);
									u.direction.transformDirection(t);
									u.coneCos = Math.cos(r.angle);
									u.penumbraCos = Math.cos(r.angle * (1 - r.penumbra));
									u.decay = r.decay;
									if (u.shadow = r.castShadow) v = r.shadow, u.shadowBias = v.bias, u.shadowRadius =
										v.radius, u.shadowMapSize = v.mapSize, b.spotShadowMap[E] = w, b.spotShadowMatrix[E] = r.shadow.matrix,
										ea++;
									b.spot[E] = u;
									E++
								} else if (r.isRectAreaLight) u = a.get(r), u.color.copy(p).multiplyScalar(v), u.position.setFromMatrixPosition(
									r.matrixWorld), u.position.applyMatrix4(t), g.identity(), e.copy(r.matrixWorld), e.premultiply(t), g.extractRotation(
									e), u.halfWidth.set(.5 * r.width, 0, 0), u.halfHeight.set(0, .5 * r.height, 0), u.halfWidth.applyMatrix4(
									g), u.halfHeight.applyMatrix4(g), b.rectArea[O] = u, O++;
								else if (r.isPointLight) {
									u =
										a.get(r);
									u.position.setFromMatrixPosition(r.matrixWorld);
									u.position.applyMatrix4(t);
									u.color.copy(r.color).multiplyScalar(r.intensity);
									u.distance = r.distance;
									u.decay = r.decay;
									if (u.shadow = r.castShadow) v = r.shadow, u.shadowBias = v.bias, u.shadowRadius = v.radius, u.shadowMapSize =
										v.mapSize, u.shadowCameraNear = v.camera.near, u.shadowCameraFar = v.camera.far, b.pointShadowMap[l] = w,
										b.pointShadowMatrix[l] = r.shadow.matrix, n++;
									b.point[l] = u;
									l++
								} else r.isHemisphereLight && (u = a.get(r), u.direction.setFromMatrixPosition(r.matrixWorld),
									u.direction.transformDirection(t), u.direction.normalize(), u.skyColor.copy(r.color).multiplyScalar(v), u
									.groundColor.copy(r.groundColor).multiplyScalar(v), b.hemi[m] = u, m++)
							}
							b.ambient[0] = f;
							b.ambient[1] = x;
							b.ambient[2] = y;
							h = b.hash;
							if (h.directionalLength !== c || h.pointLength !== l || h.spotLength !== E || h.rectAreaLength !== O || h.hemiLength !==
								m || h.numDirectionalShadows !== ka || h.numPointShadows !== n || h.numSpotShadows !== ea) b.directional.length =
								c, b.spot.length = E, b.rectArea.length = O, b.point.length = l, b.hemi.length = m, b.directionalShadowMap.length =
								ka, b.pointShadowMap.length = n, b.spotShadowMap.length = ea, b.directionalShadowMatrix.length = ka, b.pointShadowMatrix
								.length = n, b.spotShadowMatrix.length = ea, h.directionalLength = c, h.pointLength = l, h.spotLength = E,
								h.rectAreaLength = O, h.hemiLength = m, h.numDirectionalShadows = ka, h.numPointShadows = n, h.numSpotShadows =
								ea, b.version = Wj++
						},
						state: b
					}
				}

				function Kd() {
					var a = new ye,
						b = [],
						c = [];
					return {
						init: function() {
							b.length = 0;
							c.length = 0
						},
						state: {
							lightsArray: b,
							shadowsArray: c,
							lights: a
						},
						setupLights: function(h) {
							a.setup(b, c, h)
						},
						pushLight: function(a) {
							b.push(a)
						},
						pushShadow: function(a) {
							c.push(a)
						}
					}
				}

				function Ae() {
					function a(h) {
						h = h.target;
						h.removeEventListener("dispose", a);
						b.delete(h)
					}
					var b = new Fa;
					return {
						get: function(h, c) {
							if (!1 === b.has(h)) {
								var t = new Kd;
								b.set(h, new Fa);
								b.get(h).set(c, t);
								h.addEventListener("dispose", a)
							} else !1 === b.get(h).has(c) ? (t = new Kd, b.get(h).set(c, t)) : t = b.get(h).get(c);
							return t
						},
						dispose: function() {
							b = new Fa
						}
					}
				}

				function tb(a) {
					F.call(this);
					this.type = "MeshDepthMaterial";
					this.depthPacking = 3200;
					this.morphTargets = this.skinning = !1;
					this.displacementMap =
						this.alphaMap = this.map = null;
					this.displacementScale = 1;
					this.displacementBias = 0;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.fog = !1;
					this.setValues(a)
				}

				function ub(a) {
					F.call(this);
					this.type = "MeshDistanceMaterial";
					this.referencePosition = new f;
					this.nearDistance = 1;
					this.farDistance = 1E3;
					this.morphTargets = this.skinning = !1;
					this.displacementMap = this.alphaMap = this.map = null;
					this.displacementScale = 1;
					this.displacementBias = 0;
					this.fog = !1;
					this.setValues(a)
				}

				function Md(a, b, c) {
					function h(h, b, c, t, d, f) {
						var e = h.geometry;
						var x = k;
						var y = h.customDepthMaterial;
						c.isPointLight && (x = l, y = h.customDistanceMaterial);
						y ? x = y : (y = !1, b.morphTargets && (e && e.isBufferGeometry ? y = e.morphAttributes && e.morphAttributes.position &&
								0 < e.morphAttributes.position.length : e && e.isGeometry && (y = e.morphTargets && 0 < e.morphTargets.length)
							), h.isSkinnedMesh && !1 === b.skinning && console.warn(
								"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", h), h = h.isSkinnedMesh &&
							b.skinning, e = 0, y && (e |= 1), h && (e |= 2), x = x[e]);
						a.localClippingEnabled && !0 ===
							b.clipShadows && 0 !== b.clippingPlanes.length && (e = x.uuid, y = b.uuid, h = r[e], void 0 === h && (h = {},
								r[e] = h), e = h[y], void 0 === e && (e = x.clone(), h[y] = e), x = e);
						x.visible = b.visible;
						x.wireframe = b.wireframe;
						x.side = 3 === f ? null != b.shadowSide ? b.shadowSide : b.side : null != b.shadowSide ? b.shadowSide : p[b.side];
						x.clipShadows = b.clipShadows;
						x.clippingPlanes = b.clippingPlanes;
						x.clipIntersection = b.clipIntersection;
						x.wireframeLinewidth = b.wireframeLinewidth;
						x.linewidth = b.linewidth;
						c.isPointLight && x.isMeshDistanceMaterial && (x.referencePosition.setFromMatrixPosition(c.matrixWorld),
							x.nearDistance = t, x.farDistance = d);
						return x
					}

					function t(c, d, e, x, y) {
						if (!1 !== c.visible) {
							if (c.layers.test(d.layers) && (c.isMesh || c.isLine || c.isPoints) && (c.castShadow || c.receiveShadow && 3 ===
									y) && (!c.frustumCulled || f.intersectsObject(c))) {
								c.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, c.matrixWorld);
								var g = b.update(c),
									k = c.material;
								if (Array.isArray(k))
									for (var l = g.groups, E = 0, O = l.length; E < O; E++) {
										var m = l[E],
											ka = k[m.materialIndex];
										ka && ka.visible && (ka = h(c, ka, x, e.near, e.far, y), a.renderBufferDirect(e, null, g,
											ka, c, m))
									} else k.visible && (ka = h(c, k, x, e.near, e.far, y), a.renderBufferDirect(e, null, g, ka, c, null))
							}
							c = c.children;
							g = 0;
							for (k = c.length; g < k; g++) t(c[g], d, e, x, y)
						}
					}
					var f = new U,
						e = new d,
						x = new d,
						g = new m,
						k = Array(4),
						l = Array(4),
						r = {},
						p = {
							0: 1,
							1: 0,
							2: 2
						},
						v = new sa({
							defines: {
								SAMPLE_RATE: .25,
								HALF_SAMPLE_RATE: .125
							},
							uniforms: {
								shadow_pass: {
									value: null
								},
								resolution: {
									value: new d
								},
								radius: {
									value: 4
								}
							},
							vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
							fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n  \n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = decodeHalfRGBA ( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = pow( squared_mean - mean * mean, 0.5 );\n  gl_FragColor = encodeHalfRGBA( vec2( mean, std_dev ) );\n}"
						}),
						q = v.clone();
					q.defines.HORIZONAL_PASS = 1;
					var u = new I;
					u.addAttribute("position", new R(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
					var w = new ha(u, v);
					for (u = 0; 4 !== u; ++u) {
						var A = 0 !== (u & 1),
							z = 0 !== (u & 2),
							D = new tb({
								depthPacking: 3201,
								morphTargets: A,
								skinning: z
							});
						k[u] = D;
						A = new ub({
							morphTargets: A,
							skinning: z
						});
						l[u] = A
					}
					var G = this;
					this.enabled = !1;
					this.autoUpdate = !0;
					this.needsUpdate = !1;
					this.type = 1;
					this.render = function(h, d, y) {
						if (!1 !== G.enabled && (!1 !== G.autoUpdate || !1 !== G.needsUpdate) && 0 !== h.length) {
							var k = a.getRenderTarget(),
								l = a.getActiveCubeFace(),
								E = a.getActiveMipmapLevel(),
								O = a.state;
							O.setBlending(0);
							O.buffers.color.setClear(1, 1, 1, 1);
							O.buffers.depth.setTest(!0);
							O.setScissorTest(!1);
							for (var m = 0, ka = h.length; m < ka; m++) {
								var ea = h[m],
									Y = ea.shadow;
								if (void 0 === Y) console.warn("THREE.WebGLShadowMap:", ea, "has no shadow.");
								else {
									e.copy(Y.mapSize);
									var r = Y.getFrameExtents();
									e.multiply(r);
									x.copy(Y.mapSize);
									if (e.x > c || e.y > c) console.warn("THREE.WebGLShadowMap:", ea,
										"has shadow exceeding max texture size, reducing"), e.x > c && (x.x = Math.floor(c /
										r.x), e.x = x.x * r.x, Y.mapSize.x = x.x), e.y > c && (x.y = Math.floor(c / r.y), e.y = x.y * r.y, Y.mapSize
										.y = x.y);
									null !== Y.map || Y.isPointLightShadow || 3 !== this.type || (r = {
										minFilter: 1006,
										magFilter: 1006,
										format: 1023
									}, Y.map = new n(e.x, e.y, r), Y.map.texture.name = ea.name + ".shadowMap", Y.mapPass = new n(e.x, e.y,
										r), Y.camera.updateProjectionMatrix());
									null === Y.map && (r = {
										minFilter: 1003,
										magFilter: 1003,
										format: 1023
									}, Y.map = new n(e.x, e.y, r), Y.map.texture.name = ea.name + ".shadowMap", Y.camera.updateProjectionMatrix());
									a.setRenderTarget(Y.map);
									a.clear();
									r = Y.getViewportCount();
									for (var Ma = 0; Ma < r; Ma++) {
										var p = Y.getViewport(Ma);
										g.set(x.x * p.x, x.y * p.y, x.x * p.z, x.y * p.w);
										O.viewport(g);
										Y.updateMatrices(ea, y, Ma);
										f = Y.getFrustum();
										t(d, y, Y.camera, ea, this.type)
									}
									Y.isPointLightShadow || 3 !== this.type || (ea = Y, Y = y, r = b.update(w), v.uniforms.shadow_pass.value =
										ea.map.texture, v.uniforms.resolution.value = ea.mapSize, v.uniforms.radius.value = ea.radius, a.setRenderTarget(
											ea.mapPass), a.clear(), a.renderBufferDirect(Y, null, r, v, w, null), q.uniforms.shadow_pass.value = ea
										.mapPass.texture,
										q.uniforms.resolution.value = ea.mapSize, q.uniforms.radius.value = ea.radius, a.setRenderTarget(ea.map),
										a.clear(), a.renderBufferDirect(Y, null, r, q, w, null))
								}
							}
							G.needsUpdate = !1;
							a.setRenderTarget(k, l, E)
						}
					}
				}

				function Le(a, b, c, d) {
					function h(h, b, c) {
						var t = new Uint8Array(4),
							d = a.createTexture();
						a.bindTexture(h, d);
						a.texParameteri(h, 10241, 9728);
						a.texParameteri(h, 10240, 9728);
						for (h = 0; h < c; h++) a.texImage2D(b + h, 0, 6408, 1, 1, 0, 6408, 5121, t);
						return d
					}

					function t(h, c) {
						q[h] = 1;
						0 === u[h] && (a.enableVertexAttribArray(h), u[h] = 1);
						w[h] !==
							c && ((d.isWebGL2 ? a : b.get("ANGLE_instanced_arrays"))[d.isWebGL2 ? "vertexAttribDivisor" :
								"vertexAttribDivisorANGLE"](h, c), w[h] = c)
					}

					function f(h) {
						!0 !== A[h] && (a.enable(h), A[h] = !0)
					}

					function e(h) {
						!1 !== A[h] && (a.disable(h), A[h] = !1)
					}

					function x(h, b, t, d, x, y, g, k) {
						if (0 === h) G && (e(3042), G = !1);
						else if (G || (f(3042), G = !0), 5 !== h) {
							if (h !== C || k !== Kl) {
								if (100 !== K || 100 !== Q) a.blendEquation(32774), Q = K = 100;
								if (k) switch (h) {
									case 1:
										a.blendFuncSeparate(1, 771, 1, 771);
										break;
									case 2:
										a.blendFunc(1, 1);
										break;
									case 3:
										a.blendFuncSeparate(0, 0, 769,
											771);
										break;
									case 4:
										a.blendFuncSeparate(0, 768, 0, 770);
										break;
									default:
										console.error("THREE.WebGLState: Invalid blending: ", h)
								} else switch (h) {
									case 1:
										a.blendFuncSeparate(770, 771, 1, 771);
										break;
									case 2:
										a.blendFunc(770, 1);
										break;
									case 3:
										a.blendFunc(0, 769);
										break;
									case 4:
										a.blendFunc(0, 768);
										break;
									default:
										console.error("THREE.WebGLState: Invalid blending: ", h)
								}
								J = F = B = H = null;
								C = h;
								Kl = k
							}
						} else {
							x = x || b;
							y = y || t;
							g = g || d;
							if (b !== K || x !== Q) a.blendEquationSeparate(c.convert(b), c.convert(x)), K = b, Q = x;
							if (t !== H || d !== B || y !== F || g !== J) a.blendFuncSeparate(c.convert(t),
								c.convert(d), c.convert(y), c.convert(g)), H = t, B = d, F = y, J = g;
							C = h;
							Kl = null
						}
					}

					function y(h) {
						Ll !== h && (h ? a.frontFace(2304) : a.frontFace(2305), Ll = h)
					}

					function g(h) {
						0 !== h ? (f(2884), h !== Ml && (1 === h ? a.cullFace(1029) : 2 === h ? a.cullFace(1028) : a.cullFace(1032))) :
							e(2884);
						Ml = h
					}

					function k(h, b, c) {
						if (h) {
							if (f(32823), N !== b || M !== c) a.polygonOffset(b, c), N = b, M = c
						} else e(32823)
					}

					function l(h) {
						void 0 === h && (h = 33984 + L - 1);
						I !== h && (a.activeTexture(h), I = h)
					}
					var n = new function() {
							var h = !1,
								b = new m,
								c = null,
								t = new m(0, 0, 0, 0);
							return {
								setMask: function(b) {
									c ===
										b || h || (a.colorMask(b, b, b, b), c = b)
								},
								setLocked: function(a) {
									h = a
								},
								setClear: function(h, c, d, f, e) {
									!0 === e && (h *= f, c *= f, d *= f);
									b.set(h, c, d, f);
									!1 === t.equals(b) && (a.clearColor(h, c, d, f), t.copy(b))
								},
								reset: function() {
									h = !1;
									c = null;
									t.set(-1, 0, 0, 0)
								}
							}
						},
						r = new function() {
							var h = !1,
								b = null,
								c = null,
								t = null;
							return {
								setTest: function(a) {
									a ? f(2929) : e(2929)
								},
								setMask: function(c) {
									b === c || h || (a.depthMask(c), b = c)
								},
								setFunc: function(h) {
									if (c !== h) {
										if (h) switch (h) {
											case 0:
												a.depthFunc(512);
												break;
											case 1:
												a.depthFunc(519);
												break;
											case 2:
												a.depthFunc(513);
												break;
											case 3:
												a.depthFunc(515);
												break;
											case 4:
												a.depthFunc(514);
												break;
											case 5:
												a.depthFunc(518);
												break;
											case 6:
												a.depthFunc(516);
												break;
											case 7:
												a.depthFunc(517);
												break;
											default:
												a.depthFunc(515)
										} else a.depthFunc(515);
										c = h
									}
								},
								setLocked: function(a) {
									h = a
								},
								setClear: function(h) {
									t !== h && (a.clearDepth(h), t = h)
								},
								reset: function() {
									h = !1;
									t = c = b = null
								}
							}
						},
						p = new function() {
							var h = !1,
								b = null,
								c = null,
								t = null,
								d = null,
								x = null,
								y = null,
								g = null,
								k = null;
							return {
								setTest: function(a) {
									h || (a ? f(2960) : e(2960))
								},
								setMask: function(c) {
									b === c || h || (a.stencilMask(c),
										b = c)
								},
								setFunc: function(h, b, f) {
									if (c !== h || t !== b || d !== f) a.stencilFunc(h, b, f), c = h, t = b, d = f
								},
								setOp: function(h, b, c) {
									if (x !== h || y !== b || g !== c) a.stencilOp(h, b, c), x = h, y = b, g = c
								},
								setLocked: function(a) {
									h = a
								},
								setClear: function(h) {
									k !== h && (a.clearStencil(h), k = h)
								},
								reset: function() {
									h = !1;
									k = g = y = x = d = t = c = b = null
								}
							}
						},
						v = a.getParameter(34921),
						q = new Uint8Array(v),
						u = new Uint8Array(v),
						w = new Uint8Array(v),
						A = {},
						z = null,
						D = null,
						G = null,
						C = null,
						K = null,
						H = null,
						B = null,
						Q = null,
						F = null,
						J = null,
						Kl = !1,
						Ll = null,
						Ml = null,
						R = null,
						N = null,
						M = null,
						L = a.getParameter(35661),
						P = !1;
					v = 0;
					v = a.getParameter(7938); - 1 !== v.indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), P = 1 <= v) :
						-1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), P = 2 <= v);
					var I = null,
						S = {},
						wa = new m,
						U = new m,
						le = {};
					le[3553] = h(3553, 3553, 1);
					le[34067] = h(34067, 34069, 6);
					n.setClear(0, 0, 0, 1);
					r.setClear(1);
					p.setClear(0);
					f(2929);
					r.setFunc(3);
					y(!1);
					g(1);
					f(2884);
					x(0);
					return {
						buffers: {
							color: n,
							depth: r,
							stencil: p
						},
						initAttributes: function() {
							for (var a = 0, h = q.length; a < h; a++) q[a] = 0
						},
						enableAttribute: function(a) {
							t(a,
								0)
						},
						enableAttributeAndDivisor: t,
						disableUnusedAttributes: function() {
							for (var h = 0, b = u.length; h !== b; ++h) u[h] !== q[h] && (a.disableVertexAttribArray(h), u[h] = 0)
						},
						enable: f,
						disable: e,
						getCompressedTextureFormats: function() {
							if (null === z && (z = [], b.get("WEBGL_compressed_texture_pvrtc") || b.get("WEBGL_compressed_texture_s3tc") ||
									b.get("WEBGL_compressed_texture_etc1") || b.get("WEBGL_compressed_texture_astc")))
								for (var h = a.getParameter(34467), c = 0; c < h.length; c++) z.push(h[c]);
							return z
						},
						useProgram: function(h) {
							return D !== h ?
								(a.useProgram(h), D = h, !0) : !1
						},
						setBlending: x,
						setMaterial: function(a, h) {
							2 === a.side ? e(2884) : f(2884);
							var b = 1 === a.side;
							h && (b = !b);
							y(b);
							1 === a.blending && !1 === a.transparent ? x(0) : x(a.blending, a.blendEquation, a.blendSrc, a.blendDst, a.blendEquationAlpha,
								a.blendSrcAlpha, a.blendDstAlpha, a.premultipliedAlpha);
							r.setFunc(a.depthFunc);
							r.setTest(a.depthTest);
							r.setMask(a.depthWrite);
							n.setMask(a.colorWrite);
							h = a.stencilWrite;
							p.setTest(h);
							h && (p.setMask(a.stencilWriteMask), p.setFunc(a.stencilFunc, a.stencilRef, a.stencilFuncMask),
								p.setOp(a.stencilFail, a.stencilZFail, a.stencilZPass));
							k(a.polygonOffset, a.polygonOffsetFactor, a.polygonOffsetUnits)
						},
						setFlipSided: y,
						setCullFace: g,
						setLineWidth: function(h) {
							h !== R && (P && a.lineWidth(h), R = h)
						},
						setPolygonOffset: k,
						setScissorTest: function(a) {
							a ? f(3089) : e(3089)
						},
						activeTexture: l,
						bindTexture: function(h, b) {
							null === I && l();
							var c = S[I];
							void 0 === c && (c = {
								type: void 0,
								texture: void 0
							}, S[I] = c);
							if (c.type !== h || c.texture !== b) a.bindTexture(h, b || le[h]), c.type = h, c.texture = b
						},
						compressedTexImage2D: function() {
							try {
								a.compressedTexImage2D.apply(a,
									arguments)
							} catch (rk) {
								console.error("THREE.WebGLState:", rk)
							}
						},
						texImage2D: function() {
							try {
								a.texImage2D.apply(a, arguments)
							} catch (rk) {
								console.error("THREE.WebGLState:", rk)
							}
						},
						texImage3D: function() {
							try {
								a.texImage3D.apply(a, arguments)
							} catch (rk) {
								console.error("THREE.WebGLState:", rk)
							}
						},
						scissor: function(h) {
							!1 === wa.equals(h) && (a.scissor(h.x, h.y, h.z, h.w), wa.copy(h))
						},
						viewport: function(h) {
							!1 === U.equals(h) && (a.viewport(h.x, h.y, h.z, h.w), U.copy(h))
						},
						reset: function() {
							for (var h = 0; h < u.length; h++) 1 === u[h] && (a.disableVertexAttribArray(h),
								u[h] = 0);
							A = {};
							I = z = null;
							S = {};
							Ml = Ll = C = D = null;
							n.reset();
							r.reset();
							p.reset()
						}
					}
				}

				function Ne(a, b, c, d, f, e, g) {
					function h(a, h) {
						return G ? new OffscreenCanvas(a, h) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")
					}

					function t(a, b, c, t) {
						var d = 1;
						if (a.width > t || a.height > t) d = t / Math.max(a.width, a.height);
						if (1 > d || !0 === b) {
							if ("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement &&
								a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap) return t =
								b ? Ea.floorPowerOfTwo : Math.floor, b = t(d * a.width), d = t(d * a.height), void 0 === D && (D = h(b, d)),
								c = c ? h(b, d) : D, c.width = b, c.height = d, c.getContext("2d").drawImage(a, 0, 0, b, d), console.warn(
									"THREE.WebGLRenderer: Texture has been resized from (" + a.width + "x" + a.height + ") to (" + b + "x" + d +
									")."), c;
							"data" in a && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + a.width + "x" + a.height +
								").")
						}
						return a
					}

					function x(a) {
						return Ea.isPowerOfTwo(a.width) && Ea.isPowerOfTwo(a.height)
					}

					function y(a, h) {
						return a.generateMipmaps &&
							h && 1003 !== a.minFilter && 1006 !== a.minFilter
					}

					function k(h, b, c, t) {
						a.generateMipmap(h);
						d.get(b).__maxMipLevel = Math.log(Math.max(c, t)) * Math.LOG2E
					}

					function l(a, h) {
						if (!f.isWebGL2) return a;
						var c = a;
						6403 === a && (5126 === h && (c = 33326), 5131 === h && (c = 33325), 5121 === h && (c = 33321));
						6407 === a && (5126 === h && (c = 34837), 5131 === h && (c = 34843), 5121 === h && (c = 32849));
						6408 === a && (5126 === h && (c = 34836), 5131 === h && (c = 34842), 5121 === h && (c = 32856));
						33325 === c || 33326 === c || 34842 === c || 34836 === c ? b.get("EXT_color_buffer_float") : (34843 === c ||
								34837 === c) &&
							console.warn(
								"THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
						return c
					}

					function E(a) {
						return 1003 === a || 1004 === a || 1005 === a ? 9728 : 9729
					}

					function O(h) {
						h = h.target;
						h.removeEventListener("dispose", O);
						var b = d.get(h);
						void 0 !== b.__webglInit && (a.deleteTexture(b.__webglTexture), d.remove(h));
						h.isVideoTexture && z.delete(h);
						g.memory.textures--
					}

					function m(h) {
						h = h.target;
						h.removeEventListener("dispose", m);
						var b = d.get(h),
							c = d.get(h.texture);
						if (h) {
							void 0 !== c.__webglTexture &&
								a.deleteTexture(c.__webglTexture);
							h.depthTexture && h.depthTexture.dispose();
							if (h.isWebGLRenderTargetCube)
								for (c = 0; 6 > c; c++) a.deleteFramebuffer(b.__webglFramebuffer[c]), b.__webglDepthbuffer && a.deleteRenderbuffer(
									b.__webglDepthbuffer[c]);
							else a.deleteFramebuffer(b.__webglFramebuffer), b.__webglDepthbuffer && a.deleteRenderbuffer(b.__webglDepthbuffer);
							if (h.isWebGLMultiviewRenderTarget) {
								a.deleteTexture(b.__webglColorTexture);
								a.deleteTexture(b.__webglDepthStencilTexture);
								g.memory.textures -= 2;
								c = 0;
								for (var t = b.__webglViewFramebuffers.length; c <
									t; c++) a.deleteFramebuffer(b.__webglViewFramebuffers[c])
							}
							d.remove(h.texture);
							d.remove(h)
						}
						g.memory.textures--
					}

					function ka(a, h) {
						var b = d.get(a);
						if (a.isVideoTexture) {
							var t = g.render.frame;
							z.get(a) !== t && (z.set(a, t), a.update())
						}
						if (0 < a.version && b.__version !== a.version)
							if (t = a.image, void 0 === t) console.warn(
								"THREE.WebGLRenderer: Texture marked for update but image is undefined");
							else if (!1 === t.complete) console.warn(
							"THREE.WebGLRenderer: Texture marked for update but image is incomplete");
						else {
							q(b, a, h);
							return
						}
						c.activeTexture(33984 +
							h);
						c.bindTexture(3553, b.__webglTexture)
					}

					function n(h, b) {
						if (6 === h.image.length) {
							var g = d.get(h);
							if (0 < h.version && g.__version !== h.version) {
								p(g, h);
								c.activeTexture(33984 + b);
								c.bindTexture(34067, g.__webglTexture);
								a.pixelStorei(37440, h.flipY);
								var E = h && h.isCompressedTexture;
								b = h.image[0] && h.image[0].isDataTexture;
								for (var O = [], m = 0; 6 > m; m++) O[m] = E || b ? b ? h.image[m].image : h.image[m] : t(h.image[m], !1, !0,
									f.maxCubemapSize);
								var ka = O[0],
									n = x(ka) || f.isWebGL2,
									ea = e.convert(h.format),
									Y = e.convert(h.type),
									r = l(ea, Y);
								v(34067, h,
									n);
								if (E) {
									for (m = 0; 6 > m; m++) {
										var Ma = O[m].mipmaps;
										for (E = 0; E < Ma.length; E++) {
											var q = Ma[E];
											1023 !== h.format && 1022 !== h.format ? -1 < c.getCompressedTextureFormats().indexOf(ea) ? c.compressedTexImage2D(
												34069 + m, E, r, q.width, q.height, 0, q.data) : console.warn(
												"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : c.texImage2D(
												34069 + m, E, r, q.width, q.height, 0, ea, Y, q.data)
										}
									}
									g.__maxMipLevel = Ma.length - 1
								} else {
									Ma = h.mipmaps;
									for (m = 0; 6 > m; m++)
										if (b)
											for (c.texImage2D(34069 + m, 0, r, O[m].width,
													O[m].height, 0, ea, Y, O[m].data), E = 0; E < Ma.length; E++) q = Ma[E], q = q.image[m].image, c.texImage2D(
												34069 + m, E + 1, r, q.width, q.height, 0, ea, Y, q.data);
										else
											for (c.texImage2D(34069 + m, 0, r, ea, Y, O[m]), E = 0; E < Ma.length; E++) q = Ma[E], c.texImage2D(34069 +
												m, E + 1, r, ea, Y, q.image[m]);
									g.__maxMipLevel = Ma.length
								}
								y(h, n) && k(34067, h, ka.width, ka.height);
								g.__version = h.version;
								if (h.onUpdate) h.onUpdate(h)
							} else c.activeTexture(33984 + b), c.bindTexture(34067, g.__webglTexture)
						}
					}

					function r(a, h) {
						c.activeTexture(33984 + h);
						c.bindTexture(34067, d.get(a).__webglTexture)
					}

					function v(h, c, t) {
						t ? (a.texParameteri(h, 10242, e.convert(c.wrapS)), a.texParameteri(h, 10243, e.convert(c.wrapT)), 32879 !==
							h && 35866 !== h || a.texParameteri(h, 32882, e.convert(c.wrapR)), a.texParameteri(h, 10240, e.convert(c.magFilter)),
							a.texParameteri(h, 10241, e.convert(c.minFilter))) : (a.texParameteri(h, 10242, 33071), a.texParameteri(h,
								10243, 33071), 32879 !== h && 35866 !== h || a.texParameteri(h, 32882, 33071), 1001 === c.wrapS && 1001 ===
							c.wrapT || console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
							),
							a.texParameteri(h, 10240, E(c.magFilter)), a.texParameteri(h, 10241, E(c.minFilter)), 1003 !== c.minFilter &&
							1006 !== c.minFilter && console.warn(
								"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
							));
						!(t = b.get("EXT_texture_filter_anisotropic")) || 1015 === c.type && null === b.get("OES_texture_float_linear") ||
							1016 === c.type && null === (f.isWebGL2 || b.get("OES_texture_half_float_linear")) || !(1 < c.anisotropy || d
								.get(c).__currentAnisotropy) || (a.texParameterf(h,
									t.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(c.anisotropy, f.getMaxAnisotropy())), d.get(c).__currentAnisotropy =
								c.anisotropy)
					}

					function p(h, b) {
						void 0 === h.__webglInit && (h.__webglInit = !0, b.addEventListener("dispose", O), h.__webglTexture = a.createTexture(),
							g.memory.textures++)
					}

					function q(h, b, d) {
						var g = 3553;
						b.isDataTexture2DArray && (g = 35866);
						b.isDataTexture3D && (g = 32879);
						p(h, b);
						c.activeTexture(33984 + d);
						c.bindTexture(g, h.__webglTexture);
						a.pixelStorei(37440, b.flipY);
						a.pixelStorei(37441, b.premultiplyAlpha);
						a.pixelStorei(3317,
							b.unpackAlignment);
						d = f.isWebGL2 ? !1 : 1001 !== b.wrapS || 1001 !== b.wrapT || 1003 !== b.minFilter && 1006 !== b.minFilter;
						d = d && !1 === x(b.image);
						d = t(b.image, d, !1, f.maxTextureSize);
						var E = x(d) || f.isWebGL2,
							O = e.convert(b.format),
							m = e.convert(b.type),
							ka = l(O, m);
						v(g, b, E);
						var n = b.mipmaps;
						if (b.isDepthTexture) {
							ka = 6402;
							if (1015 === b.type) {
								if (!f.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
								ka = 36012
							} else f.isWebGL2 && (ka = 33189);
							1026 === b.format && 6402 === ka && 1012 !== b.type && 1014 !== b.type && (console.warn(
									"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),
								b.type = 1012, m = e.convert(b.type));
							1027 === b.format && (ka = 34041, 1020 !== b.type && (console.warn(
									"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), b.type = 1020, m = e
								.convert(b.type)));
							c.texImage2D(3553, 0, ka, d.width, d.height, 0, O, m, null)
						} else if (b.isDataTexture)
							if (0 < n.length && E) {
								for (var ea = 0, Y = n.length; ea < Y; ea++) g = n[ea], c.texImage2D(3553, ea, ka, g.width, g.height, 0, O,
									m, g.data);
								b.generateMipmaps = !1;
								h.__maxMipLevel = n.length - 1
							} else c.texImage2D(3553, 0, ka, d.width, d.height, 0, O, m, d.data),
								h.__maxMipLevel = 0;
						else if (b.isCompressedTexture) {
							ea = 0;
							for (Y = n.length; ea < Y; ea++) g = n[ea], 1023 !== b.format && 1022 !== b.format ? -1 < c.getCompressedTextureFormats()
								.indexOf(O) ? c.compressedTexImage2D(3553, ea, ka, g.width, g.height, 0, g.data) : console.warn(
									"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : c.texImage2D(
									3553, ea, ka, g.width, g.height, 0, O, m, g.data);
							h.__maxMipLevel = n.length - 1
						} else if (b.isDataTexture2DArray) c.texImage3D(35866, 0, ka, d.width, d.height, d.depth, 0,
							O, m, d.data), h.__maxMipLevel = 0;
						else if (b.isDataTexture3D) c.texImage3D(32879, 0, ka, d.width, d.height, d.depth, 0, O, m, d.data), h.__maxMipLevel =
							0;
						else if (0 < n.length && E) {
							ea = 0;
							for (Y = n.length; ea < Y; ea++) g = n[ea], c.texImage2D(3553, ea, ka, O, m, g);
							b.generateMipmaps = !1;
							h.__maxMipLevel = n.length - 1
						} else c.texImage2D(3553, 0, ka, O, m, d), h.__maxMipLevel = 0;
						y(b, E) && k(3553, b, d.width, d.height);
						h.__version = b.version;
						if (b.onUpdate) b.onUpdate(b)
					}

					function u(h, b, t, f) {
						var x = e.convert(b.texture.format),
							y = e.convert(b.texture.type),
							g = l(x,
								y);
						c.texImage2D(f, 0, g, b.width, b.height, 0, x, y, null);
						a.bindFramebuffer(36160, h);
						a.framebufferTexture2D(36160, t, f, d.get(b.texture).__webglTexture, 0);
						a.bindFramebuffer(36160, null)
					}

					function w(h, b, c) {
						a.bindRenderbuffer(36161, h);
						if (b.depthBuffer && !b.stencilBuffer) c ? (c = A(b), a.renderbufferStorageMultisample(36161, c, 33189, b.width,
							b.height)) : a.renderbufferStorage(36161, 33189, b.width, b.height), a.framebufferRenderbuffer(36160, 36096,
							36161, h);
						else if (b.depthBuffer && b.stencilBuffer) c ? (c = A(b), a.renderbufferStorageMultisample(36161,
							c, 35056, b.width, b.height)) : a.renderbufferStorage(36161, 34041, b.width, b.height), a.framebufferRenderbuffer(
							36160, 33306, 36161, h);
						else {
							h = e.convert(b.texture.format);
							var t = e.convert(b.texture.type);
							h = l(h, t);
							c ? (c = A(b), a.renderbufferStorageMultisample(36161, c, h, b.width, b.height)) : a.renderbufferStorage(
								36161, h, b.width, b.height)
						}
						a.bindRenderbuffer(36161, null)
					}

					function A(a) {
						return f.isWebGL2 && a.isWebGLMultisampleRenderTarget ? Math.min(f.maxSamples, a.samples) : 0
					}
					var z = new Fa,
						D, G = "undefined" !== typeof OffscreenCanvas &&
						null !== (new OffscreenCanvas(1, 1)).getContext("2d"),
						C = 0,
						K = !1,
						H = !1;
					this.allocateTextureUnit = function() {
						var a = C;
						a >= f.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + a +
							" texture units while this GPU supports only " + f.maxTextures);
						C += 1;
						return a
					};
					this.resetTextureUnits = function() {
						C = 0
					};
					this.setTexture2D = ka;
					this.setTexture2DArray = function(a, h) {
						var b = d.get(a);
						0 < a.version && b.__version !== a.version ? q(b, a, h) : (c.activeTexture(33984 + h), c.bindTexture(35866, b
							.__webglTexture))
					};
					this.setTexture3D = function(a,
						h) {
						var b = d.get(a);
						0 < a.version && b.__version !== a.version ? q(b, a, h) : (c.activeTexture(33984 + h), c.bindTexture(32879, b
							.__webglTexture))
					};
					this.setTextureCube = n;
					this.setTextureCubeDynamic = r;
					this.setupRenderTarget = function(h) {
						var t = d.get(h),
							E = d.get(h.texture);
						h.addEventListener("dispose", m);
						E.__webglTexture = a.createTexture();
						g.memory.textures++;
						var O = !0 === h.isWebGLRenderTargetCube,
							n = !0 === h.isWebGLMultisampleRenderTarget,
							ea = !0 === h.isWebGLMultiviewRenderTarget,
							Y = x(h) || f.isWebGL2;
						if (O) {
							t.__webglFramebuffer = [];
							for (var r = 0; 6 > r; r++) t.__webglFramebuffer[r] = a.createFramebuffer()
						} else if (t.__webglFramebuffer = a.createFramebuffer(), n)
							if (f.isWebGL2) {
								t.__webglMultisampledFramebuffer = a.createFramebuffer();
								t.__webglColorRenderbuffer = a.createRenderbuffer();
								a.bindRenderbuffer(36161, t.__webglColorRenderbuffer);
								n = e.convert(h.texture.format);
								var Ma = e.convert(h.texture.type);
								n = l(n, Ma);
								Ma = A(h);
								a.renderbufferStorageMultisample(36161, Ma, n, h.width, h.height);
								a.bindFramebuffer(36160, t.__webglMultisampledFramebuffer);
								a.framebufferRenderbuffer(36160,
									36064, 36161, t.__webglColorRenderbuffer);
								a.bindRenderbuffer(36161, null);
								h.depthBuffer && (t.__webglDepthRenderbuffer = a.createRenderbuffer(), w(t.__webglDepthRenderbuffer, h, !0));
								a.bindFramebuffer(36160, null)
							} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
						else if (ea) {
							r = h.width;
							var p = h.height;
							n = h.numViews;
							a.bindFramebuffer(36160, t.__webglFramebuffer);
							var q = b.get("OVR_multiview2");
							g.memory.textures += 2;
							Ma = a.createTexture();
							a.bindTexture(35866, Ma);
							a.texParameteri(35866,
								10240, 9728);
							a.texParameteri(35866, 10241, 9728);
							a.texImage3D(35866, 0, 32856, r, p, n, 0, 6408, 5121, null);
							q.framebufferTextureMultiviewOVR(36160, 36064, Ma, 0, 0, n);
							var Jl = a.createTexture();
							a.bindTexture(35866, Jl);
							a.texParameteri(35866, 10240, 9728);
							a.texParameteri(35866, 10241, 9728);
							a.texImage3D(35866, 0, 35056, r, p, n, 0, 34041, 34042, null);
							q.framebufferTextureMultiviewOVR(36160, 33306, Jl, 0, 0, n);
							p = Array(n);
							for (r = 0; r < n; ++r) p[r] = a.createFramebuffer(), a.bindFramebuffer(36160, p[r]), a.framebufferTextureLayer(
								36160, 36064, Ma,
								0, r);
							t.__webglColorTexture = Ma;
							t.__webglDepthStencilTexture = Jl;
							t.__webglViewFramebuffers = p;
							a.bindFramebuffer(36160, null);
							a.bindTexture(35866, null)
						}
						if (O) {
							c.bindTexture(34067, E.__webglTexture);
							v(34067, h.texture, Y);
							for (r = 0; 6 > r; r++) u(t.__webglFramebuffer[r], h, 36064, 34069 + r);
							y(h.texture, Y) && k(34067, h.texture, h.width, h.height);
							c.bindTexture(34067, null)
						} else ea || (c.bindTexture(3553, E.__webglTexture), v(3553, h.texture, Y), u(t.__webglFramebuffer, h, 36064,
								3553), y(h.texture, Y) && k(3553, h.texture, h.width, h.height),
							c.bindTexture(3553, null));
						if (h.depthBuffer) {
							t = d.get(h);
							E = !0 === h.isWebGLRenderTargetCube;
							if (h.depthTexture) {
								if (E) throw Error("target.depthTexture not supported in Cube render targets");
								if (h && h.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
								a.bindFramebuffer(36160, t.__webglFramebuffer);
								if (!h.depthTexture || !h.depthTexture.isDepthTexture) throw Error(
									"renderTarget.depthTexture must be an instance of THREE.DepthTexture");
								d.get(h.depthTexture).__webglTexture &&
									h.depthTexture.image.width === h.width && h.depthTexture.image.height === h.height || (h.depthTexture.image
										.width = h.width, h.depthTexture.image.height = h.height, h.depthTexture.needsUpdate = !0);
								ka(h.depthTexture, 0);
								t = d.get(h.depthTexture).__webglTexture;
								if (1026 === h.depthTexture.format) a.framebufferTexture2D(36160, 36096, 3553, t, 0);
								else if (1027 === h.depthTexture.format) a.framebufferTexture2D(36160, 33306, 3553, t, 0);
								else throw Error("Unknown depthTexture format");
							} else if (E)
								for (t.__webglDepthbuffer = [], E = 0; 6 > E; E++) a.bindFramebuffer(36160,
									t.__webglFramebuffer[E]), t.__webglDepthbuffer[E] = a.createRenderbuffer(), w(t.__webglDepthbuffer[E], h);
							else a.bindFramebuffer(36160, t.__webglFramebuffer), t.__webglDepthbuffer = a.createRenderbuffer(), w(t.__webglDepthbuffer,
								h);
							a.bindFramebuffer(36160, null)
						}
					};
					this.updateRenderTargetMipmap = function(a) {
						var h = a.texture,
							b = x(a) || f.isWebGL2;
						if (y(h, b)) {
							b = a.isWebGLRenderTargetCube ? 34067 : 3553;
							var t = d.get(h).__webglTexture;
							c.bindTexture(b, t);
							k(b, h, a.width, a.height);
							c.bindTexture(b, null)
						}
					};
					this.updateMultisampleRenderTarget =
						function(h) {
							if (h.isWebGLMultisampleRenderTarget)
								if (f.isWebGL2) {
									var b = d.get(h);
									a.bindFramebuffer(36008, b.__webglMultisampledFramebuffer);
									a.bindFramebuffer(36009, b.__webglFramebuffer);
									b = h.width;
									var c = h.height,
										t = 16384;
									h.depthBuffer && (t |= 256);
									h.stencilBuffer && (t |= 1024);
									a.blitFramebuffer(0, 0, b, c, 0, 0, b, c, t, 9728)
								} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
						};
					this.safeSetTexture2D = function(a, h) {
						a && a.isWebGLRenderTarget && (!1 === K && (console.warn(
								"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."
							),
							K = !0), a = a.texture);
						ka(a, h)
					};
					this.safeSetTextureCube = function(a, h) {
						a && a.isWebGLRenderTargetCube && (!1 === H && (console.warn(
							"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."
						), H = !0), a = a.texture);
						a && a.isCubeTexture || Array.isArray(a.image) && 6 === a.image.length ? n(a, h) : r(a, h)
					}
				}

				function Xd(a, b, c) {
					return {
						convert: function(a) {
							if (1E3 === a) return 10497;
							if (1001 === a) return 33071;
							if (1002 === a) return 33648;
							if (1003 === a) return 9728;
							if (1004 === a) return 9984;
							if (1005 === a) return 9986;
							if (1006 === a) return 9729;
							if (1007 === a) return 9985;
							if (1008 === a) return 9987;
							if (1009 === a) return 5121;
							if (1017 === a) return 32819;
							if (1018 === a) return 32820;
							if (1019 === a) return 33635;
							if (1010 === a) return 5120;
							if (1011 === a) return 5122;
							if (1012 === a) return 5123;
							if (1013 === a) return 5124;
							if (1014 === a) return 5125;
							if (1015 === a) return 5126;
							if (1016 === a) {
								if (c.isWebGL2) return 5131;
								var h = b.get("OES_texture_half_float");
								if (null !== h) return h.HALF_FLOAT_OES
							}
							if (1021 === a) return 6406;
							if (1022 === a) return 6407;
							if (1023 ===
								a) return 6408;
							if (1024 === a) return 6409;
							if (1025 === a) return 6410;
							if (1026 === a) return 6402;
							if (1027 === a) return 34041;
							if (1028 === a) return 6403;
							if (100 === a) return 32774;
							if (101 === a) return 32778;
							if (102 === a) return 32779;
							if (200 === a) return 0;
							if (201 === a) return 1;
							if (202 === a) return 768;
							if (203 === a) return 769;
							if (204 === a) return 770;
							if (205 === a) return 771;
							if (206 === a) return 772;
							if (207 === a) return 773;
							if (208 === a) return 774;
							if (209 === a) return 775;
							if (210 === a) return 776;
							if (33776 === a || 33777 === a || 33778 === a || 33779 === a)
								if (h = b.get("WEBGL_compressed_texture_s3tc"),
									null !== h) {
									if (33776 === a) return h.COMPRESSED_RGB_S3TC_DXT1_EXT;
									if (33777 === a) return h.COMPRESSED_RGBA_S3TC_DXT1_EXT;
									if (33778 === a) return h.COMPRESSED_RGBA_S3TC_DXT3_EXT;
									if (33779 === a) return h.COMPRESSED_RGBA_S3TC_DXT5_EXT
								} if (35840 === a || 35841 === a || 35842 === a || 35843 === a)
								if (h = b.get("WEBGL_compressed_texture_pvrtc"), null !== h) {
									if (35840 === a) return h.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
									if (35841 === a) return h.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
									if (35842 === a) return h.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
									if (35843 === a) return h.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
								} if (36196 ===
								a && (h = b.get("WEBGL_compressed_texture_etc1"), null !== h)) return h.COMPRESSED_RGB_ETC1_WEBGL;
							if (37808 === a || 37809 === a || 37810 === a || 37811 === a || 37812 === a || 37813 === a || 37814 === a ||
								37815 === a || 37816 === a || 37817 === a || 37818 === a || 37819 === a || 37820 === a || 37821 === a)
								if (h = b.get("WEBGL_compressed_texture_astc"), null !== h) return a;
							if (103 === a || 104 === a) {
								if (c.isWebGL2) {
									if (103 === a) return 32775;
									if (104 === a) return 32776
								}
								h = b.get("EXT_blend_minmax");
								if (null !== h) {
									if (103 === a) return h.MIN_EXT;
									if (104 === a) return h.MAX_EXT
								}
							}
							if (1020 === a) {
								if (c.isWebGL2) return 34042;
								h = b.get("WEBGL_depth_texture");
								if (null !== h) return h.UNSIGNED_INT_24_8_WEBGL
							}
							return 0
						}
					}
				}

				function rd(a, b, c, d) {
					n.call(this, a, b, d);
					this.stencilBuffer = this.depthBuffer = !1;
					this.numViews = c
				}

				function Re(a, b) {
					function h(a) {
						if (a.isArrayCamera) return a.cameras;
						n[0] = a;
						return n
					}

					function c(a) {
						if (void 0 === a.isArrayCamera) return !0;
						a = a.cameras;
						if (a.length > q) return !1;
						for (var h = 1, b = a.length; h < b; h++)
							if (a[0].viewport.z !== a[h].viewport.z || a[0].viewport.w !== a[h].viewport.w) return !1;
						return !0
					}
					var t = a.extensions,
						f = a.properties,
						e, g, l, m, n, r, p, q = 0;
					this.isAvailable = function() {
						if (void 0 === p) {
							var a = t.get("OVR_multiview2");
							if (p = null !== a && !1 === b.getContextAttributes().antialias)
								for (q = b.getParameter(a.MAX_VIEWS_OVR), e = new rd(0, 0, 2), r = new d, m = [], l = [], n = [], a = 0; a <
									q; a++) m[a] = new v, l[a] = new k
						}
						return p
					};
					this.attachCamera = function(h) {
						if (!1 !== c(h)) {
							(g = a.getRenderTarget()) ? r.set(g.width, g.height): a.getDrawingBufferSize(r);
							if (h.isArrayCamera) {
								var b = h.cameras[0].viewport;
								e.setSize(b.z, b.w);
								e.setNumViews(h.cameras.length)
							} else e.setSize(r.x,
								r.y), e.setNumViews(2);
							a.setRenderTarget(e)
						}
					};
					this.detachCamera = function(h) {
						if (e === a.getRenderTarget()) {
							a.setRenderTarget(g);
							var c = e,
								t = c.numViews,
								d = f.get(c).__webglViewFramebuffers,
								x = c.width;
							c = c.height;
							if (h.isArrayCamera)
								for (var y = 0; y < t; y++) {
									var k = h.cameras[y].viewport,
										l = k.x,
										E = k.y,
										O = l + k.z;
									k = E + k.w;
									b.bindFramebuffer(36008, d[y]);
									b.blitFramebuffer(0, 0, x, c, l, E, O, k, 16384, 9728)
								} else b.bindFramebuffer(36008, d[0]), b.blitFramebuffer(0, 0, x, c, 0, 0, r.x, r.y, 16384, 9728)
						}
					};
					this.updateCameraProjectionMatricesUniform =
						function(a, c) {
							a = h(a);
							for (var t = 0; t < a.length; t++) m[t].copy(a[t].projectionMatrix);
							c.setValue(b, "projectionMatrices", m)
						};
					this.updateCameraViewMatricesUniform = function(a, c) {
						a = h(a);
						for (var t = 0; t < a.length; t++) m[t].copy(a[t].matrixWorldInverse);
						c.setValue(b, "viewMatrices", m)
					};
					this.updateObjectMatricesUniforms = function(a, c, t) {
						c = h(c);
						for (var d = 0; d < c.length; d++) m[d].multiplyMatrices(c[d].matrixWorldInverse, a.matrixWorld), l[d].getNormalMatrix(
							m[d]);
						t.setValue(b, "modelViewMatrices", m);
						t.setValue(b, "normalMatrices",
							l)
					}
				}

				function Sb() {
					u.call(this);
					this.type = "Group"
				}

				function ic(a) {
					Ja.call(this);
					this.cameras = a || []
				}

				function ge(a, b, c) {
					Ci.setFromMatrixPosition(b.matrixWorld);
					Di.setFromMatrixPosition(c.matrixWorld);
					var h = Ci.distanceTo(Di),
						t = b.projectionMatrix.elements,
						d = c.projectionMatrix.elements,
						f = t[14] / (t[10] - 1);
					c = t[14] / (t[10] + 1);
					var e = (t[9] + 1) / t[5],
						x = (t[9] - 1) / t[5],
						g = (t[8] - 1) / t[0],
						k = (d[8] + 1) / d[0];
					t = f * g;
					d = f * k;
					k = h / (-g + k);
					g = k * -g;
					b.matrixWorld.decompose(a.position, a.quaternion, a.scale);
					a.translateX(g);
					a.translateZ(k);
					a.matrixWorld.compose(a.position, a.quaternion, a.scale);
					a.matrixWorldInverse.getInverse(a.matrixWorld);
					b = f + k;
					f = c + k;
					a.projectionMatrix.makePerspective(t - g, d + (h - g), e * c / f * b, x * c / f * b, b, f)
				}

				function Cd(a) {
					function h() {
						return null !== n && !0 === n.isPresenting
					}

					function b() {
						if (h()) {
							var b = n.getEyeParameters("left");
							g = 2 * b.renderWidth * w;
							k = b.renderHeight * w;
							Q = a.getPixelRatio();
							a.getSize(B);
							a.setDrawingBufferSize(g, k, 1);
							C.viewport.set(0, 0, g / 2, k);
							K.viewport.set(g / 2, 0, g / 2, k);
							J.start();
							l.dispatchEvent({
								type: "sessionstart"
							})
						} else l.enabled &&
							a.setDrawingBufferSize(B.width, B.height, Q), J.stop(), l.dispatchEvent({
								type: "sessionend"
							})
					}

					function c(a, h) {
						null !== h && 4 === h.length && a.set(h[0] * g, h[1] * k, h[2] * g, h[3] * k)
					}
					var g, k, l = this,
						n = null,
						r = null,
						Ma = null,
						p = [],
						q = new v,
						u = new v,
						w = 1,
						A = "local-floor";
					"undefined" !== typeof window && "VRFrameData" in window && (r = new window.VRFrameData, window.addEventListener(
						"vrdisplaypresentchange", b, !1));
					var z = new v,
						D = new e,
						G = new f,
						C = new Ja;
					C.viewport = new m;
					C.layers.enable(1);
					var K = new Ja;
					K.viewport = new m;
					K.layers.enable(2);
					var H =
						new ic([C, K]);
					H.layers.enable(1);
					H.layers.enable(2);
					var B = new d,
						Q, F = [];
					this.enabled = !1;
					this.getController = function(a) {
						var h = p[a];
						void 0 === h && (h = new Sb, h.matrixAutoUpdate = !1, h.visible = !1, p[a] = h);
						return h
					};
					this.getDevice = function() {
						return n
					};
					this.setDevice = function(a) {
						void 0 !== a && (n = a);
						J.setContext(a)
					};
					this.setFramebufferScaleFactor = function(a) {
						w = a
					};
					this.setReferenceSpaceType = function(a) {
						A = a
					};
					this.setPoseTarget = function(a) {
						void 0 !== a && (Ma = a)
					};
					this.getCamera = function(a) {
						var b = "local-floor" === A ? 1.6 : 0;
						if (!1 === h()) return a.position.set(0, b, 0), a.rotation.set(0, 0, 0), a;
						n.depthNear = a.near;
						n.depthFar = a.far;
						n.getFrameData(r);
						if ("local-floor" === A) {
							var t = n.stageParameters;
							t ? q.fromArray(t.sittingToStandingTransform) : q.makeTranslation(0, b, 0)
						}
						b = r.pose;
						t = null !== Ma ? Ma : a;
						t.matrix.copy(q);
						t.matrix.decompose(t.position, t.quaternion, t.scale);
						null !== b.orientation && (D.fromArray(b.orientation), t.quaternion.multiply(D));
						null !== b.position && (D.setFromRotationMatrix(q), G.fromArray(b.position), G.applyQuaternion(D), t.position
							.add(G));
						t.updateMatrixWorld();
						C.near = a.near;
						K.near = a.near;
						C.far = a.far;
						K.far = a.far;
						C.matrixWorldInverse.fromArray(r.leftViewMatrix);
						K.matrixWorldInverse.fromArray(r.rightViewMatrix);
						u.getInverse(q);
						"local-floor" === A && (C.matrixWorldInverse.multiply(u), K.matrixWorldInverse.multiply(u));
						a = t.parent;
						null !== a && (z.getInverse(a.matrixWorld), C.matrixWorldInverse.multiply(z), K.matrixWorldInverse.multiply(z));
						C.matrixWorld.getInverse(C.matrixWorldInverse);
						K.matrixWorld.getInverse(K.matrixWorldInverse);
						C.projectionMatrix.fromArray(r.leftProjectionMatrix);
						K.projectionMatrix.fromArray(r.rightProjectionMatrix);
						ge(H, C, K);
						a = n.getLayers();
						a.length && (a = a[0], c(C.viewport, a.leftBounds), c(K.viewport, a.rightBounds));
						a: for (a = 0; a < p.length; a++) {
							b = p[a];
							b: {
								t = a;
								for (var d = navigator.getGamepads && navigator.getGamepads(), f = 0, e = 0, x = d.length; f < x; f++) {
									var g = d[f];
									if (g && ("Daydream Controller" === g.id || "Gear VR Controller" === g.id || "Oculus Go Controller" ===
											g.id || "OpenVR Gamepad" === g.id || g.id.startsWith("Oculus Touch") || g.id.startsWith(
												"HTC Vive Focus") || g.id.startsWith("Spatial Controller"))) {
										if (e ===
											t) {
											t = g;
											break b
										}
										e++
									}
								}
								t = void 0
							}
							if (void 0 !== t && void 0 !== t.pose) {
								if (null === t.pose) break a;
								d = t.pose;
								!1 === d.hasPosition && b.position.set(.2, -.6, -.05);
								null !== d.position && b.position.fromArray(d.position);
								null !== d.orientation && b.quaternion.fromArray(d.orientation);
								b.matrix.compose(b.position, b.quaternion, b.scale);
								b.matrix.premultiply(q);
								b.matrix.decompose(b.position, b.quaternion, b.scale);
								b.matrixWorldNeedsUpdate = !0;
								b.visible = !0;
								d = "Daydream Controller" === t.id ? 0 : 1;
								void 0 === F[a] && (F[a] = !1);
								F[a] !== t.buttons[d].pressed &&
									(F[a] = t.buttons[d].pressed, !0 === F[a] ? b.dispatchEvent({
										type: "selectstart"
									}) : (b.dispatchEvent({
										type: "selectend"
									}), b.dispatchEvent({
										type: "select"
									})))
							} else b.visible = !1
						}
						return H
					};
					this.getStandingMatrix = function() {
						return q
					};
					this.isPresenting = h;
					var J = new Oa;
					this.setAnimationLoop = function(a) {
						J.setAnimationLoop(a);
						h() && J.start()
					};
					this.submitFrame = function() {
						h() && n.submitFrame()
					};
					this.dispose = function() {
						"undefined" !== typeof window && window.removeEventListener("vrdisplaypresentchange", b)
					};
					this.setFrameOfReferenceType =
						function() {
							console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.")
						}
				}

				function ie(a, b) {
					function h() {
						return null !== g && null !== k
					}

					function c(a) {
						for (var h = 0; h < r.length; h++) p[h] === a.inputSource && r[h].dispatchEvent({
							type: a.type
						})
					}

					function t() {
						a.setFramebuffer(null);
						a.setRenderTarget(a.getRenderTarget());
						z.stop();
						e.dispatchEvent({
							type: "sessionend"
						})
					}

					function d(a) {
						k = a;
						z.setContext(g);
						z.start();
						e.dispatchEvent({
							type: "sessionstart"
						})
					}

					function f(a, h) {
						null === h ? a.matrixWorld.copy(a.matrix) :
							a.matrixWorld.multiplyMatrices(h.matrixWorld, a.matrix);
						a.matrixWorldInverse.getInverse(a.matrixWorld)
					}
					var e = this,
						g = null,
						k = null,
						l = "local-floor",
						n = null,
						r = [],
						p = [],
						q = new Ja;
					q.layers.enable(1);
					q.viewport = new m;
					var u = new Ja;
					u.layers.enable(2);
					u.viewport = new m;
					var w = new ic([q, u]);
					w.layers.enable(1);
					w.layers.enable(2);
					this.enabled = !1;
					this.getController = function(a) {
						var h = r[a];
						void 0 === h && (h = new Sb, h.matrixAutoUpdate = !1, h.visible = !1, r[a] = h);
						return h
					};
					this.setFramebufferScaleFactor = function() {};
					this.setReferenceSpaceType =
						function(a) {
							l = a
						};
					this.getSession = function() {
						return g
					};
					this.setSession = function(a) {
						g = a;
						null !== g && (g.addEventListener("select", c), g.addEventListener("selectstart", c), g.addEventListener(
							"selectend", c), g.addEventListener("end", t), g.updateRenderState({
							baseLayer: new XRWebGLLayer(g, b)
						}), g.requestReferenceSpace(l).then(d), p = g.inputSources, g.addEventListener("inputsourceschange",
							function() {
								p = g.inputSources;
								for (var a = 0; a < r.length; a++) r[a].userData.inputSource = p[a]
							}))
					};
					this.getCamera = function(a) {
						if (h()) {
							var b =
								a.parent,
								c = w.cameras;
							f(w, b);
							for (var t = 0; t < c.length; t++) f(c[t], b);
							a.matrixWorld.copy(w.matrixWorld);
							a = a.children;
							t = 0;
							for (b = a.length; t < b; t++) a[t].updateMatrixWorld(!0);
							ge(w, q, u);
							return w
						}
						return a
					};
					this.isPresenting = h;
					var A = null,
						z = new Oa;
					z.setAnimationLoop(function(h, b) {
						n = b.getViewerPose(k);
						if (null !== n) {
							var c = n.views,
								t = g.renderState.baseLayer;
							a.setFramebuffer(t.framebuffer);
							for (var d = 0; d < c.length; d++) {
								var f = c[d],
									e = t.getViewport(f),
									x = w.cameras[d];
								x.matrix.fromArray(f.transform.inverse.matrix).getInverse(x.matrix);
								x.projectionMatrix.fromArray(f.projectionMatrix);
								x.viewport.set(e.x, e.y, e.width, e.height);
								0 === d && w.matrix.copy(x.matrix)
							}
						}
						for (d = 0; d < r.length; d++) {
							c = r[d];
							if (t = p[d])
								if (t = b.getPose(t.targetRaySpace, k), null !== t) {
									c.matrix.fromArray(t.transform.matrix);
									c.matrix.decompose(c.position, c.rotation, c.scale);
									c.visible = !0;
									continue
								} c.visible = !1
						}
						A && A(h)
					});
					this.setAnimationLoop = function(a) {
						A = a
					};
					this.dispose = function() {};
					this.getStandingMatrix = function() {
						console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed.");
						return new v
					};
					this.getDevice = function() {
						console.warn("THREE.WebXRManager: getDevice() has been deprecated.")
					};
					this.setDevice = function() {
						console.warn("THREE.WebXRManager: setDevice() has been deprecated.")
					};
					this.setFrameOfReferenceType = function() {
						console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.")
					};
					this.submitFrame = function() {}
				}

				function Dd(a) {
					var h;

					function b() {
						fb = new $a(ca);
						ya = new Ya(ca, fb, a);
						!1 === ya.isWebGL2 && (fb.get("WEBGL_depth_texture"), fb.get("OES_texture_float"),
							fb.get("OES_texture_half_float"), fb.get("OES_texture_half_float_linear"), fb.get("OES_standard_derivatives"),
							fb.get("OES_element_index_uint"), fb.get("ANGLE_instanced_arrays"));
						fb.get("OES_texture_float_linear");
						Ga = new Xd(ca, fb, ya);
						aa = new Le(ca, fb, Ga, ya);
						aa.scissor(ha.copy(ra).multiplyScalar(da).floor());
						aa.viewport(ba.copy(ma).multiplyScalar(da).floor());
						va = new jb(ca);
						qa = new Yd;
						za = new Ne(ca, fb, aa, qa, ya, Ga, va);
						La = new Ra(ca);
						Da = new ab(ca, La, va);
						Ba = new ob(ca, Da, La, va);
						Na = new mb(ca);
						Ca = new Wd(L, fb, ya);
						Ja = new fe;
						Ha = new Ae;
						Fa = new Wa(L, aa, Ba, Q);
						Pa = new Xa(ca, fb, va, ya);
						Qa = new hb(ca, fb, va, ya);
						va.programs = Ca.programs;
						L.capabilities = ya;
						L.extensions = fb;
						L.properties = qa;
						L.renderLists = Ja;
						L.state = aa;
						L.info = va
					}

					function c(a) {
						a.preventDefault();
						I = !0
					}

					function e() {
						I = !1;
						b()
					}

					function g(a) {
						a = a.target;
						a.removeEventListener("dispose", g);
						k(a);
						qa.remove(a)
					}

					function k(a) {
						var h = qa.get(a).program;
						a.program = void 0;
						void 0 !== h && Ca.releaseProgram(h)
					}

					function l(a, h) {
						a.render(function(a) {
							L.renderBufferImmediate(a, h)
						})
					}

					function n(a,
						h, b, c) {
						if (!1 !== a.visible) {
							if (a.layers.test(h.layers))
								if (a.isGroup) b = a.renderOrder;
								else if (a.isLOD) !0 === a.autoUpdate && a.update(h);
							else if (a.isLight) M.pushLight(a), a.castShadow && M.pushShadow(a);
							else if (a.isSprite) {
								if (!a.frustumCulled || ua.intersectsSprite(a)) {
									c && pa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(sa);
									var t = Ba.update(a),
										d = a.material;
									d.visible && N.push(a, t, d, b, pa.z, null)
								}
							} else if (a.isImmediateRenderObject) c && pa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(sa), N.push(a,
								null, a.material,
								b, pa.z, null);
							else if (a.isMesh || a.isLine || a.isPoints)
								if (a.isSkinnedMesh && a.skeleton.frame !== va.render.frame && (a.skeleton.update(), a.skeleton.frame = va.render
										.frame), !a.frustumCulled || ua.intersectsObject(a))
									if (c && pa.setFromMatrixPosition(a.matrixWorld).applyMatrix4(sa), t = Ba.update(a), d = a.material, Array.isArray(
											d))
										for (var f = t.groups, e = 0, x = f.length; e < x; e++) {
											var g = f[e],
												y = d[g.materialIndex];
											y && y.visible && N.push(a, t, y, b, pa.z, g)
										} else d.visible && N.push(a, t, d, b, pa.z, null);
							a = a.children;
							e = 0;
							for (x = a.length; e < x; e++) n(a[e],
								h, b, c)
						}
					}

					function r(a, h, b, c) {
						for (var t = 0, d = a.length; t < d; t++) {
							var f = a[t],
								e = f.object,
								x = f.geometry,
								g = void 0 === c ? f.material : c;
							f = f.group;
							if (b.isArrayCamera)
								if (fa = b, Va.enabled && Ka.isAvailable()) p(e, h, b, x, g, f);
								else
									for (var y = b.cameras, k = 0, l = y.length; k < l; k++) {
										var E = y[k];
										e.layers.test(E.layers) && (aa.viewport(ba.copy(E.viewport)), M.setupLights(E), p(e, h, E, x, g, f))
									} else fa = null, p(e, h, b, x, g, f)
						}
					}

					function p(a, b, c, t, d, f) {
						a.onBeforeRender(L, b, c, t, d, f);
						M = Ha.get(b, fa || c);
						a.modelViewMatrix.multiplyMatrices(c.matrixWorldInverse,
							a.matrixWorld);
						a.normalMatrix.getNormalMatrix(a.modelViewMatrix);
						if (a.isImmediateRenderObject) {
							aa.setMaterial(d);
							var e = u(c, b.fog, d, a);
							V = h = null;
							X = !1;
							l(a, e)
						} else L.renderBufferDirect(c, b.fog, t, d, a, f);
						a.onAfterRender(L, b, c, t, d, f);
						M = Ha.get(b, fa || c)
					}

					function q(a, h, b) {
						var c = qa.get(a),
							t = M.state.lights,
							d = t.state.version;
						b = Ca.getParameters(a, t.state, M.state.shadowsArray, h, ke.numPlanes, ke.numIntersection, b);
						var f = Ca.getProgramCode(a, b),
							e = c.program,
							x = !0;
						if (void 0 === e) a.addEventListener("dispose", g);
						else if (e.code !==
							f) k(a);
						else {
							if (c.lightsStateVersion !== d) c.lightsStateVersion = d;
							else if (void 0 !== b.shaderID) return;
							x = !1
						}
						x && (b.shaderID ? (f = kf[b.shaderID], c.shader = {
								name: a.type,
								uniforms: Aa(f.uniforms),
								vertexShader: f.vertexShader,
								fragmentShader: f.fragmentShader
							}) : c.shader = {
								name: a.type,
								uniforms: a.uniforms,
								vertexShader: a.vertexShader,
								fragmentShader: a.fragmentShader
							}, a.onBeforeCompile(c.shader, L), f = Ca.getProgramCode(a, b), e = Ca.acquireProgram(a, c.shader, b, f), c.program =
							e, a.program = e);
						b = e.getAttributes();
						if (a.morphTargets)
							for (f =
								a.numSupportedMorphTargets = 0; f < L.maxMorphTargets; f++) 0 <= b["morphTarget" + f] && a.numSupportedMorphTargets++;
						if (a.morphNormals)
							for (f = a.numSupportedMorphNormals = 0; f < L.maxMorphNormals; f++) 0 <= b["morphNormal" + f] && a.numSupportedMorphNormals++;
						b = c.shader.uniforms;
						if (!a.isShaderMaterial && !a.isRawShaderMaterial || !0 === a.clipping) c.numClippingPlanes = ke.numPlanes, c.numIntersection =
							ke.numIntersection, b.clippingPlanes = ke.uniform;
						c.fog = h;
						c.needsLights = a.isMeshLambertMaterial || a.isMeshPhongMaterial || a.isMeshStandardMaterial ||
							a.isShadowMaterial || a.isShaderMaterial && !0 === a.lights;
						c.lightsStateVersion = d;
						c.needsLights && (b.ambientLightColor.value = t.state.ambient, b.lightProbe.value = t.state.probe, b.directionalLights
							.value = t.state.directional, b.spotLights.value = t.state.spot, b.rectAreaLights.value = t.state.rectArea,
							b.pointLights.value = t.state.point, b.hemisphereLights.value = t.state.hemi, b.directionalShadowMap.value =
							t.state.directionalShadowMap, b.directionalShadowMatrix.value = t.state.directionalShadowMatrix, b.spotShadowMap
							.value =
							t.state.spotShadowMap, b.spotShadowMatrix.value = t.state.spotShadowMatrix, b.pointShadowMap.value = t.state
							.pointShadowMap, b.pointShadowMatrix.value = t.state.pointShadowMatrix);
						a = c.program.getUniforms();
						a = nb.seqWithValue(a.seq, b);
						c.uniformsList = a
					}

					function u(a, h, b, c) {
						za.resetTextureUnits();
						var t = qa.get(b),
							d = M.state.lights;
						ta && (xa || a !== W) && ke.setState(b.clippingPlanes, b.clipIntersection, b.clipShadows, a, t, a === W && b.id ===
							Z);
						!1 === b.needsUpdate && (void 0 === t.program ? b.needsUpdate = !0 : b.fog && t.fog !== h ? b.needsUpdate = !0 :
							t.needsLights && t.lightsStateVersion !== d.state.version ? b.needsUpdate = !0 : void 0 === t.numClippingPlanes ||
							t.numClippingPlanes === ke.numPlanes && t.numIntersection === ke.numIntersection || (b.needsUpdate = !0));
						b.needsUpdate && (q(b, h, c), b.needsUpdate = !1);
						var f = !1,
							e = !1,
							x = !1;
						d = t.program;
						var g = d.getUniforms(),
							y = t.shader.uniforms;
						aa.useProgram(d.program) && (x = e = f = !0);
						b.id !== Z && (Z = b.id, e = !0);
						if (f || W !== a) {
							0 < d.numMultiviewViews ? Ka.updateCameraProjectionMatricesUniform(a, g) : g.setValue(ca, "projectionMatrix",
								a.projectionMatrix);
							ya.logarithmicDepthBuffer && g.setValue(ca, "logDepthBufFC", 2 / (Math.log(a.far + 1) / Math.LN2));
							W !== a && (W = a, x = e = !0);
							if (b.isShaderMaterial || b.isMeshPhongMaterial || b.isMeshStandardMaterial || b.envMap) f = g.map.cameraPosition,
								void 0 !== f && f.setValue(ca, pa.setFromMatrixPosition(a.matrixWorld));
							if (b.isMeshPhongMaterial || b.isMeshLambertMaterial || b.isMeshBasicMaterial || b.isMeshStandardMaterial ||
								b.isShaderMaterial || b.skinning) 0 < d.numMultiviewViews ? Ka.updateCameraViewMatricesUniform(a, g) : g.setValue(
								ca, "viewMatrix", a.matrixWorldInverse)
						}
						if (b.skinning &&
							(g.setOptional(ca, c, "bindMatrix"), g.setOptional(ca, c, "bindMatrixInverse"), f = c.skeleton)) {
							var k = f.bones;
							if (ya.floatVertexTextures) {
								if (void 0 === f.boneTexture) {
									k = Math.sqrt(4 * k.length);
									k = Ea.ceilPowerOfTwo(k);
									k = Math.max(k, 4);
									var l = new Float32Array(k * k * 4);
									l.set(f.boneMatrices);
									var E = new Ia(l, k, k, 1023, 1015);
									f.boneMatrices = l;
									f.boneTexture = E;
									f.boneTextureSize = k
								}
								g.setValue(ca, "boneTexture", f.boneTexture, za);
								g.setValue(ca, "boneTextureSize", f.boneTextureSize)
							} else g.setOptional(ca, f, "boneMatrices")
						}
						if (e || t.receiveShadow !==
							c.receiveShadow) t.receiveShadow = c.receiveShadow, g.setValue(ca, "receiveShadow", c.receiveShadow);
						e && (g.setValue(ca, "toneMappingExposure", L.toneMappingExposure), g.setValue(ca, "toneMappingWhitePoint", L.toneMappingWhitePoint),
							t.needsLights && (e = x, y.ambientLightColor.needsUpdate = e, y.lightProbe.needsUpdate = e, y.directionalLights
								.needsUpdate = e, y.pointLights.needsUpdate = e, y.spotLights.needsUpdate = e, y.rectAreaLights.needsUpdate =
								e, y.hemisphereLights.needsUpdate = e), h && b.fog && (y.fogColor.value.copy(h.color), h.isFog ?
								(y.fogNear.value = h.near, y.fogFar.value = h.far) : h.isFogExp2 && (y.fogDensity.value = h.density)), b.isMeshBasicMaterial ?
							w(y, b) : b.isMeshLambertMaterial ? (w(y, b), b.emissiveMap && (y.emissiveMap.value = b.emissiveMap)) : b.isMeshPhongMaterial ?
							(w(y, b), b.isMeshToonMaterial ? (A(y, b), b.gradientMap && (y.gradientMap.value = b.gradientMap)) : A(y, b)) :
							b.isMeshStandardMaterial ? (w(y, b), b.isMeshPhysicalMaterial ? (z(y, b), y.reflectivity.value = b.reflectivity,
								y.clearcoat.value = b.clearcoat, y.clearcoatRoughness.value = b.clearcoatRoughness,
								b.sheen && y.sheen.value.copy(b.sheen), b.clearcoatNormalMap && (y.clearcoatNormalScale.value.copy(b.clearcoatNormalScale),
									y.clearcoatNormalMap.value = b.clearcoatNormalMap, 1 === b.side && y.clearcoatNormalScale.value.negate()),
								y.transparency.value = b.transparency) : z(y, b)) : b.isMeshMatcapMaterial ? (w(y, b), b.matcap && (y.matcap
								.value = b.matcap), b.bumpMap && (y.bumpMap.value = b.bumpMap, y.bumpScale.value = b.bumpScale, 1 === b.side &&
								(y.bumpScale.value *= -1)), b.normalMap && (y.normalMap.value = b.normalMap, y.normalScale.value.copy(b.normalScale),
								1 === b.side && y.normalScale.value.negate()), b.displacementMap && (y.displacementMap.value = b.displacementMap,
								y.displacementScale.value = b.displacementScale, y.displacementBias.value = b.displacementBias)) : b.isMeshDepthMaterial ?
							(w(y, b), b.displacementMap && (y.displacementMap.value = b.displacementMap, y.displacementScale.value = b.displacementScale,
								y.displacementBias.value = b.displacementBias)) : b.isMeshDistanceMaterial ? (w(y, b), b.displacementMap &&
								(y.displacementMap.value = b.displacementMap, y.displacementScale.value =
									b.displacementScale, y.displacementBias.value = b.displacementBias), y.referencePosition.value.copy(b.referencePosition),
								y.nearDistance.value = b.nearDistance, y.farDistance.value = b.farDistance) : b.isMeshNormalMaterial ? (w(y,
								b), b.bumpMap && (y.bumpMap.value = b.bumpMap, y.bumpScale.value = b.bumpScale, 1 === b.side && (y.bumpScale
								.value *= -1)), b.normalMap && (y.normalMap.value = b.normalMap, y.normalScale.value.copy(b.normalScale),
								1 === b.side && y.normalScale.value.negate()), b.displacementMap && (y.displacementMap.value = b.displacementMap,
								y.displacementScale.value = b.displacementScale, y.displacementBias.value = b.displacementBias)) : b.isLineBasicMaterial ?
							(y.diffuse.value.copy(b.color), y.opacity.value = b.opacity, b.isLineDashedMaterial && (y.dashSize.value = b
								.dashSize, y.totalSize.value = b.dashSize + b.gapSize, y.scale.value = b.scale)) : b.isPointsMaterial ? (y.diffuse
								.value.copy(b.color), y.opacity.value = b.opacity, y.size.value = b.size * da, y.scale.value = .5 * ia, y.map
								.value = b.map, null !== b.map && (!0 === b.map.matrixAutoUpdate && b.map.updateMatrix(), y.uvTransform.value
									.copy(b.map.matrix))) :
							b.isSpriteMaterial ? (y.diffuse.value.copy(b.color), y.opacity.value = b.opacity, y.rotation.value = b.rotation,
								y.map.value = b.map, null !== b.map && (!0 === b.map.matrixAutoUpdate && b.map.updateMatrix(), y.uvTransform
									.value.copy(b.map.matrix))) : b.isShadowMaterial && (y.color.value.copy(b.color), y.opacity.value = b.opacity),
							void 0 !== y.ltc_1 && (y.ltc_1.value = na.LTC_1), void 0 !== y.ltc_2 && (y.ltc_2.value = na.LTC_2), nb.upload(
								ca, t.uniformsList, y, za));
						b.isShaderMaterial && !0 === b.uniformsNeedUpdate && (nb.upload(ca, t.uniformsList,
							y, za), b.uniformsNeedUpdate = !1);
						b.isSpriteMaterial && g.setValue(ca, "center", c.center);
						0 < d.numMultiviewViews ? Ka.updateObjectMatricesUniforms(c, a, g) : (g.setValue(ca, "modelViewMatrix", c.modelViewMatrix),
							g.setValue(ca, "normalMatrix", c.normalMatrix));
						g.setValue(ca, "modelMatrix", c.matrixWorld);
						return d
					}

					function w(a, h) {
						a.opacity.value = h.opacity;
						h.color && a.diffuse.value.copy(h.color);
						h.emissive && a.emissive.value.copy(h.emissive).multiplyScalar(h.emissiveIntensity);
						h.map && (a.map.value = h.map);
						h.alphaMap && (a.alphaMap.value =
							h.alphaMap);
						h.specularMap && (a.specularMap.value = h.specularMap);
						h.envMap && (a.envMap.value = h.envMap, a.flipEnvMap.value = h.envMap.isCubeTexture ? -1 : 1, a.reflectivity.value =
							h.reflectivity, a.refractionRatio.value = h.refractionRatio, a.maxMipLevel.value = qa.get(h.envMap).__maxMipLevel
						);
						h.lightMap && (a.lightMap.value = h.lightMap, a.lightMapIntensity.value = h.lightMapIntensity);
						h.aoMap && (a.aoMap.value = h.aoMap, a.aoMapIntensity.value = h.aoMapIntensity);
						if (h.map) var b = h.map;
						else h.specularMap ? b = h.specularMap : h.displacementMap ?
							b = h.displacementMap : h.normalMap ? b = h.normalMap : h.bumpMap ? b = h.bumpMap : h.roughnessMap ? b = h.roughnessMap :
							h.metalnessMap ? b = h.metalnessMap : h.alphaMap ? b = h.alphaMap : h.emissiveMap && (b = h.emissiveMap);
						void 0 !== b && (b.isWebGLRenderTarget && (b = b.texture), !0 === b.matrixAutoUpdate && b.updateMatrix(), a.uvTransform
							.value.copy(b.matrix))
					}

					function A(a, h) {
						a.specular.value.copy(h.specular);
						a.shininess.value = Math.max(h.shininess, 1E-4);
						h.emissiveMap && (a.emissiveMap.value = h.emissiveMap);
						h.bumpMap && (a.bumpMap.value = h.bumpMap,
							a.bumpScale.value = h.bumpScale, 1 === h.side && (a.bumpScale.value *= -1));
						h.normalMap && (a.normalMap.value = h.normalMap, a.normalScale.value.copy(h.normalScale), 1 === h.side && a.normalScale
							.value.negate());
						h.displacementMap && (a.displacementMap.value = h.displacementMap, a.displacementScale.value = h.displacementScale,
							a.displacementBias.value = h.displacementBias)
					}

					function z(a, h) {
						a.roughness.value = h.roughness;
						a.metalness.value = h.metalness;
						h.roughnessMap && (a.roughnessMap.value = h.roughnessMap);
						h.metalnessMap && (a.metalnessMap.value =
							h.metalnessMap);
						h.emissiveMap && (a.emissiveMap.value = h.emissiveMap);
						h.bumpMap && (a.bumpMap.value = h.bumpMap, a.bumpScale.value = h.bumpScale, 1 === h.side && (a.bumpScale.value *=
							-1));
						h.normalMap && (a.normalMap.value = h.normalMap, a.normalScale.value.copy(h.normalScale), 1 === h.side && a.normalScale
							.value.negate());
						h.displacementMap && (a.displacementMap.value = h.displacementMap, a.displacementScale.value = h.displacementScale,
							a.displacementBias.value = h.displacementBias);
						h.envMap && (a.envMapIntensity.value = h.envMapIntensity)
					}
					a = a || {};
					var D = void 0 !== a.canvas ? a.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
						G = void 0 !== a.context ? a.context : null,
						C = void 0 !== a.alpha ? a.alpha : !1,
						K = void 0 !== a.depth ? a.depth : !0,
						H = void 0 !== a.stencil ? a.stencil : !0,
						B = void 0 !== a.antialias ? a.antialias : !1,
						Q = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0,
						F = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1,
						J = void 0 !== a.powerPreference ? a.powerPreference : "default",
						R = void 0 !== a.failIfMajorPerformanceCaveat ? a.failIfMajorPerformanceCaveat :
						!1,
						N = null,
						M = null;
					this.domElement = D;
					this.debug = {
						checkShaderErrors: !0
					};
					this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
					this.clippingPlanes = [];
					this.localClippingEnabled = !1;
					this.gammaFactor = 2;
					this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1;
					this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1;
					this.maxMorphTargets = 8;
					this.maxMorphNormals = 4;
					var L = this,
						I = !1,
						P = null,
						S = 0,
						wa = 0,
						T = null,
						la = null,
						Z = -1;
					var V = h = null;
					var X = !1;
					var W = null,
						fa = null,
						ba = new m,
						ha = new m,
						ja = null,
						le = D.width,
						ia = D.height,
						da = 1,
						ma = new m(0, 0, le, ia),
						ra = new m(0, 0, le, ia),
						oa = !1,
						ua = new U,
						ke = new Za,
						ta = !1,
						xa = !1,
						sa = new v,
						pa = new f;
					try {
						C = {
							alpha: C,
							depth: K,
							stencil: H,
							antialias: B,
							premultipliedAlpha: Q,
							preserveDrawingBuffer: F,
							powerPreference: J,
							failIfMajorPerformanceCaveat: R,
							xrCompatible: !0
						};
						D.addEventListener("webglcontextlost", c, !1);
						D.addEventListener("webglcontextrestored", e, !1);
						var ca = G || D.getContext("webgl", C) || D.getContext("experimental-webgl", C);
						if (null === ca) {
							if (null !==
								D.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
							throw Error("Error creating WebGL context.");
						}
						void 0 === ca.getShaderPrecisionFormat && (ca.getShaderPrecisionFormat = function() {
							return {
								rangeMin: 1,
								rangeMax: 1,
								precision: 1
							}
						})
					} catch (Ao) {
						throw console.error("THREE.WebGLRenderer: " + Ao.message), Ao;
					}
					var fb, ya, aa, va, qa, za, La, Da, Ba, Ca, Ja, Ha, Fa, Na, Pa, Qa, Ga;
					b();
					var Va = "undefined" !== typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new ie(L,
						ca) : new Cd(L);
					this.vr = Va;
					var Ka = new Re(L, ca),
						Ua = new Md(L, Ba, ya.maxTextureSize);
					this.shadowMap = Ua;
					this.getContext = function() {
						return ca
					};
					this.getContextAttributes = function() {
						return ca.getContextAttributes()
					};
					this.forceContextLoss = function() {
						var a = fb.get("WEBGL_lose_context");
						a && a.loseContext()
					};
					this.forceContextRestore = function() {
						var a = fb.get("WEBGL_lose_context");
						a && a.restoreContext()
					};
					this.getPixelRatio = function() {
						return da
					};
					this.setPixelRatio = function(a) {
						void 0 !== a && (da = a, this.setSize(le, ia, !1))
					};
					this.getSize =
						function(a) {
							void 0 === a && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), a = new d);
							return a.set(le, ia)
						};
					this.setSize = function(a, h, b) {
						Va.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (
							le = a, ia = h, D.width = Math.floor(a * da), D.height = Math.floor(h * da), !1 !== b && (D.style.width = a +
								"px", D.style.height = h + "px"), this.setViewport(0, 0, a, h))
					};
					this.getDrawingBufferSize = function(a) {
						void 0 === a && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"),
							a = new d);
						return a.set(le * da, ia * da).floor()
					};
					this.setDrawingBufferSize = function(a, h, b) {
						le = a;
						ia = h;
						da = b;
						D.width = Math.floor(a * b);
						D.height = Math.floor(h * b);
						this.setViewport(0, 0, a, h)
					};
					this.getCurrentViewport = function(a) {
						void 0 === a && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"),
							a = new m);
						return a.copy(ba)
					};
					this.getViewport = function(a) {
						return a.copy(ma)
					};
					this.setViewport = function(a, h, b, c) {
						a.isVector4 ? ma.set(a.x, a.y, a.z, a.w) : ma.set(a, h, b, c);
						aa.viewport(ba.copy(ma).multiplyScalar(da).floor())
					};
					this.getScissor = function(a) {
						return a.copy(ra)
					};
					this.setScissor = function(a, h, b, c) {
						a.isVector4 ? ra.set(a.x, a.y, a.z, a.w) : ra.set(a, h, b, c);
						aa.scissor(ha.copy(ra).multiplyScalar(da).floor())
					};
					this.getScissorTest = function() {
						return oa
					};
					this.setScissorTest = function(a) {
						aa.setScissorTest(oa = a)
					};
					this.getClearColor = function() {
						return Fa.getClearColor()
					};
					this.setClearColor = function() {
						Fa.setClearColor.apply(Fa, arguments)
					};
					this.getClearAlpha = function() {
						return Fa.getClearAlpha()
					};
					this.setClearAlpha = function() {
						Fa.setClearAlpha.apply(Fa,
							arguments)
					};
					this.clear = function(a, h, b) {
						var c = 0;
						if (void 0 === a || a) c |= 16384;
						if (void 0 === h || h) c |= 256;
						if (void 0 === b || b) c |= 1024;
						ca.clear(c)
					};
					this.clearColor = function() {
						this.clear(!0, !1, !1)
					};
					this.clearDepth = function() {
						this.clear(!1, !0, !1)
					};
					this.clearStencil = function() {
						this.clear(!1, !1, !0)
					};
					this.dispose = function() {
						D.removeEventListener("webglcontextlost", c, !1);
						D.removeEventListener("webglcontextrestored", e, !1);
						Ja.dispose();
						Ha.dispose();
						qa.dispose();
						Ba.dispose();
						Va.dispose();
						Ta.stop()
					};
					this.renderBufferImmediate =
						function(a, h) {
							aa.initAttributes();
							var b = qa.get(a);
							a.hasPositions && !b.position && (b.position = ca.createBuffer());
							a.hasNormals && !b.normal && (b.normal = ca.createBuffer());
							a.hasUvs && !b.uv && (b.uv = ca.createBuffer());
							a.hasColors && !b.color && (b.color = ca.createBuffer());
							h = h.getAttributes();
							a.hasPositions && (ca.bindBuffer(34962, b.position), ca.bufferData(34962, a.positionArray, 35048), aa.enableAttribute(
								h.position), ca.vertexAttribPointer(h.position, 3, 5126, !1, 0, 0));
							a.hasNormals && (ca.bindBuffer(34962, b.normal), ca.bufferData(34962,
								a.normalArray, 35048), aa.enableAttribute(h.normal), ca.vertexAttribPointer(h.normal, 3, 5126, !1, 0, 0));
							a.hasUvs && (ca.bindBuffer(34962, b.uv), ca.bufferData(34962, a.uvArray, 35048), aa.enableAttribute(h.uv), ca
								.vertexAttribPointer(h.uv, 2, 5126, !1, 0, 0));
							a.hasColors && (ca.bindBuffer(34962, b.color), ca.bufferData(34962, a.colorArray, 35048), aa.enableAttribute(
								h.color), ca.vertexAttribPointer(h.color, 3, 5126, !1, 0, 0));
							aa.disableUnusedAttributes();
							ca.drawArrays(4, 0, a.count);
							a.count = 0
						};
					this.renderBufferDirect = function(a,
						b, c, t, d, f) {
						var e = d.isMesh && 0 > d.matrixWorld.determinant();
						aa.setMaterial(t, e);
						var x = u(a, b, t, d),
							g = !1;
						if (h !== c.id || V !== x.id || X !== (!0 === t.wireframe)) h = c.id, V = x.id, X = !0 === t.wireframe, g = !
							0;
						d.morphTargetInfluences && (Na.update(d, c, t, x), g = !0);
						e = c.index;
						var y = c.attributes.position;
						b = 1;
						!0 === t.wireframe && (e = Da.getWireframeAttribute(c), b = 2);
						a = Pa;
						if (null !== e) {
							var k = La.get(e);
							a = Qa;
							a.setIndex(k)
						}
						if (g) {
							if (!1 !== ya.isWebGL2 || !d.isInstancedMesh && !c.isInstancedBufferGeometry || null !== fb.get(
									"ANGLE_instanced_arrays")) {
								aa.initAttributes();
								g = c.attributes;
								x = x.getAttributes();
								var l = t.defaultAttributeValues;
								for (p in x) {
									var E = x[p];
									if (0 <= E) {
										var O = g[p];
										if (void 0 !== O) {
											var m = O.normalized,
												ka = O.itemSize,
												n = La.get(O);
											if (void 0 !== n) {
												var ea = n.buffer,
													r = n.type;
												n = n.bytesPerElement;
												if (O.isInterleavedBufferAttribute) {
													var Y = O.data,
														Ma = Y.stride;
													O = O.offset;
													Y && Y.isInstancedInterleavedBuffer ? (aa.enableAttributeAndDivisor(E, Y.meshPerAttribute), void 0 ===
														c.maxInstancedCount && (c.maxInstancedCount = Y.meshPerAttribute * Y.count)) : aa.enableAttribute(E);
													ca.bindBuffer(34962,
														ea);
													ca.vertexAttribPointer(E, ka, r, m, Ma * n, O * n)
												} else O.isInstancedBufferAttribute ? (aa.enableAttributeAndDivisor(E, O.meshPerAttribute), void 0 ===
														c.maxInstancedCount && (c.maxInstancedCount = O.meshPerAttribute * O.count)) : aa.enableAttribute(E),
													ca.bindBuffer(34962, ea), ca.vertexAttribPointer(E, ka, r, m, 0, 0)
											}
										} else if ("instanceMatrix" === p) n = La.get(d.instanceMatrix), void 0 !== n && (ea = n.buffer, r = n.type,
											aa.enableAttributeAndDivisor(E + 0, 1), aa.enableAttributeAndDivisor(E + 1, 1), aa.enableAttributeAndDivisor(
												E + 2, 1), aa.enableAttributeAndDivisor(E +
												3, 1), ca.bindBuffer(34962, ea), ca.vertexAttribPointer(E + 0, 4, r, !1, 64, 0), ca.vertexAttribPointer(
												E + 1, 4, r, !1, 64, 16), ca.vertexAttribPointer(E + 2, 4, r, !1, 64, 32), ca.vertexAttribPointer(E +
												3, 4, r, !1, 64, 48));
										else if (void 0 !== l && (m = l[p], void 0 !== m)) switch (m.length) {
											case 2:
												ca.vertexAttrib2fv(E, m);
												break;
											case 3:
												ca.vertexAttrib3fv(E, m);
												break;
											case 4:
												ca.vertexAttrib4fv(E, m);
												break;
											default:
												ca.vertexAttrib1fv(E, m)
										}
									}
								}
								aa.disableUnusedAttributes()
							}
							null !== e && ca.bindBuffer(34963, k.buffer)
						}
						k = Infinity;
						null !== e ? k = e.count : void 0 !==
							y && (k = y.count);
						e = c.drawRange.start * b;
						y = null !== f ? f.start * b : 0;
						var p = Math.max(e, y);
						f = Math.max(0, Math.min(k, e + c.drawRange.count * b, y + (null !== f ? f.count * b : Infinity)) - 1 - p + 1);
						if (0 !== f) {
							if (d.isMesh)
								if (!0 === t.wireframe) aa.setLineWidth(t.wireframeLinewidth * (null === T ? da : 1)), a.setMode(1);
								else switch (d.drawMode) {
									case 0:
										a.setMode(4);
										break;
									case 1:
										a.setMode(5);
										break;
									case 2:
										a.setMode(6)
								} else d.isLine ? (t = t.linewidth, void 0 === t && (t = 1), aa.setLineWidth(t * (null === T ? da : 1)), d
									.isLineSegments ? a.setMode(1) : d.isLineLoop ? a.setMode(2) :
									a.setMode(3)) : d.isPoints ? a.setMode(0) : d.isSprite && a.setMode(4);
							d.isInstancedMesh ? a.renderInstances(c, p, f, d.count) : c.isInstancedBufferGeometry ? a.renderInstances(c,
								p, f, c.maxInstancedCount) : a.render(p, f)
						}
					};
					this.compile = function(a, h) {
						M = Ha.get(a, h);
						M.init();
						a.traverse(function(a) {
							a.isLight && (M.pushLight(a), a.castShadow && M.pushShadow(a))
						});
						M.setupLights(h);
						a.traverse(function(h) {
							if (h.material)
								if (Array.isArray(h.material))
									for (var b = 0; b < h.material.length; b++) q(h.material[b], a.fog, h);
								else q(h.material, a.fog,
									h)
						})
					};
					var Sa = null,
						Ta = new Oa;
					Ta.setAnimationLoop(function(a) {
						Va.isPresenting() || Sa && Sa(a)
					});
					"undefined" !== typeof window && Ta.setContext(window);
					this.setAnimationLoop = function(a) {
						Sa = a;
						Va.setAnimationLoop(a);
						Ta.start()
					};
					this.render = function(a, b, c, t) {
						if (void 0 !== c) {
							console.warn(
								"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."
							);
							var d = c
						}
						if (void 0 !== t) {
							console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
							var f = t
						}
						b && b.isCamera ? I || (V = h = null, X = !1, Z = -1, W = null, !0 === a.autoUpdate && a.updateMatrixWorld(),
							null === b.parent && b.updateMatrixWorld(), Va.enabled && (b = Va.getCamera(b)), M = Ha.get(a, b), M.init(),
							a.onBeforeRender(L, a, b, d || T), sa.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse), ua.setFromMatrix(
								sa), xa = this.localClippingEnabled, ta = ke.init(this.clippingPlanes, xa, b), N = Ja.get(a, b), N.init(),
							n(a, b, 0, L.sortObjects), !0 === L.sortObjects && N.sort(), ta && ke.beginShadows(), Ua.render(M.state.shadowsArray,
								a, b), M.setupLights(b),
							ta && ke.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== d && this.setRenderTarget(d),
							Va.enabled && Ka.isAvailable() && Ka.attachCamera(b), Fa.render(N, a, b, f), c = N.opaque, t = N.transparent,
							a.overrideMaterial ? (d = a.overrideMaterial, c.length && r(c, a, b, d), t.length && r(t, a, b, d)) : (c.length &&
								r(c, a, b), t.length && r(t, a, b)), a.onAfterRender(L, a, b), null !== T && (za.updateRenderTargetMipmap(
								T), za.updateMultisampleRenderTarget(T)), aa.buffers.depth.setTest(!0), aa.buffers.depth.setMask(!0), aa.buffers
							.color.setMask(!0),
							aa.setPolygonOffset(!1), Va.enabled && (Ka.isAvailable() && Ka.detachCamera(b), Va.submitFrame()), M = N =
							null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
					};
					this.setFramebuffer = function(a) {
						P !== a && ca.bindFramebuffer(36160, a);
						P = a
					};
					this.getActiveCubeFace = function() {
						return S
					};
					this.getActiveMipmapLevel = function() {
						return wa
					};
					this.getRenderTarget = function() {
						return T
					};
					this.setRenderTarget = function(a, h, b) {
						T = a;
						S = h;
						wa = b;
						a && void 0 === qa.get(a).__webglFramebuffer && za.setupRenderTarget(a);
						var c = P,
							t = !1;
						a ? (c = qa.get(a).__webglFramebuffer, a.isWebGLRenderTargetCube ? (c = c[h || 0], t = !0) : c = a.isWebGLMultisampleRenderTarget ?
								qa.get(a).__webglMultisampledFramebuffer : c, ba.copy(a.viewport), ha.copy(a.scissor), ja = a.scissorTest) :
							(ba.copy(ma).multiplyScalar(da).floor(), ha.copy(ra).multiplyScalar(da).floor(), ja = oa);
						la !== c && (ca.bindFramebuffer(36160, c), la = c);
						aa.viewport(ba);
						aa.scissor(ha);
						aa.setScissorTest(ja);
						t && (a = qa.get(a.texture), ca.framebufferTexture2D(36160, 36064, 34069 + (h || 0), a.__webglTexture, b || 0))
					};
					this.readRenderTargetPixels = function(a, h, b, c, t, d, f) {
						if (a && a.isWebGLRenderTarget) {
							var e = qa.get(a).__webglFramebuffer;
							a.isWebGLRenderTargetCube && void 0 !== f && (e = e[f]);
							if (e) {
								f = !1;
								e !== la && (ca.bindFramebuffer(36160, e), f = !0);
								try {
									var x = a.texture,
										g = x.format,
										y = x.type;
									1023 !== g && Ga.convert(g) !== ca.getParameter(35739) ? console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
									) : 1009 === y || Ga.convert(y) === ca.getParameter(35738) || 1015 === y && (ya.isWebGL2 ||
										fb.get("OES_texture_float") || fb.get("WEBGL_color_buffer_float")) || 1016 === y && (ya.isWebGL2 ? fb.get(
										"EXT_color_buffer_float") : fb.get("EXT_color_buffer_half_float")) ? 36053 === ca.checkFramebufferStatus(
										36160) ? 0 <= h && h <= a.width - c && 0 <= b && b <= a.height - t && ca.readPixels(h, b, c, t, Ga.convert(
										g), Ga.convert(y), d) : console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete."
									) : console.error(
										"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
									)
								} finally {
									f &&
										ca.bindFramebuffer(36160, la)
								}
							}
						} else console.error(
							"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
					};
					this.copyFramebufferToTexture = function(a, h, b) {
						var c = h.image.width,
							t = h.image.height,
							d = Ga.convert(h.format);
						za.setTexture2D(h, 0);
						ca.copyTexImage2D(3553, b || 0, d, a.x, a.y, c, t, 0)
					};
					this.copyTextureToTexture = function(a, h, b, c) {
						var t = h.image.width,
							d = h.image.height,
							f = Ga.convert(b.format),
							e = Ga.convert(b.type);
						za.setTexture2D(b, 0);
						h.isDataTexture ? ca.texSubImage2D(3553, c ||
							0, a.x, a.y, t, d, f, e, h.image.data) : ca.texSubImage2D(3553, c || 0, a.x, a.y, f, e, h.image)
					};
					"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
						detail: this
					}))
				}

				function Pc(a, b) {
					this.name = "";
					this.color = new Q(a);
					this.density = void 0 !== b ? b : 2.5E-4
				}

				function bd(a, b, c) {
					this.name = "";
					this.color = new Q(a);
					this.near = void 0 !== b ? b : 1;
					this.far = void 0 !== c ? c : 1E3
				}

				function Db(a, b) {
					this.array = a;
					this.stride = b;
					this.count = void 0 !== a ? a.length / b : 0;
					this.dynamic = !1;
					this.updateRange = {
						offset: 0,
						count: -1
					};
					this.version = 0
				}

				function sc(a, b, c, d) {
					this.data = a;
					this.itemSize = b;
					this.offset = c;
					this.normalized = !0 === d
				}

				function Eb(a) {
					F.call(this);
					this.type = "SpriteMaterial";
					this.color = new Q(16777215);
					this.map = null;
					this.rotation = 0;
					this.transparent = this.sizeAttenuation = !0;
					this.setValues(a)
				}

				function xc(a) {
					u.call(this);
					this.type = "Sprite";
					if (void 0 === yj) {
						yj = new I;
						var h = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
						h = new Db(h, 5);
						yj.setIndex([0, 1, 2, 0, 2, 3]);
						yj.addAttribute("position", new sc(h,
							3, 0, !1));
						yj.addAttribute("uv", new sc(h, 2, 3, !1))
					}
					this.geometry = yj;
					this.material = void 0 !== a ? a : new Eb;
					this.center = new d(.5, .5)
				}

				function md(a, b, c, d, f, e) {
					zj.subVectors(a, c).addScalar(.5).multiply(d);
					void 0 !== f ? (sk.x = e * zj.x - f * zj.y, sk.y = f * zj.x + e * zj.y) : sk.copy(zj);
					a.copy(b);
					a.x += sk.x;
					a.y += sk.y;
					a.applyMatrix4(Ei)
				}

				function zc() {
					u.call(this);
					this.type = "LOD";
					ja(this, {
						levels: {
							enumerable: !0,
							value: []
						}
					});
					this.autoUpdate = !0
				}

				function Bc(a, b) {
					a && a.isGeometry && console.error(
						"THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					ha.call(this, a, b);
					this.type = "SkinnedMesh";
					this.bindMode = "attached";
					this.bindMatrix = new v;
					this.bindMatrixInverse = new v
				}

				function nd(a, b) {
					a = a || [];
					this.bones = a.slice(0);
					this.boneMatrices = new Float32Array(16 * this.bones.length);
					this.frame = -1;
					if (void 0 === b) this.calculateInverses();
					else if (this.bones.length === b.length) this.boneInverses = b.slice(0);
					else
						for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], a = 0, b = this
							.bones.length; a < b; a++) this.boneInverses.push(new v)
				}

				function Td() {
					u.call(this);
					this.type = "Bone"
				}

				function Ud(a, b, c) {
					ha.call(this, a, b);
					this.instanceMatrix = new R(new Float32Array(16 * c), 16);
					this.count = c
				}

				function Ka(a) {
					F.call(this);
					this.type = "LineBasicMaterial";
					this.color = new Q(16777215);
					this.linewidth = 1;
					this.linejoin = this.linecap = "round";
					this.setValues(a)
				}

				function yb(a, b, c) {
					1 === c && console.error(
						"THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
					u.call(this);
					this.type = "Line";
					this.geometry = void 0 !== a ? a : new I;
					this.material = void 0 !== b ? b : new Ka({
						color: 16777215 *
							Math.random()
					})
				}

				function Sa(a, b) {
					yb.call(this, a, b);
					this.type = "LineSegments"
				}

				function qd(a, b) {
					yb.call(this, a, b);
					this.type = "LineLoop"
				}

				function me(a) {
					F.call(this);
					this.type = "PointsMaterial";
					this.color = new Q(16777215);
					this.map = null;
					this.size = 1;
					this.sizeAttenuation = !0;
					this.morphTargets = !1;
					this.setValues(a)
				}

				function ec(a, b) {
					u.call(this);
					this.type = "Points";
					this.geometry = void 0 !== a ? a : new I;
					this.material = void 0 !== b ? b : new me({
						color: 16777215 * Math.random()
					});
					this.updateMorphTargets()
				}

				function Zd(a, b, c, d, e, g,
					k) {
					var h = xh.distanceSqToPoint(a);
					h < c && (c = new f, xh.closestPointToPoint(a, c), c.applyMatrix4(d), a = e.ray.origin.distanceTo(c), a < e.near ||
						a > e.far || g.push({
							distance: a,
							distanceToRay: Math.sqrt(h),
							point: c,
							index: b,
							face: null,
							object: k
						}))
				}

				function $d(a, b, c, d, f, e, g, k, m) {
					l.call(this, a, b, c, d, f, e, g, k, m);
					this.format = void 0 !== g ? g : 1022;
					this.minFilter = void 0 !== e ? e : 1006;
					this.magFilter = void 0 !== f ? f : 1006;
					this.generateMipmaps = !1
				}

				function gc(a, b, c, d, f, e, g, k, m, n, r, p) {
					l.call(this, null, e, g, k, m, n, d, f, r, p);
					this.image = {
						width: b,
						height: c
					};
					this.mipmaps = a;
					this.generateMipmaps = this.flipY = !1
				}

				function Cc(a, b, c, d, f, e, g, k, m) {
					l.call(this, a, b, c, d, f, e, g, k, m);
					this.needsUpdate = !0
				}

				function Dc(a, b, c, d, f, e, g, k, m, n) {
					n = void 0 !== n ? n : 1026;
					if (1026 !== n && 1027 !== n) throw Error(
						"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
					void 0 === c && 1026 === n && (c = 1012);
					void 0 === c && 1027 === n && (c = 1020);
					l.call(this, null, d, f, e, g, k, n, c, m);
					this.image = {
						width: a,
						height: b
					};
					this.magFilter = void 0 !== g ? g : 1003;
					this.minFilter = void 0 !== k ? k : 1003;
					this.generateMipmaps =
						this.flipY = !1
				}

				function hc(a) {
					I.call(this);
					this.type = "WireframeGeometry";
					var h = [],
						b, c, d, e = [0, 0],
						g = {},
						k = ["a", "b", "c"];
					if (a && a.isGeometry) {
						var l = a.faces;
						var m = 0;
						for (c = l.length; m < c; m++) {
							var n = l[m];
							for (b = 0; 3 > b; b++) {
								var r = n[k[b]];
								var p = n[k[(b + 1) % 3]];
								e[0] = Math.min(r, p);
								e[1] = Math.max(r, p);
								r = e[0] + "," + e[1];
								void 0 === g[r] && (g[r] = {
									index1: e[0],
									index2: e[1]
								})
							}
						}
						for (r in g) m = g[r], k = a.vertices[m.index1], h.push(k.x, k.y, k.z), k = a.vertices[m.index2], h.push(k.x,
							k.y, k.z)
					} else if (a && a.isBufferGeometry)
						if (k = new f, null !== a.index) {
							l =
								a.attributes.position;
							n = a.index;
							var v = a.groups;
							0 === v.length && (v = [{
								start: 0,
								count: n.count,
								materialIndex: 0
							}]);
							a = 0;
							for (d = v.length; a < d; ++a)
								for (m = v[a], b = m.start, c = m.count, m = b, c = b + c; m < c; m += 3)
									for (b = 0; 3 > b; b++) r = n.getX(m + b), p = n.getX(m + (b + 1) % 3), e[0] = Math.min(r, p), e[1] = Math.max(
										r, p), r = e[0] + "," + e[1], void 0 === g[r] && (g[r] = {
										index1: e[0],
										index2: e[1]
									});
							for (r in g) m = g[r], k.fromBufferAttribute(l, m.index1), h.push(k.x, k.y, k.z), k.fromBufferAttribute(l, m.index2),
								h.push(k.x, k.y, k.z)
						} else
							for (l = a.attributes.position, m = 0, c =
								l.count / 3; m < c; m++)
								for (b = 0; 3 > b; b++) g = 3 * m + b, k.fromBufferAttribute(l, g), h.push(k.x, k.y, k.z), g = 3 * m + (b +
									1) % 3, k.fromBufferAttribute(l, g), h.push(k.x, k.y, k.z);
					this.addAttribute("position", new L(h, 3))
				}

				function Fc(a, b, c) {
					T.call(this);
					this.type = "ParametricGeometry";
					this.parameters = {
						func: a,
						slices: b,
						stacks: c
					};
					this.fromBufferGeometry(new lc(a, b, c));
					this.mergeVertices()
				}

				function lc(a, b, c) {
					I.call(this);
					this.type = "ParametricBufferGeometry";
					this.parameters = {
						func: a,
						slices: b,
						stacks: c
					};
					var h = [],
						t = [],
						d = [],
						e = [],
						x = new f,
						g = new f,
						k = new f,
						l = new f,
						m = new f,
						n, r;
					3 > a.length && console.error(
						"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
					var p = b + 1;
					for (n = 0; n <= c; n++) {
						var v = n / c;
						for (r = 0; r <= b; r++) {
							var q = r / b;
							a(q, v, g);
							t.push(g.x, g.y, g.z);
							0 <= q - 1E-5 ? (a(q - 1E-5, v, k), l.subVectors(g, k)) : (a(q + 1E-5, v, k), l.subVectors(k, g));
							0 <= v - 1E-5 ? (a(q, v - 1E-5, k), m.subVectors(g, k)) : (a(q, v + 1E-5, k), m.subVectors(k, g));
							x.crossVectors(l, m).normalize();
							d.push(x.x, x.y, x.z);
							e.push(q, v)
						}
					}
					for (n = 0; n < c; n++)
						for (r = 0; r < b; r++) a = n * p + r +
							1, x = (n + 1) * p + r + 1, g = (n + 1) * p + r, h.push(n * p + r, a, g), h.push(a, x, g);
					this.setIndex(h);
					this.addAttribute("position", new L(t, 3));
					this.addAttribute("normal", new L(d, 3));
					this.addAttribute("uv", new L(e, 2))
				}

				function Mc(a, b, c, d) {
					T.call(this);
					this.type = "PolyhedronGeometry";
					this.parameters = {
						vertices: a,
						indices: b,
						radius: c,
						detail: d
					};
					this.fromBufferGeometry(new oc(a, b, c, d));
					this.mergeVertices()
				}

				function oc(a, b, c, e) {
					function h(a) {
						g.push(a.x, a.y, a.z)
					}

					function t(h, b) {
						h *= 3;
						b.x = a[h + 0];
						b.y = a[h + 1];
						b.z = a[h + 2]
					}

					function x(a, h, b,
						c) {
						0 > c && 1 === a.x && (y[h] = a.x - 1);
						0 === b.x && 0 === b.z && (y[h] = c / 2 / Math.PI + .5)
					}
					I.call(this);
					this.type = "PolyhedronBufferGeometry";
					this.parameters = {
						vertices: a,
						indices: b,
						radius: c,
						detail: e
					};
					c = c || 1;
					e = e || 0;
					var g = [],
						y = [];
					(function(a) {
						for (var c = new f, d = new f, e = new f, x = 0; x < b.length; x += 3) {
							t(b[x + 0], c);
							t(b[x + 1], d);
							t(b[x + 2], e);
							var g, y, k = c,
								l = d,
								E = e,
								m = Math.pow(2, a),
								O = [];
							for (y = 0; y <= m; y++) {
								O[y] = [];
								var ka = k.clone().lerp(E, y / m),
									n = l.clone().lerp(E, y / m),
									r = m - y;
								for (g = 0; g <= r; g++) O[y][g] = 0 === g && y === m ? ka : ka.clone().lerp(n, g / r)
							}
							for (y =
								0; y < m; y++)
								for (g = 0; g < 2 * (m - y) - 1; g++) k = Math.floor(g / 2), 0 === g % 2 ? (h(O[y][k + 1]), h(O[y + 1][k]),
									h(O[y][k])) : (h(O[y][k + 1]), h(O[y + 1][k + 1]), h(O[y + 1][k]))
						}
					})(e);
					(function(a) {
						for (var h = new f, b = 0; b < g.length; b += 3) h.x = g[b + 0], h.y = g[b + 1], h.z = g[b + 2], h.normalize()
							.multiplyScalar(a), g[b + 0] = h.x, g[b + 1] = h.y, g[b + 2] = h.z
					})(c);
					(function() {
						for (var a = new f, h = 0; h < g.length; h += 3) a.x = g[h + 0], a.y = g[h + 1], a.z = g[h + 2], y.push(Math.atan2(
							a.z, -a.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-a.y, Math.sqrt(a.x * a.x + a.z * a.z)) / Math.PI + .5));
						a = new f;
						h = new f;
						for (var b =
								new f, c = new f, t = new d, e = new d, k = new d, l = 0, E = 0; l < g.length; l += 9, E += 6) {
							a.set(g[l + 0], g[l + 1], g[l + 2]);
							h.set(g[l + 3], g[l + 4], g[l + 5]);
							b.set(g[l + 6], g[l + 7], g[l + 8]);
							t.set(y[E + 0], y[E + 1]);
							e.set(y[E + 2], y[E + 3]);
							k.set(y[E + 4], y[E + 5]);
							c.copy(a).add(h).add(b).divideScalar(3);
							var m = Math.atan2(c.z, -c.x);
							x(t, E + 0, a, m);
							x(e, E + 2, h, m);
							x(k, E + 4, b, m)
						}
						for (a = 0; a < y.length; a += 6) h = y[a + 0], b = y[a + 2], c = y[a + 4], t = Math.min(h, b, c), .9 < Math.max(
							h, b, c) && .1 > t && (.2 > h && (y[a + 0] += 1), .2 > b && (y[a + 2] += 1), .2 > c && (y[a + 4] += 1))
					})();
					this.addAttribute("position",
						new L(g, 3));
					this.addAttribute("normal", new L(g.slice(), 3));
					this.addAttribute("uv", new L(y, 2));
					0 === e ? this.computeVertexNormals() : this.normalizeNormals()
				}

				function Nc(a, b) {
					T.call(this);
					this.type = "TetrahedronGeometry";
					this.parameters = {
						radius: a,
						detail: b
					};
					this.fromBufferGeometry(new nc(a, b));
					this.mergeVertices()
				}

				function nc(a, b) {
					oc.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], a, b);
					this.type = "TetrahedronBufferGeometry";
					this.parameters = {
						radius: a,
						detail: b
					}
				}

				function Tc(a, b) {
					T.call(this);
					this.type = "OctahedronGeometry";
					this.parameters = {
						radius: a,
						detail: b
					};
					this.fromBufferGeometry(new ac(a, b));
					this.mergeVertices()
				}

				function ac(a, b) {
					oc.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1,
						2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2
					], a, b);
					this.type = "OctahedronBufferGeometry";
					this.parameters = {
						radius: a,
						detail: b
					}
				}

				function ad(a, b) {
					T.call(this);
					this.type = "IcosahedronGeometry";
					this.parameters = {
						radius: a,
						detail: b
					};
					this.fromBufferGeometry(new rc(a, b));
					this.mergeVertices()
				}

				function rc(a, b) {
					var h =
						(1 + Math.sqrt(5)) / 2;
					oc.call(this, [-1, h, 0, 1, h, 0, -1, -h, 0, 1, -h, 0, 0, -1, h, 0, 1, h, 0, -1, -h, 0, 1, -h, h, 0, -1, h, 0,
						1, -h, 0, -1, -h, 0, 1
					], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4,
						3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1
					], a, b);
					this.type = "IcosahedronBufferGeometry";
					this.parameters = {
						radius: a,
						detail: b
					}
				}

				function fd(a, b) {
					T.call(this);
					this.type = "DodecahedronGeometry";
					this.parameters = {
						radius: a,
						detail: b
					};
					this.fromBufferGeometry(new tc(a, b));
					this.mergeVertices()
				}

				function tc(a, b) {
					var h =
						(1 + Math.sqrt(5)) / 2,
						c = 1 / h;
					oc.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -c, -h, 0,
						-c, h, 0, c, -h, 0, c, h, -c, -h, 0, -c, h, 0, c, -h, 0, c, h, 0, -h, 0, -c, h, 0, -c, -h, 0, c, h, 0, c
					], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8,
						16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13,
						18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19,
						14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9
					], a, b);
					this.type = "DodecahedronBufferGeometry";
					this.parameters = {
						radius: a,
						detail: b
					}
				}

				function hd(a, b, c, d, f, e) {
					T.call(this);
					this.type = "TubeGeometry";
					this.parameters = {
						path: a,
						tubularSegments: b,
						radius: c,
						radialSegments: d,
						closed: f
					};
					void 0 !== e && console.warn("THREE.TubeGeometry: taper has been removed.");
					a = new cc(a, b, c, d, f);
					this.tangents = a.tangents;
					this.normals = a.normals;
					this.binormals = a.binormals;
					this.fromBufferGeometry(a);
					this.mergeVertices()
				}

				function cc(a, b, c, e, g) {
					function h(h) {
						l = a.getPointAt(h / b, l);
						var d = t.normals[h];
						h = t.binormals[h];
						for (m = 0; m <= e; m++) {
							var f = m / e * Math.PI *
								2,
								g = Math.sin(f);
							f = -Math.cos(f);
							y.x = f * d.x + g * h.x;
							y.y = f * d.y + g * h.y;
							y.z = f * d.z + g * h.z;
							y.normalize();
							r.push(y.x, y.y, y.z);
							x.x = l.x + c * y.x;
							x.y = l.y + c * y.y;
							x.z = l.z + c * y.z;
							n.push(x.x, x.y, x.z)
						}
					}
					I.call(this);
					this.type = "TubeBufferGeometry";
					this.parameters = {
						path: a,
						tubularSegments: b,
						radius: c,
						radialSegments: e,
						closed: g
					};
					b = b || 64;
					c = c || 1;
					e = e || 8;
					g = g || !1;
					var t = a.computeFrenetFrames(b, g);
					this.tangents = t.tangents;
					this.normals = t.normals;
					this.binormals = t.binormals;
					var x = new f,
						y = new f,
						k = new d,
						l = new f,
						E, m, n = [],
						r = [],
						p = [],
						v = [];
					for (E =
						0; E < b; E++) h(E);
					h(!1 === g ? b : 0);
					for (E = 0; E <= b; E++)
						for (m = 0; m <= e; m++) k.x = E / b, k.y = m / e, p.push(k.x, k.y);
					(function() {
						for (m = 1; m <= b; m++)
							for (E = 1; E <= e; E++) {
								var a = (e + 1) * m + (E - 1),
									h = (e + 1) * m + E,
									c = (e + 1) * (m - 1) + E;
								v.push((e + 1) * (m - 1) + (E - 1), a, c);
								v.push(a, h, c)
							}
					})();
					this.setIndex(v);
					this.addAttribute("position", new L(n, 3));
					this.addAttribute("normal", new L(r, 3));
					this.addAttribute("uv", new L(p, 2))
				}

				function jd(a, b, c, d, f, e, g) {
					T.call(this);
					this.type = "TorusKnotGeometry";
					this.parameters = {
						radius: a,
						tube: b,
						tubularSegments: c,
						radialSegments: d,
						p: f,
						q: e
					};
					void 0 !== g && console.warn(
						"THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
					this.fromBufferGeometry(new wc(a, b, c, d, f, e));
					this.mergeVertices()
				}

				function wc(a, b, c, d, e, g) {
					function h(a, h, b, c, t) {
						var d = Math.sin(a);
						h = b / h * a;
						b = Math.cos(h);
						t.x = c * (2 + b) * .5 * Math.cos(a);
						t.y = c * (2 + b) * d * .5;
						t.z = c * Math.sin(h) * .5
					}
					I.call(this);
					this.type = "TorusKnotBufferGeometry";
					this.parameters = {
						radius: a,
						tube: b,
						tubularSegments: c,
						radialSegments: d,
						p: e,
						q: g
					};
					a = a || 1;
					b = b || .4;
					c = Math.floor(c) ||
						64;
					d = Math.floor(d) || 8;
					e = e || 2;
					g = g || 3;
					var t = [],
						x = [],
						y = [],
						k = [],
						l, E = new f,
						m = new f,
						O = new f,
						n = new f,
						r = new f,
						p = new f,
						v = new f;
					for (l = 0; l <= c; ++l) {
						var q = l / c * e * Math.PI * 2;
						h(q, e, g, a, O);
						h(q + .01, e, g, a, n);
						p.subVectors(n, O);
						v.addVectors(n, O);
						r.crossVectors(p, v);
						v.crossVectors(r, p);
						r.normalize();
						v.normalize();
						for (q = 0; q <= d; ++q) {
							var u = q / d * Math.PI * 2,
								w = -b * Math.cos(u);
							u = b * Math.sin(u);
							E.x = O.x + (w * v.x + u * r.x);
							E.y = O.y + (w * v.y + u * r.y);
							E.z = O.z + (w * v.z + u * r.z);
							x.push(E.x, E.y, E.z);
							m.subVectors(E, O).normalize();
							y.push(m.x, m.y, m.z);
							k.push(l /
								c);
							k.push(q / d)
						}
					}
					for (q = 1; q <= c; q++)
						for (l = 1; l <= d; l++) a = (d + 1) * q + (l - 1), b = (d + 1) * q + l, e = (d + 1) * (q - 1) + l, t.push((d +
							1) * (q - 1) + (l - 1), a, e), t.push(a, b, e);
					this.setIndex(t);
					this.addAttribute("position", new L(x, 3));
					this.addAttribute("normal", new L(y, 3));
					this.addAttribute("uv", new L(k, 2))
				}

				function kd(a, b, c, d, e) {
					T.call(this);
					this.type = "TorusGeometry";
					this.parameters = {
						radius: a,
						tube: b,
						radialSegments: c,
						tubularSegments: d,
						arc: e
					};
					this.fromBufferGeometry(new Ac(a, b, c, d, e));
					this.mergeVertices()
				}

				function Ac(a, b, c, d, e) {
					I.call(this);
					this.type = "TorusBufferGeometry";
					this.parameters = {
						radius: a,
						tube: b,
						radialSegments: c,
						tubularSegments: d,
						arc: e
					};
					a = a || 1;
					b = b || .4;
					c = Math.floor(c) || 8;
					d = Math.floor(d) || 6;
					e = e || 2 * Math.PI;
					var h = [],
						t = [],
						x = [],
						g = [],
						y = new f,
						k = new f,
						l = new f,
						E, m;
					for (E = 0; E <= c; E++)
						for (m = 0; m <= d; m++) {
							var n = m / d * e,
								r = E / c * Math.PI * 2;
							k.x = (a + b * Math.cos(r)) * Math.cos(n);
							k.y = (a + b * Math.cos(r)) * Math.sin(n);
							k.z = b * Math.sin(r);
							t.push(k.x, k.y, k.z);
							y.x = a * Math.cos(n);
							y.y = a * Math.sin(n);
							l.subVectors(k, y).normalize();
							x.push(l.x, l.y, l.z);
							g.push(m / d);
							g.push(E /
								c)
						}
					for (E = 1; E <= c; E++)
						for (m = 1; m <= d; m++) a = (d + 1) * (E - 1) + m - 1, b = (d + 1) * (E - 1) + m, e = (d + 1) * E + m, h.push(
							(d + 1) * E + m - 1, a, e), h.push(a, b, e);
					this.setIndex(h);
					this.addAttribute("position", new L(t, 3));
					this.addAttribute("normal", new L(x, 3));
					this.addAttribute("uv", new L(g, 2))
				}

				function wf(a, b, c, d, e) {
					for (var h, t = 0, f = b, x = c - d; f < c; f += d) t += (a[x] - a[f]) * (a[f + 1] + a[x + 1]), x = f;
					if (e === 0 < t)
						for (e = b; e < c; e += d) h = Kf(e, a[e], a[e + 1], h);
					else
						for (e = c - d; e >= b; e -= d) h = Kf(e, a[e], a[e + 1], h);
					h && bi(h, h.next) && (td(h), h = h.next);
					return h
				}

				function od(a, b) {
					if (!a) return a;
					b || (b = a);
					do {
						var h = !1;
						if (a.steiner || !bi(a, a.next) && 0 !== zb(a.prev, a, a.next)) a = a.next;
						else {
							td(a);
							a = b = a.prev;
							if (a === a.next) break;
							h = !0
						}
					} while (h || a !== b);
					return b
				}

				function pd(a, b, c, d, e, f, g) {
					if (a) {
						if (!g && f) {
							var h = a,
								t = h;
							do null === t.z && (t.z = Se(t.x, t.y, d, e, f)), t.prevZ = t.prev, t = t.nextZ = t.next; while (t !== h);
							t.prevZ.nextZ = null;
							t.prevZ = null;
							h = t;
							var x, y, k, l, E = 1;
							do {
								t = h;
								var m = h = null;
								for (y = 0; t;) {
									y++;
									var O = t;
									for (x = k = 0; x < E && (k++, O = O.nextZ, O); x++);
									for (l = E; 0 < k || 0 < l && O;) 0 !== k && (0 === l || !O || t.z <= O.z) ? (x = t, t = t.nextZ, k--) : (x =
										O, O = O.nextZ, l--), m ? m.nextZ = x : h = x, x.prevZ = m, m = x;
									t = O
								}
								m.nextZ = null;
								E *= 2
							} while (1 < y)
						}
						for (h = a; a.prev !== a.next;) {
							t = a.prev;
							O = a.next;
							if (f) m = Cg(a, d, e, f);
							else a: if (m = a, y = m.prev, k = m, E = m.next, 0 <= zb(y, k, E)) m = !1;
								else {
									for (x = m.next.next; x !== m.prev;) {
										if (Ec(y.x, y.y, k.x, k.y, E.x, E.y, x.x, x.y) && 0 <= zb(x.prev, x, x.next)) {
											m = !1;
											break a
										}
										x = x.next
									}
									m = !0
								} if (m) b.push(t.i / c), b.push(a.i / c), b.push(O.i / c), td(a), h = a = O.next;
							else if (a = O, a === h) {
								if (!g) pd(od(a), b, c, d, e, f, 1);
								else if (1 === g) {
									g = b;
									h = c;
									t = a;
									do O = t.prev, m = t.next.next, !bi(O, m) && Hf(O,
										t, t.next, m) && sd(O, m) && sd(m, O) && (g.push(O.i / h), g.push(t.i / h), g.push(m.i / h), td(t), td(t.next),
										t = a = m), t = t.next; while (t !== a);
									a = t;
									pd(a, b, c, d, e, f, 2)
								} else if (2 === g) a: {
									g = a;do {
										for (h = g.next.next; h !== g.prev;) {
											if (t = g.i !== h.i) {
												t = g;
												O = h;
												if (m = t.next.i !== O.i && t.prev.i !== O.i) {
													b: {
														m = t;do {
															if (m.i !== t.i && m.next.i !== t.i && m.i !== O.i && m.next.i !== O.i && Hf(m, m.next, t, O)) {
																m = !0;
																break b
															}
															m = m.next
														} while (m !== t);m = !1
													}
													m = !m
												}
												if (m = m && sd(t, O) && sd(O, t)) {
													m = t;
													y = !1;
													k = (t.x + O.x) / 2;
													O = (t.y + O.y) / 2;
													do m.y > O !== m.next.y > O && m.next.y !== m.y && k < (m.next.x -
														m.x) * (O - m.y) / (m.next.y - m.y) + m.x && (y = !y), m = m.next; while (m !== t);
													m = y
												}
												t = m
											}
											if (t) {
												a = Jf(g, h);
												g = od(g, g.next);
												a = od(a, a.next);
												pd(g, b, c, d, e, f);
												pd(a, b, c, d, e, f);
												break a
											}
											h = h.next
										}
										g = g.next
									} while (g !== a)
								}
								break
							}
						}
					}
				}

				function Cg(a, b, c, d) {
					var h = a.prev,
						t = a.next;
					if (0 <= zb(h, a, t)) return !1;
					var e = h.x > a.x ? h.x > t.x ? h.x : t.x : a.x > t.x ? a.x : t.x,
						f = h.y > a.y ? h.y > t.y ? h.y : t.y : a.y > t.y ? a.y : t.y,
						x = Se(h.x < a.x ? h.x < t.x ? h.x : t.x : a.x < t.x ? a.x : t.x, h.y < a.y ? h.y < t.y ? h.y : t.y : a.y < t.y ?
							a.y : t.y, b, c, d);
					b = Se(e, f, b, c, d);
					c = a.prevZ;
					for (d = a.nextZ; c && c.z >= x && d && d.z <=
						b;) {
						if (c !== a.prev && c !== a.next && Ec(h.x, h.y, a.x, a.y, t.x, t.y, c.x, c.y) && 0 <= zb(c.prev, c, c.next))
							return !1;
						c = c.prevZ;
						if (d !== a.prev && d !== a.next && Ec(h.x, h.y, a.x, a.y, t.x, t.y, d.x, d.y) && 0 <= zb(d.prev, d, d.next))
							return !1;
						d = d.nextZ
					}
					for (; c && c.z >= x;) {
						if (c !== a.prev && c !== a.next && Ec(h.x, h.y, a.x, a.y, t.x, t.y, c.x, c.y) && 0 <= zb(c.prev, c, c.next))
							return !1;
						c = c.prevZ
					}
					for (; d && d.z <= b;) {
						if (d !== a.prev && d !== a.next && Ec(h.x, h.y, a.x, a.y, t.x, t.y, d.x, d.y) && 0 <= zb(d.prev, d, d.next))
							return !1;
						d = d.nextZ
					}
					return !0
				}

				function Dg(a, b) {
					return a.x - b.x
				}

				function Eg(a, b) {
					var h = b,
						c = a.x,
						d = a.y,
						t = -Infinity;
					do {
						if (d <= h.y && d >= h.next.y && h.next.y !== h.y) {
							var e = h.x + (d - h.y) * (h.next.x - h.x) / (h.next.y - h.y);
							if (e <= c && e > t) {
								t = e;
								if (e === c) {
									if (d === h.y) return h;
									if (d === h.next.y) return h.next
								}
								var f = h.x < h.next.x ? h : h.next
							}
						}
						h = h.next
					} while (h !== b);
					if (!f) return null;
					if (c === t) return f.prev;
					b = f;
					e = f.x;
					var g = f.y,
						k = Infinity;
					for (h = f.next; h !== b;) {
						if (c >= h.x && h.x >= e && c !== h.x && Ec(d < g ? c : t, d, e, g, d < g ? t : c, d, h.x, h.y)) {
							var l = Math.abs(d - h.y) / (c - h.x);
							(l < k || l === k && h.x > f.x) && sd(h, a) && (f = h, k = l)
						}
						h =
							h.next
					}
					return f
				}

				function Se(a, b, c, d, e) {
					a = 32767 * (a - c) * e;
					b = 32767 * (b - d) * e;
					a = (a | a << 8) & 16711935;
					a = (a | a << 4) & 252645135;
					a = (a | a << 2) & 858993459;
					b = (b | b << 8) & 16711935;
					b = (b | b << 4) & 252645135;
					b = (b | b << 2) & 858993459;
					return (a | a << 1) & 1431655765 | ((b | b << 1) & 1431655765) << 1
				}

				function Ig(a) {
					var h = a,
						b = a;
					do {
						if (h.x < b.x || h.x === b.x && h.y < b.y) b = h;
						h = h.next
					} while (h !== a);
					return b
				}

				function Ec(a, b, c, d, e, f, g, k) {
					return 0 <= (e - g) * (b - k) - (a - g) * (f - k) && 0 <= (a - g) * (d - k) - (c - g) * (b - k) && 0 <= (c - g) *
						(f - k) - (e - g) * (d - k)
				}

				function zb(a, b, c) {
					return (b.y - a.y) * (c.x -
						b.x) - (b.x - a.x) * (c.y - b.y)
				}

				function bi(a, b) {
					return a.x === b.x && a.y === b.y
				}

				function Hf(a, b, c, d) {
					return bi(a, c) && bi(b, d) || bi(a, d) && bi(c, b) ? !0 : 0 < zb(a, b, c) !== 0 < zb(a, b, d) && 0 < zb(c, d,
						a) !== 0 < zb(c, d, b)
				}

				function sd(a, b) {
					return 0 > zb(a.prev, a, a.next) ? 0 <= zb(a, b, a.next) && 0 <= zb(a, a.prev, b) : 0 > zb(a, b, a.prev) || 0 >
						zb(a, a.next, b)
				}

				function Jf(a, b) {
					var h = new df(a.i, a.x, a.y),
						c = new df(b.i, b.x, b.y),
						d = a.next,
						t = b.prev;
					a.next = b;
					b.prev = a;
					h.next = d;
					d.prev = h;
					c.next = h;
					h.prev = c;
					t.next = c;
					c.prev = t;
					return c
				}

				function Kf(a, b, c, d) {
					a = new df(a,
						b, c);
					d ? (a.next = d.next, a.prev = d, d.next.prev = a, d.next = a) : (a.prev = a, a.next = a);
					return a
				}

				function td(a) {
					a.next.prev = a.prev;
					a.prev.next = a.next;
					a.prevZ && (a.prevZ.nextZ = a.nextZ);
					a.nextZ && (a.nextZ.prevZ = a.prevZ)
				}

				function df(a, b, c) {
					this.i = a;
					this.x = b;
					this.y = c;
					this.nextZ = this.prevZ = this.z = this.next = this.prev = null;
					this.steiner = !1
				}

				function Mf(a) {
					var h = a.length;
					2 < h && a[h - 1].equals(a[0]) && a.pop()
				}

				function Nf(a, b) {
					for (var h = 0; h < b.length; h++) a.push(b[h].x), a.push(b[h].y)
				}

				function ci(a, b) {
					T.call(this);
					this.type = "ExtrudeGeometry";
					this.parameters = {
						shapes: a,
						options: b
					};
					this.fromBufferGeometry(new lf(a, b));
					this.mergeVertices()
				}

				function lf(a, b) {
					function h(a) {
						function h(a, h, b) {
							h || console.error("THREE.ExtrudeGeometry: vec does not exist");
							return h.clone().multiplyScalar(b).add(a)
						}

						function x(a, h, b) {
							var c = a.x - h.x;
							var t = a.y - h.y;
							var e = b.x - a.x;
							var f = b.y - a.y,
								x = c * c + t * t;
							if (Math.abs(c * f - t * e) > Na) {
								var g = Math.sqrt(x),
									y = Math.sqrt(e * e + f * f);
								x = h.x - t / g;
								h = h.y + c / g;
								f = ((b.x - f / y - x) * f - (b.y + e / y - h) * e) / (c * f - t * e);
								e = x + c * f - a.x;
								c = h + t * f - a.y;
								t = e * e + c * c;
								if (2 >= t) return new d(e,
									c);
								t = Math.sqrt(t / 2)
							} else a = !1, c > Na ? e > Na && (a = !0) : c < -Na ? e < -Na && (a = !0) : Lg(t) === Lg(f) && (a = !0), a ?
								(e = -t, t = Math.sqrt(x)) : (e = c, c = t, t = Math.sqrt(x / 2));
							return new d(e / t, c / t)
						}

						function g(a, h) {
							for (I = a.length; 0 <= --I;) {
								var b = I;
								var d = I - 1;
								0 > d && (d = a.length - 1);
								var e, f = n + 2 * q;
								for (e = 0; e < f; e++) {
									var x = N * e,
										g = N * (e + 1),
										y = h + d + x,
										k = h + d + g;
									g = h + b + g;
									l(h + b + x);
									l(y);
									l(g);
									l(y);
									l(k);
									l(g);
									x = t.length / 3;
									x = u.generateSideWallUV(c, t, x - 6, x - 3, x - 2, x - 1);
									E(x[0]);
									E(x[1]);
									E(x[3]);
									E(x[1]);
									E(x[2]);
									E(x[3])
								}
							}
						}

						function y(a, h, b) {
							m.push(a);
							m.push(h);
							m.push(b)
						}

						function k(a, h, b) {
							l(a);
							l(h);
							l(b);
							a = t.length / 3;
							a = u.generateTopUV(c, t, a - 3, a - 2, a - 1);
							E(a[0]);
							E(a[1]);
							E(a[2])
						}

						function l(a) {
							t.push(m[3 * a]);
							t.push(m[3 * a + 1]);
							t.push(m[3 * a + 2])
						}

						function E(a) {
							e.push(a.x);
							e.push(a.y)
						}
						var m = [],
							O = void 0 !== b.curveSegments ? b.curveSegments : 12,
							n = void 0 !== b.steps ? b.steps : 1,
							ka = void 0 !== b.depth ? b.depth : 100,
							r = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0,
							ea = void 0 !== b.bevelThickness ? b.bevelThickness : 6,
							p = void 0 !== b.bevelSize ? b.bevelSize : ea - 2,
							v = void 0 !== b.bevelOffset ? b.bevelOffset : 0,
							q = void 0 !==
							b.bevelSegments ? b.bevelSegments : 3,
							Y = b.extrudePath,
							u = void 0 !== b.UVGenerator ? b.UVGenerator : Zj;
						void 0 !== b.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), ka = b
							.amount);
						var w = !1;
						if (Y) {
							var A = Y.getSpacedPoints(n);
							w = !0;
							r = !1;
							var z = Y.computeFrenetFrames(n, !1);
							var D = new f;
							var G = new f;
							var C = new f
						}
						r || (v = p = ea = q = 0);
						var K;
						O = a.extractPoints(O);
						a = O.shape;
						var H = O.holes;
						if (!hg.isClockWise(a)) {
							a = a.reverse();
							var B = 0;
							for (K = H.length; B < K; B++) {
								var Q = H[B];
								hg.isClockWise(Q) && (H[B] = Q.reverse())
							}
						}
						var F =
							hg.triangulateShape(a, H),
							J = a;
						B = 0;
						for (K = H.length; B < K; B++) Q = H[B], a = a.concat(Q);
						var L, N = a.length,
							M, R = F.length;
						O = [];
						var I = 0;
						var P = J.length;
						var S = P - 1;
						for (L = I + 1; I < P; I++, S++, L++) S === P && (S = 0), L === P && (L = 0), O[I] = x(J[I], J[S], J[L]);
						Y = [];
						var wa = O.concat();
						B = 0;
						for (K = H.length; B < K; B++) {
							Q = H[B];
							var T = [];
							I = 0;
							P = Q.length;
							S = P - 1;
							for (L = I + 1; I < P; I++, S++, L++) S === P && (S = 0), L === P && (L = 0), T[I] = x(Q[I], Q[S], Q[L]);
							Y.push(T);
							wa = wa.concat(T)
						}
						for (S = 0; S < q; S++) {
							P = S / q;
							var U = ea * Math.cos(P * Math.PI / 2);
							L = p * Math.sin(P * Math.PI / 2) + v;
							I = 0;
							for (P =
								J.length; I < P; I++) {
								var la = h(J[I], O[I], L);
								y(la.x, la.y, -U)
							}
							B = 0;
							for (K = H.length; B < K; B++)
								for (Q = H[B], T = Y[B], I = 0, P = Q.length; I < P; I++) la = h(Q[I], T[I], L), y(la.x, la.y, -U)
						}
						L = p + v;
						for (I = 0; I < N; I++) la = r ? h(a[I], wa[I], L) : a[I], w ? (G.copy(z.normals[0]).multiplyScalar(la.x), D.copy(
							z.binormals[0]).multiplyScalar(la.y), C.copy(A[0]).add(G).add(D), y(C.x, C.y, C.z)) : y(la.x, la.y, 0);
						for (P = 1; P <= n; P++)
							for (I = 0; I < N; I++) la = r ? h(a[I], wa[I], L) : a[I], w ? (G.copy(z.normals[P]).multiplyScalar(la.x), D.copy(
									z.binormals[P]).multiplyScalar(la.y),
								C.copy(A[P]).add(G).add(D), y(C.x, C.y, C.z)) : y(la.x, la.y, ka / n * P);
						for (S = q - 1; 0 <= S; S--) {
							P = S / q;
							U = ea * Math.cos(P * Math.PI / 2);
							L = p * Math.sin(P * Math.PI / 2) + v;
							I = 0;
							for (P = J.length; I < P; I++) la = h(J[I], O[I], L), y(la.x, la.y, ka + U);
							B = 0;
							for (K = H.length; B < K; B++)
								for (Q = H[B], T = Y[B], I = 0, P = Q.length; I < P; I++) la = h(Q[I], T[I], L), w ? y(la.x, la.y + A[n - 1]
									.y, A[n - 1].x + U) : y(la.x, la.y, ka + U)
						}(function() {
							var a = t.length / 3;
							if (r) {
								var h = 0 * N;
								for (I = 0; I < R; I++) M = F[I], k(M[2] + h, M[1] + h, M[0] + h);
								h = N * (n + 2 * q);
								for (I = 0; I < R; I++) M = F[I], k(M[0] + h, M[1] + h, M[2] + h)
							} else {
								for (I =
									0; I < R; I++) M = F[I], k(M[2], M[1], M[0]);
								for (I = 0; I < R; I++) M = F[I], k(M[0] + N * n, M[1] + N * n, M[2] + N * n)
							}
							c.addGroup(a, t.length / 3 - a, 0)
						})();
						(function() {
							var a = t.length / 3,
								h = 0;
							g(J, h);
							h += J.length;
							B = 0;
							for (K = H.length; B < K; B++) Q = H[B], g(Q, h), h += Q.length;
							c.addGroup(a, t.length / 3 - a, 1)
						})()
					}
					I.call(this);
					this.type = "ExtrudeBufferGeometry";
					this.parameters = {
						shapes: a,
						options: b
					};
					a = Array.isArray(a) ? a : [a];
					for (var c = this, t = [], e = [], g = 0, k = a.length; g < k; g++) h(a[g]);
					this.addAttribute("position", new L(t, 3));
					this.addAttribute("uv", new L(e, 2));
					this.computeVertexNormals()
				}

				function Of(a, b, c) {
					c.shapes = [];
					if (Array.isArray(a))
						for (var h = 0, d = a.length; h < d; h++) c.shapes.push(a[h].uuid);
					else c.shapes.push(a.uuid);
					void 0 !== b.extrudePath && (c.options.extrudePath = b.extrudePath.toJSON());
					return c
				}

				function ud(a, b) {
					T.call(this);
					this.type = "TextGeometry";
					this.parameters = {
						text: a,
						parameters: b
					};
					this.fromBufferGeometry(new Hc(a, b));
					this.mergeVertices()
				}

				function Hc(a, b) {
					b = b || {};
					var h = b.font;
					if (!h || !h.isFont) return console.error(
							"THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
						new T;
					a = h.generateShapes(a, b.size);
					b.depth = void 0 !== b.height ? b.height : 50;
					void 0 === b.bevelThickness && (b.bevelThickness = 10);
					void 0 === b.bevelSize && (b.bevelSize = 8);
					void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
					lf.call(this, a, b);
					this.type = "TextBufferGeometry"
				}

				function vd(a, b, c, d, e, f, g) {
					T.call(this);
					this.type = "SphereGeometry";
					this.parameters = {
						radius: a,
						widthSegments: b,
						heightSegments: c,
						phiStart: d,
						phiLength: e,
						thetaStart: f,
						thetaLength: g
					};
					this.fromBufferGeometry(new gh(a, b, c, d, e, f, g));
					this.mergeVertices()
				}

				function gh(a,
					b, c, d, e, g, k) {
					I.call(this);
					this.type = "SphereBufferGeometry";
					this.parameters = {
						radius: a,
						widthSegments: b,
						heightSegments: c,
						phiStart: d,
						phiLength: e,
						thetaStart: g,
						thetaLength: k
					};
					a = a || 1;
					b = Math.max(3, Math.floor(b) || 8);
					c = Math.max(2, Math.floor(c) || 6);
					d = void 0 !== d ? d : 0;
					e = void 0 !== e ? e : 2 * Math.PI;
					g = void 0 !== g ? g : 0;
					k = void 0 !== k ? k : Math.PI;
					var h = Math.min(g + k, Math.PI),
						t, x, y = 0,
						l = [],
						E = new f,
						m = new f,
						O = [],
						n = [],
						ka = [],
						r = [];
					for (x = 0; x <= c; x++) {
						var p = [],
							v = x / c,
							q = 0;
						0 == x && 0 == g ? q = .5 / b : x == c && h == Math.PI && (q = -.5 / b);
						for (t = 0; t <= b; t++) {
							var u =
								t / b;
							E.x = -a * Math.cos(d + u * e) * Math.sin(g + v * k);
							E.y = a * Math.cos(g + v * k);
							E.z = a * Math.sin(d + u * e) * Math.sin(g + v * k);
							n.push(E.x, E.y, E.z);
							m.copy(E).normalize();
							ka.push(m.x, m.y, m.z);
							r.push(u + q, 1 - v);
							p.push(y++)
						}
						l.push(p)
					}
					for (x = 0; x < c; x++)
						for (t = 0; t < b; t++) a = l[x][t + 1], d = l[x][t], e = l[x + 1][t], k = l[x + 1][t + 1], (0 !== x || 0 < g) &&
							O.push(a, d, k), (x !== c - 1 || h < Math.PI) && O.push(d, e, k);
					this.setIndex(O);
					this.addAttribute("position", new L(n, 3));
					this.addAttribute("normal", new L(ka, 3));
					this.addAttribute("uv", new L(r, 2))
				}

				function wd(a, b, c, d,
					e, f) {
					T.call(this);
					this.type = "RingGeometry";
					this.parameters = {
						innerRadius: a,
						outerRadius: b,
						thetaSegments: c,
						phiSegments: d,
						thetaStart: e,
						thetaLength: f
					};
					this.fromBufferGeometry(new Lc(a, b, c, d, e, f));
					this.mergeVertices()
				}

				function Lc(a, b, c, e, g, k) {
					I.call(this);
					this.type = "RingBufferGeometry";
					this.parameters = {
						innerRadius: a,
						outerRadius: b,
						thetaSegments: c,
						phiSegments: e,
						thetaStart: g,
						thetaLength: k
					};
					a = a || .5;
					b = b || 1;
					g = void 0 !== g ? g : 0;
					k = void 0 !== k ? k : 2 * Math.PI;
					c = void 0 !== c ? Math.max(3, c) : 8;
					e = void 0 !== e ? Math.max(1, e) : 1;
					var h = [],
						t = [],
						x = [],
						y = [],
						l = a,
						E = (b - a) / e,
						m = new f,
						O = new d,
						n, r;
					for (n = 0; n <= e; n++) {
						for (r = 0; r <= c; r++) a = g + r / c * k, m.x = l * Math.cos(a), m.y = l * Math.sin(a), t.push(m.x, m.y, m.z),
							x.push(0, 0, 1), O.x = (m.x / b + 1) / 2, O.y = (m.y / b + 1) / 2, y.push(O.x, O.y);
						l += E
					}
					for (n = 0; n < e; n++)
						for (b = n * (c + 1), r = 0; r < c; r++) a = r + b, g = a + c + 1, k = a + c + 2, l = a + 1, h.push(a, g, l),
							h.push(g, k, l);
					this.setIndex(h);
					this.addAttribute("position", new L(t, 3));
					this.addAttribute("normal", new L(x, 3));
					this.addAttribute("uv", new L(y, 2))
				}

				function Ed(a, b, c, d) {
					T.call(this);
					this.type = "LatheGeometry";
					this.parameters = {
						points: a,
						segments: b,
						phiStart: c,
						phiLength: d
					};
					this.fromBufferGeometry(new Sc(a, b, c, d));
					this.mergeVertices()
				}

				function Sc(a, b, c, e) {
					I.call(this);
					this.type = "LatheBufferGeometry";
					this.parameters = {
						points: a,
						segments: b,
						phiStart: c,
						phiLength: e
					};
					b = Math.floor(b) || 12;
					c = c || 0;
					e = e || 2 * Math.PI;
					e = Ea.clamp(e, 0, 2 * Math.PI);
					var h = [],
						t = [],
						x = [],
						g = 1 / b,
						y = new f,
						k = new d,
						l;
					for (l = 0; l <= b; l++) {
						var m = c + l * g * e;
						var n = Math.sin(m),
							r = Math.cos(m);
						for (m = 0; m <= a.length - 1; m++) y.x = a[m].x * n, y.y = a[m].y, y.z = a[m].x * r, t.push(y.x, y.y,
							y.z), k.x = l / b, k.y = m / (a.length - 1), x.push(k.x, k.y)
					}
					for (l = 0; l < b; l++)
						for (m = 0; m < a.length - 1; m++) c = m + l * a.length, g = c + a.length, y = c + a.length + 1, k = c + 1, h.push(
							c, g, k), h.push(g, y, k);
					this.setIndex(h);
					this.addAttribute("position", new L(t, 3));
					this.addAttribute("uv", new L(x, 2));
					this.computeVertexNormals();
					if (e === 2 * Math.PI)
						for (e = this.attributes.normal.array, h = new f, t = new f, x = new f, c = b * a.length * 3, m = l = 0; l < a
							.length; l++, m += 3) h.x = e[m + 0], h.y = e[m + 1], h.z = e[m + 2], t.x = e[c + m + 0], t.y = e[c + m + 1],
							t.z = e[c + m + 2], x.addVectors(h, t).normalize(),
							e[m + 0] = e[c + m + 0] = x.x, e[m + 1] = e[c + m + 1] = x.y, e[m + 2] = e[c + m + 2] = x.z
				}

				function di(a, b) {
					T.call(this);
					this.type = "ShapeGeometry";
					"object" === ("undefined" === typeof b ? "undefined" : Ni(b)) && (console.warn(
						"THREE.ShapeGeometry: Options parameter has been removed."), b = b.curveSegments);
					this.parameters = {
						shapes: a,
						curveSegments: b
					};
					this.fromBufferGeometry(new ei(a, b));
					this.mergeVertices()
				}

				function ei(a, b) {
					function h(a) {
						var h, f = d.length / 3;
						a = a.extractPoints(b);
						var x = a.shape,
							y = a.holes;
						!1 === hg.isClockWise(x) && (x = x.reverse());
						a =
							0;
						for (h = y.length; a < h; a++) {
							var k = y[a];
							!0 === hg.isClockWise(k) && (y[a] = k.reverse())
						}
						var l = hg.triangulateShape(x, y);
						a = 0;
						for (h = y.length; a < h; a++) k = y[a], x = x.concat(k);
						a = 0;
						for (h = x.length; a < h; a++) k = x[a], d.push(k.x, k.y, 0), t.push(0, 0, 1), e.push(k.x, k.y);
						a = 0;
						for (h = l.length; a < h; a++) x = l[a], c.push(x[0] + f, x[1] + f, x[2] + f), g += 3
					}
					I.call(this);
					this.type = "ShapeBufferGeometry";
					this.parameters = {
						shapes: a,
						curveSegments: b
					};
					b = b || 12;
					var c = [],
						d = [],
						t = [],
						e = [],
						f = 0,
						g = 0;
					if (!1 === Array.isArray(a)) h(a);
					else
						for (var k = 0; k < a.length; k++) h(a[k]),
							this.addGroup(f, g, k), f += g, g = 0;
					this.setIndex(c);
					this.addAttribute("position", new L(d, 3));
					this.addAttribute("normal", new L(t, 3));
					this.addAttribute("uv", new L(e, 2))
				}

				function cg(a, b) {
					b.shapes = [];
					if (Array.isArray(a))
						for (var h = 0, c = a.length; h < c; h++) b.shapes.push(a[h].uuid);
					else b.shapes.push(a.uuid);
					return b
				}

				function Vc(a, b) {
					I.call(this);
					this.type = "EdgesGeometry";
					this.parameters = {
						thresholdAngle: b
					};
					var h = [];
					b = Math.cos(Ea.DEG2RAD * (void 0 !== b ? b : 1));
					var c = [0, 0],
						d = {},
						t = ["a", "b", "c"];
					if (a.isBufferGeometry) {
						var e =
							new T;
						e.fromBufferGeometry(a)
					} else e = a.clone();
					e.mergeVertices();
					e.computeFaceNormals();
					a = e.vertices;
					e = e.faces;
					for (var f = 0, g = e.length; f < g; f++)
						for (var k = e[f], l = 0; 3 > l; l++) {
							var m = k[t[l]];
							var n = k[t[(l + 1) % 3]];
							c[0] = Math.min(m, n);
							c[1] = Math.max(m, n);
							m = c[0] + "," + c[1];
							void 0 === d[m] ? d[m] = {
								index1: c[0],
								index2: c[1],
								face1: f,
								face2: void 0
							} : d[m].face2 = f
						}
					for (m in d)
						if (c = d[m], void 0 === c.face2 || e[c.face1].normal.dot(e[c.face2].normal) <= b) t = a[c.index1], h.push(t.x,
							t.y, t.z), t = a[c.index2], h.push(t.x, t.y, t.z);
					this.addAttribute("position",
						new L(h, 3))
				}

				function fi(a, b, c, d, e, f, g, k) {
					T.call(this);
					this.type = "CylinderGeometry";
					this.parameters = {
						radiusTop: a,
						radiusBottom: b,
						height: c,
						radialSegments: d,
						heightSegments: e,
						openEnded: f,
						thetaStart: g,
						thetaLength: k
					};
					this.fromBufferGeometry(new ig(a, b, c, d, e, f, g, k));
					this.mergeVertices()
				}

				function ig(a, b, c, e, g, k, l, m) {
					function h(h) {
						var c, g = new d,
							k = new f,
							ka = 0,
							p = !0 === h ? a : b,
							v = !0 === h ? 1 : -1;
						var q = n;
						for (c = 1; c <= e; c++) y.push(0, r * v, 0), E.push(0, v, 0), O.push(.5, .5), n++;
						var Y = n;
						for (c = 0; c <= e; c++) {
							var u = c / e * m + l,
								w = Math.cos(u);
							u = Math.sin(u);
							k.x = p * u;
							k.y = r * v;
							k.z = p * w;
							y.push(k.x, k.y, k.z);
							E.push(0, v, 0);
							g.x = .5 * w + .5;
							g.y = .5 * u * v + .5;
							O.push(g.x, g.y);
							n++
						}
						for (c = 0; c < e; c++) g = q + c, k = Y + c, !0 === h ? x.push(k, k + 1, g) : x.push(k + 1, k, g), ka += 3;
						t.addGroup(ea, ka, !0 === h ? 1 : 2);
						ea += ka
					}
					I.call(this);
					this.type = "CylinderBufferGeometry";
					this.parameters = {
						radiusTop: a,
						radiusBottom: b,
						height: c,
						radialSegments: e,
						heightSegments: g,
						openEnded: k,
						thetaStart: l,
						thetaLength: m
					};
					var t = this;
					a = void 0 !== a ? a : 1;
					b = void 0 !== b ? b : 1;
					c = c || 1;
					e = Math.floor(e) || 8;
					g = Math.floor(g) || 1;
					k = void 0 !==
						k ? k : !1;
					l = void 0 !== l ? l : 0;
					m = void 0 !== m ? m : 2 * Math.PI;
					var x = [],
						y = [],
						E = [],
						O = [],
						n = 0,
						ka = [],
						r = c / 2,
						ea = 0;
					(function() {
						var h, d, k = new f,
							p = new f,
							v = 0,
							q = (b - a) / c;
						for (d = 0; d <= g; d++) {
							var Y = [],
								u = d / g,
								w = u * (b - a) + a;
							for (h = 0; h <= e; h++) {
								var Ma = h / e,
									A = Ma * m + l,
									z = Math.sin(A);
								A = Math.cos(A);
								p.x = w * z;
								p.y = -u * c + r;
								p.z = w * A;
								y.push(p.x, p.y, p.z);
								k.set(z, q, A).normalize();
								E.push(k.x, k.y, k.z);
								O.push(Ma, 1 - u);
								Y.push(n++)
							}
							ka.push(Y)
						}
						for (h = 0; h < e; h++)
							for (d = 0; d < g; d++) k = ka[d + 1][h], p = ka[d + 1][h + 1], q = ka[d][h + 1], x.push(ka[d][h], k, q), x.push(
								k, p, q), v += 6;
						t.addGroup(ea,
							v, 0);
						ea += v
					})();
					!1 === k && (0 < a && h(!0), 0 < b && h(!1));
					this.setIndex(x);
					this.addAttribute("position", new L(y, 3));
					this.addAttribute("normal", new L(E, 3));
					this.addAttribute("uv", new L(O, 2))
				}

				function Fd(a, b, c, d, e, f, g) {
					fi.call(this, 0, a, b, c, d, e, f, g);
					this.type = "ConeGeometry";
					this.parameters = {
						radius: a,
						height: b,
						radialSegments: c,
						heightSegments: d,
						openEnded: e,
						thetaStart: f,
						thetaLength: g
					}
				}

				function Id(a, b, c, d, e, f, g) {
					ig.call(this, 0, a, b, c, d, e, f, g);
					this.type = "ConeBufferGeometry";
					this.parameters = {
						radius: a,
						height: b,
						radialSegments: c,
						heightSegments: d,
						openEnded: e,
						thetaStart: f,
						thetaLength: g
					}
				}

				function Jd(a, b, c, d) {
					T.call(this);
					this.type = "CircleGeometry";
					this.parameters = {
						radius: a,
						segments: b,
						thetaStart: c,
						thetaLength: d
					};
					this.fromBufferGeometry(new cd(a, b, c, d));
					this.mergeVertices()
				}

				function cd(a, b, c, e) {
					I.call(this);
					this.type = "CircleBufferGeometry";
					this.parameters = {
						radius: a,
						segments: b,
						thetaStart: c,
						thetaLength: e
					};
					a = a || 1;
					b = void 0 !== b ? Math.max(3, b) : 8;
					c = void 0 !== c ? c : 0;
					e = void 0 !== e ? e : 2 * Math.PI;
					var h = [],
						t = [],
						g = [],
						x = [],
						k, y = new f,
						l = new d;
					t.push(0,
						0, 0);
					g.push(0, 0, 1);
					x.push(.5, .5);
					var m = 0;
					for (k = 3; m <= b; m++, k += 3) {
						var n = c + m / b * e;
						y.x = a * Math.cos(n);
						y.y = a * Math.sin(n);
						t.push(y.x, y.y, y.z);
						g.push(0, 0, 1);
						l.x = (t[k] / a + 1) / 2;
						l.y = (t[k + 1] / a + 1) / 2;
						x.push(l.x, l.y)
					}
					for (k = 1; k <= b; k++) h.push(k, k + 1, 0);
					this.setIndex(h);
					this.addAttribute("position", new L(t, 3));
					this.addAttribute("normal", new L(g, 3));
					this.addAttribute("uv", new L(x, 2))
				}

				function gi(a) {
					F.call(this);
					this.type = "ShadowMaterial";
					this.color = new Q(0);
					this.transparent = !0;
					this.setValues(a)
				}

				function ed(a) {
					sa.call(this,
						a);
					this.type = "RawShaderMaterial"
				}

				function mf(a) {
					F.call(this);
					this.defines = {
						STANDARD: ""
					};
					this.type = "MeshStandardMaterial";
					this.color = new Q(16777215);
					this.metalness = this.roughness = .5;
					this.lightMap = this.map = null;
					this.lightMapIntensity = 1;
					this.aoMap = null;
					this.aoMapIntensity = 1;
					this.emissive = new Q(0);
					this.emissiveIntensity = 1;
					this.bumpMap = this.emissiveMap = null;
					this.bumpScale = 1;
					this.normalMap = null;
					this.normalMapType = 0;
					this.normalScale = new d(1, 1);
					this.displacementMap = null;
					this.displacementScale = 1;
					this.displacementBias =
						0;
					this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null;
					this.envMapIntensity = 1;
					this.refractionRatio = .98;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.wireframeLinejoin = this.wireframeLinecap = "round";
					this.morphNormals = this.morphTargets = this.skinning = !1;
					this.setValues(a)
				}

				function hi(a) {
					mf.call(this);
					this.defines = {
						STANDARD: "",
						PHYSICAL: ""
					};
					this.type = "MeshPhysicalMaterial";
					this.reflectivity = .5;
					this.clearcoatRoughness = this.clearcoat = 0;
					this.sheen = null;
					this.clearcoatNormalScale = new d(1, 1);
					this.clearcoatNormalMap = null;
					this.transparency = 0;
					this.setValues(a)
				}

				function ne(a) {
					F.call(this);
					this.type = "MeshPhongMaterial";
					this.color = new Q(16777215);
					this.specular = new Q(1118481);
					this.shininess = 30;
					this.lightMap = this.map = null;
					this.lightMapIntensity = 1;
					this.aoMap = null;
					this.aoMapIntensity = 1;
					this.emissive = new Q(0);
					this.emissiveIntensity = 1;
					this.bumpMap = this.emissiveMap = null;
					this.bumpScale = 1;
					this.normalMap = null;
					this.normalMapType = 0;
					this.normalScale = new d(1, 1);
					this.displacementMap = null;
					this.displacementScale =
						1;
					this.displacementBias = 0;
					this.envMap = this.alphaMap = this.specularMap = null;
					this.combine = 0;
					this.reflectivity = 1;
					this.refractionRatio = .98;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.wireframeLinejoin = this.wireframeLinecap = "round";
					this.morphNormals = this.morphTargets = this.skinning = !1;
					this.setValues(a)
				}

				function ii(a) {
					ne.call(this);
					this.defines = {
						TOON: ""
					};
					this.type = "MeshToonMaterial";
					this.gradientMap = null;
					this.setValues(a)
				}

				function ji(a) {
					F.call(this);
					this.type = "MeshNormalMaterial";
					this.bumpMap = null;
					this.bumpScale =
						1;
					this.normalMap = null;
					this.normalMapType = 0;
					this.normalScale = new d(1, 1);
					this.displacementMap = null;
					this.displacementScale = 1;
					this.displacementBias = 0;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.morphNormals = this.morphTargets = this.skinning = this.fog = !1;
					this.setValues(a)
				}

				function ki(a) {
					F.call(this);
					this.type = "MeshLambertMaterial";
					this.color = new Q(16777215);
					this.lightMap = this.map = null;
					this.lightMapIntensity = 1;
					this.aoMap = null;
					this.aoMapIntensity = 1;
					this.emissive = new Q(0);
					this.emissiveIntensity = 1;
					this.envMap =
						this.alphaMap = this.specularMap = this.emissiveMap = null;
					this.combine = 0;
					this.reflectivity = 1;
					this.refractionRatio = .98;
					this.wireframe = !1;
					this.wireframeLinewidth = 1;
					this.wireframeLinejoin = this.wireframeLinecap = "round";
					this.morphNormals = this.morphTargets = this.skinning = !1;
					this.setValues(a)
				}

				function li(a) {
					F.call(this);
					this.defines = {
						MATCAP: ""
					};
					this.type = "MeshMatcapMaterial";
					this.color = new Q(16777215);
					this.bumpMap = this.map = this.matcap = null;
					this.bumpScale = 1;
					this.normalMap = null;
					this.normalMapType = 0;
					this.normalScale =
						new d(1, 1);
					this.displacementMap = null;
					this.displacementScale = 1;
					this.displacementBias = 0;
					this.alphaMap = null;
					this.morphNormals = this.morphTargets = this.skinning = !1;
					this.setValues(a)
				}

				function mi(a) {
					Ka.call(this);
					this.type = "LineDashedMaterial";
					this.scale = 1;
					this.dashSize = 3;
					this.gapSize = 1;
					this.setValues(a)
				}

				function Wc(a, b, c, d) {
					this.parameterPositions = a;
					this._cachedIndex = 0;
					this.resultBuffer = void 0 !== d ? d : new b.constructor(c);
					this.sampleValues = b;
					this.valueSize = c
				}

				function Be(a, b, c, d) {
					Wc.call(this, a, b, c, d);
					this._offsetNext =
						this._weightNext = this._offsetPrev = this._weightPrev = -0
				}

				function Ld(a, b, c, d) {
					Wc.call(this, a, b, c, d)
				}

				function Ce(a, b, c, d) {
					Wc.call(this, a, b, c, d)
				}

				function Ab(a, b, c, d) {
					if (void 0 === a) throw Error("THREE.KeyframeTrack: track name is undefined");
					if (void 0 === b || 0 === b.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + a);
					this.name = a;
					this.times = sb.convertArray(b, this.TimeBufferType);
					this.values = sb.convertArray(c, this.ValueBufferType);
					this.setInterpolation(d || this.DefaultInterpolation)
				}

				function De(a,
					b, c) {
					Ab.call(this, a, b, c)
				}

				function Ee(a, b, c, d) {
					Ab.call(this, a, b, c, d)
				}

				function id(a, b, c, d) {
					Ab.call(this, a, b, c, d)
				}

				function Ge(a, b, c, d) {
					Wc.call(this, a, b, c, d)
				}

				function Pd(a, b, c, d) {
					Ab.call(this, a, b, c, d)
				}

				function Ke(a, b, c, d) {
					Ab.call(this, a, b, c, d)
				}

				function ld(a, b, c, d) {
					Ab.call(this, a, b, c, d)
				}

				function Gd(a, b, c) {
					this.name = a;
					this.tracks = c;
					this.duration = void 0 !== b ? b : -1;
					this.uuid = Ea.generateUUID();
					0 > this.duration && this.resetDuration()
				}

				function vh(a) {
					switch (a.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return id;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return ld;
						case "color":
							return Ee;
						case "quaternion":
							return Pd;
						case "bool":
						case "boolean":
							return De;
						case "string":
							return Ke
					}
					throw Error("THREE.KeyframeTrack: Unsupported typeName: " + a);
				}

				function wh(a) {
					if (void 0 === a.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
					var b = vh(a.type);
					if (void 0 === a.times) {
						var h = [],
							c = [];
						sb.flattenJSON(a.keys, h, c, "value");
						a.times = h;
						a.values = c
					}
					return void 0 !== b.parse ? b.parse(a) : new b(a.name,
						a.times, a.values, a.interpolation)
				}

				function xf(a, b, c) {
					var h = this,
						d = !1,
						t = 0,
						e = 0,
						f = void 0,
						g = [];
					this.onStart = void 0;
					this.onLoad = a;
					this.onProgress = b;
					this.onError = c;
					this.itemStart = function(a) {
						e++;
						if (!1 === d && void 0 !== h.onStart) h.onStart(a, t, e);
						d = !0
					};
					this.itemEnd = function(a) {
						t++;
						if (void 0 !== h.onProgress) h.onProgress(a, t, e);
						if (t === e && (d = !1, void 0 !== h.onLoad)) h.onLoad()
					};
					this.itemError = function(a) {
						if (void 0 !== h.onError) h.onError(a)
					};
					this.resolveURL = function(a) {
						return f ? f(a) : a
					};
					this.setURLModifier = function(a) {
						f =
							a;
						return this
					};
					this.addHandler = function(a, b) {
						g.push(a, b);
						return this
					};
					this.removeHandler = function(a) {
						a = g.indexOf(a); - 1 !== a && g.splice(a, 2);
						return this
					};
					this.getHandler = function(a) {
						for (var b = 0, h = g.length; b < h; b += 2) {
							var c = g[b + 1];
							if (g[b].test(a)) return c
						}
						return null
					}
				}

				function Qa(a) {
					this.manager = void 0 !== a ? a : Oi;
					this.crossOrigin = "anonymous";
					this.resourcePath = this.path = ""
				}

				function Hd(a) {
					Qa.call(this, a)
				}

				function yf(a) {
					Qa.call(this, a)
				}

				function zf(a) {
					Qa.call(this, a)
				}

				function Oe(a) {
					Qa.call(this, a)
				}

				function Aj(a) {
					Qa.call(this,
						a)
				}

				function Pe(a) {
					Qa.call(this, a)
				}

				function Qe(a) {
					Qa.call(this, a)
				}

				function oa() {
					this.type = "Curve";
					this.arcLengthDivisions = 200
				}

				function Xc(a, b, c, d, e, f, g, k) {
					oa.call(this);
					this.type = "EllipseCurve";
					this.aX = a || 0;
					this.aY = b || 0;
					this.xRadius = c || 1;
					this.yRadius = d || 1;
					this.aStartAngle = e || 0;
					this.aEndAngle = f || 2 * Math.PI;
					this.aClockwise = g || !1;
					this.aRotation = k || 0
				}

				function Bj(a, b, c, d, e, f) {
					Xc.call(this, a, b, c, c, d, e, f);
					this.type = "ArcCurve"
				}

				function Bf() {
					var a = 0,
						b = 0,
						c = 0,
						d = 0;
					return {
						initCatmullRom: function(h, t, e, f, g) {
							h = g *
								(e - h);
							f = g * (f - t);
							a = t;
							b = h;
							c = -3 * t + 3 * e - 2 * h - f;
							d = 2 * t - 2 * e + h + f
						},
						initNonuniformCatmullRom: function(h, t, e, f, g, x, k) {
							h = ((t - h) / g - (e - h) / (g + x) + (e - t) / x) * x;
							f = ((e - t) / x - (f - t) / (x + k) + (f - e) / k) * x;
							a = t;
							b = h;
							c = -3 * t + 3 * e - 2 * h - f;
							d = 2 * t - 2 * e + h + f
						},
						calc: function(h) {
							var t = h * h;
							return a + b * h + c * t + d * t * h
						}
					}
				}

				function Kb(a, b, c, d) {
					oa.call(this);
					this.type = "CatmullRomCurve3";
					this.points = a || [];
					this.closed = b || !1;
					this.curveType = c || "centripetal";
					this.tension = d || .5
				}

				function Hg(a, b, c, d, e) {
					b = .5 * (d - b);
					e = .5 * (e - c);
					var h = a * a;
					return (2 * c - 2 * d + b + e) * a * h + (-3 * c +
						3 * d - 2 * b - e) * h + b * a + c
				}

				function ae(a, b, c, d) {
					var h = 1 - a;
					return h * h * b + 2 * (1 - a) * a * c + a * a * d
				}

				function be(a, b, c, d, e) {
					var h = 1 - a,
						t = 1 - a;
					return h * h * h * b + 3 * t * t * a * c + 3 * (1 - a) * a * a * d + a * a * a * e
				}

				function oe(a, b, c, e) {
					oa.call(this);
					this.type = "CubicBezierCurve";
					this.v0 = a || new d;
					this.v1 = b || new d;
					this.v2 = c || new d;
					this.v3 = e || new d
				}

				function nf(a, b, c, d) {
					oa.call(this);
					this.type = "CubicBezierCurve3";
					this.v0 = a || new f;
					this.v1 = b || new f;
					this.v2 = c || new f;
					this.v3 = d || new f
				}

				function pc(a, b) {
					oa.call(this);
					this.type = "LineCurve";
					this.v1 = a || new d;
					this.v2 = b || new d
				}

				function pe(a, b) {
					oa.call(this);
					this.type = "LineCurve3";
					this.v1 = a || new f;
					this.v2 = b || new f
				}

				function qe(a, b, c) {
					oa.call(this);
					this.type = "QuadraticBezierCurve";
					this.v0 = a || new d;
					this.v1 = b || new d;
					this.v2 = c || new d
				}

				function of (a, b, c) {
					oa.call(this);
					this.type = "QuadraticBezierCurve3";
					this.v0 = a || new f;
					this.v1 = b || new f;
					this.v2 = c || new f
				}

				function re(a) {
					oa.call(this);
					this.type = "SplineCurve";
					this.points = a || []
				}

				function jg() {
					oa.call(this);
					this.type = "CurvePath";
					this.curves = [];
					this.autoClose = !1
				}

				function se(a) {
					jg.call(this);
					this.type = "Path";
					this.currentPoint = new d;
					a && this.setFromPoints(a)
				}

				function hh(a) {
					se.call(this, a);
					this.uuid = Ea.generateUUID();
					this.type = "Shape";
					this.holes = []
				}

				function Ta(a, b) {
					u.call(this);
					this.type = "Light";
					this.color = new Q(a);
					this.intensity = void 0 !== b ? b : 1;
					this.receiveShadow = void 0
				}

				function Te(a, b, c) {
					Ta.call(this, a, c);
					this.type = "HemisphereLight";
					this.castShadow = void 0;
					this.position.copy(u.DefaultUp);
					this.updateMatrix();
					this.groundColor = new Q(b)
				}

				function pf(a) {
					this.camera = a;
					this.bias = 0;
					this.radius = 1;
					this.mapSize = new d(512, 512);
					this.mapPass = this.map = null;
					this.matrix = new v;
					this._frustum = new U;
					this._frameExtents = new d(1, 1);
					this._viewportCount = 1;
					this._viewports = [new m(0, 0, 1, 1)]
				}

				function Ue() {
					pf.call(this, new Ja(50, 1, .5, 500))
				}

				function Ve(a, b, c, d, e, f) {
					Ta.call(this, a, b);
					this.type = "SpotLight";
					this.position.copy(u.DefaultUp);
					this.updateMatrix();
					this.target = new u;
					Object.defineProperty(this, "power", {
						get: function() {
							return this.intensity * Math.PI
						},
						set: function(a) {
							this.intensity = a / Math.PI
						}
					});
					this.distance =
						void 0 !== c ? c : 0;
					this.angle = void 0 !== d ? d : Math.PI / 3;
					this.penumbra = void 0 !== e ? e : 0;
					this.decay = void 0 !== f ? f : 1;
					this.shadow = new Ue
				}

				function Ff() {
					pf.call(this, new Ja(90, 1, .5, 500));
					this._frameExtents = new d(4, 2);
					this._viewportCount = 6;
					this._viewports = [new m(2, 1, 1, 1), new m(0, 1, 1, 1), new m(3, 1, 1, 1), new m(1, 1, 1, 1), new m(3, 0, 1, 1),
						new m(1, 0, 1, 1)
					];
					this._cubeDirections = [new f(1, 0, 0), new f(-1, 0, 0), new f(0, 0, 1), new f(0, 0, -1), new f(0, 1, 0), new f(
						0, -1, 0)];
					this._cubeUps = [new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0), new f(0, 1, 0),
						new f(0, 0, 1), new f(0, 0, -1)
					]
				}

				function We(a, b, c, d) {
					Ta.call(this, a, b);
					this.type = "PointLight";
					Object.defineProperty(this, "power", {
						get: function() {
							return 4 * this.intensity * Math.PI
						},
						set: function(a) {
							this.intensity = a / (4 * Math.PI)
						}
					});
					this.distance = void 0 !== c ? c : 0;
					this.decay = void 0 !== d ? d : 1;
					this.shadow = new Ff
				}

				function ce(a, b, c, d, e, f) {
					va.call(this);
					this.type = "OrthographicCamera";
					this.zoom = 1;
					this.view = null;
					this.left = void 0 !== a ? a : -1;
					this.right = void 0 !== b ? b : 1;
					this.top = void 0 !== c ? c : 1;
					this.bottom = void 0 !== d ? d : -1;
					this.near =
						void 0 !== e ? e : .1;
					this.far = void 0 !== f ? f : 2E3;
					this.updateProjectionMatrix()
				}

				function Xe() {
					pf.call(this, new ce(-5, 5, 5, -5, .5, 500))
				}

				function Ye(a, b) {
					Ta.call(this, a, b);
					this.type = "DirectionalLight";
					this.position.copy(u.DefaultUp);
					this.updateMatrix();
					this.target = new u;
					this.shadow = new Xe
				}

				function Ze(a, b) {
					Ta.call(this, a, b);
					this.type = "AmbientLight";
					this.castShadow = void 0
				}

				function $e(a, b, c, d) {
					Ta.call(this, a, b);
					this.type = "RectAreaLight";
					this.width = void 0 !== c ? c : 10;
					this.height = void 0 !== d ? d : 10
				}

				function af(a) {
					Qa.call(this,
						a);
					this.textures = {}
				}

				function bf() {
					I.call(this);
					this.type = "InstancedBufferGeometry";
					this.maxInstancedCount = void 0
				}

				function cf(a, b, c, d) {
					"number" === typeof c && (d = c, c = !1, console.error(
						"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));
					R.call(this, a, b, c);
					this.meshPerAttribute = d || 1
				}

				function ef(a) {
					Qa.call(this, a)
				}

				function ff(a) {
					Qa.call(this, a)
				}

				function Pf(a) {
					"undefined" === typeof createImageBitmap && console.warn(
						"THREE.ImageBitmapLoader: createImageBitmap() not supported.");
					"undefined" === typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
					Qa.call(this, a);
					this.options = void 0
				}

				function Qf() {
					this.type = "ShapePath";
					this.color = new Q;
					this.subPaths = [];
					this.currentPath = null
				}

				function Rf(a) {
					this.type = "Font";
					this.data = a
				}

				function Sf(a) {
					Qa.call(this, a)
				}

				function gf(a) {
					Qa.call(this, a)
				}

				function hf() {
					this.coefficients = [];
					for (var a = 0; 9 > a; a++) this.coefficients.push(new f)
				}

				function te(a, b) {
					Ta.call(this, void 0, b);
					this.sh = void 0 !== a ? a : new hf
				}

				function Tf(a, b, c) {
					te.call(this,
						void 0, c);
					a = (new Q).set(a);
					c = (new Q).set(b);
					b = new f(a.r, a.g, a.b);
					a = new f(c.r, c.g, c.b);
					c = Math.sqrt(Math.PI);
					var h = c * Math.sqrt(.75);
					this.sh.coefficients[0].copy(b).add(a).multiplyScalar(c);
					this.sh.coefficients[1].copy(b).sub(a).multiplyScalar(h)
				}

				function Vf(a, b) {
					te.call(this, void 0, b);
					a = (new Q).set(a);
					this.sh.coefficients[0].set(a.r, a.g, a.b).multiplyScalar(2 * Math.sqrt(Math.PI))
				}

				function Sg() {
					this.type = "StereoCamera";
					this.aspect = 1;
					this.eyeSep = .064;
					this.cameraL = new Ja;
					this.cameraL.layers.enable(1);
					this.cameraL.matrixAutoUpdate = !1;
					this.cameraR = new Ja;
					this.cameraR.layers.enable(2);
					this.cameraR.matrixAutoUpdate = !1;
					this._cache = {
						focus: null,
						fov: null,
						aspect: null,
						near: null,
						far: null,
						zoom: null,
						eyeSep: null
					}
				}

				function Wf(a) {
					this.autoStart = void 0 !== a ? a : !0;
					this.elapsedTime = this.oldTime = this.startTime = 0;
					this.running = !1
				}

				function Xf() {
					u.call(this);
					this.type = "AudioListener";
					this.context = Fh.getContext();
					this.gain = this.context.createGain();
					this.gain.connect(this.context.destination);
					this.filter = null;
					this.timeDelta = 0;
					this._clock = new Wf
				}

				function Cj(a) {
					u.call(this);
					this.type = "Audio";
					this.listener = a;
					this.context = a.context;
					this.gain = this.context.createGain();
					this.gain.connect(a.getInput());
					this.autoplay = !1;
					this.buffer = null;
					this.detune = 0;
					this.loop = !1;
					this.offset = this.startTime = 0;
					this.duration = void 0;
					this.playbackRate = 1;
					this.isPlaying = !1;
					this.hasPlaybackControl = !0;
					this.sourceType = "empty";
					this.filters = []
				}

				function Yf(a) {
					Cj.call(this, a);
					this.panner = this.context.createPanner();
					this.panner.panningModel = "HRTF";
					this.panner.connect(this.gain)
				}

				function Zf(a, b) {
					this.analyser =
						a.context.createAnalyser();
					this.analyser.fftSize = void 0 !== b ? b : 2048;
					this.data = new Uint8Array(this.analyser.frequencyBinCount);
					a.getOutput().connect(this.analyser)
				}

				function $f(a, b, c) {
					this.binding = a;
					this.valueSize = c;
					a = Float64Array;
					switch (b) {
						case "quaternion":
							b = this._slerp;
							break;
						case "string":
						case "bool":
							a = Array;
							b = this._select;
							break;
						default:
							b = this._lerp
					}
					this.buffer = new a(4 * c);
					this._mixBufferRegion = b;
					this.referenceCount = this.useCount = this.cumulativeWeight = 0
				}

				function Ug(a, b, c) {
					c = c || Lb.parseTrackName(b);
					this._targetGroup = a;
					this._bindings = a.subscribe_(b, c)
				}

				function Lb(a, b, c) {
					this.path = b;
					this.parsedPath = c || Lb.parseTrackName(b);
					this.node = Lb.findNode(a, this.parsedPath.nodeName) || a;
					this.rootNode = a
				}

				function Xg() {
					this.uuid = Ea.generateUUID();
					this._objects = Array.prototype.slice.call(arguments);
					this.nCachedObjects_ = 0;
					var a = {};
					this._indicesByUUID = a;
					for (var b = 0, c = arguments.length; b !== c; ++b) a[arguments[b].uuid] = b;
					this._paths = [];
					this._parsedPaths = [];
					this._bindings = [];
					this._bindingsIndicesByPath = {};
					var d = this;
					this.stats = {
						objects: {
							get total() {
								return d._objects.length
							},
							get inUse() {
								return this.total - d.nCachedObjects_
							}
						},
						get bindingsPerObject() {
							return d._bindings.length
						}
					}
				}

				function Yg(a, b, c) {
					this._mixer = a;
					this._clip = b;
					this._localRoot = c || null;
					a = b.tracks;
					b = a.length;
					c = Array(b);
					for (var h = {
							endingStart: 2400,
							endingEnd: 2400
						}, d = 0; d !== b; ++d) {
						var t = a[d].createInterpolant(null);
						c[d] = t;
						t.settings = h
					}
					this._interpolantSettings = h;
					this._interpolants = c;
					this._propertyBindings = Array(b);
					this._weightInterpolant = this._timeScaleInterpolant =
						this._byClipCacheIndex = this._cacheIndex = null;
					this.loop = 2201;
					this._loopCount = -1;
					this._startTime = null;
					this.time = 0;
					this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1;
					this.repetitions = Infinity;
					this.paused = !1;
					this.enabled = !0;
					this.clampWhenFinished = !1;
					this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
				}

				function ag(a) {
					this._root = a;
					this._initMemoryManager();
					this.time = this._accuIndex = 0;
					this.timeScale = 1
				}

				function jf(a, b) {
					"string" === typeof a && (console.warn("THREE.Uniform: Type parameter is no longer needed."),
						a = b);
					this.value = a
				}

				function eg(a, b, c) {
					Db.call(this, a, b);
					this.meshPerAttribute = c || 1
				}

				function dh(a, b, c, d) {
					this.ray = new B(a, b);
					this.near = c || 0;
					this.far = d || Infinity;
					this.camera = null;
					this.params = {
						Mesh: {},
						Line: {},
						LOD: {},
						Points: {
							threshold: 1
						},
						Sprite: {}
					};
					ja(this.params, {
						PointCloud: {
							get: function() {
								console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
								return this.Points
							}
						}
					})
				}

				function eh(a, b) {
					return a.distance - b.distance
				}

				function fg(a, b, c, d) {
					if (!1 !== a.visible && (a.raycast(b, c), !0 ===
							d)) {
						a = a.children;
						d = 0;
						for (var h = a.length; d < h; d++) fg(a[d], b, c, !0)
					}
				}

				function fh(a, b, c) {
					this.radius = void 0 !== a ? a : 1;
					this.phi = void 0 !== b ? b : 0;
					this.theta = void 0 !== c ? c : 0;
					return this
				}

				function oh(a, b, c) {
					this.radius = void 0 !== a ? a : 1;
					this.theta = void 0 !== b ? b : 0;
					this.y = void 0 !== c ? c : 0;
					return this
				}

				function sg(a, b) {
					this.min = void 0 !== a ? a : new d(Infinity, Infinity);
					this.max = void 0 !== b ? b : new d(-Infinity, -Infinity)
				}

				function tg(a, b) {
					this.start = void 0 !== a ? a : new f;
					this.end = void 0 !== b ? b : new f
				}

				function xe(a) {
					u.call(this);
					this.material =
						a;
					this.render = function() {}
				}

				function ze(a, b, c, d) {
					this.object = a;
					this.size = void 0 !== b ? b : 1;
					a = void 0 !== c ? c : 16711680;
					d = void 0 !== d ? d : 1;
					b = 0;
					(c = this.object.geometry) && c.isGeometry ? b = 3 * c.faces.length : c && c.isBufferGeometry && (b = c.attributes
						.normal.count);
					c = new I;
					b = new L(6 * b, 3);
					c.addAttribute("position", b);
					Sa.call(this, c, new Ka({
						color: a,
						linewidth: d
					}));
					this.matrixAutoUpdate = !1;
					this.update()
				}

				function Dj(a, b) {
					u.call(this);
					this.light = a;
					this.light.updateMatrixWorld();
					this.matrix = a.matrixWorld;
					this.matrixAutoUpdate = !1;
					this.color = b;
					a = new I;
					b = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
					for (var h = 0, c = 1; 32 > h; h++, c++) {
						var d = h / 32 * Math.PI * 2,
							t = c / 32 * Math.PI * 2;
						b.push(Math.cos(d), Math.sin(d), 1, Math.cos(t), Math.sin(t), 1)
					}
					a.addAttribute("position", new L(b, 3));
					b = new Ka({
						fog: !1
					});
					this.cone = new Sa(a, b);
					this.add(this.cone);
					this.update()
				}

				function ph(a) {
					var b = [];
					a && a.isBone && b.push(a);
					for (var h = 0; h < a.children.length; h++) b.push.apply(b, ph(a.children[h]));
					return b
				}

				function Ej(a) {
					for (var b = ph(a), h = new I, c = [],
							d = [], e = new Q(0, 0, 1), f = new Q(0, 1, 0), g = 0; g < b.length; g++) {
						var k = b[g];
						k.parent && k.parent.isBone && (c.push(0, 0, 0), c.push(0, 0, 0), d.push(e.r, e.g, e.b), d.push(f.r, f.g, f.b))
					}
					h.addAttribute("position", new L(c, 3));
					h.addAttribute("color", new L(d, 3));
					c = new Ka({
						vertexColors: 2,
						depthTest: !1,
						depthWrite: !1,
						transparent: !0
					});
					Sa.call(this, h, c);
					this.root = a;
					this.bones = b;
					this.matrix = a.matrixWorld;
					this.matrixAutoUpdate = !1
				}

				function Fj(a, b, c) {
					this.light = a;
					this.light.updateMatrixWorld();
					this.color = c;
					a = new gh(b, 4, 2);
					b = new S({
						wireframe: !0,
						fog: !1
					});
					ha.call(this, a, b);
					this.matrix = this.light.matrixWorld;
					this.matrixAutoUpdate = !1;
					this.update()
				}

				function Gj(a, b) {
					this.type = "RectAreaLightHelper";
					this.light = a;
					this.color = b;
					a = new I;
					a.addAttribute("position", new L([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3));
					a.computeBoundingSphere();
					b = new Ka({
						fog: !1
					});
					yb.call(this, a, b);
					a = new I;
					a.addAttribute("position", new L([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3));
					a.computeBoundingSphere();
					this.add(new ha(a, new S({
						side: 1,
						fog: !1
					})));
					this.update()
				}

				function Hj(a,
					b, c) {
					u.call(this);
					this.light = a;
					this.light.updateMatrixWorld();
					this.matrix = a.matrixWorld;
					this.matrixAutoUpdate = !1;
					this.color = c;
					a = new ac(b);
					a.rotateY(.5 * Math.PI);
					this.material = new S({
						wireframe: !0,
						fog: !1
					});
					void 0 === this.color && (this.material.vertexColors = 2);
					b = a.getAttribute("position");
					b = new Float32Array(3 * b.count);
					a.addAttribute("color", new R(b, 3));
					this.add(new ha(a, this.material));
					this.update()
				}

				function Ij(a, b) {
					this.lightProbe = a;
					this.size = b;
					a = new sa({
						defines: {
							GAMMA_OUTPUT: ""
						},
						uniforms: {
							sh: {
								value: this.lightProbe.sh.coefficients
							},
							intensity: {
								value: this.lightProbe.intensity
							}
						},
						vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
						fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}"
					});
					b = new gh(1, 32, 16);
					ha.call(this, b, a);
					this.onBeforeRender()
				}

				function uf(a, b, c, d) {
					a = a || 10;
					b = b || 10;
					c = new Q(void 0 !== c ? c : 4473924);
					d = new Q(void 0 !== d ? d : 8947848);
					var h = b / 2,
						t = a / b,
						e = a / 2;
					a = [];
					for (var f = [], g = 0, x = 0, k = -e; g <= b; g++, k += t) {
						a.push(-e, 0, k, e, 0, k);
						a.push(k, 0, -e, k, 0, e);
						var y = g === h ? c : d;
						y.toArray(f, x);
						x += 3;
						y.toArray(f, x);
						x += 3;
						y.toArray(f, x);
						x += 3;
						y.toArray(f, x);
						x += 3
					}
					b = new I;
					b.addAttribute("position", new L(a, 3));
					b.addAttribute("color", new L(f, 3));
					c = new Ka({
						vertexColors: 2
					});
					Sa.call(this, b, c)
				}

				function vf(a,
					b, c, d, e, f) {
					a = a || 10;
					b = b || 16;
					c = c || 8;
					d = d || 64;
					e = new Q(void 0 !== e ? e : 4473924);
					f = new Q(void 0 !== f ? f : 8947848);
					var h = [],
						t = [],
						g;
					for (g = 0; g <= b; g++) {
						var x = g / b * 2 * Math.PI;
						var k = Math.sin(x) * a;
						x = Math.cos(x) * a;
						h.push(0, 0, 0);
						h.push(k, 0, x);
						var y = g & 1 ? e : f;
						t.push(y.r, y.g, y.b);
						t.push(y.r, y.g, y.b)
					}
					for (g = 0; g <= c; g++) {
						y = g & 1 ? e : f;
						var l = a - a / c * g;
						for (b = 0; b < d; b++) x = b / d * 2 * Math.PI, k = Math.sin(x) * l, x = Math.cos(x) * l, h.push(k, 0, x), t.push(
							y.r, y.g, y.b), x = (b + 1) / d * 2 * Math.PI, k = Math.sin(x) * l, x = Math.cos(x) * l, h.push(k, 0, x), t.push(
							y.r, y.g, y.b)
					}
					a =
						new I;
					a.addAttribute("position", new L(h, 3));
					a.addAttribute("color", new L(t, 3));
					h = new Ka({
						vertexColors: 2
					});
					Sa.call(this, a, h)
				}

				function Jj(a, b, c, d) {
					this.audio = a;
					this.range = b || 1;
					this.divisionsInnerAngle = c || 16;
					this.divisionsOuterAngle = d || 2;
					a = new I;
					b = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3));
					a.addAttribute("position", new R(b, 3));
					b = new Ka({
						color: 65280
					});
					c = new Ka({
						color: 16776960
					});
					yb.call(this, a, [c, b]);
					this.update()
				}

				function Fe(a, b, c, d) {
					this.object = a;
					this.size = void 0 !==
						b ? b : 1;
					a = void 0 !== c ? c : 16776960;
					d = void 0 !== d ? d : 1;
					b = 0;
					(c = this.object.geometry) && c.isGeometry ? b = c.faces.length : console.warn(
						"THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.");
					c = new I;
					b = new L(6 * b, 3);
					c.addAttribute("position", b);
					Sa.call(this, c, new Ka({
						color: a,
						linewidth: d
					}));
					this.matrixAutoUpdate = !1;
					this.update()
				}

				function Kj(a, b, c) {
					u.call(this);
					this.light = a;
					this.light.updateMatrixWorld();
					this.matrix = a.matrixWorld;
					this.matrixAutoUpdate = !1;
					this.color = c;
					void 0 ===
						b && (b = 1);
					a = new I;
					a.addAttribute("position", new L([-b, b, 0, b, b, 0, b, -b, 0, -b, -b, 0, -b, b, 0], 3));
					b = new Ka({
						fog: !1
					});
					this.lightPlane = new yb(a, b);
					this.add(this.lightPlane);
					a = new I;
					a.addAttribute("position", new L([0, 0, 0, 0, 0, 1], 3));
					this.targetLine = new yb(a, b);
					this.add(this.targetLine);
					this.update()
				}

				function He(a) {
					function b(a, b, c) {
						h(a, c);
						h(b, c)
					}

					function h(a, b) {
						e.push(0, 0, 0);
						f.push(b.r, b.g, b.b);
						void 0 === g[a] && (g[a] = []);
						g[a].push(e.length / 3 - 1)
					}
					var c = new I,
						d = new Ka({
							color: 16777215,
							vertexColors: 1
						}),
						e = [],
						f = [],
						g = {},
						k = new Q(16755200),
						l = new Q(16711680),
						m = new Q(43775),
						n = new Q(16777215),
						r = new Q(3355443);
					b("n1", "n2", k);
					b("n2", "n4", k);
					b("n4", "n3", k);
					b("n3", "n1", k);
					b("f1", "f2", k);
					b("f2", "f4", k);
					b("f4", "f3", k);
					b("f3", "f1", k);
					b("n1", "f1", k);
					b("n2", "f2", k);
					b("n3", "f3", k);
					b("n4", "f4", k);
					b("p", "n1", l);
					b("p", "n2", l);
					b("p", "n3", l);
					b("p", "n4", l);
					b("u1", "u2", m);
					b("u2", "u3", m);
					b("u3", "u1", m);
					b("c", "t", n);
					b("p", "c", r);
					b("cn1", "cn2", r);
					b("cn3", "cn4", r);
					b("cf1", "cf2", r);
					b("cf3", "cf4", r);
					c.addAttribute("position", new L(e, 3));
					c.addAttribute("color", new L(f, 3));
					Sa.call(this, c, d);
					this.camera = a;
					this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix();
					this.matrix = a.matrixWorld;
					this.matrixAutoUpdate = !1;
					this.pointMap = g;
					this.update()
				}

				function ib(a, b, c, d, e, f, g) {
					Ek.set(e, f, g).unproject(d);
					a = b[a];
					if (void 0 !== a)
						for (c = c.getAttribute("position"), b = 0, d = a.length; b < d; b++) c.setXYZ(a[b], Ek.x, Ek.y, Ek.z)
				}

				function kg(a, b) {
					this.object = a;
					void 0 === b && (b = 16776960);
					a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6,
						3, 7
					]);
					var h = new Float32Array(24),
						c = new I;
					c.setIndex(new R(a, 1));
					c.addAttribute("position", new R(h, 3));
					Sa.call(this, c, new Ka({
						color: b
					}));
					this.matrixAutoUpdate = !1;
					this.update()
				}

				function Ie(a, b) {
					this.type = "Box3Helper";
					this.box = a;
					b = b || 16776960;
					a = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
					var h = new I;
					h.setIndex(new R(a, 1));
					h.addAttribute("position", new L([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -
						1, -1
					], 3));
					Sa.call(this, h, new Ka({
						color: b
					}));
					this.geometry.computeBoundingSphere()
				}

				function Je(a, b, c) {
					this.type = "PlaneHelper";
					this.plane = a;
					this.size = void 0 === b ? 1 : b;
					a = void 0 !== c ? c : 16776960;
					b = new I;
					b.addAttribute("position", new L([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1,
						1, 0, 0, 1, 0, 0, 0
					], 3));
					b.computeBoundingSphere();
					yb.call(this, b, new Ka({
						color: a
					}));
					b = new I;
					b.addAttribute("position", new L([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3));
					b.computeBoundingSphere();
					this.add(new ha(b, new S({
						color: a,
						opacity: .2,
						transparent: !0,
						depthWrite: !1
					})))
				}

				function lg(a, b, c, d, e, g) {
					u.call(this);
					void 0 === a && (a = new f(0, 0, 1));
					void 0 === b && (b = new f(0, 0, 0));
					void 0 === c && (c = 1);
					void 0 === d && (d = 16776960);
					void 0 === e && (e = .2 * c);
					void 0 === g && (g = .2 * e);
					void 0 === Fk && (Fk = new I, Fk.addAttribute("position", new L([0, 0, 0, 0, 1, 0], 3)), Rh = new ig(0, .5, 1,
						5, 1), Rh.translate(0, -.5, 0));
					this.position.copy(b);
					this.line = new yb(Fk, new Ka({
						color: d
					}));
					this.line.matrixAutoUpdate = !1;
					this.add(this.line);
					this.cone = new ha(Rh, new S({
						color: d
					}));
					this.cone.matrixAutoUpdate = !1;
					this.add(this.cone);
					this.setDirection(a);
					this.setLength(c, e,
						g)
				}

				function Me(a) {
					a = a || 1;
					var b = [0, 0, 0, a, 0, 0, 0, 0, 0, 0, a, 0, 0, 0, 0, 0, 0, a];
					a = new I;
					a.addAttribute("position", new L(b, 3));
					a.addAttribute("color", new L([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3));
					b = new Ka({
						vertexColors: 2
					});
					Sa.call(this, a, b)
				}

				function th(a) {
					console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
					Kb.call(this, a);
					this.type = "catmullrom";
					this.closed = !0
				}

				function uh(a) {
					console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
					Kb.call(this, a);
					this.type = "catmullrom"
				}

				function zg(a) {
					console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
					Kb.call(this, a);
					this.type = "catmullrom"
				}
				void 0 === Na && (Number.EPSILON = Math.pow(2, -52));
				void 0 === Dk && (Number.isInteger = function(a) {
					return "number" === typeof a && isFinite(a) && Math.floor(a) === a
				});
				void 0 === Lg && (Math.sign = function(a) {
					return 0 > a ? -1 : 0 < a ? 1 : +a
				});
				!1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
					get: function() {
						return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
					}
				});
				void 0 === q && (Object.assign = function(a) {
					if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
					for (var b = Object(a), h = 1; h < arguments.length; h++) {
						var c = arguments[h];
						if (void 0 !== c && null !== c)
							for (var d in c) Object.prototype.hasOwnProperty.call(c, d) && (b[d] = c[d])
					}
					return b
				});
				q(b.prototype, {
					addEventListener: function(a, b) {
						void 0 === this._listeners && (this._listeners = {});
						var h = this._listeners;
						void 0 === h[a] && (h[a] = []); - 1 === h[a].indexOf(b) && h[a].push(b)
					},
					hasEventListener: function(a,
						b) {
						if (void 0 === this._listeners) return !1;
						var h = this._listeners;
						return void 0 !== h[a] && -1 !== h[a].indexOf(b)
					},
					removeEventListener: function(a, b) {
						void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(
							b, 1)))
					},
					dispatchEvent: function(a) {
						if (void 0 !== this._listeners) {
							var b = this._listeners[a.type];
							if (void 0 !== b) {
								a.target = this;
								b = b.slice(0);
								for (var h = 0, c = b.length; h < c; h++) b[h].call(this, a)
							}
						}
					}
				});
				for (var Bb = [], tk = 0; 256 > tk; tk++) Bb[tk] = (16 > tk ? "0" : "") + tk.toString(16);
				var Ea = {
					DEG2RAD: Math.PI /
						180,
					RAD2DEG: 180 / Math.PI,
					generateUUID: function() {
						var a = 4294967295 * Math.random() | 0,
							b = 4294967295 * Math.random() | 0,
							c = 4294967295 * Math.random() | 0,
							d = 4294967295 * Math.random() | 0;
						return (Bb[a & 255] + Bb[a >> 8 & 255] + Bb[a >> 16 & 255] + Bb[a >> 24 & 255] + "-" + Bb[b & 255] + Bb[b >>
								8 & 255] + "-" + Bb[b >> 16 & 15 | 64] + Bb[b >> 24 & 255] + "-" + Bb[c & 63 | 128] + Bb[c >> 8 & 255] +
							"-" + Bb[c >> 16 & 255] + Bb[c >> 24 & 255] + Bb[d & 255] + Bb[d >> 8 & 255] + Bb[d >> 16 & 255] + Bb[d >>
								24 & 255]).toUpperCase()
					},
					clamp: function(a, b, c) {
						return Math.max(b, Math.min(c, a))
					},
					euclideanModulo: function(a, b) {
						return (a %
							b + b) % b
					},
					mapLinear: function(a, b, c, d, e) {
						return d + (a - b) * (e - d) / (c - b)
					},
					lerp: function(a, b, c) {
						return (1 - c) * a + c * b
					},
					smoothstep: function(a, b, c) {
						if (a <= b) return 0;
						if (a >= c) return 1;
						a = (a - b) / (c - b);
						return a * a * (3 - 2 * a)
					},
					smootherstep: function(a, b, c) {
						if (a <= b) return 0;
						if (a >= c) return 1;
						a = (a - b) / (c - b);
						return a * a * a * (a * (6 * a - 15) + 10)
					},
					randInt: function(a, b) {
						return a + Math.floor(Math.random() * (b - a + 1))
					},
					randFloat: function(a, b) {
						return a + Math.random() * (b - a)
					},
					randFloatSpread: function(a) {
						return a * (.5 - Math.random())
					},
					degToRad: function(a) {
						return a *
							Ea.DEG2RAD
					},
					radToDeg: function(a) {
						return a * Ea.RAD2DEG
					},
					isPowerOfTwo: function(a) {
						return 0 === (a & a - 1) && 0 !== a
					},
					ceilPowerOfTwo: function(a) {
						return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
					},
					floorPowerOfTwo: function(a) {
						return Math.pow(2, Math.floor(Math.log(a) / Math.LN2))
					}
				};
				ja(d.prototype, {
					width: {
						get: function() {
							return this.x
						},
						set: function(a) {
							this.x = a
						}
					},
					height: {
						get: function() {
							return this.y
						},
						set: function(a) {
							this.y = a
						}
					}
				});
				q(d.prototype, {
					isVector2: !0,
					set: function(a, b) {
						this.x = a;
						this.y = b;
						return this
					},
					setScalar: function(a) {
						this.y =
							this.x = a;
						return this
					},
					setX: function(a) {
						this.x = a;
						return this
					},
					setY: function(a) {
						this.y = a;
						return this
					},
					setComponent: function(a, b) {
						switch (a) {
							case 0:
								this.x = b;
								break;
							case 1:
								this.y = b;
								break;
							default:
								throw Error("index is out of range: " + a);
						}
						return this
					},
					getComponent: function(a) {
						switch (a) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							default:
								throw Error("index is out of range: " + a);
						}
					},
					clone: function() {
						return new this.constructor(this.x, this.y)
					},
					copy: function(a) {
						this.x = a.x;
						this.y = a.y;
						return this
					},
					add: function(a,
						b) {
						if (void 0 !== b) return console.warn(
							"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(
							a, b);
						this.x += a.x;
						this.y += a.y;
						return this
					},
					addScalar: function(a) {
						this.x += a;
						this.y += a;
						return this
					},
					addVectors: function(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;
						return this
					},
					addScaledVector: function(a, b) {
						this.x += a.x * b;
						this.y += a.y * b;
						return this
					},
					sub: function(a, b) {
						if (void 0 !== b) return console.warn(
								"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
							this.subVectors(a, b);
						this.x -= a.x;
						this.y -= a.y;
						return this
					},
					subScalar: function(a) {
						this.x -= a;
						this.y -= a;
						return this
					},
					subVectors: function(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;
						return this
					},
					multiply: function(a) {
						this.x *= a.x;
						this.y *= a.y;
						return this
					},
					multiplyScalar: function(a) {
						this.x *= a;
						this.y *= a;
						return this
					},
					divide: function(a) {
						this.x /= a.x;
						this.y /= a.y;
						return this
					},
					divideScalar: function(a) {
						return this.multiplyScalar(1 / a)
					},
					applyMatrix3: function(a) {
						var b = this.x,
							h = this.y;
						a = a.elements;
						this.x = a[0] * b + a[3] * h + a[6];
						this.y =
							a[1] * b + a[4] * h + a[7];
						return this
					},
					min: function(a) {
						this.x = Math.min(this.x, a.x);
						this.y = Math.min(this.y, a.y);
						return this
					},
					max: function(a) {
						this.x = Math.max(this.x, a.x);
						this.y = Math.max(this.y, a.y);
						return this
					},
					clamp: function(a, b) {
						this.x = Math.max(a.x, Math.min(b.x, this.x));
						this.y = Math.max(a.y, Math.min(b.y, this.y));
						return this
					},
					clampScalar: function(a, b) {
						this.x = Math.max(a, Math.min(b, this.x));
						this.y = Math.max(a, Math.min(b, this.y));
						return this
					},
					clampLength: function(a, b) {
						var h = this.length();
						return this.divideScalar(h ||
							1).multiplyScalar(Math.max(a, Math.min(b, h)))
					},
					floor: function() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);
						return this
					},
					ceil: function() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);
						return this
					},
					round: function() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);
						return this
					},
					roundToZero: function() {
						this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
						this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
						return this
					},
					negate: function() {
						this.x = -this.x;
						this.y = -this.y;
						return this
					},
					dot: function(a) {
						return this.x *
							a.x + this.y * a.y
					},
					cross: function(a) {
						return this.x * a.y - this.y * a.x
					},
					lengthSq: function() {
						return this.x * this.x + this.y * this.y
					},
					length: function() {
						return Math.sqrt(this.x * this.x + this.y * this.y)
					},
					manhattanLength: function() {
						return Math.abs(this.x) + Math.abs(this.y)
					},
					normalize: function() {
						return this.divideScalar(this.length() || 1)
					},
					angle: function() {
						var a = Math.atan2(this.y, this.x);
						0 > a && (a += 2 * Math.PI);
						return a
					},
					distanceTo: function(a) {
						return Math.sqrt(this.distanceToSquared(a))
					},
					distanceToSquared: function(a) {
						var b =
							this.x - a.x;
						a = this.y - a.y;
						return b * b + a * a
					},
					manhattanDistanceTo: function(a) {
						return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
					},
					setLength: function(a) {
						return this.normalize().multiplyScalar(a)
					},
					lerp: function(a, b) {
						this.x += (a.x - this.x) * b;
						this.y += (a.y - this.y) * b;
						return this
					},
					lerpVectors: function(a, b, c) {
						return this.subVectors(b, a).multiplyScalar(c).add(a)
					},
					equals: function(a) {
						return a.x === this.x && a.y === this.y
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						this.x = a[b];
						this.y = a[b + 1];
						return this
					},
					toArray: function(a,
						b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						a[b] = this.x;
						a[b + 1] = this.y;
						return a
					},
					fromBufferAttribute: function(a, b, c) {
						void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
						this.x = a.getX(b);
						this.y = a.getY(b);
						return this
					},
					rotateAround: function(a, b) {
						var h = Math.cos(b);
						b = Math.sin(b);
						var c = this.x - a.x,
							d = this.y - a.y;
						this.x = c * h - d * b + a.x;
						this.y = c * b + d * h + a.y;
						return this
					}
				});
				q(e, {
					slerp: function(a, b, c, d) {
						return c.copy(a).slerp(b, d)
					},
					slerpFlat: function(a, b, c, d, e, f, g) {
						var h = c[d + 0],
							t = c[d + 1],
							x = c[d + 2];
						c = c[d + 3];
						d = e[f + 0];
						var k = e[f + 1],
							y = e[f + 2];
						e = e[f + 3];
						if (c !== e || h !== d || t !== k || x !== y) {
							f = 1 - g;
							var l = h * d + t * k + x * y + c * e,
								m = 0 <= l ? 1 : -1,
								E = 1 - l * l;
							E > Na && (E = Math.sqrt(E), l = Math.atan2(E, l * m), f = Math.sin(f * l) / E, g = Math.sin(g * l) / E);
							m *= g;
							h = h * f + d * m;
							t = t * f + k * m;
							x = x * f + y * m;
							c = c * f + e * m;
							f === 1 - g && (g = 1 / Math.sqrt(h * h + t * t + x * x + c * c), h *= g, t *= g, x *= g, c *= g)
						}
						a[b] = h;
						a[b + 1] = t;
						a[b + 2] = x;
						a[b + 3] = c
					}
				});
				ja(e.prototype, {
					x: {
						get: function() {
							return this._x
						},
						set: function(a) {
							this._x = a;
							this._onChangeCallback()
						}
					},
					y: {
						get: function() {
							return this._y
						},
						set: function(a) {
							this._y = a;
							this._onChangeCallback()
						}
					},
					z: {
						get: function() {
							return this._z
						},
						set: function(a) {
							this._z = a;
							this._onChangeCallback()
						}
					},
					w: {
						get: function() {
							return this._w
						},
						set: function(a) {
							this._w = a;
							this._onChangeCallback()
						}
					}
				});
				q(e.prototype, {
					isQuaternion: !0,
					set: function(a, b, c, d) {
						this._x = a;
						this._y = b;
						this._z = c;
						this._w = d;
						this._onChangeCallback();
						return this
					},
					clone: function() {
						return new this.constructor(this._x, this._y, this._z, this._w)
					},
					copy: function(a) {
						this._x = a.x;
						this._y = a.y;
						this._z = a.z;
						this._w = a.w;
						this._onChangeCallback();
						return this
					},
					setFromEuler: function(a, b) {
						if (!a || !a.isEuler) throw Error(
							"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
						var h = a._x,
							c = a._y,
							d = a._z;
						a = a.order;
						var t = Math.cos,
							e = Math.sin,
							f = t(h / 2),
							g = t(c / 2);
						t = t(d / 2);
						h = e(h / 2);
						c = e(c / 2);
						d = e(d / 2);
						"XYZ" === a ? (this._x = h * g * t + f * c * d, this._y = f * c * t - h * g * d, this._z = f * g * d + h *
								c * t, this._w = f * g * t - h * c * d) : "YXZ" === a ? (this._x = h * g * t + f * c * d, this._y = f * c *
								t - h * g * d, this._z = f * g * d - h * c * t, this._w = f * g * t + h * c * d) : "ZXY" ===
							a ? (this._x = h * g * t - f * c * d, this._y = f * c * t + h * g * d, this._z = f * g * d + h * c * t,
								this._w = f * g * t - h * c * d) : "ZYX" === a ? (this._x = h * g * t - f * c * d, this._y = f * c * t +
								h * g * d, this._z = f * g * d - h * c * t, this._w = f * g * t + h * c * d) : "YZX" === a ? (this._x = h *
								g * t + f * c * d, this._y = f * c * t + h * g * d, this._z = f * g * d - h * c * t, this._w = f * g * t -
								h * c * d) : "XZY" === a && (this._x = h * g * t - f * c * d, this._y = f * c * t - h * g * d, this._z =
								f * g * d + h * c * t, this._w = f * g * t + h * c * d);
						!1 !== b && this._onChangeCallback();
						return this
					},
					setFromAxisAngle: function(a, b) {
						b /= 2;
						var h = Math.sin(b);
						this._x = a.x * h;
						this._y = a.y * h;
						this._z = a.z *
							h;
						this._w = Math.cos(b);
						this._onChangeCallback();
						return this
					},
					setFromRotationMatrix: function(a) {
						var b = a.elements,
							h = b[0];
						a = b[4];
						var c = b[8],
							d = b[1],
							e = b[5],
							f = b[9],
							g = b[2],
							k = b[6];
						b = b[10];
						var l = h + e + b;
						0 < l ? (h = .5 / Math.sqrt(l + 1), this._w = .25 / h, this._x = (k - f) * h, this._y = (c - g) * h, this._z =
							(d - a) * h) : h > e && h > b ? (h = 2 * Math.sqrt(1 + h - e - b), this._w = (k - f) / h, this._x = .25 *
							h, this._y = (a + d) / h, this._z = (c + g) / h) : e > b ? (h = 2 * Math.sqrt(1 + e - h - b), this._w = (
							c - g) / h, this._x = (a + d) / h, this._y = .25 * h, this._z = (f + k) / h) : (h = 2 * Math.sqrt(1 + b -
							h - e), this._w = (d -
							a) / h, this._x = (c + g) / h, this._y = (f + k) / h, this._z = .25 * h);
						this._onChangeCallback();
						return this
					},
					setFromUnitVectors: function(a, b) {
						var h = a.dot(b) + 1;
						1E-6 > h ? (h = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x =
							0, this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z,
							this._z = a.x * b.y - a.y * b.x);
						this._w = h;
						return this.normalize()
					},
					angleTo: function(a) {
						return 2 * Math.acos(Math.abs(Ea.clamp(this.dot(a), -1, 1)))
					},
					rotateTowards: function(a, b) {
						var h = this.angleTo(a);
						if (0 === h) return this;
						this.slerp(a, Math.min(1, b / h));
						return this
					},
					inverse: function() {
						return this.conjugate()
					},
					conjugate: function() {
						this._x *= -1;
						this._y *= -1;
						this._z *= -1;
						this._onChangeCallback();
						return this
					},
					dot: function(a) {
						return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
					},
					lengthSq: function() {
						return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
					},
					length: function() {
						return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
					},
					normalize: function() {
						var a = this.length();
						0 === a ? (this._z =
							this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
						this._onChangeCallback();
						return this
					},
					multiply: function(a, b) {
						return void 0 !== b ? (console.warn(
							"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."
						), this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
					},
					premultiply: function(a) {
						return this.multiplyQuaternions(a, this)
					},
					multiplyQuaternions: function(a, b) {
						var h = a._x,
							c = a._y,
							d = a._z;
						a = a._w;
						var t = b._x,
							e = b._y,
							f = b._z;
						b = b._w;
						this._x = h * b + a * t + c * f - d * e;
						this._y = c * b + a * e + d * t - h * f;
						this._z = d * b + a * f + h * e - c * t;
						this._w = a * b - h * t - c * e - d * f;
						this._onChangeCallback();
						return this
					},
					slerp: function(a, b) {
						if (0 === b) return this;
						if (1 === b) return this.copy(a);
						var h = this._x,
							c = this._y,
							d = this._z,
							t = this._w,
							e = t * a._w + h * a._x + c * a._y + d * a._z;
						0 > e ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, e = -e) : this.copy(a);
						if (1 <= e) return this._w = t, this._x = h, this._y = c, this._z = d, this;
						a = 1 - e * e;
						if (a <= Na) return e = 1 - b, this._w = e * t + b * this._w, this._x = e * h + b * this._x, this._y =
							e * c + b * this._y, this._z = e * d + b * this._z, this.normalize(), this._onChangeCallback(), this;
						a = Math.sqrt(a);
						var f = Math.atan2(a, e);
						e = Math.sin((1 - b) * f) / a;
						b = Math.sin(b * f) / a;
						this._w = t * e + this._w * b;
						this._x = h * e + this._x * b;
						this._y = c * e + this._y * b;
						this._z = d * e + this._z * b;
						this._onChangeCallback();
						return this
					},
					equals: function(a) {
						return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						this._x = a[b];
						this._y = a[b + 1];
						this._z = a[b + 2];
						this._w = a[b + 3];
						this._onChangeCallback();
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						a[b] = this._x;
						a[b + 1] = this._y;
						a[b + 2] = this._z;
						a[b + 3] = this._w;
						return a
					},
					_onChange: function(a) {
						this._onChangeCallback = a;
						return this
					},
					_onChangeCallback: function() {}
				});
				var Bg = new f,
					Ah = new e;
				q(f.prototype, {
					isVector3: !0,
					set: function(a, b, c) {
						this.x = a;
						this.y = b;
						this.z = c;
						return this
					},
					setScalar: function(a) {
						this.z = this.y = this.x = a;
						return this
					},
					setX: function(a) {
						this.x = a;
						return this
					},
					setY: function(a) {
						this.y = a;
						return this
					},
					setZ: function(a) {
						this.z =
							a;
						return this
					},
					setComponent: function(a, b) {
						switch (a) {
							case 0:
								this.x = b;
								break;
							case 1:
								this.y = b;
								break;
							case 2:
								this.z = b;
								break;
							default:
								throw Error("index is out of range: " + a);
						}
						return this
					},
					getComponent: function(a) {
						switch (a) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							default:
								throw Error("index is out of range: " + a);
						}
					},
					clone: function() {
						return new this.constructor(this.x, this.y, this.z)
					},
					copy: function(a) {
						this.x = a.x;
						this.y = a.y;
						this.z = a.z;
						return this
					},
					add: function(a, b) {
						if (void 0 !== b) return console.warn(
								"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
							this.addVectors(a, b);
						this.x += a.x;
						this.y += a.y;
						this.z += a.z;
						return this
					},
					addScalar: function(a) {
						this.x += a;
						this.y += a;
						this.z += a;
						return this
					},
					addVectors: function(a, b) {
						this.x = a.x + b.x;
						this.y = a.y + b.y;
						this.z = a.z + b.z;
						return this
					},
					addScaledVector: function(a, b) {
						this.x += a.x * b;
						this.y += a.y * b;
						this.z += a.z * b;
						return this
					},
					sub: function(a, b) {
						if (void 0 !== b) return console.warn(
							"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(
							a, b);
						this.x -= a.x;
						this.y -= a.y;
						this.z -= a.z;
						return this
					},
					subScalar: function(a) {
						this.x -= a;
						this.y -= a;
						this.z -= a;
						return this
					},
					subVectors: function(a, b) {
						this.x = a.x - b.x;
						this.y = a.y - b.y;
						this.z = a.z - b.z;
						return this
					},
					multiply: function(a, b) {
						if (void 0 !== b) return console.warn(
								"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this
							.multiplyVectors(a, b);
						this.x *= a.x;
						this.y *= a.y;
						this.z *= a.z;
						return this
					},
					multiplyScalar: function(a) {
						this.x *= a;
						this.y *= a;
						this.z *= a;
						return this
					},
					multiplyVectors: function(a, b) {
						this.x = a.x *
							b.x;
						this.y = a.y * b.y;
						this.z = a.z * b.z;
						return this
					},
					applyEuler: function(a) {
						a && a.isEuler || console.error(
							"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
						return this.applyQuaternion(Ah.setFromEuler(a))
					},
					applyAxisAngle: function(a, b) {
						return this.applyQuaternion(Ah.setFromAxisAngle(a, b))
					},
					applyMatrix3: function(a) {
						var b = this.x,
							h = this.y,
							c = this.z;
						a = a.elements;
						this.x = a[0] * b + a[3] * h + a[6] * c;
						this.y = a[1] * b + a[4] * h + a[7] * c;
						this.z = a[2] * b + a[5] * h + a[8] * c;
						return this
					},
					applyMatrix4: function(a) {
						var b =
							this.x,
							h = this.y,
							c = this.z;
						a = a.elements;
						var d = 1 / (a[3] * b + a[7] * h + a[11] * c + a[15]);
						this.x = (a[0] * b + a[4] * h + a[8] * c + a[12]) * d;
						this.y = (a[1] * b + a[5] * h + a[9] * c + a[13]) * d;
						this.z = (a[2] * b + a[6] * h + a[10] * c + a[14]) * d;
						return this
					},
					applyQuaternion: function(a) {
						var b = this.x,
							h = this.y,
							c = this.z,
							d = a.x,
							e = a.y,
							f = a.z;
						a = a.w;
						var g = a * b + e * c - f * h,
							k = a * h + f * b - d * c,
							l = a * c + d * h - e * b;
						b = -d * b - e * h - f * c;
						this.x = g * a + b * -d + k * -f - l * -e;
						this.y = k * a + b * -e + l * -d - g * -f;
						this.z = l * a + b * -f + g * -e - k * -d;
						return this
					},
					project: function(a) {
						return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix)
					},
					unproject: function(a) {
						return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld)
					},
					transformDirection: function(a) {
						var b = this.x,
							h = this.y,
							c = this.z;
						a = a.elements;
						this.x = a[0] * b + a[4] * h + a[8] * c;
						this.y = a[1] * b + a[5] * h + a[9] * c;
						this.z = a[2] * b + a[6] * h + a[10] * c;
						return this.normalize()
					},
					divide: function(a) {
						this.x /= a.x;
						this.y /= a.y;
						this.z /= a.z;
						return this
					},
					divideScalar: function(a) {
						return this.multiplyScalar(1 / a)
					},
					min: function(a) {
						this.x = Math.min(this.x, a.x);
						this.y = Math.min(this.y, a.y);
						this.z = Math.min(this.z,
							a.z);
						return this
					},
					max: function(a) {
						this.x = Math.max(this.x, a.x);
						this.y = Math.max(this.y, a.y);
						this.z = Math.max(this.z, a.z);
						return this
					},
					clamp: function(a, b) {
						this.x = Math.max(a.x, Math.min(b.x, this.x));
						this.y = Math.max(a.y, Math.min(b.y, this.y));
						this.z = Math.max(a.z, Math.min(b.z, this.z));
						return this
					},
					clampScalar: function(a, b) {
						this.x = Math.max(a, Math.min(b, this.x));
						this.y = Math.max(a, Math.min(b, this.y));
						this.z = Math.max(a, Math.min(b, this.z));
						return this
					},
					clampLength: function(a, b) {
						var h = this.length();
						return this.divideScalar(h ||
							1).multiplyScalar(Math.max(a, Math.min(b, h)))
					},
					floor: function() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);
						this.z = Math.floor(this.z);
						return this
					},
					ceil: function() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);
						this.z = Math.ceil(this.z);
						return this
					},
					round: function() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);
						this.z = Math.round(this.z);
						return this
					},
					roundToZero: function() {
						this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
						this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
						this.z =
							0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
						return this
					},
					negate: function() {
						this.x = -this.x;
						this.y = -this.y;
						this.z = -this.z;
						return this
					},
					dot: function(a) {
						return this.x * a.x + this.y * a.y + this.z * a.z
					},
					lengthSq: function() {
						return this.x * this.x + this.y * this.y + this.z * this.z
					},
					length: function() {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
					},
					manhattanLength: function() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
					},
					normalize: function() {
						return this.divideScalar(this.length() || 1)
					},
					setLength: function(a) {
						return this.normalize().multiplyScalar(a)
					},
					lerp: function(a, b) {
						this.x += (a.x - this.x) * b;
						this.y += (a.y - this.y) * b;
						this.z += (a.z - this.z) * b;
						return this
					},
					lerpVectors: function(a, b, c) {
						return this.subVectors(b, a).multiplyScalar(c).add(a)
					},
					cross: function(a, b) {
						return void 0 !== b ? (console.warn(
							"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(
							a, b)) : this.crossVectors(this, a)
					},
					crossVectors: function(a, b) {
						var h = a.x,
							c = a.y;
						a = a.z;
						var d = b.x,
							e = b.y;
						b = b.z;
						this.x = c * b - a * e;
						this.y = a * d - h * b;
						this.z = h * e - c * d;
						return this
					},
					projectOnVector: function(a) {
						var b = a.dot(this) / a.lengthSq();
						return this.copy(a).multiplyScalar(b)
					},
					projectOnPlane: function(a) {
						Bg.copy(this).projectOnVector(a);
						return this.sub(Bg)
					},
					reflect: function(a) {
						return this.sub(Bg.copy(a).multiplyScalar(2 * this.dot(a)))
					},
					angleTo: function(a) {
						var b = Math.sqrt(this.lengthSq() * a.lengthSq());
						0 === b && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
						a = this.dot(a) / b;
						return Math.acos(Ea.clamp(a, -1, 1))
					},
					distanceTo: function(a) {
						return Math.sqrt(this.distanceToSquared(a))
					},
					distanceToSquared: function(a) {
						var b = this.x - a.x,
							h = this.y - a.y;
						a = this.z - a.z;
						return b * b + h * h + a * a
					},
					manhattanDistanceTo: function(a) {
						return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
					},
					setFromSpherical: function(a) {
						return this.setFromSphericalCoords(a.radius, a.phi, a.theta)
					},
					setFromSphericalCoords: function(a, b, c) {
						var h = Math.sin(b) * a;
						this.x = h * Math.sin(c);
						this.y = Math.cos(b) * a;
						this.z = h * Math.cos(c);
						return this
					},
					setFromCylindrical: function(a) {
						return this.setFromCylindricalCoords(a.radius, a.theta,
							a.y)
					},
					setFromCylindricalCoords: function(a, b, c) {
						this.x = a * Math.sin(b);
						this.y = c;
						this.z = a * Math.cos(b);
						return this
					},
					setFromMatrixPosition: function(a) {
						a = a.elements;
						this.x = a[12];
						this.y = a[13];
						this.z = a[14];
						return this
					},
					setFromMatrixScale: function(a) {
						var b = this.setFromMatrixColumn(a, 0).length(),
							h = this.setFromMatrixColumn(a, 1).length();
						a = this.setFromMatrixColumn(a, 2).length();
						this.x = b;
						this.y = h;
						this.z = a;
						return this
					},
					setFromMatrixColumn: function(a, b) {
						return this.fromArray(a.elements, 4 * b)
					},
					equals: function(a) {
						return a.x ===
							this.x && a.y === this.y && a.z === this.z
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						this.x = a[b];
						this.y = a[b + 1];
						this.z = a[b + 2];
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						a[b] = this.x;
						a[b + 1] = this.y;
						a[b + 2] = this.z;
						return a
					},
					fromBufferAttribute: function(a, b, c) {
						void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
						this.x = a.getX(b);
						this.y = a.getY(b);
						this.z = a.getZ(b);
						return this
					}
				});
				var ni = new f;
				q(k.prototype, {
					isMatrix3: !0,
					set: function(a, b, c, d, e,
						f, g, k, l) {
						var h = this.elements;
						h[0] = a;
						h[1] = d;
						h[2] = g;
						h[3] = b;
						h[4] = e;
						h[5] = k;
						h[6] = c;
						h[7] = f;
						h[8] = l;
						return this
					},
					identity: function() {
						this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
						return this
					},
					clone: function() {
						return (new this.constructor).fromArray(this.elements)
					},
					copy: function(a) {
						var b = this.elements;
						a = a.elements;
						b[0] = a[0];
						b[1] = a[1];
						b[2] = a[2];
						b[3] = a[3];
						b[4] = a[4];
						b[5] = a[5];
						b[6] = a[6];
						b[7] = a[7];
						b[8] = a[8];
						return this
					},
					setFromMatrix4: function(a) {
						a = a.elements;
						this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
						return this
					},
					applyToBufferAttribute: function(a) {
						for (var b =
								0, h = a.count; b < h; b++) ni.x = a.getX(b), ni.y = a.getY(b), ni.z = a.getZ(b), ni.applyMatrix3(this),
							a.setXYZ(b, ni.x, ni.y, ni.z);
						return a
					},
					multiply: function(a) {
						return this.multiplyMatrices(this, a)
					},
					premultiply: function(a) {
						return this.multiplyMatrices(a, this)
					},
					multiplyMatrices: function(a, b) {
						var h = a.elements,
							c = b.elements;
						b = this.elements;
						a = h[0];
						var d = h[3],
							e = h[6],
							t = h[1],
							f = h[4],
							g = h[7],
							k = h[2],
							l = h[5];
						h = h[8];
						var m = c[0],
							n = c[3],
							r = c[6],
							p = c[1],
							v = c[4],
							q = c[7],
							u = c[2],
							w = c[5];
						c = c[8];
						b[0] = a * m + d * p + e * u;
						b[3] = a * n + d * v + e * w;
						b[6] = a * r + d *
							q + e * c;
						b[1] = t * m + f * p + g * u;
						b[4] = t * n + f * v + g * w;
						b[7] = t * r + f * q + g * c;
						b[2] = k * m + l * p + h * u;
						b[5] = k * n + l * v + h * w;
						b[8] = k * r + l * q + h * c;
						return this
					},
					multiplyScalar: function(a) {
						var b = this.elements;
						b[0] *= a;
						b[3] *= a;
						b[6] *= a;
						b[1] *= a;
						b[4] *= a;
						b[7] *= a;
						b[2] *= a;
						b[5] *= a;
						b[8] *= a;
						return this
					},
					determinant: function() {
						var a = this.elements,
							b = a[0],
							c = a[1],
							d = a[2],
							e = a[3],
							f = a[4],
							g = a[5],
							k = a[6],
							l = a[7];
						a = a[8];
						return b * f * a - b * g * l - c * e * a + c * g * k + d * e * l - d * f * k
					},
					getInverse: function(a, b) {
						a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
						var h = a.elements;
						a = this.elements;
						var c = h[0],
							d = h[1],
							e = h[2],
							f = h[3],
							t = h[4],
							g = h[5],
							k = h[6],
							l = h[7];
						h = h[8];
						var m = h * t - g * l,
							n = g * k - h * f,
							r = l * f - t * k,
							p = c * m + d * n + e * r;
						if (0 === p) {
							if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
							console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
							return this.identity()
						}
						b = 1 / p;
						a[0] = m * b;
						a[1] = (e * l - h * d) * b;
						a[2] = (g * d - e * t) * b;
						a[3] = n * b;
						a[4] = (h * c - e * k) * b;
						a[5] = (e * f - g * c) * b;
						a[6] = r * b;
						a[7] = (d * k - l * c) * b;
						a[8] = (t * c - d * f) * b;
						return this
					},
					transpose: function() {
						var a = this.elements;
						var b = a[1];
						a[1] = a[3];
						a[3] = b;
						b = a[2];
						a[2] = a[6];
						a[6] = b;
						b = a[5];
						a[5] = a[7];
						a[7] = b;
						return this
					},
					getNormalMatrix: function(a) {
						return this.setFromMatrix4(a).getInverse(this).transpose()
					},
					transposeIntoArray: function(a) {
						var b = this.elements;
						a[0] = b[0];
						a[1] = b[3];
						a[2] = b[6];
						a[3] = b[1];
						a[4] = b[4];
						a[5] = b[7];
						a[6] = b[2];
						a[7] = b[5];
						a[8] = b[8];
						return this
					},
					setUvTransform: function(a, b, c, d, e, f, g) {
						var h = Math.cos(e);
						e = Math.sin(e);
						this.set(c * h, c * e, -c * (h * f + e * g) + f + a, -d * e, d * h, -d * (-e * f + h * g) + g +
							b, 0, 0, 1)
					},
					scale: function(a, b) {
						var h = this.elements;
						h[0] *= a;
						h[3] *= a;
						h[6] *= a;
						h[1] *= b;
						h[4] *= b;
						h[7] *= b;
						return this
					},
					rotate: function(a) {
						var b = Math.cos(a);
						a = Math.sin(a);
						var h = this.elements,
							c = h[0],
							d = h[3],
							e = h[6],
							f = h[1],
							g = h[4],
							k = h[7];
						h[0] = b * c + a * f;
						h[3] = b * d + a * g;
						h[6] = b * e + a * k;
						h[1] = -a * c + b * f;
						h[4] = -a * d + b * g;
						h[7] = -a * e + b * k;
						return this
					},
					translate: function(a, b) {
						var h = this.elements;
						h[0] += a * h[2];
						h[3] += a * h[5];
						h[6] += a * h[8];
						h[1] += b * h[2];
						h[4] += b * h[5];
						h[7] += b * h[8];
						return this
					},
					equals: function(a) {
						var b = this.elements;
						a = a.elements;
						for (var h = 0; 9 > h; h++)
							if (b[h] !== a[h]) return !1;
						return !0
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						for (var h = 0; 9 > h; h++) this.elements[h] = a[h + b];
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						var h = this.elements;
						a[b] = h[0];
						a[b + 1] = h[1];
						a[b + 2] = h[2];
						a[b + 3] = h[3];
						a[b + 4] = h[4];
						a[b + 5] = h[5];
						a[b + 6] = h[6];
						a[b + 7] = h[7];
						a[b + 8] = h[8];
						return a
					}
				});
				var Lj, ih = {
						getDataURL: function(a) {
							if ("undefined" == typeof HTMLCanvasElement) return a.src;
							if (!(a instanceof HTMLCanvasElement)) {
								void 0 === Lj && (Lj = document.createElementNS("http://www.w3.org/1999/xhtml",
									"canvas"));
								Lj.width = a.width;
								Lj.height = a.height;
								var b = Lj.getContext("2d");
								a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height);
								a = Lj
							}
							return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png")
						}
					},
					Qi = 0;
				l.DEFAULT_IMAGE = void 0;
				l.DEFAULT_MAPPING = 300;
				l.prototype = q(p(b.prototype), {
					constructor: l,
					isTexture: !0,
					updateMatrix: function() {
						this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center
							.x, this.center.y)
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.name = a.name;
						this.image = a.image;
						this.mipmaps = a.mipmaps.slice(0);
						this.mapping = a.mapping;
						this.wrapS = a.wrapS;
						this.wrapT = a.wrapT;
						this.magFilter = a.magFilter;
						this.minFilter = a.minFilter;
						this.anisotropy = a.anisotropy;
						this.format = a.format;
						this.type = a.type;
						this.offset.copy(a.offset);
						this.repeat.copy(a.repeat);
						this.center.copy(a.center);
						this.rotation = a.rotation;
						this.matrixAutoUpdate = a.matrixAutoUpdate;
						this.matrix.copy(a.matrix);
						this.generateMipmaps =
							a.generateMipmaps;
						this.premultiplyAlpha = a.premultiplyAlpha;
						this.flipY = a.flipY;
						this.unpackAlignment = a.unpackAlignment;
						this.encoding = a.encoding;
						return this
					},
					toJSON: function(a) {
						var b = void 0 === a || "string" === typeof a;
						if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
						var h = {
							metadata: {
								version: 4.5,
								type: "Texture",
								generator: "Texture.toJSON"
							},
							uuid: this.uuid,
							name: this.name,
							mapping: this.mapping,
							repeat: [this.repeat.x, this.repeat.y],
							offset: [this.offset.x, this.offset.y],
							center: [this.center.x, this.center.y],
							rotation: this.rotation,
							wrap: [this.wrapS, this.wrapT],
							format: this.format,
							type: this.type,
							encoding: this.encoding,
							minFilter: this.minFilter,
							magFilter: this.magFilter,
							anisotropy: this.anisotropy,
							flipY: this.flipY,
							premultiplyAlpha: this.premultiplyAlpha,
							unpackAlignment: this.unpackAlignment
						};
						if (void 0 !== this.image) {
							var c = this.image;
							void 0 === c.uuid && (c.uuid = Ea.generateUUID());
							if (!b && void 0 === a.images[c.uuid]) {
								if (Array.isArray(c)) {
									var d = [];
									for (var e = 0, f = c.length; e < f; e++) d.push(ih.getDataURL(c[e]))
								} else d = ih.getDataURL(c);
								a.images[c.uuid] = {
									uuid: c.uuid,
									url: d
								}
							}
							h.image = c.uuid
						}
						b || (a.textures[this.uuid] = h);
						return h
					},
					dispose: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					},
					transformUv: function(a) {
						if (300 !== this.mapping) return a;
						a.applyMatrix3(this.matrix);
						if (0 > a.x || 1 < a.x) switch (this.wrapS) {
							case 1E3:
								a.x -= Math.floor(a.x);
								break;
							case 1001:
								a.x = 0 > a.x ? 0 : 1;
								break;
							case 1002:
								a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
						}
						if (0 > a.y || 1 < a.y) switch (this.wrapT) {
							case 1E3:
								a.y -= Math.floor(a.y);
								break;
							case 1001:
								a.y =
									0 > a.y ? 0 : 1;
								break;
							case 1002:
								a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
						}
						this.flipY && (a.y = 1 - a.y);
						return a
					}
				});
				Object.defineProperty(l.prototype, "needsUpdate", {
					set: function(a) {
						!0 === a && this.version++
					}
				});
				ja(m.prototype, {
					width: {
						get: function() {
							return this.z
						},
						set: function(a) {
							this.z = a
						}
					},
					height: {
						get: function() {
							return this.w
						},
						set: function(a) {
							this.w = a
						}
					}
				});
				q(m.prototype, {
					isVector4: !0,
					set: function(a, b, c, d) {
						this.x = a;
						this.y = b;
						this.z = c;
						this.w = d;
						return this
					},
					setScalar: function(a) {
						this.w =
							this.z = this.y = this.x = a;
						return this
					},
					setX: function(a) {
						this.x = a;
						return this
					},
					setY: function(a) {
						this.y = a;
						return this
					},
					setZ: function(a) {
						this.z = a;
						return this
					},
					setW: function(a) {
						this.w = a;
						return this
					},
					setComponent: function(a, b) {
						switch (a) {
							case 0:
								this.x = b;
								break;
							case 1:
								this.y = b;
								break;
							case 2:
								this.z = b;
								break;
							case 3:
								this.w = b;
								break;
							default:
								throw Error("index is out of range: " + a);
						}
						return this
					},
					getComponent: function(a) {
						switch (a) {
							case 0:
								return this.x;
							case 1:
								return this.y;
							case 2:
								return this.z;
							case 3:
								return this.w;
							default:
								throw Error("index is out of range: " +
									a);
						}
					},
					clone: function() {
						return new this.constructor(this.x, this.y, this.z, this.w)
					},
					copy: function(a) {
						this.x = a.x;
						this.y = a.y;
						this.z = a.z;
						this.w = void 0 !== a.w ? a.w : 1;
						return this
					},
					add: function(a, b) {
						if (void 0 !== b) return console.warn(
							"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(
							a, b);
						this.x += a.x;
						this.y += a.y;
						this.z += a.z;
						this.w += a.w;
						return this
					},
					addScalar: function(a) {
						this.x += a;
						this.y += a;
						this.z += a;
						this.w += a;
						return this
					},
					addVectors: function(a, b) {
						this.x = a.x +
							b.x;
						this.y = a.y + b.y;
						this.z = a.z + b.z;
						this.w = a.w + b.w;
						return this
					},
					addScaledVector: function(a, b) {
						this.x += a.x * b;
						this.y += a.y * b;
						this.z += a.z * b;
						this.w += a.w * b;
						return this
					},
					sub: function(a, b) {
						if (void 0 !== b) return console.warn(
							"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(
							a, b);
						this.x -= a.x;
						this.y -= a.y;
						this.z -= a.z;
						this.w -= a.w;
						return this
					},
					subScalar: function(a) {
						this.x -= a;
						this.y -= a;
						this.z -= a;
						this.w -= a;
						return this
					},
					subVectors: function(a, b) {
						this.x = a.x - b.x;
						this.y =
							a.y - b.y;
						this.z = a.z - b.z;
						this.w = a.w - b.w;
						return this
					},
					multiplyScalar: function(a) {
						this.x *= a;
						this.y *= a;
						this.z *= a;
						this.w *= a;
						return this
					},
					applyMatrix4: function(a) {
						var b = this.x,
							h = this.y,
							c = this.z,
							d = this.w;
						a = a.elements;
						this.x = a[0] * b + a[4] * h + a[8] * c + a[12] * d;
						this.y = a[1] * b + a[5] * h + a[9] * c + a[13] * d;
						this.z = a[2] * b + a[6] * h + a[10] * c + a[14] * d;
						this.w = a[3] * b + a[7] * h + a[11] * c + a[15] * d;
						return this
					},
					divideScalar: function(a) {
						return this.multiplyScalar(1 / a)
					},
					setAxisAngleFromQuaternion: function(a) {
						this.w = 2 * Math.acos(a.w);
						var b = Math.sqrt(1 -
							a.w * a.w);
						1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
						return this
					},
					setAxisAngleFromRotationMatrix: function(a) {
						a = a.elements;
						var b = a[0];
						var h = a[4];
						var c = a[8],
							d = a[1],
							e = a[5],
							f = a[9];
						var g = a[2];
						var k = a[6];
						var l = a[10];
						if (.01 > Math.abs(h - d) && .01 > Math.abs(c - g) && .01 > Math.abs(f - k)) {
							if (.1 > Math.abs(h + d) && .1 > Math.abs(c + g) && .1 > Math.abs(f + k) && .1 > Math.abs(b + e + l - 3))
								return this.set(1, 0, 0, 0), this;
							a = Math.PI;
							b = (b + 1) / 2;
							e = (e + 1) / 2;
							l = (l + 1) / 2;
							h = (h + d) / 4;
							c = (c + g) / 4;
							f = (f + k) / 4;
							b > e && b > l ? .01 > b ? (k = 0, h =
								g = .707106781) : (k = Math.sqrt(b), g = h / k, h = c / k) : e > l ? .01 > e ? (k = .707106781, g = 0, h =
								.707106781) : (g = Math.sqrt(e), k = h / g, h = f / g) : .01 > l ? (g = k = .707106781, h = 0) : (h =
								Math.sqrt(l), k = c / h, g = f / h);
							this.set(k, g, h, a);
							return this
						}
						a = Math.sqrt((k - f) * (k - f) + (c - g) * (c - g) + (d - h) * (d - h));
						.001 > Math.abs(a) && (a = 1);
						this.x = (k - f) / a;
						this.y = (c - g) / a;
						this.z = (d - h) / a;
						this.w = Math.acos((b + e + l - 1) / 2);
						return this
					},
					min: function(a) {
						this.x = Math.min(this.x, a.x);
						this.y = Math.min(this.y, a.y);
						this.z = Math.min(this.z, a.z);
						this.w = Math.min(this.w, a.w);
						return this
					},
					max: function(a) {
						this.x = Math.max(this.x, a.x);
						this.y = Math.max(this.y, a.y);
						this.z = Math.max(this.z, a.z);
						this.w = Math.max(this.w, a.w);
						return this
					},
					clamp: function(a, b) {
						this.x = Math.max(a.x, Math.min(b.x, this.x));
						this.y = Math.max(a.y, Math.min(b.y, this.y));
						this.z = Math.max(a.z, Math.min(b.z, this.z));
						this.w = Math.max(a.w, Math.min(b.w, this.w));
						return this
					},
					clampScalar: function(a, b) {
						this.x = Math.max(a, Math.min(b, this.x));
						this.y = Math.max(a, Math.min(b, this.y));
						this.z = Math.max(a, Math.min(b, this.z));
						this.w = Math.max(a, Math.min(b,
							this.w));
						return this
					},
					clampLength: function(a, b) {
						var h = this.length();
						return this.divideScalar(h || 1).multiplyScalar(Math.max(a, Math.min(b, h)))
					},
					floor: function() {
						this.x = Math.floor(this.x);
						this.y = Math.floor(this.y);
						this.z = Math.floor(this.z);
						this.w = Math.floor(this.w);
						return this
					},
					ceil: function() {
						this.x = Math.ceil(this.x);
						this.y = Math.ceil(this.y);
						this.z = Math.ceil(this.z);
						this.w = Math.ceil(this.w);
						return this
					},
					round: function() {
						this.x = Math.round(this.x);
						this.y = Math.round(this.y);
						this.z = Math.round(this.z);
						this.w =
							Math.round(this.w);
						return this
					},
					roundToZero: function() {
						this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
						this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
						this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
						this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
						return this
					},
					negate: function() {
						this.x = -this.x;
						this.y = -this.y;
						this.z = -this.z;
						this.w = -this.w;
						return this
					},
					dot: function(a) {
						return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
					},
					lengthSq: function() {
						return this.x * this.x + this.y * this.y + this.z *
							this.z + this.w * this.w
					},
					length: function() {
						return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
					},
					manhattanLength: function() {
						return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
					},
					normalize: function() {
						return this.divideScalar(this.length() || 1)
					},
					setLength: function(a) {
						return this.normalize().multiplyScalar(a)
					},
					lerp: function(a, b) {
						this.x += (a.x - this.x) * b;
						this.y += (a.y - this.y) * b;
						this.z += (a.z - this.z) * b;
						this.w += (a.w - this.w) * b;
						return this
					},
					lerpVectors: function(a, b, c) {
						return this.subVectors(b,
							a).multiplyScalar(c).add(a)
					},
					equals: function(a) {
						return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						this.x = a[b];
						this.y = a[b + 1];
						this.z = a[b + 2];
						this.w = a[b + 3];
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						a[b] = this.x;
						a[b + 1] = this.y;
						a[b + 2] = this.z;
						a[b + 3] = this.w;
						return a
					},
					fromBufferAttribute: function(a, b, c) {
						void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
						this.x = a.getX(b);
						this.y = a.getY(b);
						this.z = a.getZ(b);
						this.w = a.getW(b);
						return this
					}
				});
				n.prototype = q(p(b.prototype), {
					constructor: n,
					isWebGLRenderTarget: !0,
					setSize: function(a, b) {
						if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.texture.image.width = a,
							this.texture.image.height = b, this.dispose();
						this.viewport.set(0, 0, a, b);
						this.scissor.set(0, 0, a, b)
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.width = a.width;
						this.height = a.height;
						this.viewport.copy(a.viewport);
						this.texture = a.texture.clone();
						this.depthBuffer = a.depthBuffer;
						this.stencilBuffer = a.stencilBuffer;
						this.depthTexture = a.depthTexture;
						return this
					},
					dispose: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				});
				r.prototype = q(p(n.prototype), {
					constructor: r,
					isWebGLMultisampleRenderTarget: !0,
					copy: function(a) {
						n.prototype.copy.call(this, a);
						this.samples = a.samples;
						return this
					}
				});
				var Yc = new f,
					lb = new v,
					Ri = new f(0, 0, 0),
					Ui = new f(1, 1, 1),
					jh = new f,
					Af = new f,
					Wb = new f;
				q(v.prototype, {
					isMatrix4: !0,
					set: function(a, b, c, d, e, f, g, k, l, m, n, r, p, v, q, u) {
						var h = this.elements;
						h[0] = a;
						h[4] = b;
						h[8] = c;
						h[12] = d;
						h[1] = e;
						h[5] = f;
						h[9] = g;
						h[13] = k;
						h[2] = l;
						h[6] = m;
						h[10] = n;
						h[14] = r;
						h[3] = p;
						h[7] = v;
						h[11] = q;
						h[15] = u;
						return this
					},
					identity: function() {
						this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
						return this
					},
					clone: function() {
						return (new v).fromArray(this.elements)
					},
					copy: function(a) {
						var b = this.elements;
						a = a.elements;
						b[0] = a[0];
						b[1] = a[1];
						b[2] = a[2];
						b[3] = a[3];
						b[4] = a[4];
						b[5] = a[5];
						b[6] = a[6];
						b[7] = a[7];
						b[8] = a[8];
						b[9] = a[9];
						b[10] = a[10];
						b[11] = a[11];
						b[12] = a[12];
						b[13] = a[13];
						b[14] = a[14];
						b[15] = a[15];
						return this
					},
					copyPosition: function(a) {
						var b =
							this.elements;
						a = a.elements;
						b[12] = a[12];
						b[13] = a[13];
						b[14] = a[14];
						return this
					},
					extractBasis: function(a, b, c) {
						a.setFromMatrixColumn(this, 0);
						b.setFromMatrixColumn(this, 1);
						c.setFromMatrixColumn(this, 2);
						return this
					},
					makeBasis: function(a, b, c) {
						this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
						return this
					},
					extractRotation: function(a) {
						var b = this.elements,
							h = a.elements,
							c = 1 / Yc.setFromMatrixColumn(a, 0).length(),
							d = 1 / Yc.setFromMatrixColumn(a, 1).length();
						a = 1 / Yc.setFromMatrixColumn(a, 2).length();
						b[0] = h[0] *
							c;
						b[1] = h[1] * c;
						b[2] = h[2] * c;
						b[3] = 0;
						b[4] = h[4] * d;
						b[5] = h[5] * d;
						b[6] = h[6] * d;
						b[7] = 0;
						b[8] = h[8] * a;
						b[9] = h[9] * a;
						b[10] = h[10] * a;
						b[11] = 0;
						b[12] = 0;
						b[13] = 0;
						b[14] = 0;
						b[15] = 1;
						return this
					},
					makeRotationFromEuler: function(a) {
						a && a.isEuler || console.error(
							"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
						var b = this.elements,
							h = a.x,
							c = a.y,
							d = a.z,
							e = Math.cos(h);
						h = Math.sin(h);
						var f = Math.cos(c);
						c = Math.sin(c);
						var g = Math.cos(d);
						d = Math.sin(d);
						if ("XYZ" === a.order) {
							a = e * g;
							var k = e * d,
								l =
								h * g,
								m = h * d;
							b[0] = f * g;
							b[4] = -f * d;
							b[8] = c;
							b[1] = k + l * c;
							b[5] = a - m * c;
							b[9] = -h * f;
							b[2] = m - a * c;
							b[6] = l + k * c;
							b[10] = e * f
						} else "YXZ" === a.order ? (a = f * g, k = f * d, l = c * g, m = c * d, b[0] = a + m * h, b[4] = l * h - k,
								b[8] = e * c, b[1] = e * d, b[5] = e * g, b[9] = -h, b[2] = k * h - l, b[6] = m + a * h, b[10] = e * f) :
							"ZXY" === a.order ? (a = f * g, k = f * d, l = c * g, m = c * d, b[0] = a - m * h, b[4] = -e * d, b[8] = l +
								k * h, b[1] = k + l * h, b[5] = e * g, b[9] = m - a * h, b[2] = -e * c, b[6] = h, b[10] = e * f) : "ZYX" ===
							a.order ? (a = e * g, k = e * d, l = h * g, m = h * d, b[0] = f * g, b[4] = l * c - k, b[8] = a * c + m, b[
								1] = f * d, b[5] = m * c + a, b[9] = k * c - l, b[2] = -c, b[6] = h * f, b[10] = e * f) : "YZX" ===
							a.order ? (a = e * f, k = e * c, l = h * f, m = h * c, b[0] = f * g, b[4] = m - a * d, b[8] = l * d + k, b[
								1] = d, b[5] = e * g, b[9] = -h * g, b[2] = -c * g, b[6] = k * d + l, b[10] = a - m * d) : "XZY" === a.order &&
							(a = e * f, k = e * c, l = h * f, m = h * c, b[0] = f * g, b[4] = -d, b[8] = c * g, b[1] = a * d + m, b[5] =
								e * g, b[9] = k * d - l, b[2] = l * d - k, b[6] = h * g, b[10] = m * d + a);
						b[3] = 0;
						b[7] = 0;
						b[11] = 0;
						b[12] = 0;
						b[13] = 0;
						b[14] = 0;
						b[15] = 1;
						return this
					},
					makeRotationFromQuaternion: function(a) {
						return this.compose(Ri, a, Ui)
					},
					lookAt: function(a, b, c) {
						var h = this.elements;
						Wb.subVectors(a, b);
						0 === Wb.lengthSq() && (Wb.z = 1);
						Wb.normalize();
						jh.crossVectors(c,
							Wb);
						0 === jh.lengthSq() && (1 === Math.abs(c.z) ? Wb.x += 1E-4 : Wb.z += 1E-4, Wb.normalize(), jh.crossVectors(
							c, Wb));
						jh.normalize();
						Af.crossVectors(Wb, jh);
						h[0] = jh.x;
						h[4] = Af.x;
						h[8] = Wb.x;
						h[1] = jh.y;
						h[5] = Af.y;
						h[9] = Wb.y;
						h[2] = jh.z;
						h[6] = Af.z;
						h[10] = Wb.z;
						return this
					},
					multiply: function(a, b) {
						return void 0 !== b ? (console.warn(
								"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
							this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
					},
					premultiply: function(a) {
						return this.multiplyMatrices(a,
							this)
					},
					multiplyMatrices: function(a, b) {
						var h = a.elements,
							c = b.elements;
						b = this.elements;
						a = h[0];
						var d = h[4],
							e = h[8],
							f = h[12],
							t = h[1],
							g = h[5],
							k = h[9],
							l = h[13],
							m = h[2],
							n = h[6],
							r = h[10],
							p = h[14],
							v = h[3],
							q = h[7],
							u = h[11];
						h = h[15];
						var w = c[0],
							A = c[4],
							z = c[8],
							D = c[12],
							C = c[1],
							G = c[5],
							K = c[9],
							B = c[13],
							H = c[2],
							Q = c[6],
							I = c[10],
							L = c[14],
							F = c[3],
							M = c[7],
							J = c[11];
						c = c[15];
						b[0] = a * w + d * C + e * H + f * F;
						b[4] = a * A + d * G + e * Q + f * M;
						b[8] = a * z + d * K + e * I + f * J;
						b[12] = a * D + d * B + e * L + f * c;
						b[1] = t * w + g * C + k * H + l * F;
						b[5] = t * A + g * G + k * Q + l * M;
						b[9] = t * z + g * K + k * I + l * J;
						b[13] = t * D + g * B + k * L + l * c;
						b[2] =
							m * w + n * C + r * H + p * F;
						b[6] = m * A + n * G + r * Q + p * M;
						b[10] = m * z + n * K + r * I + p * J;
						b[14] = m * D + n * B + r * L + p * c;
						b[3] = v * w + q * C + u * H + h * F;
						b[7] = v * A + q * G + u * Q + h * M;
						b[11] = v * z + q * K + u * I + h * J;
						b[15] = v * D + q * B + u * L + h * c;
						return this
					},
					multiplyScalar: function(a) {
						var b = this.elements;
						b[0] *= a;
						b[4] *= a;
						b[8] *= a;
						b[12] *= a;
						b[1] *= a;
						b[5] *= a;
						b[9] *= a;
						b[13] *= a;
						b[2] *= a;
						b[6] *= a;
						b[10] *= a;
						b[14] *= a;
						b[3] *= a;
						b[7] *= a;
						b[11] *= a;
						b[15] *= a;
						return this
					},
					applyToBufferAttribute: function(a) {
						for (var b = 0, h = a.count; b < h; b++) Yc.x = a.getX(b), Yc.y = a.getY(b), Yc.z = a.getZ(b), Yc.applyMatrix4(
								this),
							a.setXYZ(b, Yc.x, Yc.y, Yc.z);
						return a
					},
					determinant: function() {
						var a = this.elements,
							b = a[0],
							c = a[4],
							d = a[8],
							e = a[12],
							f = a[1],
							g = a[5],
							k = a[9],
							l = a[13],
							m = a[2],
							n = a[6],
							r = a[10],
							p = a[14];
						return a[3] * (+e * k * n - d * l * n - e * g * r + c * l * r + d * g * p - c * k * p) + a[7] * (+b * k * p -
							b * l * r + e * f * r - d * f * p + d * l * m - e * k * m) + a[11] * (+b * l * n - b * g * p - e * f * n +
							c * f * p + e * g * m - c * l * m) + a[15] * (-d * g * m - b * k * n + b * g * r + d * f * n - c * f * r +
							c * k * m)
					},
					transpose: function() {
						var a = this.elements;
						var b = a[1];
						a[1] = a[4];
						a[4] = b;
						b = a[2];
						a[2] = a[8];
						a[8] = b;
						b = a[6];
						a[6] = a[9];
						a[9] = b;
						b = a[3];
						a[3] = a[12];
						a[12] = b;
						b = a[7];
						a[7] = a[13];
						a[13] = b;
						b = a[11];
						a[11] = a[14];
						a[14] = b;
						return this
					},
					setPosition: function(a, b, c) {
						var h = this.elements;
						a.isVector3 ? (h[12] = a.x, h[13] = a.y, h[14] = a.z) : (h[12] = a, h[13] = b, h[14] = c);
						return this
					},
					getInverse: function(a, b) {
						var h = this.elements,
							c = a.elements;
						a = c[0];
						var d = c[1],
							e = c[2],
							f = c[3],
							t = c[4],
							g = c[5],
							k = c[6],
							l = c[7],
							m = c[8],
							n = c[9],
							r = c[10],
							p = c[11],
							v = c[12],
							q = c[13],
							u = c[14];
						c = c[15];
						var w = n * u * l - q * r * l + q * k * p - g * u * p - n * k * c + g * r * c,
							A = v * r * l - m * u * l - v * k * p + t * u * p + m * k * c - t * r * c,
							z = m * q * l - v * n * l + v * g * p - t * q * p - m * g * c + t * n * c,
							D = v * n * k - m * q *
							k - v * g * r + t * q * r + m * g * u - t * n * u,
							C = a * w + d * A + e * z + f * D;
						if (0 === C) {
							if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
							console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
							return this.identity()
						}
						b = 1 / C;
						h[0] = w * b;
						h[1] = (q * r * f - n * u * f - q * e * p + d * u * p + n * e * c - d * r * c) * b;
						h[2] = (g * u * f - q * k * f + q * e * l - d * u * l - g * e * c + d * k * c) * b;
						h[3] = (n * k * f - g * r * f - n * e * l + d * r * l + g * e * p - d * k * p) * b;
						h[4] = A * b;
						h[5] = (m * u * f - v * r * f + v * e * p - a * u * p - m * e * c + a * r * c) * b;
						h[6] = (v * k * f - t * u * f - v * e * l + a * u * l + t * e * c - a * k * c) * b;
						h[7] = (t * r * f - m * k * f + m * e * l - a * r * l - t * e * p + a * k * p) * b;
						h[8] = z * b;
						h[9] = (v * n * f - m * q * f - v * d * p + a * q * p + m * d * c - a * n * c) * b;
						h[10] = (t * q * f - v * g * f + v * d * l - a * q * l - t * d * c + a * g * c) * b;
						h[11] = (m * g * f - t * n * f - m * d * l + a * n * l + t * d * p - a * g * p) * b;
						h[12] = D * b;
						h[13] = (m * q * e - v * n * e + v * d * r - a * q * r - m * d * u + a * n * u) * b;
						h[14] = (v * g * e - t * q * e - v * d * k + a * q * k + t * d * u - a * g * u) * b;
						h[15] = (t * n * e - m * g * e + m * d * k - a * n * k - t * d * r + a * g * r) * b;
						return this
					},
					scale: function(a) {
						var b = this.elements,
							h = a.x,
							c = a.y;
						a = a.z;
						b[0] *= h;
						b[4] *= c;
						b[8] *= a;
						b[1] *= h;
						b[5] *= c;
						b[9] *= a;
						b[2] *= h;
						b[6] *= c;
						b[10] *= a;
						b[3] *= h;
						b[7] *= c;
						b[11] *=
							a;
						return this
					},
					getMaxScaleOnAxis: function() {
						var a = this.elements;
						return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6],
							a[8] * a[8] + a[9] * a[9] + a[10] * a[10]))
					},
					makeTranslation: function(a, b, c) {
						this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
						return this
					},
					makeRotationX: function(a) {
						var b = Math.cos(a);
						a = Math.sin(a);
						this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
						return this
					},
					makeRotationY: function(a) {
						var b = Math.cos(a);
						a = Math.sin(a);
						this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
						return this
					},
					makeRotationZ: function(a) {
						var b =
							Math.cos(a);
						a = Math.sin(a);
						this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
						return this
					},
					makeRotationAxis: function(a, b) {
						var h = Math.cos(b);
						b = Math.sin(b);
						var c = 1 - h,
							d = a.x,
							e = a.y;
						a = a.z;
						var f = c * d,
							t = c * e;
						this.set(f * d + h, f * e - b * a, f * a + b * e, 0, f * e + b * a, t * e + h, t * a - b * d, 0, f * a - b *
							e, t * a + b * d, c * a * a + h, 0, 0, 0, 0, 1);
						return this
					},
					makeScale: function(a, b, c) {
						this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
						return this
					},
					makeShear: function(a, b, c) {
						this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
						return this
					},
					compose: function(a, b, c) {
						var h = this.elements,
							d =
							b._x,
							e = b._y,
							f = b._z,
							t = b._w,
							g = d + d,
							k = e + e,
							x = f + f;
						b = d * g;
						var l = d * k;
						d *= x;
						var m = e * k;
						e *= x;
						f *= x;
						g *= t;
						k *= t;
						t *= x;
						x = c.x;
						var n = c.y;
						c = c.z;
						h[0] = (1 - (m + f)) * x;
						h[1] = (l + t) * x;
						h[2] = (d - k) * x;
						h[3] = 0;
						h[4] = (l - t) * n;
						h[5] = (1 - (b + f)) * n;
						h[6] = (e + g) * n;
						h[7] = 0;
						h[8] = (d + k) * c;
						h[9] = (e - g) * c;
						h[10] = (1 - (b + m)) * c;
						h[11] = 0;
						h[12] = a.x;
						h[13] = a.y;
						h[14] = a.z;
						h[15] = 1;
						return this
					},
					decompose: function(a, b, c) {
						var h = this.elements,
							d = Yc.set(h[0], h[1], h[2]).length(),
							e = Yc.set(h[4], h[5], h[6]).length(),
							f = Yc.set(h[8], h[9], h[10]).length();
						0 > this.determinant() && (d = -d);
						a.x = h[12];
						a.y = h[13];
						a.z = h[14];
						lb.copy(this);
						a = 1 / d;
						h = 1 / e;
						var t = 1 / f;
						lb.elements[0] *= a;
						lb.elements[1] *= a;
						lb.elements[2] *= a;
						lb.elements[4] *= h;
						lb.elements[5] *= h;
						lb.elements[6] *= h;
						lb.elements[8] *= t;
						lb.elements[9] *= t;
						lb.elements[10] *= t;
						b.setFromRotationMatrix(lb);
						c.x = d;
						c.y = e;
						c.z = f;
						return this
					},
					makePerspective: function(a, b, c, d, e, f) {
						void 0 === f && console.warn(
							"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
						var h = this.elements;
						h[0] = 2 * e / (b - a);
						h[4] = 0;
						h[8] =
							(b + a) / (b - a);
						h[12] = 0;
						h[1] = 0;
						h[5] = 2 * e / (c - d);
						h[9] = (c + d) / (c - d);
						h[13] = 0;
						h[2] = 0;
						h[6] = 0;
						h[10] = -(f + e) / (f - e);
						h[14] = -2 * f * e / (f - e);
						h[3] = 0;
						h[7] = 0;
						h[11] = -1;
						h[15] = 0;
						return this
					},
					makeOrthographic: function(a, b, c, d, e, f) {
						var h = this.elements,
							t = 1 / (b - a),
							g = 1 / (c - d),
							k = 1 / (f - e);
						h[0] = 2 * t;
						h[4] = 0;
						h[8] = 0;
						h[12] = -((b + a) * t);
						h[1] = 0;
						h[5] = 2 * g;
						h[9] = 0;
						h[13] = -((c + d) * g);
						h[2] = 0;
						h[6] = 0;
						h[10] = -2 * k;
						h[14] = -((f + e) * k);
						h[3] = 0;
						h[7] = 0;
						h[11] = 0;
						h[15] = 1;
						return this
					},
					equals: function(a) {
						var b = this.elements;
						a = a.elements;
						for (var h = 0; 16 > h; h++)
							if (b[h] !== a[h]) return !1;
						return !0
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						for (var h = 0; 16 > h; h++) this.elements[h] = a[h + b];
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						var h = this.elements;
						a[b] = h[0];
						a[b + 1] = h[1];
						a[b + 2] = h[2];
						a[b + 3] = h[3];
						a[b + 4] = h[4];
						a[b + 5] = h[5];
						a[b + 6] = h[6];
						a[b + 7] = h[7];
						a[b + 8] = h[8];
						a[b + 9] = h[9];
						a[b + 10] = h[10];
						a[b + 11] = h[11];
						a[b + 12] = h[12];
						a[b + 13] = h[13];
						a[b + 14] = h[14];
						a[b + 15] = h[15];
						return a
					}
				});
				var Gh = new v,
					Hh = new e;
				A.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
				A.DefaultOrder = "XYZ";
				ja(A.prototype, {
					x: {
						get: function() {
							return this._x
						},
						set: function(a) {
							this._x = a;
							this._onChangeCallback()
						}
					},
					y: {
						get: function() {
							return this._y
						},
						set: function(a) {
							this._y = a;
							this._onChangeCallback()
						}
					},
					z: {
						get: function() {
							return this._z
						},
						set: function(a) {
							this._z = a;
							this._onChangeCallback()
						}
					},
					order: {
						get: function() {
							return this._order
						},
						set: function(a) {
							this._order = a;
							this._onChangeCallback()
						}
					}
				});
				q(A.prototype, {
					isEuler: !0,
					set: function(a, b, c, d) {
						this._x = a;
						this._y = b;
						this._z = c;
						this._order = d || this._order;
						this._onChangeCallback();
						return this
					},
					clone: function() {
						return new this.constructor(this._x, this._y, this._z, this._order)
					},
					copy: function(a) {
						this._x = a._x;
						this._y = a._y;
						this._z = a._z;
						this._order = a._order;
						this._onChangeCallback();
						return this
					},
					setFromRotationMatrix: function(a, b, c) {
						var h = Ea.clamp,
							d = a.elements;
						a = d[0];
						var e = d[4],
							f = d[8],
							t = d[1],
							g = d[5],
							k = d[9],
							x = d[2],
							l = d[6];
						d = d[10];
						b = b || this._order;
						"XYZ" === b ? (this._y = Math.asin(h(f, -1, 1)), .9999999 > Math.abs(f) ? (this._x = Math.atan2(-k, d),
								this._z = Math.atan2(-e, a)) : (this._x = Math.atan2(l, g), this._z = 0)) : "YXZ" ===
							b ? (this._x = Math.asin(-h(k, -1, 1)), .9999999 > Math.abs(k) ? (this._y = Math.atan2(f, d), this._z =
								Math.atan2(t, g)) : (this._y = Math.atan2(-x, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(h(l,
								-1, 1)), .9999999 > Math.abs(l) ? (this._y = Math.atan2(-x, d), this._z = Math.atan2(-e, g)) : (this._y =
								0, this._z = Math.atan2(t, a))) : "ZYX" === b ? (this._y = Math.asin(-h(x, -1, 1)), .9999999 > Math.abs(x) ?
								(this._x = Math.atan2(l, d), this._z = Math.atan2(t, a)) : (this._x = 0, this._z = Math.atan2(-e, g))) :
							"YZX" === b ? (this._z = Math.asin(h(t, -1, 1)), .9999999 > Math.abs(t) ?
								(this._x = Math.atan2(-k, g), this._y = Math.atan2(-x, a)) : (this._x = 0, this._y = Math.atan2(f, d))) :
							"XZY" === b ? (this._z = Math.asin(-h(e, -1, 1)), .9999999 > Math.abs(e) ? (this._x = Math.atan2(l, g),
								this._y = Math.atan2(f, a)) : (this._x = Math.atan2(-k, d), this._y = 0)) : console.warn(
								"THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
						this._order = b;
						!1 !== c && this._onChangeCallback();
						return this
					},
					setFromQuaternion: function(a, b, c) {
						Gh.makeRotationFromQuaternion(a);
						return this.setFromRotationMatrix(Gh, b, c)
					},
					setFromVector3: function(a,
						b) {
						return this.set(a.x, a.y, a.z, b || this._order)
					},
					reorder: function(a) {
						Hh.setFromEuler(this);
						return this.setFromQuaternion(Hh, a)
					},
					equals: function(a) {
						return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
					},
					fromArray: function(a) {
						this._x = a[0];
						this._y = a[1];
						this._z = a[2];
						void 0 !== a[3] && (this._order = a[3]);
						this._onChangeCallback();
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						a[b] = this._x;
						a[b + 1] = this._y;
						a[b + 2] = this._z;
						a[b + 3] = this._order;
						return a
					},
					toVector3: function(a) {
						return a ?
							a.set(this._x, this._y, this._z) : new f(this._x, this._y, this._z)
					},
					_onChange: function(a) {
						this._onChangeCallback = a;
						return this
					},
					_onChangeCallback: function() {}
				});
				q(w.prototype, {
					set: function(a) {
						this.mask = 1 << a | 0
					},
					enable: function(a) {
						this.mask = this.mask | 1 << a | 0
					},
					enableAll: function() {
						this.mask = -1
					},
					toggle: function(a) {
						this.mask ^= 1 << a | 0
					},
					disable: function(a) {
						this.mask &= ~(1 << a | 0)
					},
					disableAll: function() {
						this.mask = 0
					},
					test: function(a) {
						return 0 !== (this.mask & a.mask)
					}
				});
				var Yi = 0,
					Kh = new f,
					Mj = new e,
					mg = new v,
					Cf = new f,
					uk = new f,
					Zi = new f,
					$i = new e,
					Lh = new f(1, 0, 0),
					Mh = new f(0, 1, 0),
					Nh = new f(0, 0, 1),
					bj = {
						type: "added"
					},
					cj = {
						type: "removed"
					};
				u.DefaultUp = new f(0, 1, 0);
				u.DefaultMatrixAutoUpdate = !0;
				u.prototype = q(p(b.prototype), {
					constructor: u,
					isObject3D: !0,
					onBeforeRender: function() {},
					onAfterRender: function() {},
					applyMatrix: function(a) {
						this.matrixAutoUpdate && this.updateMatrix();
						this.matrix.premultiply(a);
						this.matrix.decompose(this.position, this.quaternion, this.scale)
					},
					applyQuaternion: function(a) {
						this.quaternion.premultiply(a);
						return this
					},
					setRotationFromAxisAngle: function(a, b) {
						this.quaternion.setFromAxisAngle(a, b)
					},
					setRotationFromEuler: function(a) {
						this.quaternion.setFromEuler(a, !0)
					},
					setRotationFromMatrix: function(a) {
						this.quaternion.setFromRotationMatrix(a)
					},
					setRotationFromQuaternion: function(a) {
						this.quaternion.copy(a)
					},
					rotateOnAxis: function(a, b) {
						Mj.setFromAxisAngle(a, b);
						this.quaternion.multiply(Mj);
						return this
					},
					rotateOnWorldAxis: function(a, b) {
						Mj.setFromAxisAngle(a, b);
						this.quaternion.premultiply(Mj);
						return this
					},
					rotateX: function(a) {
						return this.rotateOnAxis(Lh,
							a)
					},
					rotateY: function(a) {
						return this.rotateOnAxis(Mh, a)
					},
					rotateZ: function(a) {
						return this.rotateOnAxis(Nh, a)
					},
					translateOnAxis: function(a, b) {
						Kh.copy(a).applyQuaternion(this.quaternion);
						this.position.add(Kh.multiplyScalar(b));
						return this
					},
					translateX: function(a) {
						return this.translateOnAxis(Lh, a)
					},
					translateY: function(a) {
						return this.translateOnAxis(Mh, a)
					},
					translateZ: function(a) {
						return this.translateOnAxis(Nh, a)
					},
					localToWorld: function(a) {
						return a.applyMatrix4(this.matrixWorld)
					},
					worldToLocal: function(a) {
						return a.applyMatrix4(mg.getInverse(this.matrixWorld))
					},
					lookAt: function(a, b, c) {
						a.isVector3 ? Cf.copy(a) : Cf.set(a, b, c);
						a = this.parent;
						this.updateWorldMatrix(!0, !1);
						uk.setFromMatrixPosition(this.matrixWorld);
						this.isCamera || this.isLight ? mg.lookAt(uk, Cf, this.up) : mg.lookAt(Cf, uk, this.up);
						this.quaternion.setFromRotationMatrix(mg);
						a && (mg.extractRotation(a.matrixWorld), Mj.setFromRotationMatrix(mg), this.quaternion.premultiply(Mj.inverse()))
					},
					add: function(a) {
						if (1 < arguments.length) {
							for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
							return this
						}
						if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.",
							a), this;
						a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, this.children.push(a), a.dispatchEvent(
							bj)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
						return this
					},
					remove: function(a) {
						if (1 < arguments.length) {
							for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
							return this
						}
						b = this.children.indexOf(a); - 1 !== b && (a.parent = null, this.children.splice(b, 1), a.dispatchEvent(cj));
						return this
					},
					attach: function(a) {
						this.updateWorldMatrix(!0, !1);
						mg.getInverse(this.matrixWorld);
						null !== a.parent && (a.parent.updateWorldMatrix(!0, !1), mg.multiply(a.parent.matrixWorld));
						a.applyMatrix(mg);
						a.updateWorldMatrix(!1, !1);
						this.add(a);
						return this
					},
					getObjectById: function(a) {
						return this.getObjectByProperty("id", a)
					},
					getObjectByName: function(a) {
						return this.getObjectByProperty("name", a)
					},
					getObjectByProperty: function(a, b) {
						if (this[a] === b) return this;
						for (var h = 0, c = this.children.length; h < c; h++) {
							var d = this.children[h].getObjectByProperty(a, b);
							if (void 0 !== d) return d
						}
					},
					getWorldPosition: function(a) {
						void 0 ===
							a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new f);
						this.updateMatrixWorld(!0);
						return a.setFromMatrixPosition(this.matrixWorld)
					},
					getWorldQuaternion: function(a) {
						void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), a = new e);
						this.updateMatrixWorld(!0);
						this.matrixWorld.decompose(uk, a, Zi);
						return a
					},
					getWorldScale: function(a) {
						void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), a = new f);
						this.updateMatrixWorld(!0);
						this.matrixWorld.decompose(uk, $i, a);
						return a
					},
					getWorldDirection: function(a) {
						void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new f);
						this.updateMatrixWorld(!0);
						var b = this.matrixWorld.elements;
						return a.set(b[8], b[9], b[10]).normalize()
					},
					raycast: function() {},
					traverse: function(a) {
						a(this);
						for (var b = this.children, h = 0, c = b.length; h < c; h++) b[h].traverse(a)
					},
					traverseVisible: function(a) {
						if (!1 !== this.visible) {
							a(this);
							for (var b = this.children, h = 0, c = b.length; h < c; h++) b[h].traverseVisible(a)
						}
					},
					traverseAncestors: function(a) {
						var b = this.parent;
						null !== b && (a(b), b.traverseAncestors(a))
					},
					updateMatrix: function() {
						this.matrix.compose(this.position, this.quaternion, this.scale);
						this.matrixWorldNeedsUpdate = !0
					},
					updateMatrixWorld: function(a) {
						this.matrixAutoUpdate && this.updateMatrix();
						if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld
							.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
						for (var b = this.children, h =
								0, c = b.length; h < c; h++) b[h].updateMatrixWorld(a)
					},
					updateWorldMatrix: function(a, b) {
						var h = this.parent;
						!0 === a && null !== h && h.updateWorldMatrix(!0, !1);
						this.matrixAutoUpdate && this.updateMatrix();
						null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,
							this.matrix);
						if (!0 === b)
							for (a = this.children, b = 0, h = a.length; b < h; b++) a[b].updateWorldMatrix(!1, !0)
					},
					toJSON: function(a) {
						function b(b, h) {
							void 0 === b[h.uuid] && (b[h.uuid] = h.toJSON(a));
							return h.uuid
						}

						function h(a) {
							var b = [],
								h;
							for (h in a) {
								var c = a[h];
								delete c.metadata;
								b.push(c)
							}
							return b
						}
						var c = void 0 === a || "string" === typeof a,
							d = {};
						c && (a = {
							geometries: {},
							materials: {},
							textures: {},
							images: {},
							shapes: {}
						}, d.metadata = {
							version: 4.5,
							type: "Object",
							generator: "Object3D.toJSON"
						});
						var e = {};
						e.uuid = this.uuid;
						e.type = this.type;
						"" !== this.name && (e.name = this.name);
						!0 === this.castShadow && (e.castShadow = !0);
						!0 === this.receiveShadow && (e.receiveShadow = !0);
						!1 === this.visible && (e.visible = !1);
						!1 === this.frustumCulled && (e.frustumCulled = !1);
						0 !== this.renderOrder &&
							(e.renderOrder = this.renderOrder);
						"{}" !== Rd(this.userData) && (e.userData = this.userData);
						e.layers = this.layers.mask;
						e.matrix = this.matrix.toArray();
						!1 === this.matrixAutoUpdate && (e.matrixAutoUpdate = !1);
						this.isMesh && 0 !== this.drawMode && (e.drawMode = this.drawMode);
						if (this.isMesh || this.isLine || this.isPoints) {
							e.geometry = b(a.geometries, this.geometry);
							var f = this.geometry.parameters;
							if (void 0 !== f && void 0 !== f.shapes)
								if (f = f.shapes, Array.isArray(f))
									for (var g = 0, k = f.length; g < k; g++) b(a.shapes, f[g]);
								else b(a.shapes, f)
						}
						if (void 0 !==
							this.material)
							if (Array.isArray(this.material)) {
								f = [];
								g = 0;
								for (k = this.material.length; g < k; g++) f.push(b(a.materials, this.material[g]));
								e.material = f
							} else e.material = b(a.materials, this.material);
						if (0 < this.children.length)
							for (e.children = [], g = 0; g < this.children.length; g++) e.children.push(this.children[g].toJSON(a).object);
						if (c) {
							c = h(a.geometries);
							g = h(a.materials);
							k = h(a.textures);
							var l = h(a.images);
							f = h(a.shapes);
							0 < c.length && (d.geometries = c);
							0 < g.length && (d.materials = g);
							0 < k.length && (d.textures = k);
							0 < l.length && (d.images =
								l);
							0 < f.length && (d.shapes = f)
						}
						d.object = e;
						return d
					},
					clone: function(a) {
						return (new this.constructor).copy(this, a)
					},
					copy: function(a, b) {
						void 0 === b && (b = !0);
						this.name = a.name;
						this.up.copy(a.up);
						this.position.copy(a.position);
						this.quaternion.copy(a.quaternion);
						this.scale.copy(a.scale);
						this.matrix.copy(a.matrix);
						this.matrixWorld.copy(a.matrixWorld);
						this.matrixAutoUpdate = a.matrixAutoUpdate;
						this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
						this.layers.mask = a.layers.mask;
						this.visible = a.visible;
						this.castShadow =
							a.castShadow;
						this.receiveShadow = a.receiveShadow;
						this.frustumCulled = a.frustumCulled;
						this.renderOrder = a.renderOrder;
						this.userData = JSON.parse(Rd(a.userData));
						if (!0 === b)
							for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
						return this
					}
				});
				C.prototype = q(p(u.prototype), {
					constructor: C,
					isScene: !0,
					copy: function(a, b) {
						u.prototype.copy.call(this, a, b);
						null !== a.background && (this.background = a.background.clone());
						null !== a.fog && (this.fog = a.fog.clone());
						null !== a.overrideMaterial && (this.overrideMaterial = a.overrideMaterial.clone());
						this.autoUpdate = a.autoUpdate;
						this.matrixAutoUpdate = a.matrixAutoUpdate;
						return this
					},
					toJSON: function(a) {
						var b = u.prototype.toJSON.call(this, a);
						null !== this.background && (b.object.background = this.background.toJSON(a));
						null !== this.fog && (b.object.fog = this.fog.toJSON());
						return b
					},
					dispose: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				});
				var ng = [new f, new f, new f, new f, new f, new f, new f, new f],
					qf = new f,
					Nj = new f,
					Oj = new f,
					Pj = new f,
					kh = new f,
					lh = new f,
					oi = new f,
					vk = new f,
					Df = new f,
					Ef = new f,
					Yh = new f;
				q(D.prototype, {
					isBox3: !0,
					set: function(a, b) {
						this.min.copy(a);
						this.max.copy(b);
						return this
					},
					setFromArray: function(a) {
						for (var b = Infinity, h = Infinity, c = Infinity, d = -Infinity, e = -Infinity, f = -Infinity, g = 0, k =
								a.length; g < k; g += 3) {
							var l = a[g],
								m = a[g + 1],
								n = a[g + 2];
							l < b && (b = l);
							m < h && (h = m);
							n < c && (c = n);
							l > d && (d = l);
							m > e && (e = m);
							n > f && (f = n)
						}
						this.min.set(b, h, c);
						this.max.set(d, e, f);
						return this
					},
					setFromBufferAttribute: function(a) {
						for (var b = Infinity, h = Infinity, c = Infinity, d = -Infinity, e = -Infinity, f = -Infinity, g = 0, k =
								a.count; g < k; g++) {
							var l = a.getX(g),
								m = a.getY(g),
								n = a.getZ(g);
							l < b && (b = l);
							m < h && (h = m);
							n < c && (c = n);
							l > d && (d = l);
							m > e && (e = m);
							n > f && (f = n)
						}
						this.min.set(b, h, c);
						this.max.set(d, e, f);
						return this
					},
					setFromPoints: function(a) {
						this.makeEmpty();
						for (var b = 0, h = a.length; b < h; b++) this.expandByPoint(a[b]);
						return this
					},
					setFromCenterAndSize: function(a, b) {
						b = qf.copy(b).multiplyScalar(.5);
						this.min.copy(a).sub(b);
						this.max.copy(a).add(b);
						return this
					},
					setFromObject: function(a) {
						this.makeEmpty();
						return this.expandByObject(a)
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.min.copy(a.min);
						this.max.copy(a.max);
						return this
					},
					makeEmpty: function() {
						this.min.x = this.min.y = this.min.z = Infinity;
						this.max.x = this.max.y = this.max.z = -Infinity;
						return this
					},
					isEmpty: function() {
						return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
					},
					getCenter: function(a) {
						void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new f);
						return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
					},
					getSize: function(a) {
						void 0 ===
							a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new f);
						return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
					},
					expandByPoint: function(a) {
						this.min.min(a);
						this.max.max(a);
						return this
					},
					expandByVector: function(a) {
						this.min.sub(a);
						this.max.add(a);
						return this
					},
					expandByScalar: function(a) {
						this.min.addScalar(-a);
						this.max.addScalar(a);
						return this
					},
					expandByObject: function(a) {
						var b;
						a.updateWorldMatrix(!1, !1);
						var c = a.geometry;
						if (void 0 !== c)
							if (c.isGeometry) {
								var h = c.vertices;
								c = 0;
								for (b =
									h.length; c < b; c++) qf.copy(h[c]), qf.applyMatrix4(a.matrixWorld), this.expandByPoint(qf)
							} else if (c.isBufferGeometry && (h = c.attributes.position, void 0 !== h))
							for (c = 0, b = h.count; c < b; c++) qf.fromBufferAttribute(h, c).applyMatrix4(a.matrixWorld), this.expandByPoint(
								qf);
						a = a.children;
						c = 0;
						for (b = a.length; c < b; c++) this.expandByObject(a[c]);
						return this
					},
					containsPoint: function(a) {
						return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z ||
							a.z > this.max.z ? !1 : !0
					},
					containsBox: function(a) {
						return this.min.x <=
							a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z &&
							a.max.z <= this.max.z
					},
					getParameter: function(a, b) {
						void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new f);
						return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y),
							(a.z - this.min.z) / (this.max.z - this.min.z))
					},
					intersectsBox: function(a) {
						return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max
							.z < this.min.z ||
							a.min.z > this.max.z ? !1 : !0
					},
					intersectsSphere: function(a) {
						this.clampPoint(a.center, qf);
						return qf.distanceToSquared(a.center) <= a.radius * a.radius
					},
					intersectsPlane: function(a) {
						if (0 < a.normal.x) {
							var b = a.normal.x * this.min.x;
							var c = a.normal.x * this.max.x
						} else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x;
						0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max
							.y, c += a.normal.y * this.min.y);
						0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max
							.z,
							c += a.normal.z * this.min.z);
						return b <= -a.constant && c >= -a.constant
					},
					intersectsTriangle: function(a) {
						if (this.isEmpty()) return !1;
						this.getCenter(vk);
						Df.subVectors(this.max, vk);
						Nj.subVectors(a.a, vk);
						Oj.subVectors(a.b, vk);
						Pj.subVectors(a.c, vk);
						kh.subVectors(Oj, Nj);
						lh.subVectors(Pj, Oj);
						oi.subVectors(Nj, Pj);
						a = [0, -kh.z, kh.y, 0, -lh.z, lh.y, 0, -oi.z, oi.y, kh.z, 0, -kh.x, lh.z, 0, -lh.x, oi.z, 0, -oi.x, -kh.y,
							kh.x, 0, -lh.y, lh.x, 0, -oi.y, oi.x, 0
						];
						if (!K(a, Nj, Oj, Pj, Df)) return !1;
						a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
						if (!K(a, Nj, Oj, Pj, Df)) return !1;
						Ef.crossVectors(kh, lh);
						a = [Ef.x, Ef.y, Ef.z];
						return K(a, Nj, Oj, Pj, Df)
					},
					clampPoint: function(a, b) {
						void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new f);
						return b.copy(a).clamp(this.min, this.max)
					},
					distanceToPoint: function(a) {
						return qf.copy(a).clamp(this.min, this.max).sub(a).length()
					},
					getBoundingSphere: function(a) {
						void 0 === a && console.error("THREE.Box3: .getBoundingSphere() target is now required");
						this.getCenter(a.center);
						a.radius = .5 * this.getSize(qf).length();
						return a
					},
					intersect: function(a) {
						this.min.max(a.min);
						this.max.min(a.max);
						this.isEmpty() && this.makeEmpty();
						return this
					},
					union: function(a) {
						this.min.min(a.min);
						this.max.max(a.max);
						return this
					},
					applyMatrix4: function(a) {
						if (this.isEmpty()) return this;
						ng[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
						ng[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
						ng[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
						ng[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
						ng[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
						ng[5].set(this.max.x,
							this.min.y, this.max.z).applyMatrix4(a);
						ng[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
						ng[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
						this.setFromPoints(ng);
						return this
					},
					translate: function(a) {
						this.min.add(a);
						this.max.add(a);
						return this
					},
					equals: function(a) {
						return a.min.equals(this.min) && a.max.equals(this.max)
					}
				});
				var dj = new D;
				q(G.prototype, {
					set: function(a, b) {
						this.center.copy(a);
						this.radius = b;
						return this
					},
					setFromPoints: function(a, b) {
						var c = this.center;
						void 0 !== b ? c.copy(b) : dj.setFromPoints(a).getCenter(c);
						for (var h = b = 0, d = a.length; h < d; h++) b = Math.max(b, c.distanceToSquared(a[h]));
						this.radius = Math.sqrt(b);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.center.copy(a.center);
						this.radius = a.radius;
						return this
					},
					empty: function() {
						return 0 >= this.radius
					},
					containsPoint: function(a) {
						return a.distanceToSquared(this.center) <= this.radius * this.radius
					},
					distanceToPoint: function(a) {
						return a.distanceTo(this.center) - this.radius
					},
					intersectsSphere: function(a) {
						var b = this.radius + a.radius;
						return a.center.distanceToSquared(this.center) <= b * b
					},
					intersectsBox: function(a) {
						return a.intersectsSphere(this)
					},
					intersectsPlane: function(a) {
						return Math.abs(a.distanceToPoint(this.center)) <= this.radius
					},
					clampPoint: function(a, b) {
						var c = this.center.distanceToSquared(a);
						void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new f);
						b.copy(a);
						c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
						return b
					},
					getBoundingBox: function(a) {
						void 0 ===
							a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new D);
						a.set(this.center, this.center);
						a.expandByScalar(this.radius);
						return a
					},
					applyMatrix4: function(a) {
						this.center.applyMatrix4(a);
						this.radius *= a.getMaxScaleOnAxis();
						return this
					},
					translate: function(a) {
						this.center.add(a);
						return this
					},
					equals: function(a) {
						return a.center.equals(this.center) && a.radius === this.radius
					}
				});
				var og = new f,
					Jg = new f,
					Gf = new f,
					mh = new f,
					Kg = new f,
					If = new f,
					Mg = new f;
				q(B.prototype, {
					set: function(a, b) {
						this.origin.copy(a);
						this.direction.copy(b);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.origin.copy(a.origin);
						this.direction.copy(a.direction);
						return this
					},
					at: function(a, b) {
						void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new f);
						return b.copy(this.direction).multiplyScalar(a).add(this.origin)
					},
					lookAt: function(a) {
						this.direction.copy(a).sub(this.origin).normalize();
						return this
					},
					recast: function(a) {
						this.origin.copy(this.at(a, og));
						return this
					},
					closestPointToPoint: function(a,
						b) {
						void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new f);
						b.subVectors(a, this.origin);
						a = b.dot(this.direction);
						return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
					},
					distanceToPoint: function(a) {
						return Math.sqrt(this.distanceSqToPoint(a))
					},
					distanceSqToPoint: function(a) {
						var b = og.subVectors(a, this.origin).dot(this.direction);
						if (0 > b) return this.origin.distanceToSquared(a);
						og.copy(this.direction).multiplyScalar(b).add(this.origin);
						return og.distanceToSquared(a)
					},
					distanceSqToSegment: function(a, b, c, d) {
						Jg.copy(a).add(b).multiplyScalar(.5);
						Gf.copy(b).sub(a).normalize();
						mh.copy(this.origin).sub(Jg);
						var h = .5 * a.distanceTo(b),
							e = -this.direction.dot(Gf),
							f = mh.dot(this.direction),
							g = -mh.dot(Gf),
							t = mh.lengthSq(),
							k = Math.abs(1 - e * e);
						if (0 < k) {
							a = e * g - f;
							b = e * f - g;
							var l = h * k;
							0 <= a ? b >= -l ? b <= l ? (h = 1 / k, a *= h, b *= h, e = a * (a + e * b + 2 * f) + b * (e * a + b + 2 *
									g) + t) : (b = h, a = Math.max(0, -(e * b + f)), e = -a * a + b * (b + 2 * g) + t) : (b = -h, a = Math.max(
									0, -(e * b + f)), e = -a * a + b * (b + 2 * g) + t) : b <= -l ? (a = Math.max(0,
									-(-e * h + f)), b = 0 < a ? -h : Math.min(Math.max(-h, -g), h), e = -a * a + b * (b + 2 * g) + t) : b <=
								l ? (a = 0, b = Math.min(Math.max(-h, -g), h), e = b * (b + 2 * g) + t) : (a = Math.max(0, -(e * h + f)),
									b = 0 < a ? h : Math.min(Math.max(-h, -g), h), e = -a * a + b * (b + 2 * g) + t)
						} else b = 0 < e ? -h : h, a = Math.max(0, -(e * b + f)), e = -a * a + b * (b + 2 * g) + t;
						c && c.copy(this.direction).multiplyScalar(a).add(this.origin);
						d && d.copy(Gf).multiplyScalar(b).add(Jg);
						return e
					},
					intersectSphere: function(a, b) {
						og.subVectors(a.center, this.origin);
						var c = og.dot(this.direction),
							h = og.dot(og) - c * c;
						a = a.radius * a.radius;
						if (h > a) return null;
						a = Math.sqrt(a - h);
						h = c - a;
						c += a;
						return 0 > h && 0 > c ? null : 0 > h ? this.at(c, b) : this.at(h, b)
					},
					intersectsSphere: function(a) {
						return this.distanceSqToPoint(a.center) <= a.radius * a.radius
					},
					distanceToPlane: function(a) {
						var b = a.normal.dot(this.direction);
						if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
						a = -(this.origin.dot(a.normal) + a.constant) / b;
						return 0 <= a ? a : null
					},
					intersectPlane: function(a, b) {
						a = this.distanceToPlane(a);
						return null === a ? null : this.at(a, b)
					},
					intersectsPlane: function(a) {
						var b = a.distanceToPoint(this.origin);
						return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
					},
					intersectBox: function(a, b) {
						var c = 1 / this.direction.x;
						var h = 1 / this.direction.y;
						var d = 1 / this.direction.z,
							e = this.origin;
						if (0 <= c) {
							var f = (a.min.x - e.x) * c;
							c *= a.max.x - e.x
						} else f = (a.max.x - e.x) * c, c *= a.min.x - e.x;
						if (0 <= h) {
							var g = (a.min.y - e.y) * h;
							h *= a.max.y - e.y
						} else g = (a.max.y - e.y) * h, h *= a.min.y - e.y;
						if (f > h || g > c) return null;
						if (g > f || f !== f) f = g;
						if (h < c || c !== c) c = h;
						0 <= d ? (g = (a.min.z - e.z) * d, a = (a.max.z - e.z) * d) : (g = (a.max.z - e.z) * d, a = (a.min.z - e.z) *
							d);
						if (f > a || g > c) return null;
						if (g > f || f !== f) f = g;
						if (a < c || c !== c) c = a;
						return 0 > c ? null : this.at(0 <= f ? f : c, b)
					},
					intersectsBox: function(a) {
						return null !== this.intersectBox(a, og)
					},
					intersectTriangle: function(a, b, c, d, e) {
						Kg.subVectors(b, a);
						If.subVectors(c, a);
						Mg.crossVectors(Kg, If);
						b = this.direction.dot(Mg);
						if (0 < b) {
							if (d) return null;
							d = 1
						} else if (0 > b) d = -1, b = -b;
						else return null;
						mh.subVectors(this.origin, a);
						a = d * this.direction.dot(If.crossVectors(mh, If));
						if (0 > a) return null;
						c = d * this.direction.dot(Kg.cross(mh));
						if (0 > c || a + c > b) return null;
						a = -d * mh.dot(Mg);
						return 0 > a ? null : this.at(a / b, e)
					},
					applyMatrix4: function(a) {
						this.origin.applyMatrix4(a);
						this.direction.transformDirection(a);
						return this
					},
					equals: function(a) {
						return a.origin.equals(this.origin) && a.direction.equals(this.direction)
					}
				});
				var ue = new f,
					pg = new f,
					Ng = new f,
					qg = new f,
					Qj = new f,
					Rj = new f,
					Ph = new f,
					Og = new f,
					Pg = new f,
					Qg = new f;
				q(H, {
					getNormal: function(a, b, c, d) {
						void 0 === d && (console.warn("THREE.Triangle: .getNormal() target is now required"), d = new f);
						d.subVectors(c, b);
						ue.subVectors(a, b);
						d.cross(ue);
						a = d.lengthSq();
						return 0 < a ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0)
					},
					getBarycoord: function(a, b, c, d, e) {
						ue.subVectors(d, b);
						pg.subVectors(c, b);
						Ng.subVectors(a, b);
						a = ue.dot(ue);
						b = ue.dot(pg);
						c = ue.dot(Ng);
						var h = pg.dot(pg);
						d = pg.dot(Ng);
						var g = a * h - b * b;
						void 0 === e && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), e = new f);
						if (0 === g) return e.set(-2, -1, -1);
						g = 1 / g;
						h = (h * c - b * d) * g;
						a = (a * d - b * c) * g;
						return e.set(1 - h - a, a, h)
					},
					containsPoint: function(a, b, c, d) {
						H.getBarycoord(a, b, c, d, qg);
						return 0 <= qg.x && 0 <= qg.y && 1 >=
							qg.x + qg.y
					},
					getUV: function(a, b, c, d, e, f, g, k) {
						this.getBarycoord(a, b, c, d, qg);
						k.set(0, 0);
						k.addScaledVector(e, qg.x);
						k.addScaledVector(f, qg.y);
						k.addScaledVector(g, qg.z);
						return k
					},
					isFrontFacing: function(a, b, c, d) {
						ue.subVectors(c, b);
						pg.subVectors(a, b);
						return 0 > ue.cross(pg).dot(d) ? !0 : !1
					}
				});
				q(H.prototype, {
					set: function(a, b, c) {
						this.a.copy(a);
						this.b.copy(b);
						this.c.copy(c);
						return this
					},
					setFromPointsAndIndices: function(a, b, c, d) {
						this.a.copy(a[b]);
						this.b.copy(a[c]);
						this.c.copy(a[d]);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.a.copy(a.a);
						this.b.copy(a.b);
						this.c.copy(a.c);
						return this
					},
					getArea: function() {
						ue.subVectors(this.c, this.b);
						pg.subVectors(this.a, this.b);
						return .5 * ue.cross(pg).length()
					},
					getMidpoint: function(a) {
						void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new f);
						return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
					},
					getNormal: function(a) {
						return H.getNormal(this.a, this.b, this.c, a)
					},
					getPlane: function(a) {
						void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"),
							a = new f);
						return a.setFromCoplanarPoints(this.a, this.b, this.c)
					},
					getBarycoord: function(a, b) {
						return H.getBarycoord(a, this.a, this.b, this.c, b)
					},
					getUV: function(a, b, c, d, e) {
						return H.getUV(a, this.a, this.b, this.c, b, c, d, e)
					},
					containsPoint: function(a) {
						return H.containsPoint(a, this.a, this.b, this.c)
					},
					isFrontFacing: function(a) {
						return H.isFrontFacing(this.a, this.b, this.c, a)
					},
					intersectsBox: function(a) {
						return a.intersectsTriangle(this)
					},
					closestPointToPoint: function(a, b) {
						void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
							b = new f);
						var c = this.a,
							h = this.b,
							d = this.c;
						Qj.subVectors(h, c);
						Rj.subVectors(d, c);
						Og.subVectors(a, c);
						var e = Qj.dot(Og),
							g = Rj.dot(Og);
						if (0 >= e && 0 >= g) return b.copy(c);
						Pg.subVectors(a, h);
						var t = Qj.dot(Pg),
							k = Rj.dot(Pg);
						if (0 <= t && k <= t) return b.copy(h);
						var l = e * k - t * g;
						if (0 >= l && 0 <= e && 0 >= t) return h = e / (e - t), b.copy(c).addScaledVector(Qj, h);
						Qg.subVectors(a, d);
						a = Qj.dot(Qg);
						var m = Rj.dot(Qg);
						if (0 <= m && a <= m) return b.copy(d);
						e = a * g - e * m;
						if (0 >= e && 0 <= g && 0 >= m) return l = g / (g - m), b.copy(c).addScaledVector(Rj, l);
						g = t * m - a * k;
						if (0 >= g && 0 <=
							k - t && 0 <= a - m) return Ph.subVectors(d, h), l = (k - t) / (k - t + (a - m)), b.copy(h).addScaledVector(
							Ph, l);
						d = 1 / (g + e + l);
						h = e * d;
						l *= d;
						return b.copy(c).addScaledVector(Qj, h).addScaledVector(Rj, l)
					},
					equals: function(a) {
						return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
					}
				});
				var fj = {
						aliceblue: 15792383,
						antiquewhite: 16444375,
						aqua: 65535,
						aquamarine: 8388564,
						azure: 15794175,
						beige: 16119260,
						bisque: 16770244,
						black: 0,
						blanchedalmond: 16772045,
						blue: 255,
						blueviolet: 9055202,
						brown: 10824234,
						burlywood: 14596231,
						cadetblue: 6266528,
						chartreuse: 8388352,
						chocolate: 13789470,
						coral: 16744272,
						cornflowerblue: 6591981,
						cornsilk: 16775388,
						crimson: 14423100,
						cyan: 65535,
						darkblue: 139,
						darkcyan: 35723,
						darkgoldenrod: 12092939,
						darkgray: 11119017,
						darkgreen: 25600,
						darkgrey: 11119017,
						darkkhaki: 12433259,
						darkmagenta: 9109643,
						darkolivegreen: 5597999,
						darkorange: 16747520,
						darkorchid: 10040012,
						darkred: 9109504,
						darksalmon: 15308410,
						darkseagreen: 9419919,
						darkslateblue: 4734347,
						darkslategray: 3100495,
						darkslategrey: 3100495,
						darkturquoise: 52945,
						darkviolet: 9699539,
						deeppink: 16716947,
						deepskyblue: 49151,
						dimgray: 6908265,
						dimgrey: 6908265,
						dodgerblue: 2003199,
						firebrick: 11674146,
						floralwhite: 16775920,
						forestgreen: 2263842,
						fuchsia: 16711935,
						gainsboro: 14474460,
						ghostwhite: 16316671,
						gold: 16766720,
						goldenrod: 14329120,
						gray: 8421504,
						green: 32768,
						greenyellow: 11403055,
						grey: 8421504,
						honeydew: 15794160,
						hotpink: 16738740,
						indianred: 13458524,
						indigo: 4915330,
						ivory: 16777200,
						khaki: 15787660,
						lavender: 15132410,
						lavenderblush: 16773365,
						lawngreen: 8190976,
						lemonchiffon: 16775885,
						lightblue: 11393254,
						lightcoral: 15761536,
						lightcyan: 14745599,
						lightgoldenrodyellow: 16448210,
						lightgray: 13882323,
						lightgreen: 9498256,
						lightgrey: 13882323,
						lightpink: 16758465,
						lightsalmon: 16752762,
						lightseagreen: 2142890,
						lightskyblue: 8900346,
						lightslategray: 7833753,
						lightslategrey: 7833753,
						lightsteelblue: 11584734,
						lightyellow: 16777184,
						lime: 65280,
						limegreen: 3329330,
						linen: 16445670,
						magenta: 16711935,
						maroon: 8388608,
						mediumaquamarine: 6737322,
						mediumblue: 205,
						mediumorchid: 12211667,
						mediumpurple: 9662683,
						mediumseagreen: 3978097,
						mediumslateblue: 8087790,
						mediumspringgreen: 64154,
						mediumturquoise: 4772300,
						mediumvioletred: 13047173,
						midnightblue: 1644912,
						mintcream: 16121850,
						mistyrose: 16770273,
						moccasin: 16770229,
						navajowhite: 16768685,
						navy: 128,
						oldlace: 16643558,
						olive: 8421376,
						olivedrab: 7048739,
						orange: 16753920,
						orangered: 16729344,
						orchid: 14315734,
						palegoldenrod: 15657130,
						palegreen: 10025880,
						paleturquoise: 11529966,
						palevioletred: 14381203,
						papayawhip: 16773077,
						peachpuff: 16767673,
						peru: 13468991,
						pink: 16761035,
						plum: 14524637,
						powderblue: 11591910,
						purple: 8388736,
						rebeccapurple: 6697881,
						red: 16711680,
						rosybrown: 12357519,
						royalblue: 4286945,
						saddlebrown: 9127187,
						salmon: 16416882,
						sandybrown: 16032864,
						seagreen: 3050327,
						seashell: 16774638,
						sienna: 10506797,
						silver: 12632256,
						skyblue: 8900331,
						slateblue: 6970061,
						slategray: 7372944,
						slategrey: 7372944,
						snow: 16775930,
						springgreen: 65407,
						steelblue: 4620980,
						tan: 13808780,
						teal: 32896,
						thistle: 14204888,
						tomato: 16737095,
						turquoise: 4251856,
						violet: 15631086,
						wheat: 16113331,
						white: 16777215,
						whitesmoke: 16119285,
						yellow: 16776960,
						yellowgreen: 10145074
					},
					qc = {
						h: 0,
						s: 0,
						l: 0
					},
					Lf = {
						h: 0,
						s: 0,
						l: 0
					};
				q(Q.prototype, {
					isColor: !0,
					r: 1,
					g: 1,
					b: 1,
					set: function(a) {
						a && a.isColor ?
							this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
						return this
					},
					setScalar: function(a) {
						this.b = this.g = this.r = a;
						return this
					},
					setHex: function(a) {
						a = Math.floor(a);
						this.r = (a >> 16 & 255) / 255;
						this.g = (a >> 8 & 255) / 255;
						this.b = (a & 255) / 255;
						return this
					},
					setRGB: function(a, b, c) {
						this.r = a;
						this.g = b;
						this.b = c;
						return this
					},
					setHSL: function(a, b, c) {
						a = Ea.euclideanModulo(a, 1);
						b = Ea.clamp(b, 0, 1);
						c = Ea.clamp(c, 0, 1);
						0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r =
							J(c, b, a + 1 / 3), this.g =
							J(c, b, a), this.b = J(c, b, a - 1 / 3));
						return this
					},
					setStyle: function(a) {
						function b(b) {
							void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a +
								" will be ignored.")
						}
						var c;
						if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
							var h = c[2];
							switch (c[1]) {
								case "rgb":
								case "rgba":
									if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(h)) return this.r = Math.min(
										255, parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(
										255, parseInt(c[3], 10)) / 255, b(c[5]), this;
									if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(h)) return this.r = Math
										.min(100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(
											100, parseInt(c[3], 10)) / 100, b(c[5]), this;
									break;
								case "hsl":
								case "hsla":
									if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(h)) {
										h = parseFloat(c[1]) / 360;
										var d = parseInt(c[2], 10) / 100,
											e = parseInt(c[3], 10) / 100;
										b(c[5]);
										return this.setHSL(h, d, e)
									}
							}
						} else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
							c =
								c[1];
							h = c.length;
							if (3 === h) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) +
								c.charAt(1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
							if (6 === h) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) +
								c.charAt(3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
						}
						a && 0 < a.length && (c = fj[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " +
							a));
						return this
					},
					clone: function() {
						return new this.constructor(this.r,
							this.g, this.b)
					},
					copy: function(a) {
						this.r = a.r;
						this.g = a.g;
						this.b = a.b;
						return this
					},
					copyGammaToLinear: function(a, b) {
						void 0 === b && (b = 2);
						this.r = Math.pow(a.r, b);
						this.g = Math.pow(a.g, b);
						this.b = Math.pow(a.b, b);
						return this
					},
					copyLinearToGamma: function(a, b) {
						void 0 === b && (b = 2);
						b = 0 < b ? 1 / b : 1;
						this.r = Math.pow(a.r, b);
						this.g = Math.pow(a.g, b);
						this.b = Math.pow(a.b, b);
						return this
					},
					convertGammaToLinear: function(a) {
						this.copyGammaToLinear(this, a);
						return this
					},
					convertLinearToGamma: function(a) {
						this.copyLinearToGamma(this, a);
						return this
					},
					copySRGBToLinear: function(a) {
						this.r = N(a.r);
						this.g = N(a.g);
						this.b = N(a.b);
						return this
					},
					copyLinearToSRGB: function(a) {
						this.r = P(a.r);
						this.g = P(a.g);
						this.b = P(a.b);
						return this
					},
					convertSRGBToLinear: function() {
						this.copySRGBToLinear(this);
						return this
					},
					convertLinearToSRGB: function() {
						this.copyLinearToSRGB(this);
						return this
					},
					getHex: function() {
						return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
					},
					getHexString: function() {
						return ("000000" + this.getHex().toString(16)).slice(-6)
					},
					getHSL: function(a) {
						void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"),
							a = {
								h: 0,
								s: 0,
								l: 0
							});
						var b = this.r,
							c = this.g,
							h = this.b,
							d = Math.max(b, c, h),
							e = Math.min(b, c, h),
							f, g = (e + d) / 2;
						if (e === d) e = f = 0;
						else {
							var k = d - e;
							e = .5 >= g ? k / (d + e) : k / (2 - d - e);
							switch (d) {
								case b:
									f = (c - h) / k + (c < h ? 6 : 0);
									break;
								case c:
									f = (h - b) / k + 2;
									break;
								case h:
									f = (b - c) / k + 4
							}
							f /= 6
						}
						a.h = f;
						a.s = e;
						a.l = g;
						return a
					},
					getStyle: function() {
						return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
					},
					offsetHSL: function(a, b, c) {
						this.getHSL(qc);
						qc.h += a;
						qc.s += b;
						qc.l += c;
						this.setHSL(qc.h, qc.s, qc.l);
						return this
					},
					add: function(a) {
						this.r += a.r;
						this.g +=
							a.g;
						this.b += a.b;
						return this
					},
					addColors: function(a, b) {
						this.r = a.r + b.r;
						this.g = a.g + b.g;
						this.b = a.b + b.b;
						return this
					},
					addScalar: function(a) {
						this.r += a;
						this.g += a;
						this.b += a;
						return this
					},
					sub: function(a) {
						this.r = Math.max(0, this.r - a.r);
						this.g = Math.max(0, this.g - a.g);
						this.b = Math.max(0, this.b - a.b);
						return this
					},
					multiply: function(a) {
						this.r *= a.r;
						this.g *= a.g;
						this.b *= a.b;
						return this
					},
					multiplyScalar: function(a) {
						this.r *= a;
						this.g *= a;
						this.b *= a;
						return this
					},
					lerp: function(a, b) {
						this.r += (a.r - this.r) * b;
						this.g += (a.g - this.g) * b;
						this.b +=
							(a.b - this.b) * b;
						return this
					},
					lerpHSL: function(a, b) {
						this.getHSL(qc);
						a.getHSL(Lf);
						a = Ea.lerp(qc.h, Lf.h, b);
						var c = Ea.lerp(qc.s, Lf.s, b);
						b = Ea.lerp(qc.l, Lf.l, b);
						this.setHSL(a, c, b);
						return this
					},
					equals: function(a) {
						return a.r === this.r && a.g === this.g && a.b === this.b
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						this.r = a[b];
						this.g = a[b + 1];
						this.b = a[b + 2];
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						a[b] = this.r;
						a[b + 1] = this.g;
						a[b + 2] = this.b;
						return a
					},
					toJSON: function() {
						return this.getHex()
					}
				});
				q(M.prototype, {
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.a = a.a;
						this.b = a.b;
						this.c = a.c;
						this.normal.copy(a.normal);
						this.color.copy(a.color);
						this.materialIndex = a.materialIndex;
						for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
						b = 0;
						for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
						return this
					}
				});
				var gj = 0;
				F.prototype = q(p(b.prototype), {
					constructor: F,
					isMaterial: !0,
					onBeforeCompile: function() {},
					setValues: function(a) {
						if (void 0 !==
							a)
							for (var b in a) {
								var c = a[b];
								if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
								else if ("shading" === b) console.warn("THREE." + this.type +
										": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 :
									!1;
								else {
									var h = this[b];
									void 0 === h ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") :
										h && h.isColor ? h.set(c) : h && h.isVector3 && c && c.isVector3 ? h.copy(c) : this[b] = c
								}
							}
					},
					toJSON: function(a) {
						function b(a) {
							var b = [],
								c;
							for (c in a) {
								var h =
									a[c];
								delete h.metadata;
								b.push(h)
							}
							return b
						}
						var c = void 0 === a || "string" === typeof a;
						c && (a = {
							textures: {},
							images: {}
						});
						var h = {
							metadata: {
								version: 4.5,
								type: "Material",
								generator: "Material.toJSON"
							}
						};
						h.uuid = this.uuid;
						h.type = this.type;
						"" !== this.name && (h.name = this.name);
						this.color && this.color.isColor && (h.color = this.color.getHex());
						void 0 !== this.roughness && (h.roughness = this.roughness);
						void 0 !== this.metalness && (h.metalness = this.metalness);
						this.sheen && this.sheen.isColor && (h.sheen = this.sheen.getHex());
						this.emissive &&
							this.emissive.isColor && (h.emissive = this.emissive.getHex());
						this.emissiveIntensity && 1 !== this.emissiveIntensity && (h.emissiveIntensity = this.emissiveIntensity);
						this.specular && this.specular.isColor && (h.specular = this.specular.getHex());
						void 0 !== this.shininess && (h.shininess = this.shininess);
						void 0 !== this.clearcoat && (h.clearcoat = this.clearcoat);
						void 0 !== this.clearcoatRoughness && (h.clearcoatRoughness = this.clearcoatRoughness);
						this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (h.clearcoatNormalMap =
							this.clearcoatNormalMap.toJSON(a).uuid, h.clearcoatNormalScale = this.clearcoatNormalScale.toArray());
						this.map && this.map.isTexture && (h.map = this.map.toJSON(a).uuid);
						this.matcap && this.matcap.isTexture && (h.matcap = this.matcap.toJSON(a).uuid);
						this.alphaMap && this.alphaMap.isTexture && (h.alphaMap = this.alphaMap.toJSON(a).uuid);
						this.lightMap && this.lightMap.isTexture && (h.lightMap = this.lightMap.toJSON(a).uuid);
						this.aoMap && this.aoMap.isTexture && (h.aoMap = this.aoMap.toJSON(a).uuid, h.aoMapIntensity = this.aoMapIntensity);
						this.bumpMap && this.bumpMap.isTexture && (h.bumpMap = this.bumpMap.toJSON(a).uuid, h.bumpScale = this.bumpScale);
						this.normalMap && this.normalMap.isTexture && (h.normalMap = this.normalMap.toJSON(a).uuid, h.normalMapType =
							this.normalMapType, h.normalScale = this.normalScale.toArray());
						this.displacementMap && this.displacementMap.isTexture && (h.displacementMap = this.displacementMap.toJSON(
							a).uuid, h.displacementScale = this.displacementScale, h.displacementBias = this.displacementBias);
						this.roughnessMap && this.roughnessMap.isTexture &&
							(h.roughnessMap = this.roughnessMap.toJSON(a).uuid);
						this.metalnessMap && this.metalnessMap.isTexture && (h.metalnessMap = this.metalnessMap.toJSON(a).uuid);
						this.emissiveMap && this.emissiveMap.isTexture && (h.emissiveMap = this.emissiveMap.toJSON(a).uuid);
						this.specularMap && this.specularMap.isTexture && (h.specularMap = this.specularMap.toJSON(a).uuid);
						this.envMap && this.envMap.isTexture && (h.envMap = this.envMap.toJSON(a).uuid, h.reflectivity = this.reflectivity,
							h.refractionRatio = this.refractionRatio, void 0 !== this.combine &&
							(h.combine = this.combine), void 0 !== this.envMapIntensity && (h.envMapIntensity = this.envMapIntensity)
						);
						this.gradientMap && this.gradientMap.isTexture && (h.gradientMap = this.gradientMap.toJSON(a).uuid);
						void 0 !== this.size && (h.size = this.size);
						void 0 !== this.sizeAttenuation && (h.sizeAttenuation = this.sizeAttenuation);
						1 !== this.blending && (h.blending = this.blending);
						!0 === this.flatShading && (h.flatShading = this.flatShading);
						0 !== this.side && (h.side = this.side);
						0 !== this.vertexColors && (h.vertexColors = this.vertexColors);
						1 > this.opacity &&
							(h.opacity = this.opacity);
						!0 === this.transparent && (h.transparent = this.transparent);
						h.depthFunc = this.depthFunc;
						h.depthTest = this.depthTest;
						h.depthWrite = this.depthWrite;
						h.stencilWrite = this.stencilWrite;
						h.stencilWriteMask = this.stencilWriteMask;
						h.stencilFunc = this.stencilFunc;
						h.stencilRef = this.stencilRef;
						h.stencilFuncMask = this.stencilFuncMask;
						h.stencilFail = this.stencilFail;
						h.stencilZFail = this.stencilZFail;
						h.stencilZPass = this.stencilZPass;
						this.rotation && 0 !== this.rotation && (h.rotation = this.rotation);
						!0 === this.polygonOffset &&
							(h.polygonOffset = !0);
						0 !== this.polygonOffsetFactor && (h.polygonOffsetFactor = this.polygonOffsetFactor);
						0 !== this.polygonOffsetUnits && (h.polygonOffsetUnits = this.polygonOffsetUnits);
						this.linewidth && 1 !== this.linewidth && (h.linewidth = this.linewidth);
						void 0 !== this.dashSize && (h.dashSize = this.dashSize);
						void 0 !== this.gapSize && (h.gapSize = this.gapSize);
						void 0 !== this.scale && (h.scale = this.scale);
						!0 === this.dithering && (h.dithering = !0);
						0 < this.alphaTest && (h.alphaTest = this.alphaTest);
						!0 === this.premultipliedAlpha && (h.premultipliedAlpha =
							this.premultipliedAlpha);
						!0 === this.wireframe && (h.wireframe = this.wireframe);
						1 < this.wireframeLinewidth && (h.wireframeLinewidth = this.wireframeLinewidth);
						"round" !== this.wireframeLinecap && (h.wireframeLinecap = this.wireframeLinecap);
						"round" !== this.wireframeLinejoin && (h.wireframeLinejoin = this.wireframeLinejoin);
						!0 === this.morphTargets && (h.morphTargets = !0);
						!0 === this.morphNormals && (h.morphNormals = !0);
						!0 === this.skinning && (h.skinning = !0);
						!1 === this.visible && (h.visible = !1);
						!1 === this.toneMapped && (h.toneMapped = !1);
						"{}" !== Rd(this.userData) && (h.userData = this.userData);
						c && (c = b(a.textures), a = b(a.images), 0 < c.length && (h.textures = c), 0 < a.length && (h.images = a));
						return h
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.name = a.name;
						this.fog = a.fog;
						this.blending = a.blending;
						this.side = a.side;
						this.flatShading = a.flatShading;
						this.vertexColors = a.vertexColors;
						this.opacity = a.opacity;
						this.transparent = a.transparent;
						this.blendSrc = a.blendSrc;
						this.blendDst = a.blendDst;
						this.blendEquation = a.blendEquation;
						this.blendSrcAlpha = a.blendSrcAlpha;
						this.blendDstAlpha = a.blendDstAlpha;
						this.blendEquationAlpha = a.blendEquationAlpha;
						this.depthFunc = a.depthFunc;
						this.depthTest = a.depthTest;
						this.depthWrite = a.depthWrite;
						this.stencilWrite = a.stencilWrite;
						this.stencilWriteMask = a.stencilWriteMask;
						this.stencilFunc = a.stencilFunc;
						this.stencilRef = a.stencilRef;
						this.stencilFuncMask = a.stencilFuncMask;
						this.stencilFail = a.stencilFail;
						this.stencilZFail = a.stencilZFail;
						this.stencilZPass = a.stencilZPass;
						this.colorWrite = a.colorWrite;
						this.precision =
							a.precision;
						this.polygonOffset = a.polygonOffset;
						this.polygonOffsetFactor = a.polygonOffsetFactor;
						this.polygonOffsetUnits = a.polygonOffsetUnits;
						this.dithering = a.dithering;
						this.alphaTest = a.alphaTest;
						this.premultipliedAlpha = a.premultipliedAlpha;
						this.visible = a.visible;
						this.toneMapped = a.toneMapped;
						this.userData = JSON.parse(Rd(a.userData));
						this.clipShadows = a.clipShadows;
						this.clipIntersection = a.clipIntersection;
						var b = a.clippingPlanes,
							c = null;
						if (null !== b) {
							var h = b.length;
							c = Array(h);
							for (var d = 0; d !== h; ++d) c[d] = b[d].clone()
						}
						this.clippingPlanes =
							c;
						this.shadowSide = a.shadowSide;
						return this
					},
					dispose: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				});
				S.prototype = p(F.prototype);
				S.prototype.constructor = S;
				S.prototype.isMeshBasicMaterial = !0;
				S.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					this.map = a.map;
					this.lightMap = a.lightMap;
					this.lightMapIntensity = a.lightMapIntensity;
					this.aoMap = a.aoMap;
					this.aoMapIntensity = a.aoMapIntensity;
					this.specularMap = a.specularMap;
					this.alphaMap = a.alphaMap;
					this.envMap = a.envMap;
					this.combine =
						a.combine;
					this.reflectivity = a.reflectivity;
					this.refractionRatio = a.refractionRatio;
					this.wireframe = a.wireframe;
					this.wireframeLinewidth = a.wireframeLinewidth;
					this.wireframeLinecap = a.wireframeLinecap;
					this.wireframeLinejoin = a.wireframeLinejoin;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					return this
				};
				Object.defineProperty(R.prototype, "needsUpdate", {
					set: function(a) {
						!0 === a && this.version++
					}
				});
				q(R.prototype, {
					isBufferAttribute: !0,
					onUploadCallback: function() {},
					setDynamic: function(a) {
						this.dynamic =
							a;
						return this
					},
					copy: function(a) {
						this.name = a.name;
						this.array = new a.array.constructor(a.array);
						this.itemSize = a.itemSize;
						this.count = a.count;
						this.normalized = a.normalized;
						this.dynamic = a.dynamic;
						return this
					},
					copyAt: function(a, b, c) {
						a *= this.itemSize;
						c *= b.itemSize;
						for (var h = 0, d = this.itemSize; h < d; h++) this.array[a + h] = b.array[c + h];
						return this
					},
					copyArray: function(a) {
						this.array.set(a);
						return this
					},
					copyColorsArray: function(a) {
						for (var b = this.array, c = 0, h = 0, d = a.length; h < d; h++) {
							var e = a[h];
							void 0 === e && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",
								h), e = new Q);
							b[c++] = e.r;
							b[c++] = e.g;
							b[c++] = e.b
						}
						return this
					},
					copyVector2sArray: function(a) {
						for (var b = this.array, c = 0, h = 0, e = a.length; h < e; h++) {
							var f = a[h];
							void 0 === f && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", h), f =
								new d);
							b[c++] = f.x;
							b[c++] = f.y
						}
						return this
					},
					copyVector3sArray: function(a) {
						for (var b = this.array, c = 0, h = 0, d = a.length; h < d; h++) {
							var e = a[h];
							void 0 === e && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", h), e =
								new f);
							b[c++] = e.x;
							b[c++] = e.y;
							b[c++] = e.z
						}
						return this
					},
					copyVector4sArray: function(a) {
						for (var b = this.array, c = 0, h = 0, d = a.length; h < d; h++) {
							var e = a[h];
							void 0 === e && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", h), e =
								new m);
							b[c++] = e.x;
							b[c++] = e.y;
							b[c++] = e.z;
							b[c++] = e.w
						}
						return this
					},
					set: function(a, b) {
						void 0 === b && (b = 0);
						this.array.set(a, b);
						return this
					},
					getX: function(a) {
						return this.array[a * this.itemSize]
					},
					setX: function(a, b) {
						this.array[a * this.itemSize] = b;
						return this
					},
					getY: function(a) {
						return this.array[a * this.itemSize +
							1]
					},
					setY: function(a, b) {
						this.array[a * this.itemSize + 1] = b;
						return this
					},
					getZ: function(a) {
						return this.array[a * this.itemSize + 2]
					},
					setZ: function(a, b) {
						this.array[a * this.itemSize + 2] = b;
						return this
					},
					getW: function(a) {
						return this.array[a * this.itemSize + 3]
					},
					setW: function(a, b) {
						this.array[a * this.itemSize + 3] = b;
						return this
					},
					setXY: function(a, b, c) {
						a *= this.itemSize;
						this.array[a + 0] = b;
						this.array[a + 1] = c;
						return this
					},
					setXYZ: function(a, b, c, d) {
						a *= this.itemSize;
						this.array[a + 0] = b;
						this.array[a + 1] = c;
						this.array[a + 2] = d;
						return this
					},
					setXYZW: function(a, b, c, d, e) {
						a *= this.itemSize;
						this.array[a + 0] = b;
						this.array[a + 1] = c;
						this.array[a + 2] = d;
						this.array[a + 3] = e;
						return this
					},
					onUpload: function(a) {
						this.onUploadCallback = a;
						return this
					},
					clone: function() {
						return (new this.constructor(this.array, this.itemSize)).copy(this)
					},
					toJSON: function() {
						return {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: Array.prototype.slice.call(this.array),
							normalized: this.normalized
						}
					}
				});
				V.prototype = p(R.prototype);
				V.prototype.constructor = V;
				X.prototype = p(R.prototype);
				X.prototype.constructor = X;
				W.prototype = p(R.prototype);
				W.prototype.constructor = W;
				ba.prototype = p(R.prototype);
				ba.prototype.constructor = ba;
				fa.prototype = p(R.prototype);
				fa.prototype.constructor = fa;
				ia.prototype = p(R.prototype);
				ia.prototype.constructor = ia;
				da.prototype = p(R.prototype);
				da.prototype.constructor = da;
				L.prototype = p(R.prototype);
				L.prototype.constructor = L;
				ma.prototype = p(R.prototype);
				ma.prototype.constructor = ma;
				q(ua.prototype, {
					computeGroups: function(a) {
						var b = [],
							c = void 0;
						a = a.faces;
						for (var h = 0; h < a.length; h++) {
							var d =
								a[h];
							if (d.materialIndex !== c) {
								c = d.materialIndex;
								void 0 !== e && (e.count = 3 * h - e.start, b.push(e));
								var e = {
									start: 3 * h,
									materialIndex: c
								}
							}
						}
						void 0 !== e && (e.count = 3 * h - e.start, b.push(e));
						this.groups = b
					},
					fromGeometry: function(a) {
						var b = a.faces,
							c = a.vertices,
							h = a.faceVertexUvs,
							e = h[0] && 0 < h[0].length,
							f = h[1] && 0 < h[1].length,
							g = a.morphTargets,
							k = g.length;
						if (0 < k) {
							var l = [];
							for (var m = 0; m < k; m++) l[m] = {
								name: g[m].name,
								data: []
							};
							this.morphTargets.position = l
						}
						var n = a.morphNormals,
							r = n.length;
						if (0 < r) {
							var p = [];
							for (m = 0; m < r; m++) p[m] = {
								name: n[m].name,
								data: []
							};
							this.morphTargets.normal = p
						}
						var v = a.skinIndices,
							q = a.skinWeights,
							u = v.length === c.length,
							w = q.length === c.length;
						0 < c.length && 0 === b.length && console.error(
							"THREE.DirectGeometry: Faceless geometries are not supported.");
						for (m = 0; m < b.length; m++) {
							var A = b[m];
							this.vertices.push(c[A.a], c[A.b], c[A.c]);
							var z = A.vertexNormals;
							3 === z.length ? this.normals.push(z[0], z[1], z[2]) : (z = A.normal, this.normals.push(z, z, z));
							z = A.vertexColors;
							3 === z.length ? this.colors.push(z[0], z[1], z[2]) : (z = A.color, this.colors.push(z, z, z));
							!0 === e && (z = h[0][m], void 0 !== z ? this.uvs.push(z[0], z[1], z[2]) : (console.warn(
								"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", m), this.uvs.push(new d, new d, new d)));
							!0 === f && (z = h[1][m], void 0 !== z ? this.uvs2.push(z[0], z[1], z[2]) : (console.warn(
								"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", m), this.uvs2.push(new d, new d, new d)));
							for (z = 0; z < k; z++) {
								var D = g[z].vertices;
								l[z].data.push(D[A.a], D[A.b], D[A.c])
							}
							for (z = 0; z < r; z++) D = n[z].vertexNormals[m], p[z].data.push(D.a, D.b, D.c);
							u && this.skinIndices.push(v[A.a],
								v[A.b], v[A.c]);
							w && this.skinWeights.push(q[A.a], q[A.b], q[A.c])
						}
						this.computeGroups(a);
						this.verticesNeedUpdate = a.verticesNeedUpdate;
						this.normalsNeedUpdate = a.normalsNeedUpdate;
						this.colorsNeedUpdate = a.colorsNeedUpdate;
						this.uvsNeedUpdate = a.uvsNeedUpdate;
						this.groupsNeedUpdate = a.groupsNeedUpdate;
						null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
						null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
						return this
					}
				});
				var jj = 1,
					rf = new v,
					Rg = new u,
					Uf = new f,
					pi = new D,
					Tg = new D,
					ve = new f;
				I.prototype = q(p(b.prototype), {
					constructor: I,
					isBufferGeometry: !0,
					getIndex: function() {
						return this.index
					},
					setIndex: function(a) {
						Array.isArray(a) ? this.index = new(65535 < ta(a) ? da : fa)(a, 1) : this.index = a
					},
					addAttribute: function(a, b, c) {
						return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn(
								"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this) :
							this.setAttribute(a, b) : (console.warn(
									"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
								this.addAttribute(a, new R(b, c)))
					},
					getAttribute: function(a) {
						return this.attributes[a]
					},
					setAttribute: function(a, b) {
						this.attributes[a] = b;
						return this
					},
					removeAttribute: function(a) {
						delete this.attributes[a];
						return this
					},
					addGroup: function(a, b, c) {
						this.groups.push({
							start: a,
							count: b,
							materialIndex: void 0 !== c ? c : 0
						})
					},
					clearGroups: function() {
						this.groups = []
					},
					setDrawRange: function(a, b) {
						this.drawRange.start = a;
						this.drawRange.count = b
					},
					applyMatrix: function(a) {
						var b = this.attributes.position;
						void 0 !== b && (a.applyToBufferAttribute(b),
							b.needsUpdate = !0);
						var c = this.attributes.normal;
						void 0 !== c && (b = (new k).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0);
						c = this.attributes.tangent;
						void 0 !== c && (b = (new k).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0);
						null !== this.boundingBox && this.computeBoundingBox();
						null !== this.boundingSphere && this.computeBoundingSphere();
						return this
					},
					rotateX: function(a) {
						rf.makeRotationX(a);
						this.applyMatrix(rf);
						return this
					},
					rotateY: function(a) {
						rf.makeRotationY(a);
						this.applyMatrix(rf);
						return this
					},
					rotateZ: function(a) {
						rf.makeRotationZ(a);
						this.applyMatrix(rf);
						return this
					},
					translate: function(a, b, c) {
						rf.makeTranslation(a, b, c);
						this.applyMatrix(rf);
						return this
					},
					scale: function(a, b, c) {
						rf.makeScale(a, b, c);
						this.applyMatrix(rf);
						return this
					},
					lookAt: function(a) {
						Rg.lookAt(a);
						Rg.updateMatrix();
						this.applyMatrix(Rg.matrix);
						return this
					},
					center: function() {
						this.computeBoundingBox();
						this.boundingBox.getCenter(Uf).negate();
						this.translate(Uf.x, Uf.y, Uf.z);
						return this
					},
					setFromObject: function(a) {
						var b = a.geometry;
						if (a.isPoints || a.isLine) {
							a = new L(3 * b.vertices.length, 3);
							var c = new L(3 * b.colors.length, 3);
							this.addAttribute("position", a.copyVector3sArray(b.vertices));
							this.addAttribute("color", c.copyColorsArray(b.colors));
							b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new L(b.lineDistances.length, 1),
								this.addAttribute("lineDistance", a.copyArray(b.lineDistances)));
							null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
							null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
						} else a.isMesh &&
							b && b.isGeometry && this.fromGeometry(b);
						return this
					},
					setFromPoints: function(a) {
						for (var b = [], c = 0, h = a.length; c < h; c++) {
							var d = a[c];
							b.push(d.x, d.y, d.z || 0)
						}
						this.addAttribute("position", new L(b, 3));
						return this
					},
					updateFromObject: function(a) {
						var b = a.geometry;
						if (a.isMesh) {
							var c = b.__directGeometry;
							!0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
							if (void 0 === c) return this.fromGeometry(b);
							c.verticesNeedUpdate = b.verticesNeedUpdate;
							c.normalsNeedUpdate = b.normalsNeedUpdate;
							c.colorsNeedUpdate = b.colorsNeedUpdate;
							c.uvsNeedUpdate = b.uvsNeedUpdate;
							c.groupsNeedUpdate = b.groupsNeedUpdate;
							b.verticesNeedUpdate = !1;
							b.normalsNeedUpdate = !1;
							b.colorsNeedUpdate = !1;
							b.uvsNeedUpdate = !1;
							b.groupsNeedUpdate = !1;
							b = c
						}!0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices),
							c.needsUpdate = !0), b.verticesNeedUpdate = !1);
						!0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals),
							c.needsUpdate = !0), b.normalsNeedUpdate = !1);
						!0 === b.colorsNeedUpdate && (c = this.attributes.color,
							void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1);
						b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0),
							b.uvsNeedUpdate = !1);
						b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances),
							c.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
						b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
						return this
					},
					fromGeometry: function(a) {
						a.__directGeometry = (new ua).fromGeometry(a);
						return this.fromDirectGeometry(a.__directGeometry)
					},
					fromDirectGeometry: function(a) {
						var b = new Float32Array(3 * a.vertices.length);
						this.addAttribute("position", (new R(b, 3)).copyVector3sArray(a.vertices));
						0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new R(b,
							3)).copyVector3sArray(a.normals)));
						0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new R(b, 3))
							.copyColorsArray(a.colors)));
						0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length),
							this.addAttribute("uv", (new R(b, 2)).copyVector2sArray(a.uvs)));
						0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new R(b, 2)).copyVector2sArray(
							a.uvs2)));
						this.groups = a.groups;
						for (var c in a.morphTargets) {
							b = [];
							for (var h = a.morphTargets[c], d = 0, e = h.length; d < e; d++) {
								var f = h[d],
									g = new L(3 * f.data.length, 3);
								g.name = f.name;
								b.push(g.copyVector3sArray(f.data))
							}
							this.morphAttributes[c] = b
						}
						0 < a.skinIndices.length && (c = new L(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(
							a.skinIndices)));
						0 < a.skinWeights.length && (c = new L(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(
							a.skinWeights)));
						null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
						null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
						return this
					},
					computeBoundingBox: function() {
						null === this.boundingBox && (this.boundingBox = new D);
						var a = this.attributes.position,
							b = this.morphAttributes.position;
						if (void 0 !== a) {
							if (this.boundingBox.setFromBufferAttribute(a), b) {
								a = 0;
								for (var c = b.length; a <
									c; a++) pi.setFromBufferAttribute(b[a]), this.boundingBox.expandByPoint(pi.min), this.boundingBox.expandByPoint(
									pi.max)
							}
						} else this.boundingBox.makeEmpty();
						(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) &&
						console.error(
							'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
							this)
					},
					computeBoundingSphere: function() {
						null === this.boundingSphere && (this.boundingSphere = new G);
						var a = this.attributes.position,
							b = this.morphAttributes.position;
						if (a) {
							var c = this.boundingSphere.center;
							pi.setFromBufferAttribute(a);
							if (b)
								for (var d = 0, e = b.length; d < e; d++) {
									var f = b[d];
									Tg.setFromBufferAttribute(f);
									pi.expandByPoint(Tg.min);
									pi.expandByPoint(Tg.max)
								}
							pi.getCenter(c);
							var g = 0;
							d = 0;
							for (e = a.count; d < e; d++) ve.fromBufferAttribute(a, d), g = Math.max(g, c.distanceToSquared(ve));
							if (b)
								for (d = 0, e = b.length; d < e; d++) {
									f = b[d];
									a = 0;
									for (var k = f.count; a < k; a++) ve.fromBufferAttribute(f, a), g = Math.max(g, c.distanceToSquared(ve))
								}
							this.boundingSphere.radius =
								Math.sqrt(g);
							isNaN(this.boundingSphere.radius) && console.error(
								'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
								this)
						}
					},
					computeFaceNormals: function() {},
					computeVertexNormals: function() {
						var a = this.index,
							b = this.attributes;
						if (b.position) {
							var c = b.position.array;
							if (void 0 === b.normal) this.addAttribute("normal", new R(new Float32Array(c.length), 3));
							else
								for (var d = b.normal.array, e = 0, g = d.length; e < g; e++) d[e] = 0;
							d = b.normal.array;
							var k =
								new f,
								l = new f,
								m = new f,
								n = new f,
								r = new f;
							if (a) {
								var p = a.array;
								e = 0;
								for (g = a.count; e < g; e += 3) {
									a = 3 * p[e + 0];
									var v = 3 * p[e + 1];
									var q = 3 * p[e + 2];
									k.fromArray(c, a);
									l.fromArray(c, v);
									m.fromArray(c, q);
									n.subVectors(m, l);
									r.subVectors(k, l);
									n.cross(r);
									d[a] += n.x;
									d[a + 1] += n.y;
									d[a + 2] += n.z;
									d[v] += n.x;
									d[v + 1] += n.y;
									d[v + 2] += n.z;
									d[q] += n.x;
									d[q + 1] += n.y;
									d[q + 2] += n.z
								}
							} else
								for (e = 0, g = c.length; e < g; e += 9) k.fromArray(c, e), l.fromArray(c, e + 3), m.fromArray(c, e + 6),
									n.subVectors(m, l), r.subVectors(k, l), n.cross(r), d[e] = n.x, d[e + 1] = n.y, d[e + 2] = n.z, d[e + 3] =
									n.x, d[e + 4] = n.y, d[e + 5] = n.z, d[e + 6] = n.x, d[e + 7] = n.y, d[e + 8] = n.z;
							this.normalizeNormals();
							b.normal.needsUpdate = !0
						}
					},
					merge: function(a, b) {
						if (a && a.isBufferGeometry) {
							void 0 === b && (b = 0, console.warn(
								"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
							));
							var c = this.attributes,
								h;
							for (h in c)
								if (void 0 !== a.attributes[h]) {
									var d = c[h].array,
										e = a.attributes[h],
										f = e.array,
										g = e.itemSize * b;
									e = Math.min(f.length, d.length - g);
									for (var k =
											0; k < e; k++, g++) d[g] = f[k]
								} return this
						}
						console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
					},
					normalizeNormals: function() {
						for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++) ve.x = a.getX(b), ve.y = a.getY(b), ve
							.z = a.getZ(b), ve.normalize(), a.setXYZ(b, ve.x, ve.y, ve.z)
					},
					toNonIndexed: function() {
						function a(a, b) {
							var c = a.array;
							a = a.itemSize;
							for (var h = new c.constructor(b.length * a), d, e = 0, f = 0, g = b.length; f < g; f++) {
								d = b[f] * a;
								for (var k = 0; k < a; k++) h[e++] = c[d++]
							}
							return new R(h,
								a)
						}
						if (null === this.index) return console.warn(
							"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
						var b = new I,
							c = this.index.array,
							d = this.attributes,
							e;
						for (e in d) {
							var f = d[e];
							f = a(f, c);
							b.addAttribute(e, f)
						}
						var g = this.morphAttributes;
						for (e in g) {
							var k = [],
								l = g[e];
							d = 0;
							for (var m = l.length; d < m; d++) f = l[d], f = a(f, c), k.push(f);
							b.morphAttributes[e] = k
						}
						c = this.groups;
						d = 0;
						for (e = c.length; d < e; d++) f = c[d], b.addGroup(f.start, f.count, f.materialIndex);
						return b
					},
					toJSON: function() {
						var a = {
							metadata: {
								version: 4.5,
								type: "BufferGeometry",
								generator: "BufferGeometry.toJSON"
							}
						};
						a.uuid = this.uuid;
						a.type = this.type;
						"" !== this.name && (a.name = this.name);
						0 < Ha(this.userData).length && (a.userData = this.userData);
						if (void 0 !== this.parameters) {
							var b = this.parameters;
							for (m in b) void 0 !== b[m] && (a[m] = b[m]);
							return a
						}
						a.data = {
							attributes: {}
						};
						b = this.index;
						null !== b && (a.data.index = {
							type: b.array.constructor.name,
							array: Array.prototype.slice.call(b.array)
						});
						var c = this.attributes;
						for (m in c) {
							b = c[m];
							var d = b.toJSON();
							"" !== b.name && (d.name = b.name);
							a.data.attributes[m] = d
						}
						c = {};
						var e = !1;
						for (m in this.morphAttributes) {
							for (var f = this.morphAttributes[m], g = [], k = 0, l = f.length; k < l; k++) b = f[k], d = b.toJSON(),
								"" !== b.name && (d.name = b.name), g.push(d);
							0 < g.length && (c[m] = g, e = !0)
						}
						e && (a.data.morphAttributes = c);
						var m = this.groups;
						0 < m.length && (a.data.groups = JSON.parse(Rd(m)));
						m = this.boundingSphere;
						null !== m && (a.data.boundingSphere = {
							center: m.center.toArray(),
							radius: m.radius
						});
						return a
					},
					clone: function() {
						return (new I).copy(this)
					},
					copy: function(a) {
						var b;
						this.index = null;
						this.attributes = {};
						this.morphAttributes = {};
						this.groups = [];
						this.boundingSphere = this.boundingBox = null;
						this.name = a.name;
						var c = a.index;
						null !== c && this.setIndex(c.clone());
						c = a.attributes;
						for (f in c) this.addAttribute(f, c[f].clone());
						var h = a.morphAttributes;
						for (f in h) {
							var d = [],
								e = h[f];
							c = 0;
							for (b = e.length; c < b; c++) d.push(e[c].clone());
							this.morphAttributes[f] = d
						}
						var f = a.groups;
						c = 0;
						for (b = f.length; c < b; c++) h = f[c], this.addGroup(h.start, h.count, h.materialIndex);
						f = a.boundingBox;
						null !== f && (this.boundingBox = f.clone());
						f = a.boundingSphere;
						null !== f && (this.boundingSphere = f.clone());
						this.drawRange.start = a.drawRange.start;
						this.drawRange.count = a.drawRange.count;
						this.userData = a.userData;
						return this
					},
					dispose: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				});
				var Sh = new v,
					qi = new B,
					Vg = new G,
					Zh = new f,
					$h = new f,
					ai = new f,
					Th = new f,
					Uh = new f,
					Vh = new f,
					Wg = new f,
					Zg = new f,
					$g = new f,
					vj = new d,
					wj = new d,
					xj = new d,
					pk = new f,
					bg = new f;
				ha.prototype = q(p(u.prototype), {
					constructor: ha,
					isMesh: !0,
					setDrawMode: function(a) {
						this.drawMode = a
					},
					copy: function(a) {
						u.prototype.copy.call(this,
							a);
						this.drawMode = a.drawMode;
						void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
						void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = q({}, a.morphTargetDictionary));
						return this
					},
					updateMorphTargets: function() {
						var a = this.geometry;
						if (a.isBufferGeometry) {
							a = a.morphAttributes;
							var b = Ha(a);
							if (0 < b.length) {
								var c = a[b[0]];
								if (void 0 !== c)
									for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
										var d = c[a].name || String(a);
										this.morphTargetInfluences.push(0);
										this.morphTargetDictionary[d] = a
									}
							}
						} else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error(
							"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
					},
					raycast: function(a, b) {
						var c = this.geometry,
							h = this.material,
							e = this.matrixWorld;
						if (void 0 !== h && (null === c.boundingSphere && c.computeBoundingSphere(), Vg.copy(c.boundingSphere), Vg.applyMatrix4(
								e), !1 !== a.ray.intersectsSphere(Vg) && (Sh.getInverse(e), qi.copy(a.ray).applyMatrix4(Sh), null === c.boundingBox ||
								!1 !== qi.intersectsBox(c.boundingBox))))
							if (c.isBufferGeometry) {
								var f =
									c.index;
								e = c.attributes.position;
								var g = c.morphAttributes.position,
									k = c.attributes.uv,
									t = c.attributes.uv2,
									l = c.groups,
									m = c.drawRange,
									n, r;
								if (null !== f)
									if (Array.isArray(h)) {
										var p = 0;
										for (n = l.length; p < n; p++) {
											var v = l[p];
											var q = h[v.materialIndex];
											var u = Math.max(v.start, m.start);
											for (r = c = Math.min(v.start + v.count, m.start + m.count); u < r; u += 3) {
												c = f.getX(u);
												var w = f.getX(u + 1);
												var A = f.getX(u + 2);
												if (c = xa(this, q, a, qi, e, g, k, t, c, w, A)) c.faceIndex = Math.floor(u / 3), c.face.materialIndex =
													v.materialIndex, b.push(c)
											}
										}
									} else
										for (u = Math.max(0,
												m.start), c = Math.min(f.count, m.start + m.count), p = u, n = c; p < n; p += 3) {
											if (c = f.getX(p), w = f.getX(p + 1), A = f.getX(p + 2), c = xa(this, h, a, qi, e, g, k, t, c, w, A)) c
												.faceIndex = Math.floor(p / 3), b.push(c)
										} else if (void 0 !== e)
											if (Array.isArray(h))
												for (p = 0, n = l.length; p < n; p++)
													for (v = l[p], q = h[v.materialIndex], u = Math.max(v.start, m.start), r = c = Math.min(v.start + v.count,
															m.start + m.count); u < r; u += 3) {
														if (c = u, w = u + 1, A = u + 2, c = xa(this, q, a, qi, e, g, k, t, c, w, A)) c.faceIndex = Math.floor(
															u / 3), c.face.materialIndex = v.materialIndex, b.push(c)
													} else
														for (u = Math.max(0,
																m.start), c = Math.min(e.count, m.start + m.count), p = u, n = c; p < n; p += 3)
															if (c = p, w = p + 1, A = p + 2, c = xa(this, h, a, qi, e, g, k, t, c, w, A)) c.faceIndex = Math.floor(
																p / 3), b.push(c)
							} else if (c.isGeometry)
							for (e = Array.isArray(h), g = c.vertices, k = c.faces, c = c.faceVertexUvs[0], 0 < c.length && (f = c), p =
								0, n = k.length; p < n; p++)
								if (v = k[p], c = e ? h[v.materialIndex] : h, void 0 !== c && (t = g[v.a], l = g[v.b], m = g[v.c], c = Z(
										this, c, a, qi, t, l, m, pk))) f && f[p] && (q = f[p], vj.copy(q[0]), wj.copy(q[1]), xj.copy(q[2]), c.uv =
										H.getUV(pk, t, l, m, vj, wj, xj, new d)), c.face = v, c.faceIndex =
									p, b.push(c)
					},
					clone: function() {
						return (new this.constructor(this.geometry, this.material)).copy(this)
					}
				});
				var pj = 0,
					sf = new v,
					ah = new u,
					dg = new f;
				T.prototype = q(p(b.prototype), {
					constructor: T,
					isGeometry: !0,
					applyMatrix: function(a) {
						for (var b = (new k).getNormalMatrix(a), c = 0, h = this.vertices.length; c < h; c++) this.vertices[c].applyMatrix4(
							a);
						c = 0;
						for (h = this.faces.length; c < h; c++) {
							a = this.faces[c];
							a.normal.applyMatrix3(b).normalize();
							for (var d = 0, e = a.vertexNormals.length; d < e; d++) a.vertexNormals[d].applyMatrix3(b).normalize()
						}
						null !==
							this.boundingBox && this.computeBoundingBox();
						null !== this.boundingSphere && this.computeBoundingSphere();
						this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
						return this
					},
					rotateX: function(a) {
						sf.makeRotationX(a);
						this.applyMatrix(sf);
						return this
					},
					rotateY: function(a) {
						sf.makeRotationY(a);
						this.applyMatrix(sf);
						return this
					},
					rotateZ: function(a) {
						sf.makeRotationZ(a);
						this.applyMatrix(sf);
						return this
					},
					translate: function(a, b, c) {
						sf.makeTranslation(a, b, c);
						this.applyMatrix(sf);
						return this
					},
					scale: function(a, b, c) {
						sf.makeScale(a,
							b, c);
						this.applyMatrix(sf);
						return this
					},
					lookAt: function(a) {
						ah.lookAt(a);
						ah.updateMatrix();
						this.applyMatrix(ah.matrix);
						return this
					},
					fromBufferGeometry: function(a) {
						function b(a, b, h, e) {
							var g = void 0 === l ? [] : [c.colors[a].clone(), c.colors[b].clone(), c.colors[h].clone()],
								t = void 0 === k ? [] : [(new f).fromArray(k, 3 * a), (new f).fromArray(k, 3 * b), (new f).fromArray(k, 3 *
									h)];
							e = new M(a, b, h, t, g, e);
							c.faces.push(e);
							void 0 !== m && c.faceVertexUvs[0].push([(new d).fromArray(m, 2 * a), (new d).fromArray(m, 2 * b), (new d)
								.fromArray(m, 2 *
									h)
							]);
							void 0 !== n && c.faceVertexUvs[1].push([(new d).fromArray(n, 2 * a), (new d).fromArray(n, 2 * b), (new d)
								.fromArray(n, 2 * h)
							])
						}
						var c = this,
							h = null !== a.index ? a.index.array : void 0,
							e = a.attributes;
						if (void 0 === e.position) return console.error(
							"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
						var g = e.position.array,
							k = void 0 !== e.normal ? e.normal.array : void 0,
							l = void 0 !== e.color ? e.color.array : void 0,
							m = void 0 !== e.uv ? e.uv.array : void 0,
							n = void 0 !== e.uv2 ? e.uv2.array : void 0;
						void 0 !== n &&
							(this.faceVertexUvs[1] = []);
						for (e = 0; e < g.length; e += 3) c.vertices.push((new f).fromArray(g, e)), void 0 !== l && c.colors.push((
							new Q).fromArray(l, e));
						var r = a.groups;
						if (0 < r.length)
							for (e = 0; e < r.length; e++) {
								g = r[e];
								var p = g.start,
									v = p;
								for (p += g.count; v < p; v += 3) void 0 !== h ? b(h[v], h[v + 1], h[v + 2], g.materialIndex) : b(v, v +
									1, v + 2, g.materialIndex)
							} else if (void 0 !== h)
								for (e = 0; e < h.length; e += 3) b(h[e], h[e + 1], h[e + 2]);
							else
								for (e = 0; e < g.length / 3; e += 3) b(e, e + 1, e + 2);
						this.computeFaceNormals();
						null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
						null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
						return this
					},
					center: function() {
						this.computeBoundingBox();
						this.boundingBox.getCenter(dg).negate();
						this.translate(dg.x, dg.y, dg.z);
						return this
					},
					normalize: function() {
						this.computeBoundingSphere();
						var a = this.boundingSphere.center,
							b = this.boundingSphere.radius;
						b = 0 === b ? 1 : 1 / b;
						var c = new v;
						c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
						this.applyMatrix(c);
						return this
					},
					computeFaceNormals: function() {
						for (var a = new f, b = new f, c = 0, d = this.faces.length; c <
							d; c++) {
							var e = this.faces[c],
								g = this.vertices[e.a],
								k = this.vertices[e.b];
							a.subVectors(this.vertices[e.c], k);
							b.subVectors(g, k);
							a.cross(b);
							a.normalize();
							e.normal.copy(a)
						}
					},
					computeVertexNormals: function(a) {
						void 0 === a && (a = !0);
						var b;
						var c = Array(this.vertices.length);
						var h = 0;
						for (b = this.vertices.length; h < b; h++) c[h] = new f;
						if (a) {
							var d = new f,
								e = new f;
							a = 0;
							for (h = this.faces.length; a < h; a++) {
								b = this.faces[a];
								var g = this.vertices[b.a];
								var k = this.vertices[b.b];
								var l = this.vertices[b.c];
								d.subVectors(l, k);
								e.subVectors(g, k);
								d.cross(e);
								c[b.a].add(d);
								c[b.b].add(d);
								c[b.c].add(d)
							}
						} else
							for (this.computeFaceNormals(), a = 0, h = this.faces.length; a < h; a++) b = this.faces[a], c[b.a].add(b.normal),
								c[b.b].add(b.normal), c[b.c].add(b.normal);
						h = 0;
						for (b = this.vertices.length; h < b; h++) c[h].normalize();
						a = 0;
						for (h = this.faces.length; a < h; a++) b = this.faces[a], g = b.vertexNormals, 3 === g.length ? (g[0].copy(
							c[b.a]), g[1].copy(c[b.b]), g[2].copy(c[b.c])) : (g[0] = c[b.a].clone(), g[1] = c[b.b].clone(), g[2] = c[
							b.c].clone());
						0 < this.faces.length && (this.normalsNeedUpdate = !0)
					},
					computeFlatVertexNormals: function() {
						var a;
						this.computeFaceNormals();
						var b = 0;
						for (a = this.faces.length; b < a; b++) {
							var c = this.faces[b];
							var d = c.vertexNormals;
							3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(),
								d[1] = c.normal.clone(), d[2] = c.normal.clone())
						}
						0 < this.faces.length && (this.normalsNeedUpdate = !0)
					},
					computeMorphNormals: function() {
						var a, b;
						var c = 0;
						for (b = this.faces.length; c < b; c++) {
							var d = this.faces[c];
							d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) :
								d.__originalFaceNormal = d.normal.clone();
							d.__originalVertexNormals || (d.__originalVertexNormals = []);
							var e = 0;
							for (a = d.vertexNormals.length; e < a; e++) d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(
								d.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone()
						}
						var g = new T;
						g.faces = this.faces;
						e = 0;
						for (a = this.morphTargets.length; e < a; e++) {
							if (!this.morphNormals[e]) {
								this.morphNormals[e] = {};
								this.morphNormals[e].faceNormals = [];
								this.morphNormals[e].vertexNormals = [];
								d = this.morphNormals[e].faceNormals;
								var k = this.morphNormals[e].vertexNormals;
								c = 0;
								for (b = this.faces.length; c < b; c++) {
									var l = new f;
									var m = {
										a: new f,
										b: new f,
										c: new f
									};
									d.push(l);
									k.push(m)
								}
							}
							k = this.morphNormals[e];
							g.vertices = this.morphTargets[e].vertices;
							g.computeFaceNormals();
							g.computeVertexNormals();
							c = 0;
							for (b = this.faces.length; c < b; c++) d = this.faces[c], l = k.faceNormals[c], m = k.vertexNormals[c], l
								.copy(d.normal), m.a.copy(d.vertexNormals[0]), m.b.copy(d.vertexNormals[1]), m.c.copy(d.vertexNormals[2])
						}
						c = 0;
						for (b = this.faces.length; c < b; c++) d = this.faces[c],
							d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals
					},
					computeBoundingBox: function() {
						null === this.boundingBox && (this.boundingBox = new D);
						this.boundingBox.setFromPoints(this.vertices)
					},
					computeBoundingSphere: function() {
						null === this.boundingSphere && (this.boundingSphere = new G);
						this.boundingSphere.setFromPoints(this.vertices)
					},
					merge: function(a, b, c) {
						if (a && a.isGeometry) {
							var h, d = this.vertices.length,
								e = this.vertices,
								f = a.vertices,
								g = this.faces,
								t = a.faces,
								l = this.colors,
								m = a.colors;
							void 0 === c &&
								(c = 0);
							void 0 !== b && (h = (new k).getNormalMatrix(b));
							for (var x = 0, n = f.length; x < n; x++) {
								var r = f[x].clone();
								void 0 !== b && r.applyMatrix4(b);
								e.push(r)
							}
							x = 0;
							for (n = m.length; x < n; x++) l.push(m[x].clone());
							x = 0;
							for (n = t.length; x < n; x++) {
								f = t[x];
								var p = f.vertexNormals;
								m = f.vertexColors;
								l = new M(f.a + d, f.b + d, f.c + d);
								l.normal.copy(f.normal);
								void 0 !== h && l.normal.applyMatrix3(h).normalize();
								b = 0;
								for (e = p.length; b < e; b++) r = p[b].clone(), void 0 !== h && r.applyMatrix3(h).normalize(), l.vertexNormals
									.push(r);
								l.color.copy(f.color);
								b = 0;
								for (e =
									m.length; b < e; b++) r = m[b], l.vertexColors.push(r.clone());
								l.materialIndex = f.materialIndex + c;
								g.push(l)
							}
							x = 0;
							for (n = a.faceVertexUvs.length; x < n; x++)
								for (c = a.faceVertexUvs[x], void 0 === this.faceVertexUvs[x] && (this.faceVertexUvs[x] = []), b = 0, e =
									c.length; b < e; b++) {
									h = c[b];
									d = [];
									g = 0;
									for (t = h.length; g < t; g++) d.push(h[g].clone());
									this.faceVertexUvs[x].push(d)
								}
						} else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
					},
					mergeMesh: function(a) {
						a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(),
							this.merge(a.geometry, a.matrix)) : console.error(
							"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a)
					},
					mergeVertices: function() {
						var a = {},
							b = [],
							c = [],
							d = Math.pow(10, 4),
							e;
						var f = 0;
						for (e = this.vertices.length; f < e; f++) {
							var g = this.vertices[f];
							g = Math.round(g.x * d) + "_" + Math.round(g.y * d) + "_" + Math.round(g.z * d);
							void 0 === a[g] ? (a[g] = f, b.push(this.vertices[f]), c[f] = b.length - 1) : c[f] = c[a[g]]
						}
						a = [];
						f = 0;
						for (e = this.faces.length; f < e; f++)
							for (d = this.faces[f], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], g = 0; 3 >
								g; g++)
								if (d[g] === d[(g + 1) % 3]) {
									a.push(f);
									break
								} for (f = a.length - 1; 0 <= f; f--)
							for (d = a[f], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++) this.faceVertexUvs[
								c].splice(d, 1);
						f = this.vertices.length - b.length;
						this.vertices = b;
						return f
					},
					setFromPoints: function(a) {
						this.vertices = [];
						for (var b = 0, c = a.length; b < c; b++) {
							var h = a[b];
							this.vertices.push(new f(h.x, h.y, h.z || 0))
						}
						return this
					},
					sortFacesByMaterialIndex: function() {
						for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
						a.sort(function(a, b) {
							return a.materialIndex -
								b.materialIndex
						});
						var d = this.faceVertexUvs[0],
							e = this.faceVertexUvs[1],
							f, g;
						d && d.length === b && (f = []);
						e && e.length === b && (g = []);
						for (c = 0; c < b; c++) {
							var k = a[c]._id;
							f && f.push(d[k]);
							g && g.push(e[k])
						}
						f && (this.faceVertexUvs[0] = f);
						g && (this.faceVertexUvs[1] = g)
					},
					toJSON: function() {
						function a(a, b, c) {
							return c ? a | 1 << b : a & ~(1 << b)
						}

						function b(a) {
							var b = a.x.toString() + a.y.toString() + a.z.toString();
							if (void 0 !== m[b]) return m[b];
							m[b] = l.length / 3;
							l.push(a.x, a.y, a.z);
							return m[b]
						}

						function c(a) {
							var b = a.r.toString() + a.g.toString() + a.b.toString();
							if (void 0 !== r[b]) return r[b];
							r[b] = n.length;
							n.push(a.getHex());
							return r[b]
						}

						function d(a) {
							var b = a.x.toString() + a.y.toString();
							if (void 0 !== v[b]) return v[b];
							v[b] = p.length / 2;
							p.push(a.x, a.y);
							return v[b]
						}
						var e = {
							metadata: {
								version: 4.5,
								type: "Geometry",
								generator: "Geometry.toJSON"
							}
						};
						e.uuid = this.uuid;
						e.type = this.type;
						"" !== this.name && (e.name = this.name);
						if (void 0 !== this.parameters) {
							var f = this.parameters,
								g;
							for (g in f) void 0 !== f[g] && (e[g] = f[g]);
							return e
						}
						f = [];
						for (g = 0; g < this.vertices.length; g++) {
							var k = this.vertices[g];
							f.push(k.x, k.y, k.z)
						}
						k = [];
						var l = [],
							m = {},
							n = [],
							r = {},
							p = [],
							v = {};
						for (g = 0; g < this.faces.length; g++) {
							var q = this.faces[g],
								u = void 0 !== this.faceVertexUvs[0][g],
								w = 0 < q.normal.length(),
								A = 0 < q.vertexNormals.length,
								z = 1 !== q.color.r || 1 !== q.color.g || 1 !== q.color.b,
								D = 0 < q.vertexColors.length,
								C = 0;
							C = a(C, 0, 0);
							C = a(C, 1, !0);
							C = a(C, 2, !1);
							C = a(C, 3, u);
							C = a(C, 4, w);
							C = a(C, 5, A);
							C = a(C, 6, z);
							C = a(C, 7, D);
							k.push(C);
							k.push(q.a, q.b, q.c);
							k.push(q.materialIndex);
							u && (u = this.faceVertexUvs[0][g], k.push(d(u[0]), d(u[1]), d(u[2])));
							w && k.push(b(q.normal));
							A && (w = q.vertexNormals, k.push(b(w[0]), b(w[1]), b(w[2])));
							z && k.push(c(q.color));
							D && (q = q.vertexColors, k.push(c(q[0]), c(q[1]), c(q[2])))
						}
						e.data = {};
						e.data.vertices = f;
						e.data.normals = l;
						0 < n.length && (e.data.colors = n);
						0 < p.length && (e.data.uvs = [p]);
						e.data.faces = k;
						return e
					},
					clone: function() {
						return (new T).copy(this)
					},
					copy: function(a) {
						var b, c, h;
						this.vertices = [];
						this.colors = [];
						this.faces = [];
						this.faceVertexUvs = [
							[]
						];
						this.morphTargets = [];
						this.morphNormals = [];
						this.skinWeights = [];
						this.skinIndices = [];
						this.lineDistances = [];
						this.boundingSphere = this.boundingBox = null;
						this.name = a.name;
						var d = a.vertices;
						var e = 0;
						for (b = d.length; e < b; e++) this.vertices.push(d[e].clone());
						d = a.colors;
						e = 0;
						for (b = d.length; e < b; e++) this.colors.push(d[e].clone());
						d = a.faces;
						e = 0;
						for (b = d.length; e < b; e++) this.faces.push(d[e].clone());
						e = 0;
						for (b = a.faceVertexUvs.length; e < b; e++) {
							var f = a.faceVertexUvs[e];
							void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []);
							d = 0;
							for (c = f.length; d < c; d++) {
								var g = f[d],
									k = [];
								var l = 0;
								for (h = g.length; l < h; l++) k.push(g[l].clone());
								this.faceVertexUvs[e].push(k)
							}
						}
						l = a.morphTargets;
						e = 0;
						for (b = l.length; e < b; e++) {
							h = {};
							h.name = l[e].name;
							if (void 0 !== l[e].vertices)
								for (h.vertices = [], d = 0, c = l[e].vertices.length; d < c; d++) h.vertices.push(l[e].vertices[d].clone());
							if (void 0 !== l[e].normals)
								for (h.normals = [], d = 0, c = l[e].normals.length; d < c; d++) h.normals.push(l[e].normals[d].clone());
							this.morphTargets.push(h)
						}
						l = a.morphNormals;
						e = 0;
						for (b = l.length; e < b; e++) {
							h = {};
							if (void 0 !== l[e].vertexNormals)
								for (h.vertexNormals = [], d = 0, c = l[e].vertexNormals.length; d < c; d++) f =
									l[e].vertexNormals[d], g = {}, g.a = f.a.clone(), g.b = f.b.clone(), g.c = f.c.clone(), h.vertexNormals.push(
										g);
							if (void 0 !== l[e].faceNormals)
								for (h.faceNormals = [], d = 0, c = l[e].faceNormals.length; d < c; d++) h.faceNormals.push(l[e].faceNormals[
									d].clone());
							this.morphNormals.push(h)
						}
						d = a.skinWeights;
						e = 0;
						for (b = d.length; e < b; e++) this.skinWeights.push(d[e].clone());
						d = a.skinIndices;
						e = 0;
						for (b = d.length; e < b; e++) this.skinIndices.push(d[e].clone());
						d = a.lineDistances;
						e = 0;
						for (b = d.length; e < b; e++) this.lineDistances.push(d[e]);
						e = a.boundingBox;
						null !== e && (this.boundingBox = e.clone());
						e = a.boundingSphere;
						null !== e && (this.boundingSphere = e.clone());
						this.elementsNeedUpdate = a.elementsNeedUpdate;
						this.verticesNeedUpdate = a.verticesNeedUpdate;
						this.uvsNeedUpdate = a.uvsNeedUpdate;
						this.normalsNeedUpdate = a.normalsNeedUpdate;
						this.colorsNeedUpdate = a.colorsNeedUpdate;
						this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
						this.groupsNeedUpdate = a.groupsNeedUpdate;
						return this
					},
					dispose: function() {
						this.dispatchEvent({
							type: "dispose"
						})
					}
				});
				var bh = function(a) {
						function b(b,
							c, h, d, e, f) {
							a.call(this);
							this.type = "BoxGeometry";
							this.parameters = {
								width: b,
								height: c,
								depth: h,
								widthSegments: d,
								heightSegments: e,
								depthSegments: f
							};
							this.fromBufferGeometry(new qk(b, c, h, d, e, f));
							this.mergeVertices()
						}
						a && (b.__proto__ = a);
						b.prototype = p(a && a.prototype);
						return b.prototype.constructor = b
					}(T),
					qk = function(a) {
						function b(b, c, h, d, e, g) {
							function k(a, b, c, h, d, e, g, k, E, p, v) {
								var q = e / E,
									O = g / p,
									u = e / 2,
									w = g / 2,
									ka = k / 2;
								g = E + 1;
								var A = p + 1,
									z = e = 0,
									ea, Y, D = new f;
								for (Y = 0; Y < A; Y++) {
									var C = Y * O - w;
									for (ea = 0; ea < g; ea++) D[a] = (ea * q - u) * h, D[b] =
										C * d, D[c] = ka, m.push(D.x, D.y, D.z), D[a] = 0, D[b] = 0, D[c] = 0 < k ? 1 : -1, x.push(D.x, D.y, D.z),
										y.push(ea / E), y.push(1 - Y / p), e += 1
								}
								for (Y = 0; Y < p; Y++)
									for (ea = 0; ea < E; ea++) a = n + ea + g * (Y + 1), b = n + (ea + 1) + g * (Y + 1), c = n + (ea + 1) + g *
										Y, l.push(n + ea + g * Y, a, c), l.push(a, b, c), z += 6;
								t.addGroup(r, z, v);
								r += z;
								n += e
							}
							a.call(this);
							this.type = "BoxBufferGeometry";
							this.parameters = {
								width: b,
								height: c,
								depth: h,
								widthSegments: d,
								heightSegments: e,
								depthSegments: g
							};
							var t = this;
							b = b || 1;
							c = c || 1;
							h = h || 1;
							d = Math.floor(d) || 1;
							e = Math.floor(e) || 1;
							g = Math.floor(g) || 1;
							var l = [],
								m = [],
								x = [],
								y = [],
								n = 0,
								r = 0;
							k("z", "y", "x", -1, -1, h, c, b, g, e, 0);
							k("z", "y", "x", 1, -1, h, c, -b, g, e, 1);
							k("x", "z", "y", 1, 1, b, h, c, d, g, 2);
							k("x", "z", "y", 1, -1, b, h, -c, d, g, 3);
							k("x", "y", "z", 1, -1, b, c, h, d, e, 4);
							k("x", "y", "z", -1, -1, b, c, -h, d, e, 5);
							this.setIndex(l);
							this.addAttribute("position", new L(m, 3));
							this.addAttribute("normal", new L(x, 3));
							this.addAttribute("uv", new L(y, 2))
						}
						a && (b.__proto__ = a);
						b.prototype = p(a && a.prototype);
						return b.prototype.constructor = b
					}(I),
					qj = {
						clone: Aa,
						merge: pa
					};
				sa.prototype = p(F.prototype);
				sa.prototype.constructor =
					sa;
				sa.prototype.isShaderMaterial = !0;
				sa.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.fragmentShader = a.fragmentShader;
					this.vertexShader = a.vertexShader;
					this.uniforms = Aa(a.uniforms);
					this.defines = q({}, a.defines);
					this.wireframe = a.wireframe;
					this.wireframeLinewidth = a.wireframeLinewidth;
					this.lights = a.lights;
					this.clipping = a.clipping;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.morphNormals = a.morphNormals;
					this.extensions = a.extensions;
					return this
				};
				sa.prototype.toJSON = function(a) {
					var b =
						F.prototype.toJSON.call(this, a);
					b.uniforms = {};
					for (var c in this.uniforms) {
						var h = this.uniforms[c].value;
						b.uniforms[c] = h && h.isTexture ? {
							type: "t",
							value: h.toJSON(a).uuid
						} : h && h.isColor ? {
							type: "c",
							value: h.getHex()
						} : h && h.isVector2 ? {
							type: "v2",
							value: h.toArray()
						} : h && h.isVector3 ? {
							type: "v3",
							value: h.toArray()
						} : h && h.isVector4 ? {
							type: "v4",
							value: h.toArray()
						} : h && h.isMatrix3 ? {
							type: "m3",
							value: h.toArray()
						} : h && h.isMatrix4 ? {
							type: "m4",
							value: h.toArray()
						} : {
							value: h
						}
					}
					0 < Ha(this.defines).length && (b.defines = this.defines);
					b.vertexShader =
						this.vertexShader;
					b.fragmentShader = this.fragmentShader;
					a = {};
					for (var d in this.extensions) !0 === this.extensions[d] && (a[d] = !0);
					0 < Ha(a).length && (b.extensions = a);
					return b
				};
				va.prototype = q(p(u.prototype), {
					constructor: va,
					isCamera: !0,
					copy: function(a, b) {
						u.prototype.copy.call(this, a, b);
						this.matrixWorldInverse.copy(a.matrixWorldInverse);
						this.projectionMatrix.copy(a.projectionMatrix);
						this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
						return this
					},
					getWorldDirection: function(a) {
						void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"),
							a = new f);
						this.updateMatrixWorld(!0);
						var b = this.matrixWorld.elements;
						return a.set(-b[8], -b[9], -b[10]).normalize()
					},
					updateMatrixWorld: function(a) {
						u.prototype.updateMatrixWorld.call(this, a);
						this.matrixWorldInverse.getInverse(this.matrixWorld)
					},
					clone: function() {
						return (new this.constructor).copy(this)
					}
				});
				Ja.prototype = q(p(va.prototype), {
					constructor: Ja,
					isPerspectiveCamera: !0,
					copy: function(a, b) {
						va.prototype.copy.call(this, a, b);
						this.fov = a.fov;
						this.zoom = a.zoom;
						this.near = a.near;
						this.far = a.far;
						this.focus = a.focus;
						this.aspect = a.aspect;
						this.view = null === a.view ? null : q({}, a.view);
						this.filmGauge = a.filmGauge;
						this.filmOffset = a.filmOffset;
						return this
					},
					setFocalLength: function(a) {
						a = .5 * this.getFilmHeight() / a;
						this.fov = 2 * Ea.RAD2DEG * Math.atan(a);
						this.updateProjectionMatrix()
					},
					getFocalLength: function() {
						var a = Math.tan(.5 * Ea.DEG2RAD * this.fov);
						return .5 * this.getFilmHeight() / a
					},
					getEffectiveFOV: function() {
						return 2 * Ea.RAD2DEG * Math.atan(Math.tan(.5 * Ea.DEG2RAD * this.fov) / this.zoom)
					},
					getFilmWidth: function() {
						return this.filmGauge * Math.min(this.aspect,
							1)
					},
					getFilmHeight: function() {
						return this.filmGauge / Math.max(this.aspect, 1)
					},
					setViewOffset: function(a, b, c, d, e, f) {
						this.aspect = a / b;
						null === this.view && (this.view = {
							enabled: !0,
							fullWidth: 1,
							fullHeight: 1,
							offsetX: 0,
							offsetY: 0,
							width: 1,
							height: 1
						});
						this.view.enabled = !0;
						this.view.fullWidth = a;
						this.view.fullHeight = b;
						this.view.offsetX = c;
						this.view.offsetY = d;
						this.view.width = e;
						this.view.height = f;
						this.updateProjectionMatrix()
					},
					clearViewOffset: function() {
						null !== this.view && (this.view.enabled = !1);
						this.updateProjectionMatrix()
					},
					updateProjectionMatrix: function() {
						var a = this.near,
							b = a * Math.tan(.5 * Ea.DEG2RAD * this.fov) / this.zoom,
							c = 2 * b,
							d = this.aspect * c,
							e = -.5 * d,
							f = this.view;
						if (null !== this.view && this.view.enabled) {
							var g = f.fullWidth,
								k = f.fullHeight;
							e += f.offsetX * d / g;
							b -= f.offsetY * c / k;
							d *= f.width / g;
							c *= f.height / k
						}
						f = this.filmOffset;
						0 !== f && (e += a * f / this.getFilmWidth());
						this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far);
						this.projectionMatrixInverse.getInverse(this.projectionMatrix)
					},
					toJSON: function(a) {
						a = u.prototype.toJSON.call(this,
							a);
						a.object.fov = this.fov;
						a.object.zoom = this.zoom;
						a.object.near = this.near;
						a.object.far = this.far;
						a.object.focus = this.focus;
						a.object.aspect = this.aspect;
						null !== this.view && (a.object.view = q({}, this.view));
						a.object.filmGauge = this.filmGauge;
						a.object.filmOffset = this.filmOffset;
						return a
					}
				});
				Da.prototype = p(u.prototype);
				Da.prototype.constructor = Da;
				qa.prototype = p(n.prototype);
				qa.prototype.constructor = qa;
				qa.prototype.isWebGLRenderTargetCube = !0;
				qa.prototype.fromEquirectangularTexture = function(a, b) {
					this.texture.type =
						b.type;
					this.texture.format = b.format;
					this.texture.encoding = b.encoding;
					var c = new C,
						h = new sa({
							type: "CubemapFromEquirect",
							uniforms: Aa({
								tEquirect: {
									value: null
								}
							}),
							vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
							fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
							side: 1,
							blending: 0
						});
					h.uniforms.tEquirect.value = b;
					b = new ha(new qk(5, 5, 5), h);
					c.add(b);
					h = new Da(1, 10, 1);
					h.renderTarget = this;
					h.renderTarget.texture.name = "CubeCameraTexture";
					h.update(a, c);
					b.geometry.dispose();
					b.material.dispose();
					return this
				};
				Ia.prototype = p(l.prototype);
				Ia.prototype.constructor = Ia;
				Ia.prototype.isDataTexture = !0;
				var ch = new f,
					rj = new f,
					sj = new k;
				q(za.prototype, {
					isPlane: !0,
					set: function(a, b) {
						this.normal.copy(a);
						this.constant = b;
						return this
					},
					setComponents: function(a, b, c, d) {
						this.normal.set(a, b,
							c);
						this.constant = d;
						return this
					},
					setFromNormalAndCoplanarPoint: function(a, b) {
						this.normal.copy(a);
						this.constant = -b.dot(this.normal);
						return this
					},
					setFromCoplanarPoints: function(a, b, c) {
						b = ch.subVectors(c, b).cross(rj.subVectors(a, b)).normalize();
						this.setFromNormalAndCoplanarPoint(b, a);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.normal.copy(a.normal);
						this.constant = a.constant;
						return this
					},
					normalize: function() {
						var a = 1 / this.normal.length();
						this.normal.multiplyScalar(a);
						this.constant *= a;
						return this
					},
					negate: function() {
						this.constant *= -1;
						this.normal.negate();
						return this
					},
					distanceToPoint: function(a) {
						return this.normal.dot(a) + this.constant
					},
					distanceToSphere: function(a) {
						return this.distanceToPoint(a.center) - a.radius
					},
					projectPoint: function(a, b) {
						void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new f);
						return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)
					},
					intersectLine: function(a, b) {
						void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"),
							b = new f);
						var c = a.delta(ch),
							h = this.normal.dot(c);
						if (0 === h) {
							if (0 === this.distanceToPoint(a.start)) return b.copy(a.start)
						} else if (h = -(a.start.dot(this.normal) + this.constant) / h, !(0 > h || 1 < h)) return b.copy(c).multiplyScalar(
							h).add(a.start)
					},
					intersectsLine: function(a) {
						var b = this.distanceToPoint(a.start);
						a = this.distanceToPoint(a.end);
						return 0 > b && 0 < a || 0 > a && 0 < b
					},
					intersectsBox: function(a) {
						return a.intersectsPlane(this)
					},
					intersectsSphere: function(a) {
						return a.intersectsPlane(this)
					},
					coplanarPoint: function(a) {
						void 0 ===
							a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new f);
						return a.copy(this.normal).multiplyScalar(-this.constant)
					},
					applyMatrix4: function(a, b) {
						b = b || sj.getNormalMatrix(a);
						a = this.coplanarPoint(ch).applyMatrix4(a);
						b = this.normal.applyMatrix3(b).normalize();
						this.constant = -a.dot(b);
						return this
					},
					translate: function(a) {
						this.constant -= a.dot(this.normal);
						return this
					},
					equals: function(a) {
						return a.normal.equals(this.normal) && a.constant === this.constant
					}
				});
				var Sj = new G,
					gg = new f;
				q(U.prototype, {
					set: function(a, b, c, d, e, f) {
						var h = this.planes;
						h[0].copy(a);
						h[1].copy(b);
						h[2].copy(c);
						h[3].copy(d);
						h[4].copy(e);
						h[5].copy(f);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
						return this
					},
					setFromMatrix: function(a) {
						var b = this.planes,
							c = a.elements;
						a = c[0];
						var h = c[1],
							d = c[2],
							e = c[3],
							f = c[4],
							g = c[5],
							k = c[6],
							l = c[7],
							m = c[8],
							n = c[9],
							r = c[10],
							p = c[11],
							v = c[12],
							q = c[13],
							u = c[14];
						c = c[15];
						b[0].setComponents(e - a, l - f, p - m, c - v).normalize();
						b[1].setComponents(e + a, l + f, p + m, c + v).normalize();
						b[2].setComponents(e + h, l + g, p + n, c + q).normalize();
						b[3].setComponents(e - h, l - g, p - n, c - q).normalize();
						b[4].setComponents(e - d, l - k, p - r, c - u).normalize();
						b[5].setComponents(e + d, l + k, p + r, c + u).normalize();
						return this
					},
					intersectsObject: function(a) {
						var b = a.geometry;
						null === b.boundingSphere && b.computeBoundingSphere();
						Sj.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
						return this.intersectsSphere(Sj)
					},
					intersectsSprite: function(a) {
						Sj.center.set(0, 0, 0);
						Sj.radius = .7071067811865476;
						Sj.applyMatrix4(a.matrixWorld);
						return this.intersectsSphere(Sj)
					},
					intersectsSphere: function(a) {
						var b = this.planes,
							c = a.center;
						a = -a.radius;
						for (var h = 0; 6 > h; h++)
							if (b[h].distanceToPoint(c) < a) return !1;
						return !0
					},
					intersectsBox: function(a) {
						for (var b = this.planes, c = 0; 6 > c; c++) {
							var h = b[c];
							gg.x = 0 < h.normal.x ? a.max.x : a.min.x;
							gg.y = 0 < h.normal.y ? a.max.y : a.min.y;
							gg.z = 0 < h.normal.z ? a.max.z : a.min.z;
							if (0 > h.distanceToPoint(gg)) return !1
						}
						return !0
					},
					containsPoint: function(a) {
						for (var b = this.planes, c = 0; 6 > c; c++)
							if (0 > b[c].distanceToPoint(a)) return !1;
						return !0
					}
				});
				var Ca = {
						alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
						alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
						alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
						aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
						aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
						begin_vertex: "vec3 transformed = vec3( position );",
						beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
						bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
						bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
						clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
						clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
						clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
						clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
						color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
						color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
						color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
						color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
						common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
						cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
						defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
						displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
						displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
						emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
						emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
						encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
						encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
						envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
						envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
						envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
						envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
						envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
						envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
						fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
						fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
						fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
						fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
						gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
						lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
						lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
						lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
						lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
						lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
						lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
						lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
						lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
						lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
						lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
						lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
						logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
						logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
						logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
						logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
						map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
						map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
						map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
						map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
						metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
						metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
						morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
						morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
						morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
						normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
						normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
						normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
						clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
						clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
						clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
						packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
						premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
						project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
						dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
						dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
						roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
						roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
						shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
						shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
						shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
						shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
						skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
						skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
						skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
						skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
						specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
						specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
						tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
						tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
						uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
						uv_pars_vertex: "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
						uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
						uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
						uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
						uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
						worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
						background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
						background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
						cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
						cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
						depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
						depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
						distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
						distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
						equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
						equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
						linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
						linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
						meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
						meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
						meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
						meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
						meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
						meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
						normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
						points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
						points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
						shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
						shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
						sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
						sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
					},
					na = {
						common: {
							diffuse: {
								value: new Q(15658734)
							},
							opacity: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new k
							},
							alphaMap: {
								value: null
							}
						},
						specularmap: {
							specularMap: {
								value: null
							}
						},
						envmap: {
							envMap: {
								value: null
							},
							flipEnvMap: {
								value: -1
							},
							reflectivity: {
								value: 1
							},
							refractionRatio: {
								value: .98
							},
							maxMipLevel: {
								value: 0
							}
						},
						aomap: {
							aoMap: {
								value: null
							},
							aoMapIntensity: {
								value: 1
							}
						},
						lightmap: {
							lightMap: {
								value: null
							},
							lightMapIntensity: {
								value: 1
							}
						},
						emissivemap: {
							emissiveMap: {
								value: null
							}
						},
						bumpmap: {
							bumpMap: {
								value: null
							},
							bumpScale: {
								value: 1
							}
						},
						normalmap: {
							normalMap: {
								value: null
							},
							normalScale: {
								value: new d(1, 1)
							}
						},
						displacementmap: {
							displacementMap: {
								value: null
							},
							displacementScale: {
								value: 1
							},
							displacementBias: {
								value: 0
							}
						},
						roughnessmap: {
							roughnessMap: {
								value: null
							}
						},
						metalnessmap: {
							metalnessMap: {
								value: null
							}
						},
						gradientmap: {
							gradientMap: {
								value: null
							}
						},
						fog: {
							fogDensity: {
								value: 2.5E-4
							},
							fogNear: {
								value: 1
							},
							fogFar: {
								value: 2E3
							},
							fogColor: {
								value: new Q(16777215)
							}
						},
						lights: {
							ambientLightColor: {
								value: []
							},
							lightProbe: {
								value: []
							},
							directionalLights: {
								value: [],
								properties: {
									direction: {},
									color: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							directionalShadowMap: {
								value: []
							},
							directionalShadowMatrix: {
								value: []
							},
							spotLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									direction: {},
									distance: {},
									coneCos: {},
									penumbraCos: {},
									decay: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {}
								}
							},
							spotShadowMap: {
								value: []
							},
							spotShadowMatrix: {
								value: []
							},
							pointLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									decay: {},
									distance: {},
									shadow: {},
									shadowBias: {},
									shadowRadius: {},
									shadowMapSize: {},
									shadowCameraNear: {},
									shadowCameraFar: {}
								}
							},
							pointShadowMap: {
								value: []
							},
							pointShadowMatrix: {
								value: []
							},
							hemisphereLights: {
								value: [],
								properties: {
									direction: {},
									skyColor: {},
									groundColor: {}
								}
							},
							rectAreaLights: {
								value: [],
								properties: {
									color: {},
									position: {},
									width: {},
									height: {}
								}
							}
						},
						points: {
							diffuse: {
								value: new Q(15658734)
							},
							opacity: {
								value: 1
							},
							size: {
								value: 1
							},
							scale: {
								value: 1
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new k
							}
						},
						sprite: {
							diffuse: {
								value: new Q(15658734)
							},
							opacity: {
								value: 1
							},
							center: {
								value: new d(.5, .5)
							},
							rotation: {
								value: 0
							},
							map: {
								value: null
							},
							uvTransform: {
								value: new k
							}
						}
					},
					kf = {
						basic: {
							uniforms: pa([na.common, na.specularmap, na.envmap, na.aomap, na.lightmap, na.fog]),
							vertexShader: Ca.meshbasic_vert,
							fragmentShader: Ca.meshbasic_frag
						},
						lambert: {
							uniforms: pa([na.common, na.specularmap, na.envmap, na.aomap, na.lightmap, na.emissivemap, na.fog, na.lights,
								{
									emissive: {
										value: new Q(0)
									}
								}
							]),
							vertexShader: Ca.meshlambert_vert,
							fragmentShader: Ca.meshlambert_frag
						},
						phong: {
							uniforms: pa([na.common, na.specularmap, na.envmap, na.aomap, na.lightmap, na.emissivemap, na.bumpmap, na.normalmap,
								na.displacementmap, na.gradientmap,
								na.fog, na.lights, {
									emissive: {
										value: new Q(0)
									},
									specular: {
										value: new Q(1118481)
									},
									shininess: {
										value: 30
									}
								}
							]),
							vertexShader: Ca.meshphong_vert,
							fragmentShader: Ca.meshphong_frag
						},
						standard: {
							uniforms: pa([na.common, na.envmap, na.aomap, na.lightmap, na.emissivemap, na.bumpmap, na.normalmap, na.displacementmap,
								na.roughnessmap, na.metalnessmap, na.fog, na.lights, {
									emissive: {
										value: new Q(0)
									},
									roughness: {
										value: .5
									},
									metalness: {
										value: .5
									},
									envMapIntensity: {
										value: 1
									}
								}
							]),
							vertexShader: Ca.meshphysical_vert,
							fragmentShader: Ca.meshphysical_frag
						},
						matcap: {
							uniforms: pa([na.common, na.bumpmap, na.normalmap, na.displacementmap, na.fog, {
								matcap: {
									value: null
								}
							}]),
							vertexShader: Ca.meshmatcap_vert,
							fragmentShader: Ca.meshmatcap_frag
						},
						points: {
							uniforms: pa([na.points, na.fog]),
							vertexShader: Ca.points_vert,
							fragmentShader: Ca.points_frag
						},
						dashed: {
							uniforms: pa([na.common, na.fog, {
								scale: {
									value: 1
								},
								dashSize: {
									value: 1
								},
								totalSize: {
									value: 2
								}
							}]),
							vertexShader: Ca.linedashed_vert,
							fragmentShader: Ca.linedashed_frag
						},
						depth: {
							uniforms: pa([na.common, na.displacementmap]),
							vertexShader: Ca.depth_vert,
							fragmentShader: Ca.depth_frag
						},
						normal: {
							uniforms: pa([na.common, na.bumpmap, na.normalmap, na.displacementmap, {
								opacity: {
									value: 1
								}
							}]),
							vertexShader: Ca.normal_vert,
							fragmentShader: Ca.normal_frag
						},
						sprite: {
							uniforms: pa([na.sprite, na.fog]),
							vertexShader: Ca.sprite_vert,
							fragmentShader: Ca.sprite_frag
						},
						background: {
							uniforms: {
								uvTransform: {
									value: new k
								},
								t2D: {
									value: null
								}
							},
							vertexShader: Ca.background_vert,
							fragmentShader: Ca.background_frag
						},
						cube: {
							uniforms: {
								tCube: {
									value: null
								},
								tFlip: {
									value: -1
								},
								opacity: {
									value: 1
								}
							},
							vertexShader: Ca.cube_vert,
							fragmentShader: Ca.cube_frag
						},
						equirect: {
							uniforms: {
								tEquirect: {
									value: null
								}
							},
							vertexShader: Ca.equirect_vert,
							fragmentShader: Ca.equirect_frag
						},
						distanceRGBA: {
							uniforms: pa([na.common, na.displacementmap, {
								referencePosition: {
									value: new f
								},
								nearDistance: {
									value: 1
								},
								farDistance: {
									value: 1E3
								}
							}]),
							vertexShader: Ca.distanceRGBA_vert,
							fragmentShader: Ca.distanceRGBA_frag
						},
						shadow: {
							uniforms: pa([na.lights, na.fog, {
								color: {
									value: new Q(0)
								},
								opacity: {
									value: 1
								}
							}]),
							vertexShader: Ca.shadow_vert,
							fragmentShader: Ca.shadow_frag
						}
					};
				kf.physical = {
					uniforms: pa([kf.standard.uniforms, {
						transparency: {
							value: 0
						},
						clearcoat: {
							value: 0
						},
						clearcoatRoughness: {
							value: 0
						},
						sheen: {
							value: new Q(0)
						},
						clearcoatNormalScale: {
							value: new d(1, 1)
						},
						clearcoatNormalMap: {
							value: null
						}
					}]),
					vertexShader: Ca.meshphysical_vert,
					fragmentShader: Ca.meshphysical_frag
				};
				aa.prototype = p(T.prototype);
				aa.prototype.constructor = aa;
				Ba.prototype = p(I.prototype);
				Ba.prototype.constructor = Ba;
				Ua.prototype = p(l.prototype);
				Ua.prototype.constructor = Ua;
				Ua.prototype.isCubeTexture = !0;
				Object.defineProperty(Ua.prototype,
					"images", {
						get: function() {
							return this.image
						},
						set: function(a) {
							this.image = a
						}
					});
				cb.prototype = p(l.prototype);
				cb.prototype.constructor = cb;
				cb.prototype.isDataTexture2DArray = !0;
				db.prototype = p(l.prototype);
				db.prototype.constructor = db;
				db.prototype.isDataTexture3D = !0;
				var Wh = new l,
					tj = new cb,
					uj = new db,
					Xh = new Ua,
					wi = [],
					xi = [],
					yi = new Float32Array(16),
					zi = new Float32Array(9),
					Ai = new Float32Array(4);
				uc.prototype.updateCache = function(a) {
					var b = this.cache;
					a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length));
					Pa(b, a)
				};
				vc.prototype.setValue = function(a, b, c) {
					for (var h = this.seq, d = 0, e = h.length; d !== e; ++d) {
						var f = h[d];
						f.setValue(a, b[f.id], c)
					}
				};
				var qh = /([\w\d_]+)(\])?(\[|\.)?/g;
				nb.prototype.setValue = function(a, b, c, d) {
					b = this.map[b];
					void 0 !== b && b.setValue(a, c, d)
				};
				nb.prototype.setOptional = function(a, b, c) {
					b = b[c];
					void 0 !== b && this.setValue(a, c, b)
				};
				nb.upload = function(a, b, c, d) {
					for (var h = 0, e = b.length; h !== e; ++h) {
						var f = b[h],
							g = c[f.id];
						!1 !== g.needsUpdate && f.setValue(a, g.value, d)
					}
				};
				nb.seqWithValue = function(a, b) {
					for (var c = [],
							h = 0, d = a.length; h !== d; ++h) {
						var e = a[h];
						e.id in b && c.push(e)
					}
					return c
				};
				var Vj = 0,
					rh = /^[ \t]*#include +<([\w\d./]+)>/gm,
					Bi = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
					Wj = 0;
				tb.prototype = p(F.prototype);
				tb.prototype.constructor = tb;
				tb.prototype.isMeshDepthMaterial = !0;
				tb.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.depthPacking = a.depthPacking;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.map = a.map;
					this.alphaMap = a.alphaMap;
					this.displacementMap =
						a.displacementMap;
					this.displacementScale = a.displacementScale;
					this.displacementBias = a.displacementBias;
					this.wireframe = a.wireframe;
					this.wireframeLinewidth = a.wireframeLinewidth;
					return this
				};
				ub.prototype = p(F.prototype);
				ub.prototype.constructor = ub;
				ub.prototype.isMeshDistanceMaterial = !0;
				ub.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.referencePosition.copy(a.referencePosition);
					this.nearDistance = a.nearDistance;
					this.farDistance = a.farDistance;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.map = a.map;
					this.alphaMap = a.alphaMap;
					this.displacementMap = a.displacementMap;
					this.displacementScale = a.displacementScale;
					this.displacementBias = a.displacementBias;
					return this
				};
				rd.prototype = q(p(n.prototype), {
					constructor: rd,
					isWebGLMultiviewRenderTarget: !0,
					copy: function(a) {
						n.prototype.copy.call(this, a);
						this.numViews = a.numViews;
						return this
					},
					setNumViews: function(a) {
						this.numViews !== a && (this.numViews = a, this.dispose());
						return this
					}
				});
				Sb.prototype = q(p(u.prototype), {
					constructor: Sb,
					isGroup: !0
				});
				ic.prototype =
					q(p(Ja.prototype), {
						constructor: ic,
						isArrayCamera: !0
					});
				var Ci = new f,
					Di = new f;
				q(Cd.prototype, b.prototype);
				q(ie.prototype, b.prototype);
				q(Pc.prototype, {
					isFogExp2: !0,
					clone: function() {
						return new Pc(this.color, this.density)
					},
					toJSON: function() {
						return {
							type: "FogExp2",
							color: this.color.getHex(),
							density: this.density
						}
					}
				});
				q(bd.prototype, {
					isFog: !0,
					clone: function() {
						return new bd(this.color, this.near, this.far)
					},
					toJSON: function() {
						return {
							type: "Fog",
							color: this.color.getHex(),
							near: this.near,
							far: this.far
						}
					}
				});
				Object.defineProperty(Db.prototype,
					"needsUpdate", {
						set: function(a) {
							!0 === a && this.version++
						}
					});
				q(Db.prototype, {
					isInterleavedBuffer: !0,
					onUploadCallback: function() {},
					setDynamic: function(a) {
						this.dynamic = a;
						return this
					},
					copy: function(a) {
						this.array = new a.array.constructor(a.array);
						this.count = a.count;
						this.stride = a.stride;
						this.dynamic = a.dynamic;
						return this
					},
					copyAt: function(a, b, c) {
						a *= this.stride;
						c *= b.stride;
						for (var h = 0, d = this.stride; h < d; h++) this.array[a + h] = b.array[c + h];
						return this
					},
					set: function(a, b) {
						void 0 === b && (b = 0);
						this.array.set(a, b);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					onUpload: function(a) {
						this.onUploadCallback = a;
						return this
					}
				});
				ja(sc.prototype, {
					count: {
						get: function() {
							return this.data.count
						}
					},
					array: {
						get: function() {
							return this.data.array
						}
					}
				});
				q(sc.prototype, {
					isInterleavedBufferAttribute: !0,
					setX: function(a, b) {
						this.data.array[a * this.data.stride + this.offset] = b;
						return this
					},
					setY: function(a, b) {
						this.data.array[a * this.data.stride + this.offset + 1] = b;
						return this
					},
					setZ: function(a, b) {
						this.data.array[a * this.data.stride + this.offset +
							2] = b;
						return this
					},
					setW: function(a, b) {
						this.data.array[a * this.data.stride + this.offset + 3] = b;
						return this
					},
					getX: function(a) {
						return this.data.array[a * this.data.stride + this.offset]
					},
					getY: function(a) {
						return this.data.array[a * this.data.stride + this.offset + 1]
					},
					getZ: function(a) {
						return this.data.array[a * this.data.stride + this.offset + 2]
					},
					getW: function(a) {
						return this.data.array[a * this.data.stride + this.offset + 3]
					},
					setXY: function(a, b, c) {
						a = a * this.data.stride + this.offset;
						this.data.array[a + 0] = b;
						this.data.array[a + 1] = c;
						return this
					},
					setXYZ: function(a, b, c, d) {
						a = a * this.data.stride + this.offset;
						this.data.array[a + 0] = b;
						this.data.array[a + 1] = c;
						this.data.array[a + 2] = d;
						return this
					},
					setXYZW: function(a, b, c, d, e) {
						a = a * this.data.stride + this.offset;
						this.data.array[a + 0] = b;
						this.data.array[a + 1] = c;
						this.data.array[a + 2] = d;
						this.data.array[a + 3] = e;
						return this
					}
				});
				Eb.prototype = p(F.prototype);
				Eb.prototype.constructor = Eb;
				Eb.prototype.isSpriteMaterial = !0;
				Eb.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					this.map =
						a.map;
					this.rotation = a.rotation;
					this.sizeAttenuation = a.sizeAttenuation;
					return this
				};
				var yj, wk = new f,
					Tj = new f,
					Uj = new f,
					zj = new d,
					sk = new d,
					Ei = new v,
					ug = new f,
					xk = new f,
					vg = new f,
					Fi = new d,
					sh = new d,
					Gi = new d;
				xc.prototype = q(p(u.prototype), {
					constructor: xc,
					isSprite: !0,
					raycast: function(a, b) {
						null === a.camera && console.error(
							'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
						Tj.setFromMatrixScale(this.matrixWorld);
						Ei.copy(a.camera.matrixWorld);
						this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse,
							this.matrixWorld);
						Uj.setFromMatrixPosition(this.modelViewMatrix);
						a.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Tj.multiplyScalar(-Uj.z);
						var c = this.material.rotation;
						if (0 !== c) {
							var h = Math.cos(c);
							var e = Math.sin(c)
						}
						c = this.center;
						md(ug.set(-.5, -.5, 0), Uj, c, Tj, e, h);
						md(xk.set(.5, -.5, 0), Uj, c, Tj, e, h);
						md(vg.set(.5, .5, 0), Uj, c, Tj, e, h);
						Fi.set(0, 0);
						sh.set(1, 0);
						Gi.set(1, 1);
						var f = a.ray.intersectTriangle(ug, xk, vg, !1, wk);
						if (null === f && (md(xk.set(-.5, .5, 0), Uj, c, Tj, e, h), sh.set(0, 1), f = a.ray.intersectTriangle(ug,
								vg, xk, !1, wk), null === f)) return;
						e = a.ray.origin.distanceTo(wk);
						e < a.near || e > a.far || b.push({
							distance: e,
							point: wk.clone(),
							uv: H.getUV(wk, ug, xk, vg, Fi, sh, Gi, new d),
							face: null,
							object: this
						})
					},
					clone: function() {
						return (new this.constructor(this.material)).copy(this)
					},
					copy: function(a) {
						u.prototype.copy.call(this, a);
						void 0 !== a.center && this.center.copy(a.center);
						return this
					}
				});
				var wg = new f,
					Hi = new f;
				zc.prototype = q(p(u.prototype), {
					constructor: zc,
					isLOD: !0,
					copy: function(a) {
						u.prototype.copy.call(this, a, !1);
						a = a.levels;
						for (var b =
								0, c = a.length; b < c; b++) {
							var h = a[b];
							this.addLevel(h.object.clone(), h.distance)
						}
						return this
					},
					addLevel: function(a, b) {
						void 0 === b && (b = 0);
						b = Math.abs(b);
						for (var c = this.levels, h = 0; h < c.length && !(b < c[h].distance); h++);
						c.splice(h, 0, {
							distance: b,
							object: a
						});
						this.add(a);
						return this
					},
					getObjectForDistance: function(a) {
						for (var b = this.levels, c = 1, h = b.length; c < h && !(a < b[c].distance); c++);
						return b[c - 1].object
					},
					raycast: function(a, b) {
						wg.setFromMatrixPosition(this.matrixWorld);
						var c = a.ray.origin.distanceTo(wg);
						this.getObjectForDistance(c).raycast(a,
							b)
					},
					update: function(a) {
						var b = this.levels;
						if (1 < b.length) {
							wg.setFromMatrixPosition(a.matrixWorld);
							Hi.setFromMatrixPosition(this.matrixWorld);
							a = wg.distanceTo(Hi);
							b[0].object.visible = !0;
							for (var c = 1, h = b.length; c < h; c++)
								if (a >= b[c].distance) b[c - 1].object.visible = !1, b[c].object.visible = !0;
								else break;
							for (; c < h; c++) b[c].object.visible = !1
						}
					},
					toJSON: function(a) {
						a = u.prototype.toJSON.call(this, a);
						a.object.levels = [];
						for (var b = this.levels, c = 0, h = b.length; c < h; c++) {
							var d = b[c];
							a.object.levels.push({
								object: d.object.uuid,
								distance: d.distance
							})
						}
						return a
					}
				});
				Bc.prototype = q(p(ha.prototype), {
					constructor: Bc,
					isSkinnedMesh: !0,
					bind: function(a, b) {
						this.skeleton = a;
						void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
						this.bindMatrix.copy(b);
						this.bindMatrixInverse.getInverse(b)
					},
					pose: function() {
						this.skeleton.pose()
					},
					normalizeSkinWeights: function() {
						for (var a = new m, b = this.geometry.attributes.skinWeight, c = 0, d = b.count; c < d; c++) {
							a.x = b.getX(c);
							a.y = b.getY(c);
							a.z = b.getZ(c);
							a.w = b.getW(c);
							var e = 1 / a.manhattanLength();
							Infinity !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0);
							b.setXYZW(c, a.x, a.y, a.z, a.w)
						}
					},
					updateMatrixWorld: function(a) {
						ha.prototype.updateMatrixWorld.call(this, a);
						"attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ?
							this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn(
								"THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
					},
					clone: function() {
						return (new this.constructor(this.geometry, this.material)).copy(this)
					}
				});
				var Ii = new v,
					Xj = new v;
				q(nd.prototype, {
					calculateInverses: function() {
						this.boneInverses = [];
						for (var a = 0, b = this.bones.length; a < b; a++) {
							var c = new v;
							this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
							this.boneInverses.push(c)
						}
					},
					pose: function() {
						var a, b;
						var c = 0;
						for (b = this.bones.length; c < b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
						c = 0;
						for (b = this.bones.length; c < b; c++)
							if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(
									a.matrixWorld)) : a.matrix.copy(a.matrixWorld),
								a.matrix.decompose(a.position, a.quaternion, a.scale)
					},
					update: function() {
						for (var a = this.bones, b = this.boneInverses, c = this.boneMatrices, d = this.boneTexture, e = 0, f = a.length; e <
							f; e++) Ii.multiplyMatrices(a[e] ? a[e].matrixWorld : Xj, b[e]), Ii.toArray(c, 16 * e);
						void 0 !== d && (d.needsUpdate = !0)
					},
					clone: function() {
						return new nd(this.bones, this.boneInverses)
					},
					getBoneByName: function(a) {
						for (var b = 0, c = this.bones.length; b < c; b++) {
							var h = this.bones[b];
							if (h.name === a) return h
						}
					}
				});
				Td.prototype = q(p(u.prototype), {
					constructor: Td,
					isBone: !0
				});
				Ud.prototype = q(p(ha.prototype), {
					constructor: Ud,
					isInstancedMesh: !0,
					raycast: function() {},
					setMatrixAt: function(a, b) {
						b.toArray(this.instanceMatrix.array, 16 * a)
					},
					updateMorphTargets: function() {}
				});
				Ka.prototype = p(F.prototype);
				Ka.prototype.constructor = Ka;
				Ka.prototype.isLineBasicMaterial = !0;
				Ka.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					this.linewidth = a.linewidth;
					this.linecap = a.linecap;
					this.linejoin = a.linejoin;
					return this
				};
				var Ji = new f,
					Ki = new f,
					Li = new v,
					xg = new B,
					yk = new G;
				yb.prototype = q(p(u.prototype), {
					constructor: yb,
					isLine: !0,
					computeLineDistances: function() {
						var a = this.geometry;
						if (a.isBufferGeometry)
							if (null === a.index) {
								for (var b = a.attributes.position, c = [0], d = 1, e = b.count; d < e; d++) Ji.fromBufferAttribute(b, d -
									1), Ki.fromBufferAttribute(b, d), c[d] = c[d - 1], c[d] += Ji.distanceTo(Ki);
								a.addAttribute("lineDistance", new L(c, 1))
							} else console.warn(
								"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
						else if (a.isGeometry)
							for (b = a.vertices, c = a.lineDistances,
								c[0] = 0, d = 1, e = b.length; d < e; d++) c[d] = c[d - 1], c[d] += b[d - 1].distanceTo(b[d]);
						return this
					},
					raycast: function(a, b) {
						var c = a.linePrecision,
							h = this.geometry,
							d = this.matrixWorld;
						null === h.boundingSphere && h.computeBoundingSphere();
						yk.copy(h.boundingSphere);
						yk.applyMatrix4(d);
						yk.radius += c;
						if (!1 !== a.ray.intersectsSphere(yk)) {
							Li.getInverse(d);
							xg.copy(a.ray).applyMatrix4(Li);
							c /= (this.scale.x + this.scale.y + this.scale.z) / 3;
							c *= c;
							var e = new f,
								g = new f;
							d = new f;
							var k = new f,
								t = this && this.isLineSegments ? 2 : 1;
							if (h.isBufferGeometry) {
								var l =
									h.index,
									m = h.attributes.position.array;
								if (null !== l) {
									l = l.array;
									h = 0;
									for (var n = l.length - 1; h < n; h += t) {
										var r = l[h + 1];
										e.fromArray(m, 3 * l[h]);
										g.fromArray(m, 3 * r);
										r = xg.distanceSqToSegment(e, g, k, d);
										r > c || (k.applyMatrix4(this.matrixWorld), r = a.ray.origin.distanceTo(k), r < a.near || r > a.far ||
											b.push({
												distance: r,
												point: d.clone().applyMatrix4(this.matrixWorld),
												index: h,
												face: null,
												faceIndex: null,
												object: this
											}))
									}
								} else
									for (h = 0, n = m.length / 3 - 1; h < n; h += t) e.fromArray(m, 3 * h), g.fromArray(m, 3 * h + 3), r =
										xg.distanceSqToSegment(e, g, k, d), r > c ||
										(k.applyMatrix4(this.matrixWorld), r = a.ray.origin.distanceTo(k), r < a.near || r > a.far || b.push({
											distance: r,
											point: d.clone().applyMatrix4(this.matrixWorld),
											index: h,
											face: null,
											faceIndex: null,
											object: this
										}))
							} else if (h.isGeometry)
								for (e = h.vertices, g = e.length, h = 0; h < g - 1; h += t) r = xg.distanceSqToSegment(e[h], e[h + 1], k,
									d), r > c || (k.applyMatrix4(this.matrixWorld), r = a.ray.origin.distanceTo(k), r < a.near || r > a.far ||
									b.push({
										distance: r,
										point: d.clone().applyMatrix4(this.matrixWorld),
										index: h,
										face: null,
										faceIndex: null,
										object: this
									}))
						}
					},
					clone: function() {
						return (new this.constructor(this.geometry, this.material)).copy(this)
					}
				});
				var yg = new f,
					Gk = new f;
				Sa.prototype = q(p(yb.prototype), {
					constructor: Sa,
					isLineSegments: !0,
					computeLineDistances: function() {
						var a = this.geometry;
						if (a.isBufferGeometry)
							if (null === a.index) {
								for (var b = a.attributes.position, c = [], d = 0, e = b.count; d < e; d += 2) yg.fromBufferAttribute(b,
									d), Gk.fromBufferAttribute(b, d + 1), c[d] = 0 === d ? 0 : c[d - 1], c[d + 1] = c[d] + yg.distanceTo(Gk);
								a.addAttribute("lineDistance", new L(c, 1))
							} else console.warn(
								"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
						else if (a.isGeometry)
							for (b = a.vertices, c = a.lineDistances, d = 0, e = b.length; d < e; d += 2) yg.copy(b[d]), Gk.copy(b[d +
								1]), c[d] = 0 === d ? 0 : c[d - 1], c[d + 1] = c[d] + yg.distanceTo(Gk);
						return this
					}
				});
				qd.prototype = q(p(yb.prototype), {
					constructor: qd,
					isLineLoop: !0
				});
				me.prototype = p(F.prototype);
				me.prototype.constructor = me;
				me.prototype.isPointsMaterial = !0;
				me.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					this.map = a.map;
					this.size = a.size;
					this.sizeAttenuation = a.sizeAttenuation;
					this.morphTargets =
						a.morphTargets;
					return this
				};
				var Mi = new v,
					xh = new B,
					zk = new G,
					Hk = new f;
				ec.prototype = q(p(u.prototype), {
					constructor: ec,
					isPoints: !0,
					raycast: function(a, b) {
						var c = this.geometry,
							h = this.matrixWorld,
							d = a.params.Points.threshold;
						null === c.boundingSphere && c.computeBoundingSphere();
						zk.copy(c.boundingSphere);
						zk.applyMatrix4(h);
						zk.radius += d;
						if (!1 !== a.ray.intersectsSphere(zk))
							if (Mi.getInverse(h), xh.copy(a.ray).applyMatrix4(Mi), d /= (this.scale.x + this.scale.y + this.scale.z) /
								3, d *= d, c.isBufferGeometry) {
								var e = c.index;
								c = c.attributes.position.array;
								if (null !== e) {
									var f = e.array;
									e = 0;
									for (var g = f.length; e < g; e++) {
										var k = f[e];
										Hk.fromArray(c, 3 * k);
										Zd(Hk, k, d, h, a, b, this)
									}
								} else
									for (e = 0, f = c.length / 3; e < f; e++) Hk.fromArray(c, 3 * e), Zd(Hk, e, d, h, a, b, this)
							} else
								for (c = c.vertices, e = 0, f = c.length; e < f; e++) Zd(c[e], e, d, h, a, b, this)
					},
					updateMorphTargets: function() {
						var a = this.geometry;
						if (a.isBufferGeometry) {
							a = a.morphAttributes;
							var b = Ha(a);
							if (0 < b.length) {
								var c = a[b[0]];
								if (void 0 !== c)
									for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
										var d =
											c[a].name || String(a);
										this.morphTargetInfluences.push(0);
										this.morphTargetDictionary[d] = a
									}
							}
						} else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error(
							"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
					},
					clone: function() {
						return (new this.constructor(this.geometry, this.material)).copy(this)
					}
				});
				$d.prototype = q(p(l.prototype), {
					constructor: $d,
					isVideoTexture: !0,
					update: function() {
						var a = this.image;
						a.readyState >= a.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
					}
				});
				gc.prototype = p(l.prototype);
				gc.prototype.constructor = gc;
				gc.prototype.isCompressedTexture = !0;
				Cc.prototype = p(l.prototype);
				Cc.prototype.constructor = Cc;
				Cc.prototype.isCanvasTexture = !0;
				Dc.prototype = p(l.prototype);
				Dc.prototype.constructor = Dc;
				Dc.prototype.isDepthTexture = !0;
				hc.prototype = p(I.prototype);
				hc.prototype.constructor = hc;
				Fc.prototype = p(T.prototype);
				Fc.prototype.constructor = Fc;
				lc.prototype = p(I.prototype);
				lc.prototype.constructor = lc;
				Mc.prototype = p(T.prototype);
				Mc.prototype.constructor = Mc;
				oc.prototype =
					p(I.prototype);
				oc.prototype.constructor = oc;
				Nc.prototype = p(T.prototype);
				Nc.prototype.constructor = Nc;
				nc.prototype = p(oc.prototype);
				nc.prototype.constructor = nc;
				Tc.prototype = p(T.prototype);
				Tc.prototype.constructor = Tc;
				ac.prototype = p(oc.prototype);
				ac.prototype.constructor = ac;
				ad.prototype = p(T.prototype);
				ad.prototype.constructor = ad;
				rc.prototype = p(oc.prototype);
				rc.prototype.constructor = rc;
				fd.prototype = p(T.prototype);
				fd.prototype.constructor = fd;
				tc.prototype = p(oc.prototype);
				tc.prototype.constructor = tc;
				hd.prototype =
					p(T.prototype);
				hd.prototype.constructor = hd;
				cc.prototype = p(I.prototype);
				cc.prototype.constructor = cc;
				cc.prototype.toJSON = function() {
					var a = I.prototype.toJSON.call(this);
					a.path = this.parameters.path.toJSON();
					return a
				};
				jd.prototype = p(T.prototype);
				jd.prototype.constructor = jd;
				wc.prototype = p(I.prototype);
				wc.prototype.constructor = wc;
				kd.prototype = p(T.prototype);
				kd.prototype.constructor = kd;
				Ac.prototype = p(I.prototype);
				Ac.prototype.constructor = Ac;
				var Yj = {
						triangulate: function(a, b, c) {
							c = c || 2;
							var d = b && b.length,
								h = d ?
								b[0] * c : a.length,
								e = wf(a, 0, h, c, !0),
								f = [];
							if (!e || e.next === e.prev) return f;
							var g;
							if (d) {
								var k = c;
								d = [];
								var l;
								var t = 0;
								for (l = b.length; t < l; t++) {
									var m = b[t] * k;
									var n = t < l - 1 ? b[t + 1] * k : a.length;
									m = wf(a, m, n, k, !1);
									m === m.next && (m.steiner = !0);
									d.push(Ig(m))
								}
								d.sort(Dg);
								for (t = 0; t < d.length; t++) {
									b = d[t];
									k = e;
									if (k = Eg(b, k)) b = Jf(k, b), od(b, b.next);
									e = od(e, e.next)
								}
							}
							if (a.length > 80 * c) {
								var x = g = a[0];
								var r = d = a[1];
								for (k = c; k < h; k += c) t = a[k], b = a[k + 1], t < x && (x = t), b < r && (r = b), t > g && (g = t), b >
									d && (d = b);
								g = Math.max(g - x, d - r);
								g = 0 !== g ? 1 / g : 0
							}
							pd(e, f, c, x, r, g);
							return f
						}
					},
					hg = {
						area: function(a) {
							for (var b = a.length, c = 0, d = b - 1, h = 0; h < b; d = h++) c += a[d].x * a[h].y - a[h].x * a[d].y;
							return .5 * c
						},
						isClockWise: function(a) {
							return 0 > hg.area(a)
						},
						triangulateShape: function(a, b) {
							var c = [],
								d = [],
								h = [];
							Mf(a);
							Nf(c, a);
							var e = a.length;
							b.forEach(Mf);
							for (a = 0; a < b.length; a++) d.push(e), e += b[a].length, Nf(c, b[a]);
							b = Yj.triangulate(c, d);
							for (a = 0; a < b.length; a += 3) h.push(b.slice(a, a + 3));
							return h
						}
					};
				ci.prototype = p(T.prototype);
				ci.prototype.constructor = ci;
				ci.prototype.toJSON = function() {
					var a = T.prototype.toJSON.call(this);
					return Of(this.parameters.shapes, this.parameters.options, a)
				};
				lf.prototype = p(I.prototype);
				lf.prototype.constructor = lf;
				lf.prototype.toJSON = function() {
					var a = I.prototype.toJSON.call(this);
					return Of(this.parameters.shapes, this.parameters.options, a)
				};
				var Zj = {
					generateTopUV: function(a, b, c, e, f) {
						a = b[3 * e];
						e = b[3 * e + 1];
						var h = b[3 * f];
						f = b[3 * f + 1];
						return [new d(b[3 * c], b[3 * c + 1]), new d(a, e), new d(h, f)]
					},
					generateSideWallUV: function(a, b, c, e, f, g) {
						a = b[3 * c];
						var h = b[3 * c + 1];
						c = b[3 * c + 2];
						var k = b[3 * e],
							l = b[3 * e + 1];
						e = b[3 * e + 2];
						var t =
							b[3 * f],
							m = b[3 * f + 1];
						f = b[3 * f + 2];
						var n = b[3 * g],
							x = b[3 * g + 1];
						b = b[3 * g + 2];
						return .01 > Math.abs(h - l) ? [new d(a, 1 - c), new d(k, 1 - e), new d(t, 1 - f), new d(n, 1 - b)] : [new d(
							h, 1 - c), new d(l, 1 - e), new d(m, 1 - f), new d(x, 1 - b)]
					}
				};
				ud.prototype = p(T.prototype);
				ud.prototype.constructor = ud;
				Hc.prototype = p(lf.prototype);
				Hc.prototype.constructor = Hc;
				vd.prototype = p(T.prototype);
				vd.prototype.constructor = vd;
				gh.prototype = p(I.prototype);
				gh.prototype.constructor = gh;
				wd.prototype = p(T.prototype);
				wd.prototype.constructor = wd;
				Lc.prototype = p(I.prototype);
				Lc.prototype.constructor = Lc;
				Ed.prototype = p(T.prototype);
				Ed.prototype.constructor = Ed;
				Sc.prototype = p(I.prototype);
				Sc.prototype.constructor = Sc;
				di.prototype = p(T.prototype);
				di.prototype.constructor = di;
				di.prototype.toJSON = function() {
					var a = T.prototype.toJSON.call(this);
					return cg(this.parameters.shapes, a)
				};
				ei.prototype = p(I.prototype);
				ei.prototype.constructor = ei;
				ei.prototype.toJSON = function() {
					var a = I.prototype.toJSON.call(this);
					return cg(this.parameters.shapes, a)
				};
				Vc.prototype = p(I.prototype);
				Vc.prototype.constructor =
					Vc;
				fi.prototype = p(T.prototype);
				fi.prototype.constructor = fi;
				ig.prototype = p(I.prototype);
				ig.prototype.constructor = ig;
				Fd.prototype = p(fi.prototype);
				Fd.prototype.constructor = Fd;
				Id.prototype = p(ig.prototype);
				Id.prototype.constructor = Id;
				Jd.prototype = p(T.prototype);
				Jd.prototype.constructor = Jd;
				cd.prototype = p(I.prototype);
				cd.prototype.constructor = cd;
				var Xb = Ag({
					WireframeGeometry: hc,
					ParametricGeometry: Fc,
					ParametricBufferGeometry: lc,
					TetrahedronGeometry: Nc,
					TetrahedronBufferGeometry: nc,
					OctahedronGeometry: Tc,
					OctahedronBufferGeometry: ac,
					IcosahedronGeometry: ad,
					IcosahedronBufferGeometry: rc,
					DodecahedronGeometry: fd,
					DodecahedronBufferGeometry: tc,
					PolyhedronGeometry: Mc,
					PolyhedronBufferGeometry: oc,
					TubeGeometry: hd,
					TubeBufferGeometry: cc,
					TorusKnotGeometry: jd,
					TorusKnotBufferGeometry: wc,
					TorusGeometry: kd,
					TorusBufferGeometry: Ac,
					TextGeometry: ud,
					TextBufferGeometry: Hc,
					SphereGeometry: vd,
					SphereBufferGeometry: gh,
					RingGeometry: wd,
					RingBufferGeometry: Lc,
					PlaneGeometry: aa,
					PlaneBufferGeometry: Ba,
					LatheGeometry: Ed,
					LatheBufferGeometry: Sc,
					ShapeGeometry: di,
					ShapeBufferGeometry: ei,
					ExtrudeGeometry: ci,
					ExtrudeBufferGeometry: lf,
					EdgesGeometry: Vc,
					ConeGeometry: Fd,
					ConeBufferGeometry: Id,
					CylinderGeometry: fi,
					CylinderBufferGeometry: ig,
					CircleGeometry: Jd,
					CircleBufferGeometry: cd,
					BoxGeometry: bh,
					BoxBufferGeometry: qk
				});
				gi.prototype = p(F.prototype);
				gi.prototype.constructor = gi;
				gi.prototype.isShadowMaterial = !0;
				gi.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					return this
				};
				ed.prototype = p(sa.prototype);
				ed.prototype.constructor = ed;
				ed.prototype.isRawShaderMaterial = !0;
				mf.prototype = p(F.prototype);
				mf.prototype.constructor = mf;
				mf.prototype.isMeshStandardMaterial = !0;
				mf.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.defines = {
						STANDARD: ""
					};
					this.color.copy(a.color);
					this.roughness = a.roughness;
					this.metalness = a.metalness;
					this.map = a.map;
					this.lightMap = a.lightMap;
					this.lightMapIntensity = a.lightMapIntensity;
					this.aoMap = a.aoMap;
					this.aoMapIntensity = a.aoMapIntensity;
					this.emissive.copy(a.emissive);
					this.emissiveMap = a.emissiveMap;
					this.emissiveIntensity = a.emissiveIntensity;
					this.bumpMap = a.bumpMap;
					this.bumpScale = a.bumpScale;
					this.normalMap = a.normalMap;
					this.normalMapType = a.normalMapType;
					this.normalScale.copy(a.normalScale);
					this.displacementMap = a.displacementMap;
					this.displacementScale = a.displacementScale;
					this.displacementBias = a.displacementBias;
					this.roughnessMap = a.roughnessMap;
					this.metalnessMap = a.metalnessMap;
					this.alphaMap = a.alphaMap;
					this.envMap = a.envMap;
					this.envMapIntensity = a.envMapIntensity;
					this.refractionRatio = a.refractionRatio;
					this.wireframe = a.wireframe;
					this.wireframeLinewidth =
						a.wireframeLinewidth;
					this.wireframeLinecap = a.wireframeLinecap;
					this.wireframeLinejoin = a.wireframeLinejoin;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.morphNormals = a.morphNormals;
					return this
				};
				hi.prototype = p(mf.prototype);
				hi.prototype.constructor = hi;
				hi.prototype.isMeshPhysicalMaterial = !0;
				hi.prototype.copy = function(a) {
					mf.prototype.copy.call(this, a);
					this.defines = {
						STANDARD: "",
						PHYSICAL: ""
					};
					this.reflectivity = a.reflectivity;
					this.clearcoat = a.clearcoat;
					this.clearcoatRoughness = a.clearcoatRoughness;
					this.sheen = a.sheen ? (this.sheen || new Q).copy(a.sheen) : null;
					this.clearcoatNormalMap = a.clearcoatNormalMap;
					this.clearcoatNormalScale.copy(a.clearcoatNormalScale);
					this.transparency = a.transparency;
					return this
				};
				ne.prototype = p(F.prototype);
				ne.prototype.constructor = ne;
				ne.prototype.isMeshPhongMaterial = !0;
				ne.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					this.specular.copy(a.specular);
					this.shininess = a.shininess;
					this.map = a.map;
					this.lightMap = a.lightMap;
					this.lightMapIntensity =
						a.lightMapIntensity;
					this.aoMap = a.aoMap;
					this.aoMapIntensity = a.aoMapIntensity;
					this.emissive.copy(a.emissive);
					this.emissiveMap = a.emissiveMap;
					this.emissiveIntensity = a.emissiveIntensity;
					this.bumpMap = a.bumpMap;
					this.bumpScale = a.bumpScale;
					this.normalMap = a.normalMap;
					this.normalMapType = a.normalMapType;
					this.normalScale.copy(a.normalScale);
					this.displacementMap = a.displacementMap;
					this.displacementScale = a.displacementScale;
					this.displacementBias = a.displacementBias;
					this.specularMap = a.specularMap;
					this.alphaMap = a.alphaMap;
					this.envMap = a.envMap;
					this.combine = a.combine;
					this.reflectivity = a.reflectivity;
					this.refractionRatio = a.refractionRatio;
					this.wireframe = a.wireframe;
					this.wireframeLinewidth = a.wireframeLinewidth;
					this.wireframeLinecap = a.wireframeLinecap;
					this.wireframeLinejoin = a.wireframeLinejoin;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.morphNormals = a.morphNormals;
					return this
				};
				ii.prototype = p(ne.prototype);
				ii.prototype.constructor = ii;
				ii.prototype.isMeshToonMaterial = !0;
				ii.prototype.copy = function(a) {
					ne.prototype.copy.call(this,
						a);
					this.gradientMap = a.gradientMap;
					return this
				};
				ji.prototype = p(F.prototype);
				ji.prototype.constructor = ji;
				ji.prototype.isMeshNormalMaterial = !0;
				ji.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.bumpMap = a.bumpMap;
					this.bumpScale = a.bumpScale;
					this.normalMap = a.normalMap;
					this.normalMapType = a.normalMapType;
					this.normalScale.copy(a.normalScale);
					this.displacementMap = a.displacementMap;
					this.displacementScale = a.displacementScale;
					this.displacementBias = a.displacementBias;
					this.wireframe = a.wireframe;
					this.wireframeLinewidth =
						a.wireframeLinewidth;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.morphNormals = a.morphNormals;
					return this
				};
				ki.prototype = p(F.prototype);
				ki.prototype.constructor = ki;
				ki.prototype.isMeshLambertMaterial = !0;
				ki.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.color.copy(a.color);
					this.map = a.map;
					this.lightMap = a.lightMap;
					this.lightMapIntensity = a.lightMapIntensity;
					this.aoMap = a.aoMap;
					this.aoMapIntensity = a.aoMapIntensity;
					this.emissive.copy(a.emissive);
					this.emissiveMap = a.emissiveMap;
					this.emissiveIntensity = a.emissiveIntensity;
					this.specularMap = a.specularMap;
					this.alphaMap = a.alphaMap;
					this.envMap = a.envMap;
					this.combine = a.combine;
					this.reflectivity = a.reflectivity;
					this.refractionRatio = a.refractionRatio;
					this.wireframe = a.wireframe;
					this.wireframeLinewidth = a.wireframeLinewidth;
					this.wireframeLinecap = a.wireframeLinecap;
					this.wireframeLinejoin = a.wireframeLinejoin;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.morphNormals = a.morphNormals;
					return this
				};
				li.prototype = p(F.prototype);
				li.prototype.constructor = li;
				li.prototype.isMeshMatcapMaterial = !0;
				li.prototype.copy = function(a) {
					F.prototype.copy.call(this, a);
					this.defines = {
						MATCAP: ""
					};
					this.color.copy(a.color);
					this.matcap = a.matcap;
					this.map = a.map;
					this.bumpMap = a.bumpMap;
					this.bumpScale = a.bumpScale;
					this.normalMap = a.normalMap;
					this.normalMapType = a.normalMapType;
					this.normalScale.copy(a.normalScale);
					this.displacementMap = a.displacementMap;
					this.displacementScale = a.displacementScale;
					this.displacementBias = a.displacementBias;
					this.alphaMap = a.alphaMap;
					this.skinning = a.skinning;
					this.morphTargets = a.morphTargets;
					this.morphNormals = a.morphNormals;
					return this
				};
				mi.prototype = p(Ka.prototype);
				mi.prototype.constructor = mi;
				mi.prototype.isLineDashedMaterial = !0;
				mi.prototype.copy = function(a) {
					Ka.prototype.copy.call(this, a);
					this.scale = a.scale;
					this.dashSize = a.dashSize;
					this.gapSize = a.gapSize;
					return this
				};
				var ak = Ag({
						ShadowMaterial: gi,
						SpriteMaterial: Eb,
						RawShaderMaterial: ed,
						ShaderMaterial: sa,
						PointsMaterial: me,
						MeshPhysicalMaterial: hi,
						MeshStandardMaterial: mf,
						MeshPhongMaterial: ne,
						MeshToonMaterial: ii,
						MeshNormalMaterial: ji,
						MeshLambertMaterial: ki,
						MeshDepthMaterial: tb,
						MeshDistanceMaterial: ub,
						MeshBasicMaterial: S,
						MeshMatcapMaterial: li,
						LineDashedMaterial: mi,
						LineBasicMaterial: Ka,
						Material: F
					}),
					sb = {
						arraySlice: function(a, b, c) {
							return sb.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
						},
						convertArray: function(a, b, c) {
							return !a || !c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype
								.slice.call(a)
						},
						isTypedArray: function(a) {
							return ArrayBuffer.isView(a) &&
								!(a instanceof DataView)
						},
						getKeyframeOrder: function(a) {
							for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
							c.sort(function(b, c) {
								return a[b] - a[c]
							});
							return c
						},
						sortedArray: function(a, b, c) {
							for (var d = a.length, h = new a.constructor(d), e = 0, f = 0; f !== d; ++e)
								for (var g = c[e] * b, k = 0; k !== b; ++k) h[f++] = a[g + k];
							return h
						},
						flattenJSON: function(a, b, c, d) {
							for (var h = 1, e = a[0]; void 0 !== e && void 0 === e[d];) e = a[h++];
							if (void 0 !== e) {
								var f = e[d];
								if (void 0 !== f)
									if (Array.isArray(f)) {
										do f = e[d], void 0 !== f && (b.push(e.time), c.push.apply(c, f)),
											e = a[h++]; while (void 0 !== e)
									} else if (void 0 !== f.toArray) {
									do f = e[d], void 0 !== f && (b.push(e.time), f.toArray(c, c.length)), e = a[h++]; while (void 0 !== e)
								} else {
									do f = e[d], void 0 !== f && (b.push(e.time), c.push(f)), e = a[h++]; while (void 0 !== e)
								}
							}
						}
					};
				q(Wc.prototype, {
					evaluate: function(a) {
						var b = this.parameterPositions,
							c = this._cachedIndex,
							d = b[c],
							h = b[c - 1];
						a: {
							b: {
								c: {
									d: if (!(a < d)) {
										for (var e = c + 2;;) {
											if (void 0 === d) {
												if (a < h) break d;
												this._cachedIndex = c = b.length;
												return this.afterEnd_(c - 1, a, h)
											}
											if (c === e) break;
											h = d;
											d = b[++c];
											if (a < d) break b
										}
										d =
											b.length;
										break c
									}if (a >= h) break a;
									else {
										e = b[1];
										a < e && (c = 2, h = e);
										for (e = c - 2;;) {
											if (void 0 === h) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
											if (c === e) break;
											d = h;
											h = b[--c - 1];
											if (a >= h) break b
										}
										d = c;
										c = 0
									}
								}
								for (; c < d;) h = c + d >>> 1,
								a < b[h] ? d = h : c = h + 1;d = b[c];h = b[c - 1];
								if (void 0 === h) return this._cachedIndex = 0,
								this.beforeStart_(0, a, d);
								if (void 0 === d) return this._cachedIndex = c = b.length,
								this.afterEnd_(c - 1, h, a)
							}
							this._cachedIndex = c;this.intervalChanged_(c, h, d)
						}
						return this.interpolate_(c, h, a, d)
					},
					settings: null,
					DefaultSettings_: {},
					getSettings_: function() {
						return this.settings || this.DefaultSettings_
					},
					copySampleValue_: function(a) {
						var b = this.resultBuffer,
							c = this.sampleValues,
							d = this.valueSize;
						a *= d;
						for (var h = 0; h !== d; ++h) b[h] = c[a + h];
						return b
					},
					interpolate_: function() {
						throw Error("call to abstract method");
					},
					intervalChanged_: function() {}
				});
				q(Wc.prototype, {
					beforeStart_: Wc.prototype.copySampleValue_,
					afterEnd_: Wc.prototype.copySampleValue_
				});
				Be.prototype = q(p(Wc.prototype), {
					constructor: Be,
					DefaultSettings_: {
						endingStart: 2400,
						endingEnd: 2400
					},
					intervalChanged_: function(a, b, c) {
						var d = this.parameterPositions,
							h = a - 2,
							e = a + 1,
							f = d[h],
							g = d[e];
						if (void 0 === f) switch (this.getSettings_().endingStart) {
							case 2401:
								h = a;
								f = 2 * b - c;
								break;
							case 2402:
								h = d.length - 2;
								f = b + d[h] - d[h + 1];
								break;
							default:
								h = a, f = c
						}
						if (void 0 === g) switch (this.getSettings_().endingEnd) {
							case 2401:
								e = a;
								g = 2 * c - b;
								break;
							case 2402:
								e = 1;
								g = c + d[1] - d[0];
								break;
							default:
								e = a - 1, g = b
						}
						a = .5 * (c - b);
						d = this.valueSize;
						this._weightPrev = a / (b - f);
						this._weightNext = a / (g - c);
						this._offsetPrev = h * d;
						this._offsetNext = e * d
					},
					interpolate_: function(a,
						b, c, d) {
						var h = this.resultBuffer,
							e = this.sampleValues,
							f = this.valueSize;
						a *= f;
						var g = a - f,
							k = this._offsetPrev,
							l = this._offsetNext,
							t = this._weightPrev,
							m = this._weightNext,
							n = (c - b) / (d - b);
						c = n * n;
						d = c * n;
						b = -t * d + 2 * t * c - t * n;
						t = (1 + t) * d + (-1.5 - 2 * t) * c + (-.5 + t) * n + 1;
						n = (-1 - m) * d + (1.5 + m) * c + .5 * n;
						m = m * d - m * c;
						for (c = 0; c !== f; ++c) h[c] = b * e[k + c] + t * e[g + c] + n * e[a + c] + m * e[l + c];
						return h
					}
				});
				Ld.prototype = q(p(Wc.prototype), {
					constructor: Ld,
					interpolate_: function(a, b, c, d) {
						var h = this.resultBuffer,
							e = this.sampleValues,
							f = this.valueSize;
						a *= f;
						var g = a - f;
						b = (c -
							b) / (d - b);
						c = 1 - b;
						for (d = 0; d !== f; ++d) h[d] = e[g + d] * c + e[a + d] * b;
						return h
					}
				});
				Ce.prototype = q(p(Wc.prototype), {
					constructor: Ce,
					interpolate_: function(a) {
						return this.copySampleValue_(a - 1)
					}
				});
				q(Ab, {
					toJSON: function(a) {
						var b = a.constructor;
						if (void 0 !== b.toJSON) b = b.toJSON(a);
						else {
							b = {
								name: a.name,
								times: sb.convertArray(a.times, Array),
								values: sb.convertArray(a.values, Array)
							};
							var c = a.getInterpolation();
							c !== a.DefaultInterpolation && (b.interpolation = c)
						}
						b.type = a.ValueTypeName;
						return b
					}
				});
				q(Ab.prototype, {
					constructor: Ab,
					TimeBufferType: Float32Array,
					ValueBufferType: Float32Array,
					DefaultInterpolation: 2301,
					InterpolantFactoryMethodDiscrete: function(a) {
						return new Ce(this.times, this.values, this.getValueSize(), a)
					},
					InterpolantFactoryMethodLinear: function(a) {
						return new Ld(this.times, this.values, this.getValueSize(), a)
					},
					InterpolantFactoryMethodSmooth: function(a) {
						return new Be(this.times, this.values, this.getValueSize(), a)
					},
					setInterpolation: function(a) {
						switch (a) {
							case 2300:
								var b = this.InterpolantFactoryMethodDiscrete;
								break;
							case 2301:
								b = this.InterpolantFactoryMethodLinear;
								break;
							case 2302:
								b = this.InterpolantFactoryMethodSmooth
						}
						if (void 0 === b) {
							b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
							if (void 0 === this.createInterpolant)
								if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
								else throw Error(b);
							console.warn("THREE.KeyframeTrack:", b);
							return this
						}
						this.createInterpolant = b;
						return this
					},
					getInterpolation: function() {
						switch (this.createInterpolant) {
							case this.InterpolantFactoryMethodDiscrete:
								return 2300;
							case this.InterpolantFactoryMethodLinear:
								return 2301;
							case this.InterpolantFactoryMethodSmooth:
								return 2302
						}
					},
					getValueSize: function() {
						return this.values.length / this.times.length
					},
					shift: function(a) {
						if (0 !== a)
							for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
						return this
					},
					scale: function(a) {
						if (1 !== a)
							for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] *= a;
						return this
					},
					trim: function(a, b) {
						for (var c = this.times, d = c.length, h = 0, e = d - 1; h !== d && c[h] < a;) ++h;
						for (; - 1 !== e && c[e] > b;) --e;
						++e;
						if (0 !== h || e !== d) h >= e && (e = Math.max(e, 1), h = e - 1), a = this.getValueSize(), this.times = sb
							.arraySlice(c,
								h, e), this.values = sb.arraySlice(this.values, h * a, e * a);
						return this
					},
					validate: function() {
						var a = !0,
							b = this.getValueSize();
						0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !
							1);
						var c = this.times;
						b = this.values;
						var d = c.length;
						0 === d && (console.error("THREE.KeyframeTrack: Track is empty.", this), a = !1);
						for (var e = null, f = 0; f !== d; f++) {
							var g = c[f];
							if ("number" === typeof g && isNaN(g)) {
								console.error("THREE.KeyframeTrack: Time is not a valid number.", this, f, g);
								a = !1;
								break
							}
							if (null !==
								e && e > g) {
								console.error("THREE.KeyframeTrack: Out of order keys.", this, f, g, e);
								a = !1;
								break
							}
							e = g
						}
						if (void 0 !== b && sb.isTypedArray(b))
							for (f = 0, c = b.length; f !== c; ++f)
								if (d = b[f], isNaN(d)) {
									console.error("THREE.KeyframeTrack: Value is not a valid number.", this, f, d);
									a = !1;
									break
								} return a
					},
					optimize: function() {
						for (var a = this.times, b = this.values, c = this.getValueSize(), d = 2302 === this.getInterpolation(), e =
								1, f = a.length - 1, g = 1; g < f; ++g) {
							var k = !1,
								l = a[g];
							if (l !== a[g + 1] && (1 !== g || l !== l[0]))
								if (d) k = !0;
								else {
									var m = g * c,
										n = m - c,
										r = m + c;
									for (l =
										0; l !== c; ++l) {
										var p = b[m + l];
										if (p !== b[n + l] || p !== b[r + l]) {
											k = !0;
											break
										}
									}
								} if (k) {
								if (g !== e)
									for (a[e] = a[g], k = g * c, m = e * c, l = 0; l !== c; ++l) b[m + l] = b[k + l];
								++e
							}
						}
						if (0 < f) {
							a[e] = a[f];
							k = f * c;
							m = e * c;
							for (l = 0; l !== c; ++l) b[m + l] = b[k + l];
							++e
						}
						e !== a.length && (this.times = sb.arraySlice(a, 0, e), this.values = sb.arraySlice(b, 0, e * c));
						return this
					},
					clone: function() {
						var a = sb.arraySlice(this.times, 0),
							b = sb.arraySlice(this.values, 0);
						a = new this.constructor(this.name, a, b);
						a.createInterpolant = this.createInterpolant;
						return a
					}
				});
				De.prototype = q(p(Ab.prototype), {
					constructor: De,
					ValueTypeName: "bool",
					ValueBufferType: Array,
					DefaultInterpolation: 2300,
					InterpolantFactoryMethodLinear: void 0,
					InterpolantFactoryMethodSmooth: void 0
				});
				Ee.prototype = q(p(Ab.prototype), {
					constructor: Ee,
					ValueTypeName: "color"
				});
				id.prototype = q(p(Ab.prototype), {
					constructor: id,
					ValueTypeName: "number"
				});
				Ge.prototype = q(p(Wc.prototype), {
					constructor: Ge,
					interpolate_: function(a, b, c, d) {
						var h = this.resultBuffer,
							f = this.sampleValues,
							g = this.valueSize;
						a *= g;
						b = (c - b) / (d - b);
						for (c = a + g; a !== c; a += 4) e.slerpFlat(h, 0,
							f, a - g, f, a, b);
						return h
					}
				});
				Pd.prototype = q(p(Ab.prototype), {
					constructor: Pd,
					ValueTypeName: "quaternion",
					DefaultInterpolation: 2301,
					InterpolantFactoryMethodLinear: function(a) {
						return new Ge(this.times, this.values, this.getValueSize(), a)
					},
					InterpolantFactoryMethodSmooth: void 0
				});
				Ke.prototype = q(p(Ab.prototype), {
					constructor: Ke,
					ValueTypeName: "string",
					ValueBufferType: Array,
					DefaultInterpolation: 2300,
					InterpolantFactoryMethodLinear: void 0,
					InterpolantFactoryMethodSmooth: void 0
				});
				ld.prototype = q(p(Ab.prototype), {
					constructor: ld,
					ValueTypeName: "vector"
				});
				q(Gd, {
					parse: function(a) {
						for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), h = 0, e = c.length; h !== e; ++h) b.push(wh(c[h]).scale(
							d));
						return new Gd(a.name, a.duration, b)
					},
					toJSON: function(a) {
						var b = [],
							c = a.tracks;
						a = {
							name: a.name,
							duration: a.duration,
							tracks: b,
							uuid: a.uuid
						};
						for (var d = 0, h = c.length; d !== h; ++d) b.push(Ab.toJSON(c[d]));
						return a
					},
					CreateFromMorphTargetSequence: function(a, b, c, d) {
						for (var h = b.length, e = [], f = 0; f < h; f++) {
							var g = [],
								k = [];
							g.push((f + h - 1) % h, f, (f + 1) % h);
							k.push(0, 1, 0);
							var l = sb.getKeyframeOrder(g);
							g = sb.sortedArray(g, 1, l);
							k = sb.sortedArray(k, 1, l);
							d || 0 !== g[0] || (g.push(h), k.push(k[0]));
							e.push((new id(".morphTargetInfluences[" + b[f].name + "]", g, k)).scale(1 / c))
						}
						return new Gd(a, -1, e)
					},
					findByName: function(a, b) {
						var c = a;
						Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
						for (a = 0; a < c.length; a++)
							if (c[a].name === b) return c[a];
						return null
					},
					CreateClipsFromMorphTargetSequences: function(a, b, c) {
						for (var d = {}, h = /^([\w-]*?)([\d]+)$/, e = 0, f = a.length; e < f; e++) {
							var g = a[e],
								k = g.name.match(h);
							if (k && 1 < k.length) {
								var l =
									k[1];
								(k = d[l]) || (d[l] = k = []);
								k.push(g)
							}
						}
						a = [];
						for (l in d) a.push(Gd.CreateFromMorphTargetSequence(l, d[l], b, c));
						return a
					},
					parseAnimation: function(a, b) {
						if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
						var c = function(a, b, c, d, h) {
								if (0 !== c.length) {
									var e = [],
										f = [];
									sb.flattenJSON(c, e, f, d);
									0 !== e.length && h.push(new a(b, e, f))
								}
							},
							d = [],
							h = a.name || "default",
							e = a.length || -1,
							f = a.fps || 30;
						a = a.hierarchy || [];
						for (var g = 0; g < a.length; g++) {
							var k = a[g].keys;
							if (k && 0 !== k.length)
								if (k[0].morphTargets) {
									e = {};
									for (var l = 0; l < k.length; l++)
										if (k[l].morphTargets)
											for (var t = 0; t < k[l].morphTargets.length; t++) e[k[l].morphTargets[t]] = -1;
									for (var m in e) {
										var n = [],
											r = [];
										for (t = 0; t !== k[l].morphTargets.length; ++t) {
											var p = k[l];
											n.push(p.time);
											r.push(p.morphTarget === m ? 1 : 0)
										}
										d.push(new id(".morphTargetInfluence[" + m + "]", n, r))
									}
									e = e.length * (f || 1)
								} else l = ".bones[" + b[g].name + "]", c(ld, l + ".position", k, "pos", d), c(Pd, l + ".quaternion", k,
									"rot", d), c(ld, l + ".scale", k, "scl", d)
						}
						return 0 === d.length ? null : new Gd(h, e, d)
					}
				});
				q(Gd.prototype, {
					resetDuration: function() {
						for (var a =
								0, b = 0, c = this.tracks.length; b !== c; ++b) {
							var d = this.tracks[b];
							a = Math.max(a, d.times[d.times.length - 1])
						}
						this.duration = a;
						return this
					},
					trim: function() {
						for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
						return this
					},
					validate: function() {
						for (var a = !0, b = 0; b < this.tracks.length; b++) a = a && this.tracks[b].validate();
						return a
					},
					optimize: function() {
						for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
						return this
					},
					clone: function() {
						for (var a = [], b = 0; b < this.tracks.length; b++) a.push(this.tracks[b].clone());
						return new Gd(this.name, this.duration, a)
					}
				});
				var ri = {
						enabled: !1,
						files: {},
						add: function(a, b) {
							!1 !== this.enabled && (this.files[a] = b)
						},
						get: function(a) {
							if (!1 !== this.enabled) return this.files[a]
						},
						remove: function(a) {
							delete this.files[a]
						},
						clear: function() {
							this.files = {}
						}
					},
					Oi = new xf;
				q(Qa.prototype, {
					load: function() {},
					parse: function() {},
					setCrossOrigin: function(a) {
						this.crossOrigin = a;
						return this
					},
					setPath: function(a) {
						this.path = a;
						return this
					},
					setResourcePath: function(a) {
						this.resourcePath = a;
						return this
					}
				});
				var we = {};
				Hd.prototype = q(p(Qa.prototype), {
					constructor: Hd,
					load: function(a, b, c, d) {
						void 0 === a && (a = "");
						void 0 !== this.path && (a = this.path + a);
						a = this.manager.resolveURL(a);
						var h = this,
							e = ri.get(a);
						if (void 0 !== e) return h.manager.itemStart(a), setTimeout(function() {
							b && b(e);
							h.manager.itemEnd(a)
						}, 0), e;
						if (void 0 !== we[a]) we[a].push({
							onLoad: b,
							onProgress: c,
							onError: d
						});
						else {
							var f = a.match(/^data:(.*?)(;base64)?,(.*)$/);
							if (f) {
								c = f[1];
								var g = !!f[2];
								f = f[3];
								f = decodeURIComponent(f);
								g && (f = atob(f));
								try {
									var k = (this.responseType || "").toLowerCase();
									switch (k) {
										case "arraybuffer":
										case "blob":
											var l = new Uint8Array(f.length);
											for (g = 0; g < f.length; g++) l[g] = f.charCodeAt(g);
											var t = "blob" === k ? new Blob([l.buffer], {
												type: c
											}) : l.buffer;
											break;
										case "document":
											t = (new DOMParser).parseFromString(f, c);
											break;
										case "json":
											t = JSON.parse(f);
											break;
										default:
											t = f
									}
									setTimeout(function() {
										b && b(t);
										h.manager.itemEnd(a)
									}, 0)
								} catch (fs) {
									setTimeout(function() {
										d && d(fs);
										h.manager.itemError(a);
										h.manager.itemEnd(a)
									}, 0)
								}
							} else {
								we[a] = [];
								we[a].push({
									onLoad: b,
									onProgress: c,
									onError: d
								});
								var m = new XMLHttpRequest;
								m.open("GET", a, !0);
								m.addEventListener("load", function(b) {
									var c = this.response;
									ri.add(a, c);
									var d = we[a];
									delete we[a];
									if (200 === this.status || 0 === this.status) {
										0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
										for (var e = 0, f = d.length; e < f; e++) {
											var g = d[e];
											if (g.onLoad) g.onLoad(c)
										}
									} else {
										e = 0;
										for (f = d.length; e < f; e++)
											if (g = d[e], g.onError) g.onError(b);
										h.manager.itemError(a)
									}
									h.manager.itemEnd(a)
								}, !1);
								m.addEventListener("progress", function(b) {
									for (var c = we[a], d = 0, h = c.length; d < h; d++) {
										var e = c[d];
										if (e.onProgress) e.onProgress(b)
									}
								}, !1);
								m.addEventListener("error", function(b) {
									var c = we[a];
									delete we[a];
									for (var d = 0, e = c.length; d < e; d++) {
										var f = c[d];
										if (f.onError) f.onError(b)
									}
									h.manager.itemError(a);
									h.manager.itemEnd(a)
								}, !1);
								m.addEventListener("abort", function(b) {
									var c = we[a];
									delete we[a];
									for (var d = 0, e = c.length; d < e; d++) {
										var f = c[d];
										if (f.onError) f.onError(b)
									}
									h.manager.itemError(a);
									h.manager.itemEnd(a)
								}, !1);
								void 0 !== this.responseType && (m.responseType = this.responseType);
								void 0 !== this.withCredentials && (m.withCredentials =
									this.withCredentials);
								m.overrideMimeType && m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
								for (g in this.requestHeader) m.setRequestHeader(g, this.requestHeader[g]);
								m.send(null)
							}
							h.manager.itemStart(a);
							return m
						}
					},
					setResponseType: function(a) {
						this.responseType = a;
						return this
					},
					setWithCredentials: function(a) {
						this.withCredentials = a;
						return this
					},
					setMimeType: function(a) {
						this.mimeType = a;
						return this
					},
					setRequestHeader: function(a) {
						this.requestHeader = a;
						return this
					}
				});
				yf.prototype = q(p(Qa.prototype), {
					constructor: yf,
					load: function(a, b, c, d) {
						var h = this,
							e = new Hd(h.manager);
						e.setPath(h.path);
						e.load(a, function(a) {
							b(h.parse(JSON.parse(a)))
						}, c, d)
					},
					parse: function(a) {
						for (var b = [], c = 0; c < a.length; c++) {
							var d = Gd.parse(a[c]);
							b.push(d)
						}
						return b
					}
				});
				zf.prototype = q(p(Qa.prototype), {
					constructor: zf,
					load: function(a, b, c, d) {
						function h(h) {
							k.load(a[h], function(a) {
								a = e.parse(a, !0);
								f[h] = {
									width: a.width,
									height: a.height,
									format: a.format,
									mipmaps: a.mipmaps
								};
								l += 1;
								6 === l && (1 === a.mipmapCount && (g.minFilter = 1006), g.format = a.format, g.needsUpdate = !0, b &&
									b(g))
							}, c, d)
						}
						var e = this,
							f = [],
							g = new gc;
						g.image = f;
						var k = new Hd(this.manager);
						k.setPath(this.path);
						k.setResponseType("arraybuffer");
						if (Array.isArray(a))
							for (var l = 0, t = 0, m = a.length; t < m; ++t) h(t);
						else k.load(a, function(a) {
							a = e.parse(a, !0);
							if (a.isCubemap)
								for (var c = a.mipmaps.length / a.mipmapCount, d = 0; d < c; d++) {
									f[d] = {
										mipmaps: []
									};
									for (var h = 0; h < a.mipmapCount; h++) f[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + h]), f[d].format =
										a.format, f[d].width = a.width, f[d].height = a.height
								} else g.image.width = a.width, g.image.height =
									a.height, g.mipmaps = a.mipmaps;
							1 === a.mipmapCount && (g.minFilter = 1006);
							g.format = a.format;
							g.needsUpdate = !0;
							b && b(g)
						}, c, d);
						return g
					}
				});
				Oe.prototype = q(p(Qa.prototype), {
					constructor: Oe,
					load: function(a, b, c, d) {
						var h = this,
							e = new Ia,
							f = new Hd(this.manager);
						f.setResponseType("arraybuffer");
						f.setPath(this.path);
						f.load(a, function(a) {
							if (a = h.parse(a)) void 0 !== a.image ? e.image = a.image : void 0 !== a.data && (e.image.width = a.width,
									e.image.height = a.height, e.image.data = a.data), e.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, e.wrapT =
								void 0 !==
								a.wrapT ? a.wrapT : 1001, e.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, e.minFilter = void 0 !==
								a.minFilter ? a.minFilter : 1008, e.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !==
								a.format && (e.format = a.format), void 0 !== a.type && (e.type = a.type), void 0 !== a.mipmaps && (e.mipmaps =
									a.mipmaps), 1 === a.mipmapCount && (e.minFilter = 1006), e.needsUpdate = !0, b && b(e, a)
						}, c, d);
						return e
					}
				});
				Aj.prototype = q(p(Qa.prototype), {
					constructor: Aj,
					load: function(a, b, c, d) {
						function h() {
							k.removeEventListener("load", h, !1);
							k.removeEventListener("error",
								e, !1);
							ri.add(a, this);
							b && b(this);
							f.manager.itemEnd(a)
						}

						function e(b) {
							k.removeEventListener("load", h, !1);
							k.removeEventListener("error", e, !1);
							d && d(b);
							f.manager.itemError(a);
							f.manager.itemEnd(a)
						}
						void 0 !== this.path && (a = this.path + a);
						a = this.manager.resolveURL(a);
						var f = this,
							g = ri.get(a);
						if (void 0 !== g) return f.manager.itemStart(a), setTimeout(function() {
							b && b(g);
							f.manager.itemEnd(a)
						}, 0), g;
						var k = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
						k.addEventListener("load", h, !1);
						k.addEventListener("error",
							e, !1);
						"data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (k.crossOrigin = this.crossOrigin);
						f.manager.itemStart(a);
						k.src = a;
						return k
					}
				});
				Pe.prototype = q(p(Qa.prototype), {
					constructor: Pe,
					load: function(a, b, c, d) {
						function h(c) {
							f.load(a[c], function(a) {
								e.images[c] = a;
								g++;
								6 === g && (e.needsUpdate = !0, b && b(e))
							}, void 0, d)
						}
						var e = new Ua,
							f = new Aj(this.manager);
						f.setCrossOrigin(this.crossOrigin);
						f.setPath(this.path);
						var g = 0;
						for (c = 0; c < a.length; ++c) h(c);
						return e
					}
				});
				Qe.prototype = q(p(Qa.prototype), {
					constructor: Qe,
					load: function(a,
						b, c, d) {
						var h = new l,
							e = new Aj(this.manager);
						e.setCrossOrigin(this.crossOrigin);
						e.setPath(this.path);
						e.load(a, function(c) {
							h.image = c;
							c = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/);
							h.format = c ? 1022 : 1023;
							h.needsUpdate = !0;
							void 0 !== b && b(h)
						}, c, d);
						return h
					}
				});
				q(oa.prototype, {
					getPoint: function() {
						console.warn("THREE.Curve: .getPoint() not implemented.");
						return null
					},
					getPointAt: function(a, b) {
						a = this.getUtoTmapping(a);
						return this.getPoint(a, b)
					},
					getPoints: function(a) {
						void 0 === a && (a = 5);
						for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
						return b
					},
					getSpacedPoints: function(a) {
						void 0 === a && (a = 5);
						for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
						return b
					},
					getLength: function() {
						var a = this.getLengths();
						return a[a.length - 1]
					},
					getLengths: function(a) {
						void 0 === a && (a = this.arcLengthDivisions);
						if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
						this.needsUpdate = !1;
						var b = [],
							c = this.getPoint(0),
							d, h = 0;
						b.push(0);
						for (d = 1; d <= a; d++) {
							var e = this.getPoint(d /
								a);
							h += e.distanceTo(c);
							b.push(h);
							c = e
						}
						return this.cacheArcLengths = b
					},
					updateArcLengths: function() {
						this.needsUpdate = !0;
						this.getLengths()
					},
					getUtoTmapping: function(a, b) {
						var c = this.getLengths(),
							d = c.length;
						b = b ? b : a * c[d - 1];
						for (var h = 0, e = d - 1, f; h <= e;)
							if (a = Math.floor(h + (e - h) / 2), f = c[a] - b, 0 > f) h = a + 1;
							else if (0 < f) e = a - 1;
						else {
							e = a;
							break
						}
						a = e;
						if (c[a] === b) return a / (d - 1);
						h = c[a];
						return (a + (b - h) / (c[a + 1] - h)) / (d - 1)
					},
					getTangent: function(a) {
						var b = a - 1E-4;
						a += 1E-4;
						0 > b && (b = 0);
						1 < a && (a = 1);
						b = this.getPoint(b);
						return this.getPoint(a).clone().sub(b).normalize()
					},
					getTangentAt: function(a) {
						a = this.getUtoTmapping(a);
						return this.getTangent(a)
					},
					computeFrenetFrames: function(a, b) {
						var c = new f,
							d = [],
							h = [],
							e = [],
							g = new f,
							k = new v,
							l;
						for (l = 0; l <= a; l++) {
							var t = l / a;
							d[l] = this.getTangentAt(t);
							d[l].normalize()
						}
						h[0] = new f;
						e[0] = new f;
						l = Number.MAX_VALUE;
						t = Math.abs(d[0].x);
						var m = Math.abs(d[0].y),
							n = Math.abs(d[0].z);
						t <= l && (l = t, c.set(1, 0, 0));
						m <= l && (l = m, c.set(0, 1, 0));
						n <= l && c.set(0, 0, 1);
						g.crossVectors(d[0], c).normalize();
						h[0].crossVectors(d[0], g);
						e[0].crossVectors(d[0], h[0]);
						for (l = 1; l <= a; l++) h[l] =
							h[l - 1].clone(), e[l] = e[l - 1].clone(), g.crossVectors(d[l - 1], d[l]), g.length() > Na && (g.normalize(),
								c = Math.acos(Ea.clamp(d[l - 1].dot(d[l]), -1, 1)), h[l].applyMatrix4(k.makeRotationAxis(g, c))), e[l].crossVectors(
								d[l], h[l]);
						if (!0 === b)
							for (c = Math.acos(Ea.clamp(h[0].dot(h[a]), -1, 1)), c /= a, 0 < d[0].dot(g.crossVectors(h[0], h[a])) && (
									c = -c), l = 1; l <= a; l++) h[l].applyMatrix4(k.makeRotationAxis(d[l], c * l)), e[l].crossVectors(d[l],
								h[l]);
						return {
							tangents: d,
							normals: h,
							binormals: e
						}
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.arcLengthDivisions = a.arcLengthDivisions;
						return this
					},
					toJSON: function() {
						var a = {
							metadata: {
								version: 4.5,
								type: "Curve",
								generator: "Curve.toJSON"
							}
						};
						a.arcLengthDivisions = this.arcLengthDivisions;
						a.type = this.type;
						return a
					},
					fromJSON: function(a) {
						this.arcLengthDivisions = a.arcLengthDivisions;
						return this
					}
				});
				Xc.prototype = p(oa.prototype);
				Xc.prototype.constructor = Xc;
				Xc.prototype.isEllipseCurve = !0;
				Xc.prototype.getPoint = function(a, b) {
					b = b || new d;
					for (var c = 2 * Math.PI, h = this.aEndAngle - this.aStartAngle,
							e = Math.abs(h) < Na; 0 > h;) h += c;
					for (; h > c;) h -= c;
					h < Na && (h = e ? 0 : c);
					!0 !== this.aClockwise || e || (h = h === c ? -c : h - c);
					c = this.aStartAngle + a * h;
					a = this.aX + this.xRadius * Math.cos(c);
					var f = this.aY + this.yRadius * Math.sin(c);
					0 !== this.aRotation && (c = Math.cos(this.aRotation), h = Math.sin(this.aRotation), e = a - this.aX, f -=
						this.aY, a = e * c - f * h + this.aX, f = e * h + f * c + this.aY);
					return b.set(a, f)
				};
				Xc.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.aX = a.aX;
					this.aY = a.aY;
					this.xRadius = a.xRadius;
					this.yRadius = a.yRadius;
					this.aStartAngle =
						a.aStartAngle;
					this.aEndAngle = a.aEndAngle;
					this.aClockwise = a.aClockwise;
					this.aRotation = a.aRotation;
					return this
				};
				Xc.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.aX = this.aX;
					a.aY = this.aY;
					a.xRadius = this.xRadius;
					a.yRadius = this.yRadius;
					a.aStartAngle = this.aStartAngle;
					a.aEndAngle = this.aEndAngle;
					a.aClockwise = this.aClockwise;
					a.aRotation = this.aRotation;
					return a
				};
				Xc.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.aX = a.aX;
					this.aY = a.aY;
					this.xRadius = a.xRadius;
					this.yRadius =
						a.yRadius;
					this.aStartAngle = a.aStartAngle;
					this.aEndAngle = a.aEndAngle;
					this.aClockwise = a.aClockwise;
					this.aRotation = a.aRotation;
					return this
				};
				Bj.prototype = p(Xc.prototype);
				Bj.prototype.constructor = Bj;
				Bj.prototype.isArcCurve = !0;
				var Ik = new f,
					yh = new Bf,
					zh = new Bf,
					Bh = new Bf;
				Kb.prototype = p(oa.prototype);
				Kb.prototype.constructor = Kb;
				Kb.prototype.isCatmullRomCurve3 = !0;
				Kb.prototype.getPoint = function(a, b) {
					b = b || new f;
					var c = this.points,
						d = c.length;
					a *= d - (this.closed ? 0 : 1);
					var h = Math.floor(a);
					a -= h;
					this.closed ? h += 0 < h ? 0 :
						(Math.floor(Math.abs(h) / d) + 1) * d : 0 === a && h === d - 1 && (h = d - 2, a = 1);
					if (this.closed || 0 < h) var e = c[(h - 1) % d];
					else Ik.subVectors(c[0], c[1]).add(c[0]), e = Ik;
					var g = c[h % d];
					var k = c[(h + 1) % d];
					this.closed || h + 2 < d ? c = c[(h + 2) % d] : (Ik.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = Ik);
					if ("centripetal" === this.curveType || "chordal" === this.curveType) {
						var l = "chordal" === this.curveType ? .5 : .25;
						d = Math.pow(e.distanceToSquared(g), l);
						h = Math.pow(g.distanceToSquared(k), l);
						l = Math.pow(k.distanceToSquared(c), l);
						1E-4 > h && (h = 1);
						1E-4 > d && (d = h);
						1E-4 > l &&
							(l = h);
						yh.initNonuniformCatmullRom(e.x, g.x, k.x, c.x, d, h, l);
						zh.initNonuniformCatmullRom(e.y, g.y, k.y, c.y, d, h, l);
						Bh.initNonuniformCatmullRom(e.z, g.z, k.z, c.z, d, h, l)
					} else "catmullrom" === this.curveType && (yh.initCatmullRom(e.x, g.x, k.x, c.x, this.tension), zh.initCatmullRom(
						e.y, g.y, k.y, c.y, this.tension), Bh.initCatmullRom(e.z, g.z, k.z, c.z, this.tension));
					b.set(yh.calc(a), zh.calc(a), Bh.calc(a));
					return b
				};
				Kb.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.points = [];
					for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
					this.closed = a.closed;
					this.curveType = a.curveType;
					this.tension = a.tension;
					return this
				};
				Kb.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.points = [];
					for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
					a.closed = this.closed;
					a.curveType = this.curveType;
					a.tension = this.tension;
					return a
				};
				Kb.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.points = [];
					for (var b = 0, c = a.points.length; b < c; b++) {
						var d = a.points[b];
						this.points.push((new f).fromArray(d))
					}
					this.closed =
						a.closed;
					this.curveType = a.curveType;
					this.tension = a.tension;
					return this
				};
				oe.prototype = p(oa.prototype);
				oe.prototype.constructor = oe;
				oe.prototype.isCubicBezierCurve = !0;
				oe.prototype.getPoint = function(a, b) {
					b = b || new d;
					var c = this.v0,
						h = this.v1,
						e = this.v2,
						f = this.v3;
					b.set(be(a, c.x, h.x, e.x, f.x), be(a, c.y, h.y, e.y, f.y));
					return b
				};
				oe.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.v0.copy(a.v0);
					this.v1.copy(a.v1);
					this.v2.copy(a.v2);
					this.v3.copy(a.v3);
					return this
				};
				oe.prototype.toJSON = function() {
					var a =
						oa.prototype.toJSON.call(this);
					a.v0 = this.v0.toArray();
					a.v1 = this.v1.toArray();
					a.v2 = this.v2.toArray();
					a.v3 = this.v3.toArray();
					return a
				};
				oe.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.v0.fromArray(a.v0);
					this.v1.fromArray(a.v1);
					this.v2.fromArray(a.v2);
					this.v3.fromArray(a.v3);
					return this
				};
				nf.prototype = p(oa.prototype);
				nf.prototype.constructor = nf;
				nf.prototype.isCubicBezierCurve3 = !0;
				nf.prototype.getPoint = function(a, b) {
					b = b || new f;
					var c = this.v0,
						d = this.v1,
						h = this.v2,
						e = this.v3;
					b.set(be(a,
						c.x, d.x, h.x, e.x), be(a, c.y, d.y, h.y, e.y), be(a, c.z, d.z, h.z, e.z));
					return b
				};
				nf.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.v0.copy(a.v0);
					this.v1.copy(a.v1);
					this.v2.copy(a.v2);
					this.v3.copy(a.v3);
					return this
				};
				nf.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.v0 = this.v0.toArray();
					a.v1 = this.v1.toArray();
					a.v2 = this.v2.toArray();
					a.v3 = this.v3.toArray();
					return a
				};
				nf.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.v0.fromArray(a.v0);
					this.v1.fromArray(a.v1);
					this.v2.fromArray(a.v2);
					this.v3.fromArray(a.v3);
					return this
				};
				pc.prototype = p(oa.prototype);
				pc.prototype.constructor = pc;
				pc.prototype.isLineCurve = !0;
				pc.prototype.getPoint = function(a, b) {
					b = b || new d;
					1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
					return b
				};
				pc.prototype.getPointAt = function(a, b) {
					return this.getPoint(a, b)
				};
				pc.prototype.getTangent = function() {
					return this.v2.clone().sub(this.v1).normalize()
				};
				pc.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.v1.copy(a.v1);
					this.v2.copy(a.v2);
					return this
				};
				pc.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.v1 = this.v1.toArray();
					a.v2 = this.v2.toArray();
					return a
				};
				pc.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.v1.fromArray(a.v1);
					this.v2.fromArray(a.v2);
					return this
				};
				pe.prototype = p(oa.prototype);
				pe.prototype.constructor = pe;
				pe.prototype.isLineCurve3 = !0;
				pe.prototype.getPoint = function(a, b) {
					b = b || new f;
					1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
					return b
				};
				pe.prototype.getPointAt = function(a, b) {
					return this.getPoint(a, b)
				};
				pe.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.v1.copy(a.v1);
					this.v2.copy(a.v2);
					return this
				};
				pe.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.v1 = this.v1.toArray();
					a.v2 = this.v2.toArray();
					return a
				};
				pe.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.v1.fromArray(a.v1);
					this.v2.fromArray(a.v2);
					return this
				};
				qe.prototype = p(oa.prototype);
				qe.prototype.constructor = qe;
				qe.prototype.isQuadraticBezierCurve = !0;
				qe.prototype.getPoint = function(a, b) {
					b = b || new d;
					var c = this.v0,
						h = this.v1,
						e = this.v2;
					b.set(ae(a, c.x, h.x, e.x), ae(a, c.y, h.y, e.y));
					return b
				};
				qe.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.v0.copy(a.v0);
					this.v1.copy(a.v1);
					this.v2.copy(a.v2);
					return this
				};
				qe.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.v0 = this.v0.toArray();
					a.v1 = this.v1.toArray();
					a.v2 = this.v2.toArray();
					return a
				};
				qe.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.v0.fromArray(a.v0);
					this.v1.fromArray(a.v1);
					this.v2.fromArray(a.v2);
					return this
				}; of .prototype = p(oa.prototype); of .prototype.constructor = of ; of .prototype.isQuadraticBezierCurve3 = !0; of
				.prototype.getPoint = function(a, b) {
					b = b || new f;
					var c = this.v0,
						d = this.v1,
						h = this.v2;
					b.set(ae(a, c.x, d.x, h.x), ae(a, c.y, d.y, h.y), ae(a, c.z, d.z, h.z));
					return b
				}; of .prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.v0.copy(a.v0);
					this.v1.copy(a.v1);
					this.v2.copy(a.v2);
					return this
				}; of .prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.v0 = this.v0.toArray();
					a.v1 = this.v1.toArray();
					a.v2 = this.v2.toArray();
					return a
				}; of .prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.v0.fromArray(a.v0);
					this.v1.fromArray(a.v1);
					this.v2.fromArray(a.v2);
					return this
				};
				re.prototype = p(oa.prototype);
				re.prototype.constructor = re;
				re.prototype.isSplineCurve = !0;
				re.prototype.getPoint = function(a, b) {
					b = b || new d;
					var c = this.points,
						h = (c.length - 1) * a;
					a = Math.floor(h);
					h -= a;
					var e = c[0 === a ? a : a - 1],
						f = c[a],
						g = c[a > c.length - 2 ? c.length - 1 : a + 1];
					c = c[a > c.length - 3 ?
						c.length - 1 : a + 2];
					b.set(Hg(h, e.x, f.x, g.x, c.x), Hg(h, e.y, f.y, g.y, c.y));
					return b
				};
				re.prototype.copy = function(a) {
					oa.prototype.copy.call(this, a);
					this.points = [];
					for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
					return this
				};
				re.prototype.toJSON = function() {
					var a = oa.prototype.toJSON.call(this);
					a.points = [];
					for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
					return a
				};
				re.prototype.fromJSON = function(a) {
					oa.prototype.fromJSON.call(this, a);
					this.points = [];
					for (var b =
							0, c = a.points.length; b < c; b++) {
						var h = a.points[b];
						this.points.push((new d).fromArray(h))
					}
					return this
				};
				var Ch = Ag({
					ArcCurve: Bj,
					CatmullRomCurve3: Kb,
					CubicBezierCurve: oe,
					CubicBezierCurve3: nf,
					EllipseCurve: Xc,
					LineCurve: pc,
					LineCurve3: pe,
					QuadraticBezierCurve: qe,
					QuadraticBezierCurve3: of ,
					SplineCurve: re
				});
				jg.prototype = q(p(oa.prototype), {
					constructor: jg,
					add: function(a) {
						this.curves.push(a)
					},
					closePath: function() {
						var a = this.curves[0].getPoint(0),
							b = this.curves[this.curves.length - 1].getPoint(1);
						a.equals(b) || this.curves.push(new pc(b,
							a))
					},
					getPoint: function(a) {
						var b = a * this.getLength(),
							c = this.getCurveLengths();
						for (a = 0; a < c.length;) {
							if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 -
								b / c);
							a++
						}
						return null
					},
					getLength: function() {
						var a = this.getCurveLengths();
						return a[a.length - 1]
					},
					updateArcLengths: function() {
						this.needsUpdate = !0;
						this.cacheLengths = null;
						this.getCurveLengths()
					},
					getCurveLengths: function() {
						if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
						for (var a = [],
								b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
						return this.cacheLengths = a
					},
					getSpacedPoints: function(a) {
						void 0 === a && (a = 40);
						for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
						this.autoClose && b.push(b[0]);
						return b
					},
					getPoints: function(a) {
						a = a || 12;
						for (var b = [], c, d = 0, h = this.curves; d < h.length; d++) {
							var e = h[d];
							e = e.getPoints(e && e.isEllipseCurve ? 2 * a : e && (e.isLineCurve || e.isLineCurve3) ? 1 : e && e.isSplineCurve ?
								a * e.points.length : a);
							for (var f = 0; f < e.length; f++) {
								var g = e[f];
								c && c.equals(g) ||
									(b.push(g), c = g)
							}
						}
						this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
						return b
					},
					copy: function(a) {
						oa.prototype.copy.call(this, a);
						this.curves = [];
						for (var b = 0, c = a.curves.length; b < c; b++) this.curves.push(a.curves[b].clone());
						this.autoClose = a.autoClose;
						return this
					},
					toJSON: function() {
						var a = oa.prototype.toJSON.call(this);
						a.autoClose = this.autoClose;
						a.curves = [];
						for (var b = 0, c = this.curves.length; b < c; b++) a.curves.push(this.curves[b].toJSON());
						return a
					},
					fromJSON: function(a) {
						oa.prototype.fromJSON.call(this,
							a);
						this.autoClose = a.autoClose;
						this.curves = [];
						for (var b = 0, c = a.curves.length; b < c; b++) {
							var d = a.curves[b];
							this.curves.push((new Ch[d.type]).fromJSON(d))
						}
						return this
					}
				});
				se.prototype = q(p(jg.prototype), {
					constructor: se,
					setFromPoints: function(a) {
						this.moveTo(a[0].x, a[0].y);
						for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
					},
					moveTo: function(a, b) {
						this.currentPoint.set(a, b)
					},
					lineTo: function(a, b) {
						var c = new pc(this.currentPoint.clone(), new d(a, b));
						this.curves.push(c);
						this.currentPoint.set(a, b)
					},
					quadraticCurveTo: function(a,
						b, c, e) {
						a = new qe(this.currentPoint.clone(), new d(a, b), new d(c, e));
						this.curves.push(a);
						this.currentPoint.set(c, e)
					},
					bezierCurveTo: function(a, b, c, e, f, g) {
						a = new oe(this.currentPoint.clone(), new d(a, b), new d(c, e), new d(f, g));
						this.curves.push(a);
						this.currentPoint.set(f, g)
					},
					splineThru: function(a) {
						var b = [this.currentPoint.clone()].concat(a);
						b = new re(b);
						this.curves.push(b);
						this.currentPoint.copy(a[a.length - 1])
					},
					arc: function(a, b, c, d, e, f) {
						this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f)
					},
					absarc: function(a,
						b, c, d, e, f) {
						this.absellipse(a, b, c, c, d, e, f)
					},
					ellipse: function(a, b, c, d, e, f, g, k) {
						this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, f, g, k)
					},
					absellipse: function(a, b, c, d, e, f, g, k) {
						a = new Xc(a, b, c, d, e, f, g, k);
						0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
						this.curves.push(a);
						a = a.getPoint(1);
						this.currentPoint.copy(a)
					},
					copy: function(a) {
						jg.prototype.copy.call(this, a);
						this.currentPoint.copy(a.currentPoint);
						return this
					},
					toJSON: function() {
						var a = jg.prototype.toJSON.call(this);
						a.currentPoint = this.currentPoint.toArray();
						return a
					},
					fromJSON: function(a) {
						jg.prototype.fromJSON.call(this, a);
						this.currentPoint.fromArray(a.currentPoint);
						return this
					}
				});
				hh.prototype = q(p(se.prototype), {
					constructor: hh,
					getPointsHoles: function(a) {
						for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
						return b
					},
					extractPoints: function(a) {
						return {
							shape: this.getPoints(a),
							holes: this.getPointsHoles(a)
						}
					},
					copy: function(a) {
						se.prototype.copy.call(this, a);
						this.holes = [];
						for (var b = 0, c = a.holes.length; b <
							c; b++) this.holes.push(a.holes[b].clone());
						return this
					},
					toJSON: function() {
						var a = se.prototype.toJSON.call(this);
						a.uuid = this.uuid;
						a.holes = [];
						for (var b = 0, c = this.holes.length; b < c; b++) a.holes.push(this.holes[b].toJSON());
						return a
					},
					fromJSON: function(a) {
						se.prototype.fromJSON.call(this, a);
						this.uuid = a.uuid;
						this.holes = [];
						for (var b = 0, c = a.holes.length; b < c; b++) {
							var d = a.holes[b];
							this.holes.push((new se).fromJSON(d))
						}
						return this
					}
				});
				Ta.prototype = q(p(u.prototype), {
					constructor: Ta,
					isLight: !0,
					copy: function(a) {
						u.prototype.copy.call(this,
							a);
						this.color.copy(a.color);
						this.intensity = a.intensity;
						return this
					},
					toJSON: function(a) {
						a = u.prototype.toJSON.call(this, a);
						a.object.color = this.color.getHex();
						a.object.intensity = this.intensity;
						void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
						void 0 !== this.distance && (a.object.distance = this.distance);
						void 0 !== this.angle && (a.object.angle = this.angle);
						void 0 !== this.decay && (a.object.decay = this.decay);
						void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
						void 0 !== this.shadow &&
							(a.object.shadow = this.shadow.toJSON());
						return a
					}
				});
				Te.prototype = q(p(Ta.prototype), {
					constructor: Te,
					isHemisphereLight: !0,
					copy: function(a) {
						Ta.prototype.copy.call(this, a);
						this.groundColor.copy(a.groundColor);
						return this
					}
				});
				q(pf.prototype, {
					_projScreenMatrix: new v,
					_lightPositionWorld: new f,
					_lookTarget: new f,
					getViewportCount: function() {
						return this._viewportCount
					},
					getFrustum: function() {
						return this._frustum
					},
					updateMatrices: function(a) {
						var b = this.camera,
							c = this.matrix,
							d = this._projScreenMatrix,
							e = this._lookTarget,
							h = this._lightPositionWorld;
						h.setFromMatrixPosition(a.matrixWorld);
						b.position.copy(h);
						e.setFromMatrixPosition(a.target.matrixWorld);
						b.lookAt(e);
						b.updateMatrixWorld();
						d.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
						this._frustum.setFromMatrix(d);
						c.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
						c.multiply(b.projectionMatrix);
						c.multiply(b.matrixWorldInverse)
					},
					getViewport: function(a) {
						return this._viewports[a]
					},
					getFrameExtents: function() {
						return this._frameExtents
					},
					copy: function(a) {
						this.camera = a.camera.clone();
						this.bias = a.bias;
						this.radius = a.radius;
						this.mapSize.copy(a.mapSize);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					toJSON: function() {
						var a = {};
						0 !== this.bias && (a.bias = this.bias);
						1 !== this.radius && (a.radius = this.radius);
						if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
						a.camera = this.camera.toJSON(!1).object;
						delete a.camera.matrix;
						return a
					}
				});
				Ue.prototype = q(p(pf.prototype), {
					constructor: Ue,
					isSpotLightShadow: !0,
					updateMatrices: function(a, b, c) {
						var d = this.camera,
							e = 2 * Ea.RAD2DEG * a.angle,
							h = this.mapSize.width / this.mapSize.height,
							f = a.distance || d.far;
						if (e !== d.fov || h !== d.aspect || f !== d.far) d.fov = e, d.aspect = h, d.far = f, d.updateProjectionMatrix();
						pf.prototype.updateMatrices.call(this, a, b, c)
					}
				});
				Ve.prototype = q(p(Ta.prototype), {
					constructor: Ve,
					isSpotLight: !0,
					copy: function(a) {
						Ta.prototype.copy.call(this, a);
						this.distance = a.distance;
						this.angle = a.angle;
						this.penumbra = a.penumbra;
						this.decay = a.decay;
						this.target = a.target.clone();
						this.shadow = a.shadow.clone();
						return this
					}
				});
				Ff.prototype =
					q(p(pf.prototype), {
						constructor: Ff,
						isPointLightShadow: !0,
						updateMatrices: function(a, b, c) {
							b = this.camera;
							var d = this.matrix,
								e = this._lightPositionWorld,
								h = this._lookTarget,
								f = this._projScreenMatrix;
							e.setFromMatrixPosition(a.matrixWorld);
							b.position.copy(e);
							h.copy(b.position);
							h.add(this._cubeDirections[c]);
							b.up.copy(this._cubeUps[c]);
							b.lookAt(h);
							b.updateMatrixWorld();
							d.makeTranslation(-e.x, -e.y, -e.z);
							f.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
							this._frustum.setFromMatrix(f)
						}
					});
				We.prototype =
					q(p(Ta.prototype), {
						constructor: We,
						isPointLight: !0,
						copy: function(a) {
							Ta.prototype.copy.call(this, a);
							this.distance = a.distance;
							this.decay = a.decay;
							this.shadow = a.shadow.clone();
							return this
						}
					});
				ce.prototype = q(p(va.prototype), {
					constructor: ce,
					isOrthographicCamera: !0,
					copy: function(a, b) {
						va.prototype.copy.call(this, a, b);
						this.left = a.left;
						this.right = a.right;
						this.top = a.top;
						this.bottom = a.bottom;
						this.near = a.near;
						this.far = a.far;
						this.zoom = a.zoom;
						this.view = null === a.view ? null : q({}, a.view);
						return this
					},
					setViewOffset: function(a,
						b, c, d, e, f) {
						null === this.view && (this.view = {
							enabled: !0,
							fullWidth: 1,
							fullHeight: 1,
							offsetX: 0,
							offsetY: 0,
							width: 1,
							height: 1
						});
						this.view.enabled = !0;
						this.view.fullWidth = a;
						this.view.fullHeight = b;
						this.view.offsetX = c;
						this.view.offsetY = d;
						this.view.width = e;
						this.view.height = f;
						this.updateProjectionMatrix()
					},
					clearViewOffset: function() {
						null !== this.view && (this.view.enabled = !1);
						this.updateProjectionMatrix()
					},
					updateProjectionMatrix: function() {
						var a = (this.right - this.left) / (2 * this.zoom),
							b = (this.top - this.bottom) / (2 * this.zoom),
							c = (this.right + this.left) / 2,
							d = (this.top + this.bottom) / 2,
							e = c - a;
						c += a;
						a = d + b;
						b = d - b;
						if (null !== this.view && this.view.enabled) {
							c = this.zoom / (this.view.width / this.view.fullWidth);
							b = this.zoom / (this.view.height / this.view.fullHeight);
							var f = (this.right - this.left) / this.view.width;
							d = (this.top - this.bottom) / this.view.height;
							e += this.view.offsetX / c * f;
							c = e + this.view.width / c * f;
							a -= this.view.offsetY / b * d;
							b = a - this.view.height / b * d
						}
						this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far);
						this.projectionMatrixInverse.getInverse(this.projectionMatrix)
					},
					toJSON: function(a) {
						a = u.prototype.toJSON.call(this, a);
						a.object.zoom = this.zoom;
						a.object.left = this.left;
						a.object.right = this.right;
						a.object.top = this.top;
						a.object.bottom = this.bottom;
						a.object.near = this.near;
						a.object.far = this.far;
						null !== this.view && (a.object.view = q({}, this.view));
						return a
					}
				});
				Xe.prototype = q(p(pf.prototype), {
					constructor: Xe,
					isDirectionalLightShadow: !0,
					updateMatrices: function(a, b, c) {
						pf.prototype.updateMatrices.call(this, a, b, c)
					}
				});
				Ye.prototype = q(p(Ta.prototype), {
					constructor: Ye,
					isDirectionalLight: !0,
					copy: function(a) {
						Ta.prototype.copy.call(this, a);
						this.target = a.target.clone();
						this.shadow = a.shadow.clone();
						return this
					}
				});
				Ze.prototype = q(p(Ta.prototype), {
					constructor: Ze,
					isAmbientLight: !0
				});
				$e.prototype = q(p(Ta.prototype), {
					constructor: $e,
					isRectAreaLight: !0,
					copy: function(a) {
						Ta.prototype.copy.call(this, a);
						this.width = a.width;
						this.height = a.height;
						return this
					},
					toJSON: function(a) {
						a = Ta.prototype.toJSON.call(this, a);
						a.object.width = this.width;
						a.object.height = this.height;
						return a
					}
				});
				af.prototype = q(p(Qa.prototype), {
					constructor: af,
					load: function(a, b, c, d) {
						var e = this,
							h = new Hd(e.manager);
						h.setPath(e.path);
						h.load(a, function(a) {
							b(e.parse(JSON.parse(a)))
						}, c, d)
					},
					parse: function(a) {
						function b(a) {
							void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
							return c[a]
						}
						var c = this.textures,
							e = new ak[a.type];
						void 0 !== a.uuid && (e.uuid = a.uuid);
						void 0 !== a.name && (e.name = a.name);
						void 0 !== a.color && e.color.setHex(a.color);
						void 0 !== a.roughness && (e.roughness = a.roughness);
						void 0 !== a.metalness && (e.metalness = a.metalness);
						void 0 !==
							a.sheen && (e.sheen = (new Q).setHex(a.sheen));
						void 0 !== a.emissive && e.emissive.setHex(a.emissive);
						void 0 !== a.specular && e.specular.setHex(a.specular);
						void 0 !== a.shininess && (e.shininess = a.shininess);
						void 0 !== a.clearcoat && (e.clearcoat = a.clearcoat);
						void 0 !== a.clearcoatRoughness && (e.clearcoatRoughness = a.clearcoatRoughness);
						void 0 !== a.vertexColors && (e.vertexColors = a.vertexColors);
						void 0 !== a.fog && (e.fog = a.fog);
						void 0 !== a.flatShading && (e.flatShading = a.flatShading);
						void 0 !== a.blending && (e.blending = a.blending);
						void 0 !== a.combine && (e.combine = a.combine);
						void 0 !== a.side && (e.side = a.side);
						void 0 !== a.opacity && (e.opacity = a.opacity);
						void 0 !== a.transparent && (e.transparent = a.transparent);
						void 0 !== a.alphaTest && (e.alphaTest = a.alphaTest);
						void 0 !== a.depthTest && (e.depthTest = a.depthTest);
						void 0 !== a.depthWrite && (e.depthWrite = a.depthWrite);
						void 0 !== a.colorWrite && (e.colorWrite = a.colorWrite);
						void 0 !== a.stencilWrite && (e.stencilWrite = a.stencilWrite);
						void 0 !== a.stencilWriteMask && (e.stencilWriteMask = a.stencilWriteMask);
						void 0 !==
							a.stencilFunc && (e.stencilFunc = a.stencilFunc);
						void 0 !== a.stencilRef && (e.stencilRef = a.stencilRef);
						void 0 !== a.stencilFuncMask && (e.stencilFuncMask = a.stencilFuncMask);
						void 0 !== a.stencilFail && (e.stencilFail = a.stencilFail);
						void 0 !== a.stencilZFail && (e.stencilZFail = a.stencilZFail);
						void 0 !== a.stencilZPass && (e.stencilZPass = a.stencilZPass);
						void 0 !== a.wireframe && (e.wireframe = a.wireframe);
						void 0 !== a.wireframeLinewidth && (e.wireframeLinewidth = a.wireframeLinewidth);
						void 0 !== a.wireframeLinecap && (e.wireframeLinecap =
							a.wireframeLinecap);
						void 0 !== a.wireframeLinejoin && (e.wireframeLinejoin = a.wireframeLinejoin);
						void 0 !== a.rotation && (e.rotation = a.rotation);
						1 !== a.linewidth && (e.linewidth = a.linewidth);
						void 0 !== a.dashSize && (e.dashSize = a.dashSize);
						void 0 !== a.gapSize && (e.gapSize = a.gapSize);
						void 0 !== a.scale && (e.scale = a.scale);
						void 0 !== a.polygonOffset && (e.polygonOffset = a.polygonOffset);
						void 0 !== a.polygonOffsetFactor && (e.polygonOffsetFactor = a.polygonOffsetFactor);
						void 0 !== a.polygonOffsetUnits && (e.polygonOffsetUnits = a.polygonOffsetUnits);
						void 0 !== a.skinning && (e.skinning = a.skinning);
						void 0 !== a.morphTargets && (e.morphTargets = a.morphTargets);
						void 0 !== a.morphNormals && (e.morphNormals = a.morphNormals);
						void 0 !== a.dithering && (e.dithering = a.dithering);
						void 0 !== a.visible && (e.visible = a.visible);
						void 0 !== a.toneMapped && (e.toneMapped = a.toneMapped);
						void 0 !== a.userData && (e.userData = a.userData);
						if (void 0 !== a.uniforms)
							for (var h in a.uniforms) {
								var g = a.uniforms[h];
								e.uniforms[h] = {};
								switch (g.type) {
									case "t":
										e.uniforms[h].value = b(g.value);
										break;
									case "c":
										e.uniforms[h].value =
											(new Q).setHex(g.value);
										break;
									case "v2":
										e.uniforms[h].value = (new d).fromArray(g.value);
										break;
									case "v3":
										e.uniforms[h].value = (new f).fromArray(g.value);
										break;
									case "v4":
										e.uniforms[h].value = (new m).fromArray(g.value);
										break;
									case "m3":
										e.uniforms[h].value = (new k).fromArray(g.value);
									case "m4":
										e.uniforms[h].value = (new v).fromArray(g.value);
										break;
									default:
										e.uniforms[h].value = g.value
								}
							}
						void 0 !== a.defines && (e.defines = a.defines);
						void 0 !== a.vertexShader && (e.vertexShader = a.vertexShader);
						void 0 !== a.fragmentShader &&
							(e.fragmentShader = a.fragmentShader);
						if (void 0 !== a.extensions)
							for (var l in a.extensions) e.extensions[l] = a.extensions[l];
						void 0 !== a.shading && (e.flatShading = 1 === a.shading);
						void 0 !== a.size && (e.size = a.size);
						void 0 !== a.sizeAttenuation && (e.sizeAttenuation = a.sizeAttenuation);
						void 0 !== a.map && (e.map = b(a.map));
						void 0 !== a.matcap && (e.matcap = b(a.matcap));
						void 0 !== a.alphaMap && (e.alphaMap = b(a.alphaMap), e.transparent = !0);
						void 0 !== a.bumpMap && (e.bumpMap = b(a.bumpMap));
						void 0 !== a.bumpScale && (e.bumpScale = a.bumpScale);
						void 0 !== a.normalMap && (e.normalMap = b(a.normalMap));
						void 0 !== a.normalMapType && (e.normalMapType = a.normalMapType);
						void 0 !== a.normalScale && (h = a.normalScale, !1 === Array.isArray(h) && (h = [h, h]), e.normalScale = (
							new d).fromArray(h));
						void 0 !== a.displacementMap && (e.displacementMap = b(a.displacementMap));
						void 0 !== a.displacementScale && (e.displacementScale = a.displacementScale);
						void 0 !== a.displacementBias && (e.displacementBias = a.displacementBias);
						void 0 !== a.roughnessMap && (e.roughnessMap = b(a.roughnessMap));
						void 0 !== a.metalnessMap &&
							(e.metalnessMap = b(a.metalnessMap));
						void 0 !== a.emissiveMap && (e.emissiveMap = b(a.emissiveMap));
						void 0 !== a.emissiveIntensity && (e.emissiveIntensity = a.emissiveIntensity);
						void 0 !== a.specularMap && (e.specularMap = b(a.specularMap));
						void 0 !== a.envMap && (e.envMap = b(a.envMap));
						void 0 !== a.envMapIntensity && (e.envMapIntensity = a.envMapIntensity);
						void 0 !== a.reflectivity && (e.reflectivity = a.reflectivity);
						void 0 !== a.refractionRatio && (e.refractionRatio = a.refractionRatio);
						void 0 !== a.lightMap && (e.lightMap = b(a.lightMap));
						void 0 !==
							a.lightMapIntensity && (e.lightMapIntensity = a.lightMapIntensity);
						void 0 !== a.aoMap && (e.aoMap = b(a.aoMap));
						void 0 !== a.aoMapIntensity && (e.aoMapIntensity = a.aoMapIntensity);
						void 0 !== a.gradientMap && (e.gradientMap = b(a.gradientMap));
						void 0 !== a.clearcoatNormalMap && (e.clearcoatNormalMap = b(a.clearcoatNormalMap));
						void 0 !== a.clearcoatNormalScale && (e.clearcoatNormalScale = (new d).fromArray(a.clearcoatNormalScale));
						return e
					},
					setTextures: function(a) {
						this.textures = a;
						return this
					}
				});
				var Dh = {
					decodeText: function(a) {
						if ("undefined" !==
							typeof TextDecoder) return (new TextDecoder).decode(a);
						for (var b = "", c = 0, d = a.length; c < d; c++) b += String.fromCharCode(a[c]);
						try {
							return decodeURIComponent(escape(b))
						} catch (E) {
							return b
						}
					},
					extractUrlBase: function(a) {
						var b = a.lastIndexOf("/");
						return -1 === b ? "./" : a.substr(0, b + 1)
					}
				};
				bf.prototype = q(p(I.prototype), {
					constructor: bf,
					isInstancedBufferGeometry: !0,
					copy: function(a) {
						I.prototype.copy.call(this, a);
						this.maxInstancedCount = a.maxInstancedCount;
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					toJSON: function() {
						var a = I.prototype.toJSON.call(this);
						a.maxInstancedCount = this.maxInstancedCount;
						a.isInstancedBufferGeometry = !0;
						return a
					}
				});
				cf.prototype = q(p(R.prototype), {
					constructor: cf,
					isInstancedBufferAttribute: !0,
					copy: function(a) {
						R.prototype.copy.call(this, a);
						this.meshPerAttribute = a.meshPerAttribute;
						return this
					},
					toJSON: function() {
						var a = R.prototype.toJSON.call(this);
						a.meshPerAttribute = this.meshPerAttribute;
						a.isInstancedBufferAttribute = !0;
						return a
					}
				});
				ef.prototype = q(p(Qa.prototype), {
					constructor: ef,
					load: function(a, b, c, d) {
						var e = this,
							h = new Hd(e.manager);
						h.setPath(e.path);
						h.load(a, function(a) {
							b(e.parse(JSON.parse(a)))
						}, c, d)
					},
					parse: function(a) {
						var b = a.isInstancedBufferGeometry ? new bf : new I,
							c = a.data.index;
						if (void 0 !== c) {
							var d = new Eh[c.type](c.array);
							b.setIndex(new R(d, 1))
						}
						c = a.data.attributes;
						for (var e in c) {
							var h = c[e];
							d = new Eh[h.type](h.array);
							d = new(h.isInstancedBufferAttribute ? cf : R)(d, h.itemSize, h.normalized);
							void 0 !== h.name && (d.name = h.name);
							b.addAttribute(e, d)
						}
						var g = a.data.morphAttributes;
						if (g)
							for (e in g) {
								var k =
									g[e],
									l = [];
								c = 0;
								for (var m = k.length; c < m; c++) h = k[c], d = new Eh[h.type](h.array), d = new R(d, h.itemSize, h.normalized),
									void 0 !== h.name && (d.name = h.name), l.push(d);
								b.morphAttributes[e] = l
							}
						e = a.data.groups || a.data.drawcalls || a.data.offsets;
						if (void 0 !== e)
							for (c = 0, h = e.length; c !== h; ++c) d = e[c], b.addGroup(d.start, d.count, d.materialIndex);
						c = a.data.boundingSphere;
						void 0 !== c && (e = new f, void 0 !== c.center && e.fromArray(c.center), b.boundingSphere = new G(e, c.radius));
						a.name && (b.name = a.name);
						a.userData && (b.userData = a.userData);
						return b
					}
				});
				var Eh = {
					Int8Array: Int8Array,
					Uint8Array: Uint8Array,
					Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
					Int16Array: Int16Array,
					Uint16Array: Uint16Array,
					Int32Array: Int32Array,
					Uint32Array: Uint32Array,
					Float32Array: Float32Array,
					Float64Array: Float64Array
				};
				ff.prototype = q(p(Qa.prototype), {
					constructor: ff,
					load: function(a, b, c, d) {
						var e = this,
							h = "" === this.path ? Dh.extractUrlBase(a) : this.path;
						this.resourcePath = this.resourcePath || h;
						h = new Hd(e.manager);
						h.setPath(this.path);
						h.load(a, function(c) {
							var h = null;
							try {
								h = JSON.parse(c)
							} catch (Y) {
								void 0 !== d && d(Y);
								console.error("THREE:ObjectLoader: Can't parse " + a + ".", Y.message);
								return
							}
							c = h.metadata;
							void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error(
								"THREE.ObjectLoader: Can't load " + a) : e.parse(h, b)
						}, c, d)
					},
					parse: function(a, b) {
						var c = this.parseShape(a.shapes);
						c = this.parseGeometries(a.geometries, c);
						var d = this.parseImages(a.images, function() {
							void 0 !== b && b(e)
						});
						d = this.parseTextures(a.textures, d);
						d = this.parseMaterials(a.materials,
							d);
						var e = this.parseObject(a.object, c, d);
						a.animations && (e.animations = this.parseAnimations(a.animations));
						void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
						return e
					},
					parseShape: function(a) {
						var b = {};
						if (void 0 !== a)
							for (var c = 0, d = a.length; c < d; c++) {
								var e = (new hh).fromJSON(a[c]);
								b[e.uuid] = e
							}
						return b
					},
					parseGeometries: function(a, b) {
						var c = {};
						if (void 0 !== a)
							for (var d = new ef, e = 0, h = a.length; e < h; e++) {
								var f = a[e];
								switch (f.type) {
									case "PlaneGeometry":
									case "PlaneBufferGeometry":
										var g = new Xb[f.type](f.width, f.height,
											f.widthSegments, f.heightSegments);
										break;
									case "BoxGeometry":
									case "BoxBufferGeometry":
									case "CubeGeometry":
										g = new Xb[f.type](f.width, f.height, f.depth, f.widthSegments, f.heightSegments, f.depthSegments);
										break;
									case "CircleGeometry":
									case "CircleBufferGeometry":
										g = new Xb[f.type](f.radius, f.segments, f.thetaStart, f.thetaLength);
										break;
									case "CylinderGeometry":
									case "CylinderBufferGeometry":
										g = new Xb[f.type](f.radiusTop, f.radiusBottom, f.height, f.radialSegments, f.heightSegments, f.openEnded,
											f.thetaStart, f.thetaLength);
										break;
									case "ConeGeometry":
									case "ConeBufferGeometry":
										g = new Xb[f.type](f.radius, f.height, f.radialSegments, f.heightSegments, f.openEnded, f.thetaStart, f
											.thetaLength);
										break;
									case "SphereGeometry":
									case "SphereBufferGeometry":
										g = new Xb[f.type](f.radius, f.widthSegments, f.heightSegments, f.phiStart, f.phiLength, f.thetaStart,
											f.thetaLength);
										break;
									case "DodecahedronGeometry":
									case "DodecahedronBufferGeometry":
									case "IcosahedronGeometry":
									case "IcosahedronBufferGeometry":
									case "OctahedronGeometry":
									case "OctahedronBufferGeometry":
									case "TetrahedronGeometry":
									case "TetrahedronBufferGeometry":
										g =
											new Xb[f.type](f.radius, f.detail);
										break;
									case "RingGeometry":
									case "RingBufferGeometry":
										g = new Xb[f.type](f.innerRadius, f.outerRadius, f.thetaSegments, f.phiSegments, f.thetaStart, f.thetaLength);
										break;
									case "TorusGeometry":
									case "TorusBufferGeometry":
										g = new Xb[f.type](f.radius, f.tube, f.radialSegments, f.tubularSegments, f.arc);
										break;
									case "TorusKnotGeometry":
									case "TorusKnotBufferGeometry":
										g = new Xb[f.type](f.radius, f.tube, f.tubularSegments, f.radialSegments, f.p, f.q);
										break;
									case "TubeGeometry":
									case "TubeBufferGeometry":
										g =
											new Xb[f.type]((new Ch[f.path.type]).fromJSON(f.path), f.tubularSegments, f.radius, f.radialSegments,
												f.closed);
										break;
									case "LatheGeometry":
									case "LatheBufferGeometry":
										g = new Xb[f.type](f.points, f.segments, f.phiStart, f.phiLength);
										break;
									case "PolyhedronGeometry":
									case "PolyhedronBufferGeometry":
										g = new Xb[f.type](f.vertices, f.indices, f.radius, f.details);
										break;
									case "ShapeGeometry":
									case "ShapeBufferGeometry":
										g = [];
										for (var k = 0, l = f.shapes.length; k < l; k++) {
											var m = b[f.shapes[k]];
											g.push(m)
										}
										g = new Xb[f.type](g, f.curveSegments);
										break;
									case "ExtrudeGeometry":
									case "ExtrudeBufferGeometry":
										g = [];
										k = 0;
										for (l = f.shapes.length; k < l; k++) m = b[f.shapes[k]], g.push(m);
										k = f.options.extrudePath;
										void 0 !== k && (f.options.extrudePath = (new Ch[k.type]).fromJSON(k));
										g = new Xb[f.type](g, f.options);
										break;
									case "BufferGeometry":
									case "InstancedBufferGeometry":
										g = d.parse(f);
										break;
									case "Geometry":
										"THREE" in window && "LegacyJSONLoader" in THREE ? g = (new THREE.LegacyJSONLoader).parse(f, this.resourcePath)
											.geometry : console.error(
												'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'
											);
										break;
									default:
										console.warn('THREE.ObjectLoader: Unsupported geometry type "' + f.type + '"');
										continue
								}
								g.uuid = f.uuid;
								void 0 !== f.name && (g.name = f.name);
								!0 === g.isBufferGeometry && void 0 !== f.userData && (g.userData = f.userData);
								c[f.uuid] = g
							}
						return c
					},
					parseMaterials: function(a, b) {
						var c = {},
							d = {};
						if (void 0 !== a) {
							var e = new af;
							e.setTextures(b);
							b = 0;
							for (var h = a.length; b < h; b++) {
								var f = a[b];
								if ("MultiMaterial" === f.type) {
									for (var g = [], k = 0; k < f.materials.length; k++) {
										var l = f.materials[k];
										void 0 === c[l.uuid] && (c[l.uuid] = e.parse(l));
										g.push(c[l.uuid])
									}
									d[f.uuid] = g
								} else void 0 === c[f.uuid] && (c[f.uuid] = e.parse(f)), d[f.uuid] = c[f.uuid]
							}
						}
						return d
					},
					parseAnimations: function(a) {
						for (var b = [], c = 0; c < a.length; c++) {
							var d = a[c],
								e = Gd.parse(d);
							void 0 !== d.uuid && (e.uuid = d.uuid);
							b.push(e)
						}
						return b
					},
					parseImages: function(a, b) {
						function c(a) {
							d.manager.itemStart(a);
							return h.load(a, function() {
								d.manager.itemEnd(a)
							}, void 0, function() {
								d.manager.itemError(a);
								d.manager.itemEnd(a)
							})
						}
						var d = this,
							e = {};
						if (void 0 !== a && 0 < a.length) {
							b = new xf(b);
							var h = new Aj(b);
							h.setCrossOrigin(this.crossOrigin);
							b = 0;
							for (var f = a.length; b < f; b++) {
								var g = a[b],
									k = g.url;
								if (Array.isArray(k)) {
									e[g.uuid] = [];
									for (var l = 0, m = k.length; l < m; l++) {
										var t = k[l];
										t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(t) ? t : d.resourcePath + t;
										e[g.uuid].push(c(t))
									}
								} else t = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(g.url) ? g.url : d.resourcePath + g.url, e[g.uuid] = c(t)
							}
						}
						return e
					},
					parseTextures: function(a, b) {
						function c(a, b) {
							if ("number" === typeof a) return a;
							console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
							return b[a]
						}
						var d = {};
						if (void 0 !==
							a)
							for (var e = 0, f = a.length; e < f; e++) {
								var h = a[e];
								void 0 === h.image && console.warn('THREE.ObjectLoader: No "image" specified for', h.uuid);
								void 0 === b[h.image] && console.warn("THREE.ObjectLoader: Undefined image", h.image);
								var g = Array.isArray(b[h.image]) ? new Ua(b[h.image]) : new l(b[h.image]);
								g.needsUpdate = !0;
								g.uuid = h.uuid;
								void 0 !== h.name && (g.name = h.name);
								void 0 !== h.mapping && (g.mapping = c(h.mapping, bk));
								void 0 !== h.offset && g.offset.fromArray(h.offset);
								void 0 !== h.repeat && g.repeat.fromArray(h.repeat);
								void 0 !== h.center &&
									g.center.fromArray(h.center);
								void 0 !== h.rotation && (g.rotation = h.rotation);
								void 0 !== h.wrap && (g.wrapS = c(h.wrap[0], Pi), g.wrapT = c(h.wrap[1], Pi));
								void 0 !== h.format && (g.format = h.format);
								void 0 !== h.type && (g.type = h.type);
								void 0 !== h.encoding && (g.encoding = h.encoding);
								void 0 !== h.minFilter && (g.minFilter = c(h.minFilter, Si));
								void 0 !== h.magFilter && (g.magFilter = c(h.magFilter, Si));
								void 0 !== h.anisotropy && (g.anisotropy = h.anisotropy);
								void 0 !== h.flipY && (g.flipY = h.flipY);
								void 0 !== h.premultiplyAlpha && (g.premultiplyAlpha =
									h.premultiplyAlpha);
								void 0 !== h.unpackAlignment && (g.unpackAlignment = h.unpackAlignment);
								d[h.uuid] = g
							}
						return d
					},
					parseObject: function(a, b, c) {
						function d(a) {
							void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
							return b[a]
						}

						function e(a) {
							if (void 0 !== a) {
								if (Array.isArray(a)) {
									for (var b = [], d = 0, e = a.length; d < e; d++) {
										var f = a[d];
										void 0 === c[f] && console.warn("THREE.ObjectLoader: Undefined material", f);
										b.push(c[f])
									}
									return b
								}
								void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
								return c[a]
							}
						}
						switch (a.type) {
							case "Scene":
								var f = new C;
								void 0 !== a.background && Dk(a.background) && (f.background = new Q(a.background));
								void 0 !== a.fog && ("Fog" === a.fog.type ? f.fog = new bd(a.fog.color, a.fog.near, a.fog.far) :
									"FogExp2" === a.fog.type && (f.fog = new Pc(a.fog.color, a.fog.density)));
								break;
							case "PerspectiveCamera":
								f = new Ja(a.fov, a.aspect, a.near, a.far);
								void 0 !== a.focus && (f.focus = a.focus);
								void 0 !== a.zoom && (f.zoom = a.zoom);
								void 0 !== a.filmGauge && (f.filmGauge = a.filmGauge);
								void 0 !== a.filmOffset && (f.filmOffset = a.filmOffset);
								void 0 !== a.view && (f.view = q({}, a.view));
								break;
							case "OrthographicCamera":
								f = new ce(a.left, a.right, a.top, a.bottom, a.near, a.far);
								void 0 !== a.zoom && (f.zoom = a.zoom);
								void 0 !== a.view && (f.view = q({}, a.view));
								break;
							case "AmbientLight":
								f = new Ze(a.color, a.intensity);
								break;
							case "DirectionalLight":
								f = new Ye(a.color, a.intensity);
								break;
							case "PointLight":
								f = new We(a.color, a.intensity, a.distance, a.decay);
								break;
							case "RectAreaLight":
								f = new $e(a.color, a.intensity, a.width, a.height);
								break;
							case "SpotLight":
								f = new Ve(a.color, a.intensity,
									a.distance, a.angle, a.penumbra, a.decay);
								break;
							case "HemisphereLight":
								f = new Te(a.color, a.groundColor, a.intensity);
								break;
							case "SkinnedMesh":
								console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
							case "Mesh":
								f = d(a.geometry);
								var h = e(a.material);
								f = f.bones && 0 < f.bones.length ? new Bc(f, h) : new ha(f, h);
								void 0 !== a.drawMode && f.setDrawMode(a.drawMode);
								break;
							case "LOD":
								f = new zc;
								break;
							case "Line":
								f = new yb(d(a.geometry), e(a.material), a.mode);
								break;
							case "LineLoop":
								f = new qd(d(a.geometry),
									e(a.material));
								break;
							case "LineSegments":
								f = new Sa(d(a.geometry), e(a.material));
								break;
							case "PointCloud":
							case "Points":
								f = new ec(d(a.geometry), e(a.material));
								break;
							case "Sprite":
								f = new xc(e(a.material));
								break;
							case "Group":
								f = new Sb;
								break;
							default:
								f = new u
						}
						f.uuid = a.uuid;
						void 0 !== a.name && (f.name = a.name);
						void 0 !== a.matrix ? (f.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (f.matrixAutoUpdate =
							a.matrixAutoUpdate), f.matrixAutoUpdate && f.matrix.decompose(f.position, f.quaternion, f.scale)) : (void 0 !==
							a.position &&
							f.position.fromArray(a.position), void 0 !== a.rotation && f.rotation.fromArray(a.rotation), void 0 !==
							a.quaternion && f.quaternion.fromArray(a.quaternion), void 0 !== a.scale && f.scale.fromArray(a.scale));
						void 0 !== a.castShadow && (f.castShadow = a.castShadow);
						void 0 !== a.receiveShadow && (f.receiveShadow = a.receiveShadow);
						a.shadow && (void 0 !== a.shadow.bias && (f.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (f.shadow
								.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && f.shadow.mapSize.fromArray(a.shadow.mapSize),
							void 0 !== a.shadow.camera && (f.shadow.camera = this.parseObject(a.shadow.camera)));
						void 0 !== a.visible && (f.visible = a.visible);
						void 0 !== a.frustumCulled && (f.frustumCulled = a.frustumCulled);
						void 0 !== a.renderOrder && (f.renderOrder = a.renderOrder);
						void 0 !== a.userData && (f.userData = a.userData);
						void 0 !== a.layers && (f.layers.mask = a.layers);
						if (void 0 !== a.children) {
							h = a.children;
							for (var g = 0; g < h.length; g++) f.add(this.parseObject(h[g], b, c))
						}
						if ("LOD" === a.type)
							for (a = a.levels, h = 0; h < a.length; h++) {
								g = a[h];
								var k = f.getObjectByProperty("uuid",
									g.object);
								void 0 !== k && f.addLevel(k, g.distance)
							}
						return f
					}
				});
				var bk = {
						UVMapping: 300,
						CubeReflectionMapping: 301,
						CubeRefractionMapping: 302,
						EquirectangularReflectionMapping: 303,
						EquirectangularRefractionMapping: 304,
						SphericalReflectionMapping: 305,
						CubeUVReflectionMapping: 306,
						CubeUVRefractionMapping: 307
					},
					Pi = {
						RepeatWrapping: 1E3,
						ClampToEdgeWrapping: 1001,
						MirroredRepeatWrapping: 1002
					},
					Si = {
						NearestFilter: 1003,
						NearestMipmapNearestFilter: 1004,
						NearestMipmapLinearFilter: 1005,
						LinearFilter: 1006,
						LinearMipmapNearestFilter: 1007,
						LinearMipmapLinearFilter: 1008
					};
				Pf.prototype = q(p(Qa.prototype), {
					constructor: Pf,
					setOptions: function(a) {
						this.options = a;
						return this
					},
					load: function(a, b, c, d) {
						void 0 === a && (a = "");
						void 0 !== this.path && (a = this.path + a);
						a = this.manager.resolveURL(a);
						var e = this,
							f = ri.get(a);
						if (void 0 !== f) return e.manager.itemStart(a), setTimeout(function() {
							b && b(f);
							e.manager.itemEnd(a)
						}, 0), f;
						fetch(a).then(function(a) {
							return a.blob()
						}).then(function(a) {
							return void 0 === e.options ? createImageBitmap(a) : createImageBitmap(a, e.options)
						}).then(function(c) {
							ri.add(a,
								c);
							b && b(c);
							e.manager.itemEnd(a)
						}).catch(function(b) {
							d && d(b);
							e.manager.itemError(a);
							e.manager.itemEnd(a)
						});
						e.manager.itemStart(a)
					}
				});
				q(Qf.prototype, {
					moveTo: function(a, b) {
						this.currentPath = new se;
						this.subPaths.push(this.currentPath);
						this.currentPath.moveTo(a, b)
					},
					lineTo: function(a, b) {
						this.currentPath.lineTo(a, b)
					},
					quadraticCurveTo: function(a, b, c, d) {
						this.currentPath.quadraticCurveTo(a, b, c, d)
					},
					bezierCurveTo: function(a, b, c, d, e, f) {
						this.currentPath.bezierCurveTo(a, b, c, d, e, f)
					},
					splineThru: function(a) {
						this.currentPath.splineThru(a)
					},
					toShapes: function(a, b) {
						function c(a) {
							for (var b = [], c = 0, d = a.length; c < d; c++) {
								var e = a[c],
									f = new hh;
								f.curves = e.curves;
								b.push(f)
							}
							return b
						}

						function d(a, b) {
							for (var c = b.length, d = !1, e = c - 1, f = 0; f < c; e = f++) {
								var h = b[e],
									g = b[f],
									k = g.x - h.x,
									l = g.y - h.y;
								if (Math.abs(l) > Na) {
									if (0 > l && (h = b[f], k = -k, g = b[e], l = -l), !(a.y < h.y || a.y > g.y))
										if (a.y === h.y) {
											if (a.x === h.x) return !0
										} else {
											e = l * (a.x - h.x) - k * (a.y - h.y);
											if (0 === e) return !0;
											0 > e || (d = !d)
										}
								} else if (a.y === h.y && (g.x <= a.x && a.x <= h.x || h.x <= a.x && a.x <= g.x)) return !0
							}
							return d
						}
						var e = hg.isClockWise,
							f =
							this.subPaths;
						if (0 === f.length) return [];
						if (!0 === b) return c(f);
						b = [];
						if (1 === f.length) {
							var h = f[0];
							var g = new hh;
							g.curves = h.curves;
							b.push(g);
							return b
						}
						var k = !e(f[0].getPoints());
						k = a ? !k : k;
						g = [];
						var l = [],
							m = [],
							t = 0;
						l[t] = void 0;
						m[t] = [];
						for (var n = 0, r = f.length; n < r; n++) {
							h = f[n];
							var p = h.getPoints();
							var v = e(p);
							(v = a ? !v : v) ? (!k && l[t] && t++, l[t] = {
								s: new hh,
								p: p
							}, l[t].s.curves = h.curves, k && t++, m[t] = []) : m[t].push({
								h: h,
								p: p[0]
							})
						}
						if (!l[0]) return c(f);
						if (1 < l.length) {
							n = !1;
							a = [];
							e = 0;
							for (f = l.length; e < f; e++) g[e] = [];
							e = 0;
							for (f = l.length; e <
								f; e++)
								for (h = m[e], v = 0; v < h.length; v++) {
									k = h[v];
									t = !0;
									for (p = 0; p < l.length; p++) d(k.p, l[p].p) && (e !== p && a.push({
										froms: e,
										tos: p,
										hole: v
									}), t ? (t = !1, g[p].push(k)) : n = !0);
									t && g[e].push(k)
								}
							0 < a.length && (n || (m = g))
						}
						n = 0;
						for (e = l.length; n < e; n++)
							for (g = l[n].s, b.push(g), a = m[n], f = 0, h = a.length; f < h; f++) g.holes.push(a[f].h);
						return b
					}
				});
				q(Rf.prototype, {
					isFont: !0,
					generateShapes: function(a, b) {
						void 0 === b && (b = 100);
						var c = [],
							d = b;
						b = this.data;
						var e = Ck ? Ck(a) : String(a).split("");
						d /= b.resolution;
						var f = (b.boundingBox.yMax - b.boundingBox.yMin +
							b.underlineThickness) * d;
						a = [];
						for (var h = 0, g = 0, k = 0; k < e.length; k++) {
							var l = e[k];
							if ("\n" === l) h = 0, g -= f;
							else {
								var m = l;
								l = d;
								var t = h,
									n = g,
									r = b,
									p = r.glyphs[m] || r.glyphs["?"];
								if (p) {
									m = new Qf;
									if (p.o) {
										r = p._cachedOutline || (p._cachedOutline = p.o.split(" "));
										for (var v = 0, q = r.length; v < q;) switch (r[v++]) {
											case "m":
												var u = r[v++] * l + t;
												var w = r[v++] * l + n;
												m.moveTo(u, w);
												break;
											case "l":
												u = r[v++] * l + t;
												w = r[v++] * l + n;
												m.lineTo(u, w);
												break;
											case "q":
												var A = r[v++] * l + t;
												var z = r[v++] * l + n;
												var D = r[v++] * l + t;
												var C = r[v++] * l + n;
												m.quadraticCurveTo(D, C, A, z);
												break;
											case "b":
												A = r[v++] * l + t, z = r[v++] * l + n, D = r[v++] * l + t, C = r[v++] * l + n, u = r[v++] * l + t,
													w = r[v++] * l + n, m.bezierCurveTo(D, C, u, w, A, z)
										}
									}
									l = {
										offsetX: p.ha * l,
										path: m
									}
								} else console.error('THREE.Font: character "' + m + '" does not exists in font family ' + r.familyName +
									"."), l = void 0;
								h += l.offsetX;
								a.push(l.path)
							}
						}
						b = 0;
						for (e = a.length; b < e; b++) Array.prototype.push.apply(c, a[b].toShapes());
						return c
					}
				});
				Sf.prototype = q(p(Qa.prototype), {
					constructor: Sf,
					load: function(a, b, c, d) {
						var e = this,
							f = new Hd(this.manager);
						f.setPath(this.path);
						f.load(a,
							function(a) {
								try {
									var c = JSON.parse(a)
								} catch (Y) {
									console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."),
										c = JSON.parse(a.substring(65, a.length - 2))
								}
								a = e.parse(c);
								b && b(a)
							}, c, d)
					},
					parse: function(a) {
						return new Rf(a)
					}
				});
				var Jk, Fh = {
					getContext: function() {
						void 0 === Jk && (Jk = new(window.AudioContext || window.webkitAudioContext));
						return Jk
					},
					setContext: function(a) {
						Jk = a
					}
				};
				gf.prototype = q(p(Qa.prototype), {
					constructor: gf,
					load: function(a, b, c, d) {
						var e = new Hd(this.manager);
						e.setResponseType("arraybuffer");
						e.setPath(this.path);
						e.load(a, function(a) {
							a = a.slice(0);
							Fh.getContext().decodeAudioData(a, function(a) {
								b(a)
							})
						}, c, d)
					}
				});
				q(hf.prototype, {
					isSphericalHarmonics3: !0,
					set: function(a) {
						for (var b = 0; 9 > b; b++) this.coefficients[b].copy(a[b]);
						return this
					},
					zero: function() {
						for (var a = 0; 9 > a; a++) this.coefficients[a].set(0, 0, 0);
						return this
					},
					getAt: function(a, b) {
						var c = a.x,
							d = a.y;
						a = a.z;
						var e = this.coefficients;
						b.copy(e[0]).multiplyScalar(.282095);
						b.addScale(e[1], .488603 * d);
						b.addScale(e[2], .488603 * a);
						b.addScale(e[3], .488603 *
							c);
						b.addScale(e[4], 1.092548 * c * d);
						b.addScale(e[5], 1.092548 * d * a);
						b.addScale(e[6], .315392 * (3 * a * a - 1));
						b.addScale(e[7], 1.092548 * c * a);
						b.addScale(e[8], .546274 * (c * c - d * d));
						return b
					},
					getIrradianceAt: function(a, b) {
						var c = a.x,
							d = a.y;
						a = a.z;
						var e = this.coefficients;
						b.copy(e[0]).multiplyScalar(.886227);
						b.addScale(e[1], 1.023328 * d);
						b.addScale(e[2], 1.023328 * a);
						b.addScale(e[3], 1.023328 * c);
						b.addScale(e[4], .858086 * c * d);
						b.addScale(e[5], .858086 * d * a);
						b.addScale(e[6], .743125 * a * a - .247708);
						b.addScale(e[7], .858086 * c * a);
						b.addScale(e[8],
							.429043 * (c * c - d * d));
						return b
					},
					add: function(a) {
						for (var b = 0; 9 > b; b++) this.coefficients[b].add(a.coefficients[b]);
						return this
					},
					scale: function(a) {
						for (var b = 0; 9 > b; b++) this.coefficients[b].multiplyScalar(a);
						return this
					},
					lerp: function(a, b) {
						for (var c = 0; 9 > c; c++) this.coefficients[c].lerp(a.coefficients[c], b);
						return this
					},
					equals: function(a) {
						for (var b = 0; 9 > b; b++)
							if (!this.coefficients[b].equals(a.coefficients[b])) return !1;
						return !0
					},
					copy: function(a) {
						return this.set(a.coefficients)
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					fromArray: function(a, b) {
						void 0 === b && (b = 0);
						for (var c = this.coefficients, d = 0; 9 > d; d++) c[d].fromArray(a, b + 3 * d);
						return this
					},
					toArray: function(a, b) {
						void 0 === a && (a = []);
						void 0 === b && (b = 0);
						for (var c = this.coefficients, d = 0; 9 > d; d++) c[d].toArray(a, b + 3 * d);
						return a
					}
				});
				q(hf, {
					getBasisAt: function(a, b) {
						var c = a.x,
							d = a.y;
						a = a.z;
						b[0] = .282095;
						b[1] = .488603 * d;
						b[2] = .488603 * a;
						b[3] = .488603 * c;
						b[4] = 1.092548 * c * d;
						b[5] = 1.092548 * d * a;
						b[6] = .315392 * (3 * a * a - 1);
						b[7] = 1.092548 * c * a;
						b[8] = .546274 * (c * c - d * d)
					}
				});
				te.prototype = q(p(Ta.prototype), {
					constructor: te,
					isLightProbe: !0,
					copy: function(a) {
						Ta.prototype.copy.call(this, a);
						this.sh.copy(a.sh);
						this.intensity = a.intensity;
						return this
					},
					toJSON: function(a) {
						return Ta.prototype.toJSON.call(this, a)
					}
				});
				Tf.prototype = q(p(te.prototype), {
					constructor: Tf,
					isHemisphereLightProbe: !0,
					copy: function(a) {
						te.prototype.copy.call(this, a);
						return this
					},
					toJSON: function(a) {
						return te.prototype.toJSON.call(this, a)
					}
				});
				Vf.prototype = q(p(te.prototype), {
					constructor: Vf,
					isAmbientLightProbe: !0,
					copy: function(a) {
						te.prototype.copy.call(this, a);
						return this
					},
					toJSON: function(a) {
						return te.prototype.toJSON.call(this, a)
					}
				});
				var Ti = new v,
					Vi = new v;
				q(Sg.prototype, {
					update: function(a) {
						var b = this._cache;
						if (b.focus !== a.focus || b.fov !== a.fov || b.aspect !== a.aspect * this.aspect || b.near !== a.near || b
							.far !== a.far || b.zoom !== a.zoom || b.eyeSep !== this.eyeSep) {
							b.focus = a.focus;
							b.fov = a.fov;
							b.aspect = a.aspect * this.aspect;
							b.near = a.near;
							b.far = a.far;
							b.zoom = a.zoom;
							b.eyeSep = this.eyeSep;
							var c = a.projectionMatrix.clone(),
								d = b.eyeSep / 2,
								e = d * b.near / b.focus,
								f = b.near * Math.tan(Ea.DEG2RAD * b.fov * .5) /
								b.zoom;
							Vi.elements[12] = -d;
							Ti.elements[12] = d;
							d = -f * b.aspect + e;
							var h = f * b.aspect + e;
							c.elements[0] = 2 * b.near / (h - d);
							c.elements[8] = (h + d) / (h - d);
							this.cameraL.projectionMatrix.copy(c);
							d = -f * b.aspect - e;
							h = f * b.aspect - e;
							c.elements[0] = 2 * b.near / (h - d);
							c.elements[8] = (h + d) / (h - d);
							this.cameraR.projectionMatrix.copy(c)
						}
						this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(Vi);
						this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(Ti)
					}
				});
				q(Wf.prototype, {
					start: function() {
						this.oldTime = this.startTime = ("undefined" === typeof performance ?
							Date : performance).now();
						this.elapsedTime = 0;
						this.running = !0
					},
					stop: function() {
						this.getElapsedTime();
						this.autoStart = this.running = !1
					},
					getElapsedTime: function() {
						this.getDelta();
						return this.elapsedTime
					},
					getDelta: function() {
						var a = 0;
						if (this.autoStart && !this.running) return this.start(), 0;
						if (this.running) {
							var b = ("undefined" === typeof performance ? Date : performance).now();
							a = (b - this.oldTime) / 1E3;
							this.oldTime = b;
							this.elapsedTime += a
						}
						return a
					}
				});
				var si = new f,
					Wi = new e,
					ck = new f,
					ti = new f;
				Xf.prototype = q(p(u.prototype), {
					constructor: Xf,
					getInput: function() {
						return this.gain
					},
					removeFilter: function() {
						null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination),
							this.gain.connect(this.context.destination), this.filter = null);
						return this
					},
					getFilter: function() {
						return this.filter
					},
					setFilter: function(a) {
						null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) :
							this.gain.disconnect(this.context.destination);
						this.filter = a;
						this.gain.connect(this.filter);
						this.filter.connect(this.context.destination);
						return this
					},
					getMasterVolume: function() {
						return this.gain.gain.value
					},
					setMasterVolume: function(a) {
						this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
						return this
					},
					updateMatrixWorld: function(a) {
						u.prototype.updateMatrixWorld.call(this, a);
						a = this.context.listener;
						var b = this.up;
						this.timeDelta = this._clock.getDelta();
						this.matrixWorld.decompose(si, Wi, ck);
						ti.set(0, 0, -1).applyQuaternion(Wi);
						if (a.positionX) {
							var c = this.context.currentTime + this.timeDelta;
							a.positionX.linearRampToValueAtTime(si.x, c);
							a.positionY.linearRampToValueAtTime(si.y, c);
							a.positionZ.linearRampToValueAtTime(si.z, c);
							a.forwardX.linearRampToValueAtTime(ti.x, c);
							a.forwardY.linearRampToValueAtTime(ti.y, c);
							a.forwardZ.linearRampToValueAtTime(ti.z, c);
							a.upX.linearRampToValueAtTime(b.x, c);
							a.upY.linearRampToValueAtTime(b.y, c);
							a.upZ.linearRampToValueAtTime(b.z, c)
						} else a.setPosition(si.x, si.y, si.z), a.setOrientation(ti.x, ti.y, ti.z, b.x, b.y, b.z)
					}
				});
				Cj.prototype = q(p(u.prototype), {
					constructor: Cj,
					getOutput: function() {
						return this.gain
					},
					setNodeSource: function(a) {
						this.hasPlaybackControl = !1;
						this.sourceType = "audioNode";
						this.source = a;
						this.connect();
						return this
					},
					setMediaElementSource: function(a) {
						this.hasPlaybackControl = !1;
						this.sourceType = "mediaNode";
						this.source = this.context.createMediaElementSource(a);
						this.connect();
						return this
					},
					setMediaStreamSource: function(a) {
						this.hasPlaybackControl = !1;
						this.sourceType = "mediaStreamNode";
						this.source = this.context.createMediaStreamSource(a);
						this.connect();
						return this
					},
					setBuffer: function(a) {
						this.buffer = a;
						this.sourceType = "buffer";
						this.autoplay && this.play();
						return this
					},
					play: function() {
						if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
						else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
						else {
							var a = this.context.createBufferSource();
							a.buffer = this.buffer;
							a.loop = this.loop;
							a.onended = this.onEnded.bind(this);
							this.startTime = this.context.currentTime;
							a.start(this.startTime, this.offset, this.duration);
							this.isPlaying = !0;
							this.source = a;
							this.setDetune(this.detune);
							this.setPlaybackRate(this.playbackRate);
							return this.connect()
						}
					},
					pause: function() {
						if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
						else return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context
							.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this
					},
					stop: function() {
						if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
						else return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this
					},
					connect: function() {
						if (0 < this.filters.length) {
							this.source.connect(this.filters[0]);
							for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
							this.filters[this.filters.length - 1].connect(this.getOutput())
						} else this.source.connect(this.getOutput());
						return this
					},
					disconnect: function() {
						if (0 < this.filters.length) {
							this.source.disconnect(this.filters[0]);
							for (var a = 1, b = this.filters.length; a <
								b; a++) this.filters[a - 1].disconnect(this.filters[a]);
							this.filters[this.filters.length - 1].disconnect(this.getOutput())
						} else this.source.disconnect(this.getOutput());
						return this
					},
					getFilters: function() {
						return this.filters
					},
					setFilters: function(a) {
						a || (a = []);
						!0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
						return this
					},
					setDetune: function(a) {
						this.detune = a;
						if (void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune,
							this.context.currentTime,
							.01), this
					},
					getDetune: function() {
						return this.detune
					},
					getFilter: function() {
						return this.getFilters()[0]
					},
					setFilter: function(a) {
						return this.setFilters(a ? [a] : [])
					},
					setPlaybackRate: function(a) {
						if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
						else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate,
							this.context.currentTime, .01), this
					},
					getPlaybackRate: function() {
						return this.playbackRate
					},
					onEnded: function() {
						this.isPlaying = !1
					},
					getLoop: function() {
						return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."),
							!1) : this.loop
					},
					setLoop: function(a) {
						if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
						else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this
					},
					getVolume: function() {
						return this.gain.gain.value
					},
					setVolume: function(a) {
						this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
						return this
					}
				});
				var ui = new f,
					Xi =
					new e,
					ek = new f,
					vi = new f;
				Yf.prototype = q(p(Cj.prototype), {
					constructor: Yf,
					getOutput: function() {
						return this.panner
					},
					getRefDistance: function() {
						return this.panner.refDistance
					},
					setRefDistance: function(a) {
						this.panner.refDistance = a;
						return this
					},
					getRolloffFactor: function() {
						return this.panner.rolloffFactor
					},
					setRolloffFactor: function(a) {
						this.panner.rolloffFactor = a;
						return this
					},
					getDistanceModel: function() {
						return this.panner.distanceModel
					},
					setDistanceModel: function(a) {
						this.panner.distanceModel = a;
						return this
					},
					getMaxDistance: function() {
						return this.panner.maxDistance
					},
					setMaxDistance: function(a) {
						this.panner.maxDistance = a;
						return this
					},
					setDirectionalCone: function(a, b, c) {
						this.panner.coneInnerAngle = a;
						this.panner.coneOuterAngle = b;
						this.panner.coneOuterGain = c;
						return this
					},
					updateMatrixWorld: function(a) {
						u.prototype.updateMatrixWorld.call(this, a);
						if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
							if (this.matrixWorld.decompose(ui, Xi, ek), vi.set(0, 0, 1).applyQuaternion(Xi), a = this.panner, a.positionX) {
								var b = this.context.currentTime + this.listener.timeDelta;
								a.positionX.linearRampToValueAtTime(ui.x,
									b);
								a.positionY.linearRampToValueAtTime(ui.y, b);
								a.positionZ.linearRampToValueAtTime(ui.z, b);
								a.orientationX.linearRampToValueAtTime(vi.x, b);
								a.orientationY.linearRampToValueAtTime(vi.y, b);
								a.orientationZ.linearRampToValueAtTime(vi.z, b)
							} else a.setPosition(ui.x, ui.y, ui.z), a.setOrientation(vi.x, vi.y, vi.z)
					}
				});
				q(Zf.prototype, {
					getFrequencyData: function() {
						this.analyser.getByteFrequencyData(this.data);
						return this.data
					},
					getAverageFrequency: function() {
						for (var a = 0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a +=
							b[c];
						return a / b.length
					}
				});
				q($f.prototype, {
					accumulate: function(a, b) {
						var c = this.buffer,
							d = this.valueSize;
						a = a * d + d;
						var e = this.cumulativeWeight;
						if (0 === e) {
							for (e = 0; e !== d; ++e) c[a + e] = c[e];
							e = b
						} else e += b, this._mixBufferRegion(c, a, 0, b / e, d);
						this.cumulativeWeight = e
					},
					apply: function(a) {
						var b = this.valueSize,
							c = this.buffer;
						a = a * b + b;
						var d = this.cumulativeWeight,
							e = this.binding;
						this.cumulativeWeight = 0;
						1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
						d = b;
						for (var f = b + b; d !== f; ++d)
							if (c[d] !== c[d + b]) {
								e.setValue(c, a);
								break
							}
					},
					saveOriginalState: function() {
						var a =
							this.buffer,
							b = this.valueSize,
							c = 3 * b;
						this.binding.getValue(a, c);
						for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
						this.cumulativeWeight = 0
					},
					restoreOriginalState: function() {
						this.binding.setValue(this.buffer, 3 * this.valueSize)
					},
					_select: function(a, b, c, d, e) {
						if (.5 <= d)
							for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
					},
					_slerp: function(a, b, c, d) {
						e.slerpFlat(a, b, a, b, a, c, d)
					},
					_lerp: function(a, b, c, d, e) {
						for (var f = 1 - d, h = 0; h !== e; ++h) {
							var g = b + h;
							a[g] = a[g] * f + a[c + h] * d
						}
					}
				});
				var fk = /[\[\]\.:\/]/g,
					gk = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
					hk = /((?:WC+[\/:])*)/.source.replace("WC",
						"[^\\[\\]\\.:\\/]"),
					ik = /(WCOD+)?/.source.replace("WCOD", gk),
					jk = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
					kk = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
					lk = new RegExp("^" + hk + ik + jk + kk + "$"),
					mk = ["material", "materials", "bones"];
				q(Ug.prototype, {
					getValue: function(a, b) {
						this.bind();
						var c = this._bindings[this._targetGroup.nCachedObjects_];
						void 0 !== c && c.getValue(a, b)
					},
					setValue: function(a, b) {
						for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !==
							e; ++d) c[d].setValue(a, b)
					},
					bind: function() {
						for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
					},
					unbind: function() {
						for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
					}
				});
				q(Lb, {
					Composite: Ug,
					create: function(a, b, c) {
						return a && a.isAnimationObjectGroup ? new Lb.Composite(a, b, c) : new Lb(a, b, c)
					},
					sanitizeNodeName: function(a) {
						return a.replace(/\s/g, "_").replace(fk, "")
					},
					parseTrackName: function(a) {
						var b = lk.exec(a);
						if (!b) throw Error("PropertyBinding: Cannot parse trackName: " +
							a);
						b = {
							nodeName: b[2],
							objectName: b[3],
							objectIndex: b[4],
							propertyName: b[5],
							propertyIndex: b[6]
						};
						var c = b.nodeName && b.nodeName.lastIndexOf(".");
						if (void 0 !== c && -1 !== c) {
							var d = b.nodeName.substring(c + 1); - 1 !== mk.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName =
								d)
						}
						if (null === b.propertyName || 0 === b.propertyName.length) throw Error(
							"PropertyBinding: can not parse propertyName from trackName: " + a);
						return b
					},
					findNode: function(a, b) {
						if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
						if (a.skeleton) {
							var c = a.skeleton.getBoneByName(b);
							if (void 0 !== c) return c
						}
						return a.children && (a = function O(a) {
							for (var c = 0; c < a.length; c++) {
								var d = a[c];
								if (d.name === b || d.uuid === b || (d = O(d.children))) return d
							}
							return null
						}(a.children)) ? a : null
					}
				});
				q(Lb.prototype, {
					_getValue_unavailable: function() {},
					_setValue_unavailable: function() {},
					BindingType: {
						Direct: 0,
						EntireArray: 1,
						ArrayElement: 2,
						HasFromToArray: 3
					},
					Versioning: {
						None: 0,
						NeedsUpdate: 1,
						MatrixWorldNeedsUpdate: 2
					},
					GetterByBindingType: [function(a, b) {
							a[b] = this.node[this.propertyName]
						},
						function(a, b) {
							for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
						},
						function(a, b) {
							a[b] = this.resolvedProperty[this.propertyIndex]
						},
						function(a, b) {
							this.resolvedProperty.toArray(a, b)
						}
					],
					SetterByBindingTypeAndVersioning: [
						[function(a, b) {
							this.targetObject[this.propertyName] = a[b]
						}, function(a, b) {
							this.targetObject[this.propertyName] = a[b];
							this.targetObject.needsUpdate = !0
						}, function(a, b) {
							this.targetObject[this.propertyName] = a[b];
							this.targetObject.matrixWorldNeedsUpdate = !0
						}],
						[function(a, b) {
							for (var c =
									this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
						}, function(a, b) {
							for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
							this.targetObject.needsUpdate = !0
						}, function(a, b) {
							for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
							this.targetObject.matrixWorldNeedsUpdate = !0
						}],
						[function(a, b) {
							this.resolvedProperty[this.propertyIndex] = a[b]
						}, function(a, b) {
							this.resolvedProperty[this.propertyIndex] = a[b];
							this.targetObject.needsUpdate = !0
						}, function(a, b) {
							this.resolvedProperty[this.propertyIndex] =
								a[b];
							this.targetObject.matrixWorldNeedsUpdate = !0
						}],
						[function(a, b) {
							this.resolvedProperty.fromArray(a, b)
						}, function(a, b) {
							this.resolvedProperty.fromArray(a, b);
							this.targetObject.needsUpdate = !0
						}, function(a, b) {
							this.resolvedProperty.fromArray(a, b);
							this.targetObject.matrixWorldNeedsUpdate = !0
						}]
					],
					getValue: function(a, b) {
						this.bind();
						this.getValue(a, b)
					},
					setValue: function(a, b) {
						this.bind();
						this.setValue(a, b)
					},
					bind: function() {
						var a = this.node,
							b = this.parsedPath,
							c = b.objectName,
							d = b.propertyName,
							e = b.propertyIndex;
						a || (this.node =
							a = Lb.findNode(this.rootNode, b.nodeName) || this.rootNode);
						this.getValue = this._getValue_unavailable;
						this.setValue = this._setValue_unavailable;
						if (a) {
							if (c) {
								var f = b.objectIndex;
								switch (c) {
									case "materials":
										if (!a.material) {
											console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",
												this);
											return
										}
										if (!a.material.materials) {
											console.error(
												"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
												this);
											return
										}
										a = a.material.materials;
										break;
									case "bones":
										if (!a.skeleton) {
											console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
											return
										}
										a = a.skeleton.bones;
										for (c = 0; c < a.length; c++)
											if (a[c].name === f) {
												f = c;
												break
											} break;
									default:
										if (void 0 === a[c]) {
											console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
											return
										}
										a = a[c]
								}
								if (void 0 !== f) {
									if (void 0 === a[f]) {
										console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
											this, a);
										return
									}
									a =
										a[f]
								}
							}
							f = a[d];
							if (void 0 === f) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName +
								"." + d + " but it wasn't found.", a);
							else {
								b = this.Versioning.None;
								this.targetObject = a;
								void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b =
									this.Versioning.MatrixWorldNeedsUpdate);
								c = this.BindingType.Direct;
								if (void 0 !== e) {
									if ("morphTargetInfluences" === d) {
										if (!a.geometry) {
											console.error(
												"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
												this);
											return
										}
										if (a.geometry.isBufferGeometry) {
											if (!a.geometry.morphAttributes) {
												console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
													this);
												return
											}
											for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)
												if (a.geometry.morphAttributes.position[c].name === e) {
													e = c;
													break
												}
										} else {
											if (!a.geometry.morphTargets) {
												console.error(
													"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
													this);
												return
											}
											for (c = 0; c < this.node.geometry.morphTargets.length; c++)
												if (a.geometry.morphTargets[c].name === e) {
													e = c;
													break
												}
										}
									}
									c = this.BindingType.ArrayElement;
									this.resolvedProperty = f;
									this.propertyIndex = e
								} else void 0 !== f.fromArray && void 0 !== f.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty =
										f) : Array.isArray(f) ? (c = this.BindingType.EntireArray, this.resolvedProperty = f) : this.propertyName =
									d;
								this.getValue = this.GetterByBindingType[c];
								this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
							}
						} else console.error("THREE.PropertyBinding: Trying to update node for track: " +
							this.path + " but it wasn't found.")
					},
					unbind: function() {
						this.node = null;
						this.getValue = this._getValue_unbound;
						this.setValue = this._setValue_unbound
					}
				});
				q(Lb.prototype, {
					_getValue_unbound: Lb.prototype.getValue,
					_setValue_unbound: Lb.prototype.setValue
				});
				q(Xg.prototype, {
					isAnimationObjectGroup: !0,
					add: function() {
						for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths,
								f = this._parsedPaths, g = this._bindings, k = g.length, l = void 0, m = 0, n = arguments.length; m !==
							n; ++m) {
							var r = arguments[m],
								p = r.uuid,
								v = d[p];
							if (void 0 === v) {
								v = b++;
								d[p] = v;
								a.push(r);
								p = 0;
								for (var q = k; p !== q; ++p) g[p].push(new Lb(r, e[p], f[p]))
							} else if (v < c) {
								l = a[v];
								var u = --c;
								q = a[u];
								d[q.uuid] = v;
								a[v] = q;
								d[p] = u;
								a[u] = r;
								p = 0;
								for (q = k; p !== q; ++p) {
									var w = g[p],
										A = w[v];
									w[v] = w[u];
									void 0 === A && (A = new Lb(r, e[p], f[p]));
									w[u] = A
								}
							} else a[v] !== l && console.error(
								"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
							)
						}
						this.nCachedObjects_ = c
					},
					remove: function() {
						for (var a =
								this._objects, b = this.nCachedObjects_, c = this._indicesByUUID, d = this._bindings, e = d.length, f = 0,
								g = arguments.length; f !== g; ++f) {
							var k = arguments[f],
								l = k.uuid,
								m = c[l];
							if (void 0 !== m && m >= b) {
								var n = b++,
									r = a[n];
								c[r.uuid] = m;
								a[m] = r;
								c[l] = n;
								a[n] = k;
								k = 0;
								for (l = e; k !== l; ++k) {
									r = d[k];
									var p = r[m];
									r[m] = r[n];
									r[n] = p
								}
							}
						}
						this.nCachedObjects_ = b
					},
					uncache: function() {
						for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings,
								f = e.length, g = 0, k = arguments.length; g !== k; ++g) {
							var l = arguments[g].uuid,
								m = d[l];
							if (void 0 !== m)
								if (delete d[l], m < c) {
									l = --c;
									var n = a[l],
										r = --b,
										p = a[r];
									d[n.uuid] = m;
									a[m] = n;
									d[p.uuid] = l;
									a[l] = p;
									a.pop();
									n = 0;
									for (p = f; n !== p; ++n) {
										var v = e[n],
											q = v[r];
										v[m] = v[l];
										v[l] = q;
										v.pop()
									}
								} else
									for (r = --b, p = a[r], d[p.uuid] = m, a[m] = p, a.pop(), n = 0, p = f; n !== p; ++n) v = e[n], v[m] = v[
										r], v.pop()
						}
						this.nCachedObjects_ = c
					},
					subscribe_: function(a, b) {
						var c = this._bindingsIndicesByPath,
							d = c[a],
							e = this._bindings;
						if (void 0 !== d) return e[d];
						var f = this._paths,
							h = this._parsedPaths,
							g = this._objects,
							k = this.nCachedObjects_,
							l = Array(g.length);
						d = e.length;
						c[a] = d;
						f.push(a);
						h.push(b);
						e.push(l);
						c = k;
						for (d = g.length; c !== d; ++c) l[c] = new Lb(g[c], a, b);
						return l
					},
					unsubscribe_: function(a) {
						var b = this._bindingsIndicesByPath,
							c = b[a];
						if (void 0 !== c) {
							var d = this._paths,
								e = this._parsedPaths,
								f = this._bindings,
								h = f.length - 1,
								g = f[h];
							b[a[h]] = c;
							f[c] = g;
							f.pop();
							e[c] = e[h];
							e.pop();
							d[c] = d[h];
							d.pop()
						}
					}
				});
				q(Yg.prototype, {
					play: function() {
						this._mixer._activateAction(this);
						return this
					},
					stop: function() {
						this._mixer._deactivateAction(this);
						return this.reset()
					},
					reset: function() {
						this.paused = !1;
						this.enabled = !0;
						this.time = 0;
						this._loopCount = -1;
						this._startTime = null;
						return this.stopFading().stopWarping()
					},
					isRunning: function() {
						return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(
							this)
					},
					isScheduled: function() {
						return this._mixer._isActiveAction(this)
					},
					startAt: function(a) {
						this._startTime = a;
						return this
					},
					setLoop: function(a, b) {
						this.loop = a;
						this.repetitions = b;
						return this
					},
					setEffectiveWeight: function(a) {
						this.weight = a;
						this._effectiveWeight = this.enabled ?
							a : 0;
						return this.stopFading()
					},
					getEffectiveWeight: function() {
						return this._effectiveWeight
					},
					fadeIn: function(a) {
						return this._scheduleFading(a, 0, 1)
					},
					fadeOut: function(a) {
						return this._scheduleFading(a, 1, 0)
					},
					crossFadeFrom: function(a, b, c) {
						a.fadeOut(b);
						this.fadeIn(b);
						if (c) {
							c = this._clip.duration;
							var d = a._clip.duration,
								e = c / d;
							a.warp(1, d / c, b);
							this.warp(e, 1, b)
						}
						return this
					},
					crossFadeTo: function(a, b, c) {
						return a.crossFadeFrom(this, b, c)
					},
					stopFading: function() {
						var a = this._weightInterpolant;
						null !== a && (this._weightInterpolant =
							null, this._mixer._takeBackControlInterpolant(a));
						return this
					},
					setEffectiveTimeScale: function(a) {
						this.timeScale = a;
						this._effectiveTimeScale = this.paused ? 0 : a;
						return this.stopWarping()
					},
					getEffectiveTimeScale: function() {
						return this._effectiveTimeScale
					},
					setDuration: function(a) {
						this.timeScale = this._clip.duration / a;
						return this.stopWarping()
					},
					syncWith: function(a) {
						this.time = a.time;
						this.timeScale = a.timeScale;
						return this.stopWarping()
					},
					halt: function(a) {
						return this.warp(this._effectiveTimeScale, 0, a)
					},
					warp: function(a,
						b, c) {
						var d = this._mixer,
							e = d.time,
							f = this._timeScaleInterpolant,
							h = this.timeScale;
						null === f && (this._timeScaleInterpolant = f = d._lendControlInterpolant());
						d = f.parameterPositions;
						f = f.sampleValues;
						d[0] = e;
						d[1] = e + c;
						f[0] = a / h;
						f[1] = b / h;
						return this
					},
					stopWarping: function() {
						var a = this._timeScaleInterpolant;
						null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
						return this
					},
					getMixer: function() {
						return this._mixer
					},
					getClip: function() {
						return this._clip
					},
					getRoot: function() {
						return this._localRoot ||
							this._mixer._root
					},
					_update: function(a, b, c, d) {
						if (this.enabled) {
							var e = this._startTime;
							if (null !== e) {
								b = (a - e) * c;
								if (0 > b || 0 === c) return;
								this._startTime = null;
								b *= c
							}
							b *= this._updateTimeScale(a);
							c = this._updateTime(b);
							a = this._updateWeight(a);
							if (0 < a) {
								b = this._interpolants;
								e = this._propertyBindings;
								for (var f = 0, h = b.length; f !== h; ++f) b[f].evaluate(c), e[f].accumulate(d, a)
							}
						} else this._updateWeight(a)
					},
					_updateWeight: function(a) {
						var b = 0;
						if (this.enabled) {
							b = this.weight;
							var c = this._weightInterpolant;
							if (null !== c) {
								var d = c.evaluate(a)[0];
								b *= d;
								a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
							}
						}
						return this._effectiveWeight = b
					},
					_updateTimeScale: function(a) {
						var b = 0;
						if (!this.paused) {
							b = this.timeScale;
							var c = this._timeScaleInterpolant;
							if (null !== c) {
								var d = c.evaluate(a)[0];
								b *= d;
								a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
							}
						}
						return this._effectiveTimeScale = b
					},
					_updateTime: function(a) {
						var b = this.time + a,
							c = this._clip.duration,
							d = this.loop,
							e = this._loopCount,
							f = 2202 === d;
						if (0 === a) return -1 ===
							e ? b : f && 1 === (e & 1) ? c - b : b;
						if (2200 === d) a: {
							if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
							else if (0 > b) b = 0;
							else {
								this.time = b;
								break a
							}
							this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;this.time = b;this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: 0 > a ? -1 : 1
							})
						}
						else {
							-1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, f)) : this._setEndings(0 ===
								this.repetitions, !0, f));
							if (b >= c || 0 > b) {
								d = Math.floor(b / c);
								b -= c * d;
								e += Math.abs(d);
								var h = this.repetitions - e;
								0 >= h ? (this.clampWhenFinished ?
									this.paused = !0 : this.enabled = !1, this.time = b = 0 < a ? c : 0, this._mixer.dispatchEvent({
										type: "finished",
										action: this,
										direction: 0 < a ? 1 : -1
									})) : (1 === h ? (a = 0 > a, this._setEndings(a, !a, f)) : this._setEndings(!1, !1, f), this._loopCount =
									e, this.time = b, this._mixer.dispatchEvent({
										type: "loop",
										action: this,
										loopDelta: d
									}))
							} else this.time = b;
							if (f && 1 === (e & 1)) return c - b
						}
						return b
					},
					_setEndings: function(a, b, c) {
						var d = this._interpolantSettings;
						c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 :
							2402, d.endingEnd =
							b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
					},
					_scheduleFading: function(a, b, c) {
						var d = this._mixer,
							e = d.time,
							f = this._weightInterpolant;
						null === f && (this._weightInterpolant = f = d._lendControlInterpolant());
						d = f.parameterPositions;
						f = f.sampleValues;
						d[0] = e;
						f[0] = b;
						d[1] = e + a;
						f[1] = c;
						return this
					}
				});
				ag.prototype = q(p(b.prototype), {
					constructor: ag,
					_bindAction: function(a, b) {
						var c = a._localRoot || this._root,
							d = a._clip.tracks,
							e = d.length,
							f = a._propertyBindings;
						a = a._interpolants;
						var h = c.uuid,
							g = this._bindingsByRootAndName,
							k = g[h];
						void 0 ===
							k && (k = {}, g[h] = k);
						for (g = 0; g !== e; ++g) {
							var l = d[g],
								m = l.name,
								n = k[m];
							if (void 0 === n) {
								n = f[g];
								if (void 0 !== n) {
									null === n._cacheIndex && (++n.referenceCount, this._addInactiveBinding(n, h, m));
									continue
								}
								n = new $f(Lb.create(c, m, b && b._propertyBindings[g].binding.parsedPath), l.ValueTypeName, l.getValueSize());
								++n.referenceCount;
								this._addInactiveBinding(n, h, m)
							}
							f[g] = n;
							a[g].resultBuffer = n.buffer
						}
					},
					_activateAction: function(a) {
						if (!this._isActiveAction(a)) {
							if (null === a._cacheIndex) {
								var b = (a._localRoot || this._root).uuid,
									c = a._clip.uuid,
									d = this._actionsByClip[c];
								this._bindAction(a, d && d.knownActions[0]);
								this._addInactiveAction(a, c, b)
							}
							b = a._propertyBindings;
							c = 0;
							for (d = b.length; c !== d; ++c) {
								var e = b[c];
								0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
							}
							this._lendAction(a)
						}
					},
					_deactivateAction: function(a) {
						if (this._isActiveAction(a)) {
							for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
								var e = b[c];
								0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
							}
							this._takeBackAction(a)
						}
					},
					_initMemoryManager: function() {
						this._actions = [];
						this._nActiveActions = 0;
						this._actionsByClip = {};
						this._bindings = [];
						this._nActiveBindings = 0;
						this._bindingsByRootAndName = {};
						this._controlInterpolants = [];
						this._nActiveControlInterpolants = 0;
						var a = this;
						this.stats = {
							actions: {
								get total() {
									return a._actions.length
								},
								get inUse() {
									return a._nActiveActions
								}
							},
							bindings: {
								get total() {
									return a._bindings.length
								},
								get inUse() {
									return a._nActiveBindings
								}
							},
							controlInterpolants: {
								get total() {
									return a._controlInterpolants.length
								},
								get inUse() {
									return a._nActiveControlInterpolants
								}
							}
						}
					},
					_isActiveAction: function(a) {
						a = a._cacheIndex;
						return null !== a && a < this._nActiveActions
					},
					_addInactiveAction: function(a, b, c) {
						var d = this._actions,
							e = this._actionsByClip,
							f = e[b];
						void 0 === f ? (f = {
							knownActions: [a],
							actionByRoot: {}
						}, a._byClipCacheIndex = 0, e[b] = f) : (b = f.knownActions, a._byClipCacheIndex = b.length, b.push(a));
						a._cacheIndex = d.length;
						d.push(a);
						f.actionByRoot[c] = a
					},
					_removeInactiveAction: function(a) {
						var b = this._actions,
							c = b[b.length - 1],
							d = a._cacheIndex;
						c._cacheIndex = d;
						b[d] = c;
						b.pop();
						a._cacheIndex = null;
						b = a._clip.uuid;
						c = this._actionsByClip;
						d = c[b];
						var e = d.knownActions,
							f = e[e.length - 1],
							h = a._byClipCacheIndex;
						f._byClipCacheIndex = h;
						e[h] = f;
						e.pop();
						a._byClipCacheIndex = null;
						delete d.actionByRoot[(a._localRoot || this._root).uuid];
						0 === e.length && delete c[b];
						this._removeInactiveBindingsForAction(a)
					},
					_removeInactiveBindingsForAction: function(a) {
						a = a._propertyBindings;
						for (var b = 0, c = a.length; b !== c; ++b) {
							var d = a[b];
							0 === --d.referenceCount && this._removeInactiveBinding(d)
						}
					},
					_lendAction: function(a) {
						var b = this._actions,
							c = a._cacheIndex,
							d = this._nActiveActions++,
							e = b[d];
						a._cacheIndex = d;
						b[d] = a;
						e._cacheIndex = c;
						b[c] = e
					},
					_takeBackAction: function(a) {
						var b = this._actions,
							c = a._cacheIndex,
							d = --this._nActiveActions,
							e = b[d];
						a._cacheIndex = d;
						b[d] = a;
						e._cacheIndex = c;
						b[c] = e
					},
					_addInactiveBinding: function(a, b, c) {
						var d = this._bindingsByRootAndName,
							e = d[b],
							f = this._bindings;
						void 0 === e && (e = {}, d[b] = e);
						e[c] = a;
						a._cacheIndex = f.length;
						f.push(a)
					},
					_removeInactiveBinding: function(a) {
						var b = this._bindings,
							c = a.binding,
							d = c.rootNode.uuid;
						c = c.path;
						var e = this._bindingsByRootAndName,
							f = e[d],
							h = b[b.length - 1];
						a = a._cacheIndex;
						h._cacheIndex = a;
						b[a] = h;
						b.pop();
						delete f[c];
						0 === Ha(f).length && delete e[d]
					},
					_lendBinding: function(a) {
						var b = this._bindings,
							c = a._cacheIndex,
							d = this._nActiveBindings++,
							e = b[d];
						a._cacheIndex = d;
						b[d] = a;
						e._cacheIndex = c;
						b[c] = e
					},
					_takeBackBinding: function(a) {
						var b = this._bindings,
							c = a._cacheIndex,
							d = --this._nActiveBindings,
							e = b[d];
						a._cacheIndex = d;
						b[d] = a;
						e._cacheIndex = c;
						b[c] = e
					},
					_lendControlInterpolant: function() {
						var a = this._controlInterpolants,
							b = this._nActiveControlInterpolants++,
							c = a[b];
						void 0 === c && (c = new Ld(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer),
							c.__cacheIndex = b, a[b] = c);
						return c
					},
					_takeBackControlInterpolant: function(a) {
						var b = this._controlInterpolants,
							c = a.__cacheIndex,
							d = --this._nActiveControlInterpolants,
							e = b[d];
						a.__cacheIndex = d;
						b[d] = a;
						e.__cacheIndex = c;
						b[c] = e
					},
					_controlInterpolantsResultBuffer: new Float32Array(1),
					clipAction: function(a, b) {
						var c = b || this._root,
							d = c.uuid;
						c = "string" === typeof a ? Gd.findByName(c, a) : a;
						a = null !== c ? c.uuid : a;
						var e =
							this._actionsByClip[a],
							f = null;
						if (void 0 !== e) {
							f = e.actionByRoot[d];
							if (void 0 !== f) return f;
							f = e.knownActions[0];
							null === c && (c = f._clip)
						}
						if (null === c) return null;
						b = new Yg(this, c, b);
						this._bindAction(b, f);
						this._addInactiveAction(b, a, d);
						return b
					},
					existingAction: function(a, b) {
						var c = b || this._root;
						b = c.uuid;
						c = "string" === typeof a ? Gd.findByName(c, a) : a;
						a = this._actionsByClip[c ? c.uuid : a];
						return void 0 !== a ? a.actionByRoot[b] || null : null
					},
					stopAllAction: function() {
						for (var a = this._actions, b = this._nActiveActions, c = this._bindings,
								d = this._nActiveBindings, e = this._nActiveBindings = this._nActiveActions = 0; e !== b; ++e) a[e].reset();
						for (e = 0; e !== d; ++e) c[e].useCount = 0;
						return this
					},
					update: function(a) {
						a *= this.timeScale;
						for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Lg(a), f = this._accuIndex ^=
								1, h = 0; h !== c; ++h) b[h]._update(d, a, e, f);
						a = this._bindings;
						b = this._nActiveBindings;
						for (h = 0; h !== b; ++h) a[h].apply(f);
						return this
					},
					setTime: function(a) {
						for (var b = this.time = 0; b < this._actions.length; b++) this._actions[b].time = 0;
						return this.update(a)
					},
					getRoot: function() {
						return this._root
					},
					uncacheClip: function(a) {
						var b = this._actions;
						a = a.uuid;
						var c = this._actionsByClip,
							d = c[a];
						if (void 0 !== d) {
							d = d.knownActions;
							for (var e = 0, f = d.length; e !== f; ++e) {
								var h = d[e];
								this._deactivateAction(h);
								var g = h._cacheIndex,
									k = b[b.length - 1];
								h._cacheIndex = null;
								h._byClipCacheIndex = null;
								k._cacheIndex = g;
								b[g] = k;
								b.pop();
								this._removeInactiveBindingsForAction(h)
							}
							delete c[a]
						}
					},
					uncacheRoot: function(a) {
						a = a.uuid;
						var b = this._actionsByClip;
						for (d in b) {
							var c = b[d].actionByRoot[a];
							void 0 !== c &&
								(this._deactivateAction(c), this._removeInactiveAction(c))
						}
						var d = this._bindingsByRootAndName[a];
						if (void 0 !== d)
							for (var e in d) a = d[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
					},
					uncacheAction: function(a, b) {
						a = this.existingAction(a, b);
						null !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
					}
				});
				jf.prototype.clone = function() {
					return new jf(void 0 === this.value.clone ? this.value : this.value.clone())
				};
				eg.prototype = q(p(Db.prototype), {
					constructor: eg,
					isInstancedInterleavedBuffer: !0,
					copy: function(a) {
						Db.prototype.copy.call(this,
							a);
						this.meshPerAttribute = a.meshPerAttribute;
						return this
					}
				});
				q(dh.prototype, {
					linePrecision: 1,
					set: function(a, b) {
						this.ray.set(a, b)
					},
					setFromCamera: function(a, b) {
						b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(
								a.x, a.y, .5).unproject(b).sub(this.ray.origin).normalize(), this.camera = b) : b && b.isOrthographicCamera ?
							(this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b.far)).unproject(b), this.ray.direction.set(0,
									0, -1).transformDirection(b.matrixWorld), this.camera =
								b) : console.error("THREE.Raycaster: Unsupported camera type.")
					},
					intersectObject: function(a, b, c) {
						c = c || [];
						fg(a, this, c, b);
						c.sort(eh);
						return c
					},
					intersectObjects: function(a, b, c) {
						c = c || [];
						if (!1 === Array.isArray(a)) return console.warn(
							"THREE.Raycaster.intersectObjects: objects is not an Array."), c;
						for (var d = 0, e = a.length; d < e; d++) fg(a[d], this, c, b);
						c.sort(eh);
						return c
					}
				});
				q(fh.prototype, {
					set: function(a, b, c) {
						this.radius = a;
						this.phi = b;
						this.theta = c;
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.radius = a.radius;
						this.phi = a.phi;
						this.theta = a.theta;
						return this
					},
					makeSafe: function() {
						this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
						return this
					},
					setFromVector3: function(a) {
						return this.setFromCartesianCoords(a.x, a.y, a.z)
					},
					setFromCartesianCoords: function(a, b, c) {
						this.radius = Math.sqrt(a * a + b * b + c * c);
						0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c), this.phi = Math.acos(Ea.clamp(
							b / this.radius, -1, 1)));
						return this
					}
				});
				q(oh.prototype, {
					set: function(a, b, c) {
						this.radius =
							a;
						this.theta = b;
						this.y = c;
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.radius = a.radius;
						this.theta = a.theta;
						this.y = a.y;
						return this
					},
					setFromVector3: function(a) {
						return this.setFromCartesianCoords(a.x, a.y, a.z)
					},
					setFromCartesianCoords: function(a, b, c) {
						this.radius = Math.sqrt(a * a + c * c);
						this.theta = Math.atan2(a, c);
						this.y = b;
						return this
					}
				});
				var aj = new d;
				q(sg.prototype, {
					set: function(a, b) {
						this.min.copy(a);
						this.max.copy(b);
						return this
					},
					setFromPoints: function(a) {
						this.makeEmpty();
						for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
						return this
					},
					setFromCenterAndSize: function(a, b) {
						b = aj.copy(b).multiplyScalar(.5);
						this.min.copy(a).sub(b);
						this.max.copy(a).add(b);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.min.copy(a.min);
						this.max.copy(a.max);
						return this
					},
					makeEmpty: function() {
						this.min.x = this.min.y = Infinity;
						this.max.x = this.max.y = -Infinity;
						return this
					},
					isEmpty: function() {
						return this.max.x < this.min.x || this.max.y < this.min.y
					},
					getCenter: function(a) {
						void 0 ===
							a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new d);
						return this.isEmpty() ? a.set(0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
					},
					getSize: function(a) {
						void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new d);
						return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
					},
					expandByPoint: function(a) {
						this.min.min(a);
						this.max.max(a);
						return this
					},
					expandByVector: function(a) {
						this.min.sub(a);
						this.max.add(a);
						return this
					},
					expandByScalar: function(a) {
						this.min.addScalar(-a);
						this.max.addScalar(a);
						return this
					},
					containsPoint: function(a) {
						return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
					},
					containsBox: function(a) {
						return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
					},
					getParameter: function(a, b) {
						void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new d);
						return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
					},
					intersectsBox: function(a) {
						return a.max.x <
							this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
					},
					clampPoint: function(a, b) {
						void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new d);
						return b.copy(a).clamp(this.min, this.max)
					},
					distanceToPoint: function(a) {
						return aj.copy(a).clamp(this.min, this.max).sub(a).length()
					},
					intersect: function(a) {
						this.min.max(a.min);
						this.max.min(a.max);
						return this
					},
					union: function(a) {
						this.min.min(a.min);
						this.max.max(a.max);
						return this
					},
					translate: function(a) {
						this.min.add(a);
						this.max.add(a);
						return this
					},
					equals: function(a) {
						return a.min.equals(this.min) && a.max.equals(this.max)
					}
				});
				var ej = new f,
					Kk = new f;
				q(tg.prototype, {
					set: function(a, b) {
						this.start.copy(a);
						this.end.copy(b);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					},
					copy: function(a) {
						this.start.copy(a.start);
						this.end.copy(a.end);
						return this
					},
					getCenter: function(a) {
						void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new f);
						return a.addVectors(this.start, this.end).multiplyScalar(.5)
					},
					delta: function(a) {
						void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"), a = new f);
						return a.subVectors(this.end, this.start)
					},
					distanceSq: function() {
						return this.start.distanceToSquared(this.end)
					},
					distance: function() {
						return this.start.distanceTo(this.end)
					},
					at: function(a, b) {
						void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new f);
						return this.delta(b).multiplyScalar(a).add(this.start)
					},
					closestPointToPointParameter: function(a, b) {
						ej.subVectors(a, this.start);
						Kk.subVectors(this.end,
							this.start);
						a = Kk.dot(Kk);
						a = Kk.dot(ej) / a;
						b && (a = Ea.clamp(a, 0, 1));
						return a
					},
					closestPointToPoint: function(a, b, c) {
						a = this.closestPointToPointParameter(a, b);
						void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), c = new f);
						return this.delta(c).multiplyScalar(a).add(this.start)
					},
					applyMatrix4: function(a) {
						this.start.applyMatrix4(a);
						this.end.applyMatrix4(a);
						return this
					},
					equals: function(a) {
						return a.start.equals(this.start) && a.end.equals(this.end)
					}
				});
				xe.prototype = p(u.prototype);
				xe.prototype.constructor = xe;
				xe.prototype.isImmediateRenderObject = !0;
				var tf = new f,
					rg = new f,
					Oh = new k,
					nk = ["a", "b", "c"];
				ze.prototype = p(Sa.prototype);
				ze.prototype.constructor = ze;
				ze.prototype.update = function() {
					this.object.updateMatrixWorld(!0);
					Oh.getNormalMatrix(this.object.matrixWorld);
					var a = this.object.matrixWorld,
						b = this.geometry.attributes.position,
						c = this.object.geometry;
					if (c && c.isGeometry)
						for (var d = c.vertices, e = c.faces, f = c = 0, g = e.length; f < g; f++)
							for (var k = e[f], l = 0, m = k.vertexNormals.length; l < m; l++) {
								var n =
									k.vertexNormals[l];
								tf.copy(d[k[nk[l]]]).applyMatrix4(a);
								rg.copy(n).applyMatrix3(Oh).normalize().multiplyScalar(this.size).add(tf);
								b.setXYZ(c, tf.x, tf.y, tf.z);
								c += 1;
								b.setXYZ(c, rg.x, rg.y, rg.z);
								c += 1
							} else if (c && c.isBufferGeometry)
								for (d = c.attributes.position, e = c.attributes.normal, l = c = 0, m = d.count; l < m; l++) tf.set(d.getX(
										l), d.getY(l), d.getZ(l)).applyMatrix4(a), rg.set(e.getX(l), e.getY(l), e.getZ(l)), rg.applyMatrix3(Oh).normalize()
									.multiplyScalar(this.size).add(tf), b.setXYZ(c, tf.x, tf.y, tf.z), c += 1, b.setXYZ(c, rg.x,
										rg.y, rg.z), c += 1;
					b.needsUpdate = !0
				};
				var hj = new f;
				Dj.prototype = p(u.prototype);
				Dj.prototype.constructor = Dj;
				Dj.prototype.dispose = function() {
					this.cone.geometry.dispose();
					this.cone.material.dispose()
				};
				Dj.prototype.update = function() {
					this.light.updateMatrixWorld();
					var a = this.light.distance ? this.light.distance : 1E3,
						b = a * Math.tan(this.light.angle);
					this.cone.scale.set(b, b, a);
					hj.setFromMatrixPosition(this.light.target.matrixWorld);
					this.cone.lookAt(hj);
					void 0 !== this.color ? this.cone.material.color.set(this.color) :
						this.cone.material.color.copy(this.light.color)
				};
				var nh = new f,
					Lk = new v,
					Qh = new v;
				Ej.prototype = p(Sa.prototype);
				Ej.prototype.constructor = Ej;
				Ej.prototype.updateMatrixWorld = function(a) {
					var b = this.bones,
						c = this.geometry,
						d = c.getAttribute("position");
					Qh.getInverse(this.root.matrixWorld);
					for (var e = 0, f = 0; e < b.length; e++) {
						var g = b[e];
						g.parent && g.parent.isBone && (Lk.multiplyMatrices(Qh, g.matrixWorld), nh.setFromMatrixPosition(Lk), d.setXYZ(
								f, nh.x, nh.y, nh.z), Lk.multiplyMatrices(Qh, g.parent.matrixWorld), nh.setFromMatrixPosition(Lk),
							d.setXYZ(f + 1, nh.x, nh.y, nh.z), f += 2)
					}
					c.getAttribute("position").needsUpdate = !0;
					u.prototype.updateMatrixWorld.call(this, a)
				};
				Fj.prototype = p(ha.prototype);
				Fj.prototype.constructor = Fj;
				Fj.prototype.dispose = function() {
					this.geometry.dispose();
					this.material.dispose()
				};
				Fj.prototype.update = function() {
					void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
				};
				Gj.prototype = p(yb.prototype);
				Gj.prototype.constructor = Gj;
				Gj.prototype.update = function() {
					this.scale.set(.5 * this.light.width,
						.5 * this.light.height, 1);
					if (void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
					else {
						this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
						var a = this.material.color,
							b = Math.max(a.r, a.g, a.b);
						1 < b && a.multiplyScalar(1 / b);
						this.children[0].material.color.copy(this.material.color)
					}
				};
				Gj.prototype.dispose = function() {
					this.geometry.dispose();
					this.material.dispose();
					this.children[0].geometry.dispose();
					this.children[0].material.dispose()
				};
				var ok = new f,
					ij = new Q,
					kj = new Q;
				Hj.prototype = p(u.prototype);
				Hj.prototype.constructor = Hj;
				Hj.prototype.dispose = function() {
					this.children[0].geometry.dispose();
					this.children[0].material.dispose()
				};
				Hj.prototype.update = function() {
					var a = this.children[0];
					if (void 0 !== this.color) this.material.color.set(this.color);
					else {
						var b = a.geometry.getAttribute("color");
						ij.copy(this.light.color);
						kj.copy(this.light.groundColor);
						for (var c = 0, d = b.count; c < d; c++) {
							var e = c < d / 2 ? ij : kj;
							b.setXYZ(c, e.r, e.g, e.b)
						}
						b.needsUpdate = !0
					}
					a.lookAt(ok.setFromMatrixPosition(this.light.matrixWorld).negate())
				};
				Ij.prototype = p(ha.prototype);
				Ij.prototype.constructor = Ij;
				Ij.prototype.dispose = function() {
					this.geometry.dispose();
					this.material.dispose()
				};
				Ij.prototype.onBeforeRender = function() {
					this.position.copy(this.lightProbe.position);
					this.scale.set(1, 1, 1).multiplyScalar(this.size);
					this.material.uniforms.intensity.value = this.lightProbe.intensity
				};
				uf.prototype = q(p(Sa.prototype), {
					constructor: uf,
					copy: function(a) {
						Sa.prototype.copy.call(this, a);
						this.geometry.copy(a.geometry);
						this.material.copy(a.material);
						return this
					},
					clone: function() {
						return (new this.constructor).copy(this)
					}
				});
				vf.prototype = p(Sa.prototype);
				vf.prototype.constructor = vf;
				Jj.prototype = p(yb.prototype);
				Jj.prototype.constructor = Jj;
				Jj.prototype.update = function() {
					function a(a, b, d, e) {
						d = (b - a) / d;
						v.setXYZ(l, 0, 0, 0);
						m++;
						for (n = a; n < b; n += d) r = l + m, v.setXYZ(r, Math.sin(n) * c, 0, Math.cos(n) * c), v.setXYZ(r + 1, Math.sin(
							Math.min(n + d, b)) * c, 0, Math.cos(Math.min(n + d, b)) * c), v.setXYZ(r + 2, 0, 0, 0), m += 3;
						p.addGroup(l, m, e);
						l += m;
						m = 0
					}
					var b = this.audio,
						c = this.range,
						d = this.divisionsInnerAngle,
						e = this.divisionsOuterAngle,
						f = Ea.degToRad(b.panner.coneInnerAngle);
					b = Ea.degToRad(b.panner.coneOuterAngle);
					var g = f / 2,
						k = b / 2,
						l = 0,
						m = 0,
						n, r, p = this.geometry,
						v = p.attributes.position;
					p.clearGroups();
					a(-k, -g, e, 0);
					a(-g, g, d, 1);
					a(g, k, e, 0);
					v.needsUpdate = !0;
					f === b && (this.material[0].visible = !1)
				};
				Jj.prototype.dispose = function() {
					this.geometry.dispose();
					this.material[0].dispose();
					this.material[1].dispose()
				};
				var Ak = new f,
					Mk = new f,
					lj = new k;
				Fe.prototype = p(Sa.prototype);
				Fe.prototype.constructor = Fe;
				Fe.prototype.update = function() {
					this.object.updateMatrixWorld(!0);
					lj.getNormalMatrix(this.object.matrixWorld);
					var a = this.object.matrixWorld,
						b = this.geometry.attributes.position,
						c = this.object.geometry,
						d = c.vertices;
					c = c.faces;
					for (var e = 0, f = 0, g = c.length; f < g; f++) {
						var k = c[f],
							l = k.normal;
						Ak.copy(d[k.a]).add(d[k.b]).add(d[k.c]).divideScalar(3).applyMatrix4(a);
						Mk.copy(l).applyMatrix3(lj).normalize().multiplyScalar(this.size).add(Ak);
						b.setXYZ(e, Ak.x, Ak.y, Ak.z);
						e += 1;
						b.setXYZ(e, Mk.x, Mk.y, Mk.z);
						e += 1
					}
					b.needsUpdate = !0
				};
				var mj = new f,
					Nk = new f,
					nj = new f;
				Kj.prototype = p(u.prototype);
				Kj.prototype.constructor = Kj;
				Kj.prototype.dispose = function() {
					this.lightPlane.geometry.dispose();
					this.lightPlane.material.dispose();
					this.targetLine.geometry.dispose();
					this.targetLine.material.dispose()
				};
				Kj.prototype.update = function() {
					mj.setFromMatrixPosition(this.light.matrixWorld);
					Nk.setFromMatrixPosition(this.light.target.matrixWorld);
					nj.subVectors(Nk, mj);
					this.lightPlane.lookAt(Nk);
					void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(
							this.color)) :
						(this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
					this.targetLine.lookAt(Nk);
					this.targetLine.scale.z = nj.length()
				};
				var Ek = new f,
					gb = new va;
				He.prototype = p(Sa.prototype);
				He.prototype.constructor = He;
				He.prototype.update = function() {
					var a = this.geometry,
						b = this.pointMap;
					gb.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
					ib("c", b, a, gb, 0, 0, -1);
					ib("t", b, a, gb, 0, 0, 1);
					ib("n1", b, a, gb, -1, -1, -1);
					ib("n2", b, a, gb, 1, -1, -1);
					ib("n3", b, a, gb, -1, 1,
						-1);
					ib("n4", b, a, gb, 1, 1, -1);
					ib("f1", b, a, gb, -1, -1, 1);
					ib("f2", b, a, gb, 1, -1, 1);
					ib("f3", b, a, gb, -1, 1, 1);
					ib("f4", b, a, gb, 1, 1, 1);
					ib("u1", b, a, gb, .7, 1.1, -1);
					ib("u2", b, a, gb, -.7, 1.1, -1);
					ib("u3", b, a, gb, 0, 2, -1);
					ib("cf1", b, a, gb, -1, 0, 1);
					ib("cf2", b, a, gb, 1, 0, 1);
					ib("cf3", b, a, gb, 0, -1, 1);
					ib("cf4", b, a, gb, 0, 1, 1);
					ib("cn1", b, a, gb, -1, 0, -1);
					ib("cn2", b, a, gb, 1, 0, -1);
					ib("cn3", b, a, gb, 0, -1, -1);
					ib("cn4", b, a, gb, 0, 1, -1);
					a.getAttribute("position").needsUpdate = !0
				};
				var Ok = new D;
				kg.prototype = p(Sa.prototype);
				kg.prototype.constructor = kg;
				kg.prototype.update =
					function(a) {
						void 0 !== a && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
						void 0 !== this.object && Ok.setFromObject(this.object);
						if (!Ok.isEmpty()) {
							a = Ok.min;
							var b = Ok.max,
								c = this.geometry.attributes.position,
								d = c.array;
							d[0] = b.x;
							d[1] = b.y;
							d[2] = b.z;
							d[3] = a.x;
							d[4] = b.y;
							d[5] = b.z;
							d[6] = a.x;
							d[7] = a.y;
							d[8] = b.z;
							d[9] = b.x;
							d[10] = a.y;
							d[11] = b.z;
							d[12] = b.x;
							d[13] = b.y;
							d[14] = a.z;
							d[15] = a.x;
							d[16] = b.y;
							d[17] = a.z;
							d[18] = a.x;
							d[19] = a.y;
							d[20] = a.z;
							d[21] = b.x;
							d[22] = a.y;
							d[23] = a.z;
							c.needsUpdate = !0;
							this.geometry.computeBoundingSphere()
						}
					};
				kg.prototype.setFromObject = function(a) {
					this.object = a;
					this.update();
					return this
				};
				kg.prototype.copy = function(a) {
					Sa.prototype.copy.call(this, a);
					this.object = a.object;
					return this
				};
				kg.prototype.clone = function() {
					return (new this.constructor).copy(this)
				};
				Ie.prototype = p(Sa.prototype);
				Ie.prototype.constructor = Ie;
				Ie.prototype.updateMatrixWorld = function(a) {
					var b = this.box;
					b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), u.prototype.updateMatrixWorld
						.call(this, a))
				};
				Je.prototype =
					p(yb.prototype);
				Je.prototype.constructor = Je;
				Je.prototype.updateMatrixWorld = function(a) {
					var b = -this.plane.constant;
					1E-8 > Math.abs(b) && (b = 1E-8);
					this.scale.set(.5 * this.size, .5 * this.size, b);
					this.children[0].material.side = 0 > b ? 1 : 0;
					this.lookAt(this.plane.normal);
					u.prototype.updateMatrixWorld.call(this, a)
				};
				var oj = new f,
					Fk, Rh;
				lg.prototype = p(u.prototype);
				lg.prototype.constructor = lg;
				lg.prototype.setDirection = function(a) {
					.99999 < a.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > a.y ? this.quaternion.set(1, 0, 0, 0) : (oj.set(a.z,
						0, -a.x).normalize(), this.quaternion.setFromAxisAngle(oj, Math.acos(a.y)))
				};
				lg.prototype.setLength = function(a, b, c) {
					void 0 === b && (b = .2 * a);
					void 0 === c && (c = .2 * b);
					this.line.scale.set(1, Math.max(1E-4, a - b), 1);
					this.line.updateMatrix();
					this.cone.scale.set(c, b, c);
					this.cone.position.y = a;
					this.cone.updateMatrix()
				};
				lg.prototype.setColor = function(a) {
					this.line.material.color.set(a);
					this.cone.material.color.set(a)
				};
				lg.prototype.copy = function(a) {
					u.prototype.copy.call(this, a, !1);
					this.line.copy(a.line);
					this.cone.copy(a.cone);
					return this
				};
				lg.prototype.clone = function() {
					return (new this.constructor).copy(this)
				};
				Me.prototype = p(Sa.prototype);
				Me.prototype.constructor = Me;
				oa.create = function(a, b) {
					a.prototype = p(oa.prototype);
					a.prototype.constructor = a;
					a.prototype.getPoint = b;
					return a
				};
				q(jg.prototype, {
					createPointsGeometry: function(a) {
						console.warn(
							"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
						);
						a = this.getPoints(a);
						return this.createGeometry(a)
					},
					createSpacedPointsGeometry: function(a) {
						console.warn(
							"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
						);
						a = this.getSpacedPoints(a);
						return this.createGeometry(a)
					},
					createGeometry: function(a) {
						console.warn(
							"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
						);
						for (var b = new T, c = 0, d = a.length; c < d; c++) {
							var e = a[c];
							b.vertices.push(new f(e.x, e.y, e.z || 0))
						}
						return b
					}
				});
				q(se.prototype, {
					fromPoints: function(a) {
						console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
						this.setFromPoints(a)
					}
				});
				th.prototype = p(Kb.prototype);
				uh.prototype = p(Kb.prototype);
				zg.prototype = p(Kb.prototype);
				q(zg.prototype, {
					initFromArray: function() {
						console.error("THREE.Spline: .initFromArray() has been removed.")
					},
					getControlPointsArray: function() {
						console.error("THREE.Spline: .getControlPointsArray() has been removed.")
					},
					reparametrizeByArcLength: function() {
						console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
					}
				});
				uf.prototype.setColors = function() {
					console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
				};
				Ej.prototype.update = function() {
					console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
				};
				q(Qa.prototype, {
					extractUrlBase: function(a) {
						console.warn(
							"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
						return Dh.extractUrlBase(a)
					}
				});
				Qa.Handlers = {
					add: function() {
						console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
					},
					get: function() {
						console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
					}
				};
				q(ff.prototype, {
					setTexturePath: function(a) {
						console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
						return this.setResourcePath(a)
					}
				});
				q(sg.prototype, {
					center: function(a) {
						console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
						return this.getCenter(a)
					},
					empty: function() {
						console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
						return this.isEmpty()
					},
					isIntersectionBox: function(a) {
						console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
						return this.intersectsBox(a)
					},
					size: function(a) {
						console.warn("THREE.Box2: .size() has been renamed to .getSize().");
						return this.getSize(a)
					}
				});
				q(D.prototype, {
					center: function(a) {
						console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
						return this.getCenter(a)
					},
					empty: function() {
						console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
						return this.isEmpty()
					},
					isIntersectionBox: function(a) {
						console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
						return this.intersectsBox(a)
					},
					isIntersectionSphere: function(a) {
						console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
						return this.intersectsSphere(a)
					},
					size: function(a) {
						console.warn("THREE.Box3: .size() has been renamed to .getSize().");
						return this.getSize(a)
					}
				});
				tg.prototype.center = function(a) {
					console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
					return this.getCenter(a)
				};
				q(Ea, {
					random16: function() {
						console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
						return Math.random()
					},
					nearestPowerOfTwo: function(a) {
						console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
						return Ea.floorPowerOfTwo(a)
					},
					nextPowerOfTwo: function(a) {
						console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
						return Ea.ceilPowerOfTwo(a)
					}
				});
				q(k.prototype, {
					flattenToArrayOffset: function(a, b) {
						console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
						return this.toArray(a, b)
					},
					multiplyVector3: function(a) {
						console.warn(
							"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
						return a.applyMatrix3(this)
					},
					multiplyVector3Array: function() {
						console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
					},
					applyToBuffer: function(a) {
						console.warn(
							"THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
						);
						return this.applyToBufferAttribute(a)
					},
					applyToVector3Array: function() {
						console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
					}
				});
				q(v.prototype, {
					extractPosition: function(a) {
						console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
						return this.copyPosition(a)
					},
					flattenToArrayOffset: function(a, b) {
						console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
						return this.toArray(a, b)
					},
					getPosition: function() {
						console.warn(
							"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
						return (new f).setFromMatrixColumn(this, 3)
					},
					setRotationFromQuaternion: function(a) {
						console.warn(
							"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
						return this.makeRotationFromQuaternion(a)
					},
					multiplyToArray: function() {
						console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
					},
					multiplyVector3: function(a) {
						console.warn(
							"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
						return a.applyMatrix4(this)
					},
					multiplyVector4: function(a) {
						console.warn(
							"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
						return a.applyMatrix4(this)
					},
					multiplyVector3Array: function() {
						console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
					},
					rotateAxis: function(a) {
						console.warn(
							"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
						a.transformDirection(this)
					},
					crossVector: function(a) {
						console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
						return a.applyMatrix4(this)
					},
					translate: function() {
						console.error("THREE.Matrix4: .translate() has been removed.")
					},
					rotateX: function() {
						console.error("THREE.Matrix4: .rotateX() has been removed.")
					},
					rotateY: function() {
						console.error("THREE.Matrix4: .rotateY() has been removed.")
					},
					rotateZ: function() {
						console.error("THREE.Matrix4: .rotateZ() has been removed.")
					},
					rotateByAxis: function() {
						console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
					},
					applyToBuffer: function(a) {
						console.warn(
							"THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."
						);
						return this.applyToBufferAttribute(a)
					},
					applyToVector3Array: function() {
						console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
					},
					makeFrustum: function(a, b, c, d, e, f) {
						console.warn(
							"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
						);
						return this.makePerspective(a, b, d, c, e, f)
					}
				});
				za.prototype.isIntersectionLine = function(a) {
					console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
					return this.intersectsLine(a)
				};
				e.prototype.multiplyVector3 = function(a) {
					console.warn(
						"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
					);
					return a.applyQuaternion(this)
				};
				q(B.prototype, {
					isIntersectionBox: function(a) {
						console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
						return this.intersectsBox(a)
					},
					isIntersectionPlane: function(a) {
						console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
						return this.intersectsPlane(a)
					},
					isIntersectionSphere: function(a) {
						console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
						return this.intersectsSphere(a)
					}
				});
				q(H.prototype, {
					area: function() {
						console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
						return this.getArea()
					},
					barycoordFromPoint: function(a, b) {
						console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
						return this.getBarycoord(a, b)
					},
					midpoint: function(a) {
						console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
						return this.getMidpoint(a)
					},
					normal: function(a) {
						console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
						return this.getNormal(a)
					},
					plane: function(a) {
						console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
						return this.getPlane(a)
					}
				});
				q(H, {
					barycoordFromPoint: function(a, b, c, d, e) {
						console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
						return H.getBarycoord(a, b, c, d, e)
					},
					normal: function(a, b, c, d) {
						console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
						return H.getNormal(a, b, c, d)
					}
				});
				q(hh.prototype, {
					extractAllPoints: function(a) {
						console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
						return this.extractPoints(a)
					},
					extrude: function(a) {
						console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
						return new ci(this, a)
					},
					makeGeometry: function(a) {
						console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
						return new di(this, a)
					}
				});
				q(d.prototype, {
					fromAttribute: function(a, b, c) {
						console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
						return this.fromBufferAttribute(a, b, c)
					},
					distanceToManhattan: function(a) {
						console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
						return this.manhattanDistanceTo(a)
					},
					lengthManhattan: function() {
						console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
						return this.manhattanLength()
					}
				});
				q(f.prototype, {
					setEulerFromRotationMatrix: function() {
						console.error(
							"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead."
						)
					},
					setEulerFromQuaternion: function() {
						console.error(
							"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
					},
					getPositionFromMatrix: function(a) {
						console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
						return this.setFromMatrixPosition(a)
					},
					getScaleFromMatrix: function(a) {
						console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
						return this.setFromMatrixScale(a)
					},
					getColumnFromMatrix: function(a, b) {
						console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
						return this.setFromMatrixColumn(b, a)
					},
					applyProjection: function(a) {
						console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
						return this.applyMatrix4(a)
					},
					fromAttribute: function(a,
						b, c) {
						console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
						return this.fromBufferAttribute(a, b, c)
					},
					distanceToManhattan: function(a) {
						console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
						return this.manhattanDistanceTo(a)
					},
					lengthManhattan: function() {
						console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
						return this.manhattanLength()
					}
				});
				q(m.prototype, {
					fromAttribute: function(a, b, c) {
						console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
						return this.fromBufferAttribute(a, b, c)
					},
					lengthManhattan: function() {
						console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
						return this.manhattanLength()
					}
				});
				q(T.prototype, {
					computeTangents: function() {
						console.error("THREE.Geometry: .computeTangents() has been removed.")
					},
					computeLineDistances: function() {
						console.error(
							"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead."
						)
					}
				});
				q(u.prototype, {
					getChildByName: function(a) {
						console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
						return this.getObjectByName(a)
					},
					renderDepth: function() {
						console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
					},
					translate: function(a, b) {
						console.warn(
							"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
						return this.translateOnAxis(b, a)
					},
					getWorldRotation: function() {
						console.error(
							"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
						)
					}
				});
				ja(u.prototype, {
					eulerOrder: {
						get: function() {
							console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
							return this.rotation.order
						},
						set: function(a) {
							console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
							this.rotation.order = a
						}
					},
					useQuaternion: {
						get: function() {
							console.warn(
								"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
						},
						set: function() {
							console.warn(
								"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
						}
					}
				});
				ja(zc.prototype, {
					objects: {
						get: function() {
							console.warn("THREE.LOD: .objects has been renamed to .levels.");
							return this.levels
						}
					}
				});
				Object.defineProperty(nd.prototype, "useVertexTexture", {
					get: function() {
						console.warn("THREE.Skeleton: useVertexTexture has been removed.")
					},
					set: function() {
						console.warn("THREE.Skeleton: useVertexTexture has been removed.")
					}
				});
				Bc.prototype.initBones = function() {
					console.error("THREE.SkinnedMesh: initBones() has been removed.")
				};
				Object.defineProperty(oa.prototype, "__arcLengthDivisions", {
					get: function() {
						console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
						return this.arcLengthDivisions
					},
					set: function(a) {
						console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
						this.arcLengthDivisions = a
					}
				});
				Ja.prototype.setLens = function(a, b) {
					console.warn(
						"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."
					);
					void 0 !== b && (this.filmGauge = b);
					this.setFocalLength(a)
				};
				ja(Ta.prototype, {
					onlyShadow: {
						set: function() {
							console.warn("THREE.Light: .onlyShadow has been removed.")
						}
					},
					shadowCameraFov: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
							this.shadow.camera.fov = a
						}
					},
					shadowCameraLeft: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
							this.shadow.camera.left = a
						}
					},
					shadowCameraRight: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
							this.shadow.camera.right = a
						}
					},
					shadowCameraTop: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
							this.shadow.camera.top = a
						}
					},
					shadowCameraBottom: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
							this.shadow.camera.bottom = a
						}
					},
					shadowCameraNear: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
							this.shadow.camera.near = a
						}
					},
					shadowCameraFar: {
						set: function(a) {
							console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
							this.shadow.camera.far = a
						}
					},
					shadowCameraVisible: {
						set: function() {
							console.warn(
								"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
							)
						}
					},
					shadowBias: {
						set: function(a) {
							console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
							this.shadow.bias = a
						}
					},
					shadowDarkness: {
						set: function() {
							console.warn("THREE.Light: .shadowDarkness has been removed.")
						}
					},
					shadowMapWidth: {
						set: function(a) {
							console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
							this.shadow.mapSize.width = a
						}
					},
					shadowMapHeight: {
						set: function(a) {
							console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
							this.shadow.mapSize.height = a
						}
					}
				});
				ja(R.prototype, {
					length: {
						get: function() {
							console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
							return this.array.length
						}
					}
				});
				q(R.prototype, {
					copyIndicesArray: function() {
						console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
					},
					setArray: function(a) {
						console.warn(
							"THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
						);
						this.count = void 0 !== a ? a.length / this.itemSize : 0;
						this.array = a;
						return this
					}
				});
				q(I.prototype, {
					addIndex: function(a) {
						console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
						this.setIndex(a)
					},
					addDrawCall: function(a, b, c) {
						void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
						console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
						this.addGroup(a, b)
					},
					clearDrawCalls: function() {
						console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
						this.clearGroups()
					},
					computeTangents: function() {
						console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
					},
					computeOffsets: function() {
						console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
					}
				});
				ja(I.prototype, {
					drawcalls: {
						get: function() {
							console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
							return this.groups
						}
					},
					offsets: {
						get: function() {
							console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
							return this.groups
						}
					}
				});
				q(Db.prototype, {
					setArray: function(a) {
						console.warn(
							"THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
						);
						this.count = void 0 !== a ? a.length / this.stride : 0;
						this.array = a;
						return this
					}
				});
				q(lf.prototype, {
					getArrays: function() {
						console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
					},
					addShapeList: function() {
						console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
					},
					addShape: function() {
						console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
					}
				});
				ja(jf.prototype, {
					dynamic: {
						set: function() {
							console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
						}
					},
					onUpdate: {
						value: function() {
							console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
							return this
						}
					}
				});
				ja(F.prototype, {
					wrapAround: {
						get: function() {
							console.warn("THREE.Material: .wrapAround has been removed.")
						},
						set: function() {
							console.warn("THREE.Material: .wrapAround has been removed.")
						}
					},
					overdraw: {
						get: function() {
							console.warn("THREE.Material: .overdraw has been removed.")
						},
						set: function() {
							console.warn("THREE.Material: .overdraw has been removed.")
						}
					},
					wrapRGB: {
						get: function() {
							console.warn("THREE.Material: .wrapRGB has been removed.");
							return new Q
						}
					},
					shading: {
						get: function() {
							console.error("THREE." +
								this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
						},
						set: function(a) {
							console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
							this.flatShading = 1 === a
						}
					},
					stencilMask: {
						get: function() {
							console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
							return this.stencilFuncMask
						},
						set: function(a) {
							console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
							this.stencilFuncMask =
								a
						}
					}
				});
				ja(ne.prototype, {
					metal: {
						get: function() {
							console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
							return !1
						},
						set: function() {
							console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
						}
					}
				});
				ja(sa.prototype, {
					derivatives: {
						get: function() {
							console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
							return this.extensions.derivatives
						},
						set: function(a) {
							console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
							this.extensions.derivatives = a
						}
					}
				});
				q(Dd.prototype, {
					clearTarget: function(a, b, c, d) {
						console.warn(
							"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
						this.setRenderTarget(a);
						this.clear(b, c, d)
					},
					animate: function(a) {
						console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
						this.setAnimationLoop(a)
					},
					getCurrentRenderTarget: function() {
						console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
						return this.getRenderTarget()
					},
					getMaxAnisotropy: function() {
						console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
						return this.capabilities.getMaxAnisotropy()
					},
					getPrecision: function() {
						console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
						return this.capabilities.precision
					},
					resetGLState: function() {
						console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
						return this.state.reset()
					},
					supportsFloatTextures: function() {
						console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
						return this.extensions.get("OES_texture_float")
					},
					supportsHalfFloatTextures: function() {
						console.warn(
							"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
						return this.extensions.get("OES_texture_half_float")
					},
					supportsStandardDerivatives: function() {
						console.warn(
							"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
						);
						return this.extensions.get("OES_standard_derivatives")
					},
					supportsCompressedTextureS3TC: function() {
						console.warn(
							"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
						);
						return this.extensions.get("WEBGL_compressed_texture_s3tc")
					},
					supportsCompressedTexturePVRTC: function() {
						console.warn(
							"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
						);
						return this.extensions.get("WEBGL_compressed_texture_pvrtc")
					},
					supportsBlendMinMax: function() {
						console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
						return this.extensions.get("EXT_blend_minmax")
					},
					supportsVertexTextures: function() {
						console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
						return this.capabilities.vertexTextures
					},
					supportsInstancedArrays: function() {
						console.warn(
							"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
						return this.extensions.get("ANGLE_instanced_arrays")
					},
					enableScissorTest: function(a) {
						console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
						this.setScissorTest(a)
					},
					initMaterial: function() {
						console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
					},
					addPrePlugin: function() {
						console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
					},
					addPostPlugin: function() {
						console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
					},
					updateShadowMap: function() {
						console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
					},
					setFaceCulling: function() {
						console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
					},
					allocTextureUnit: function() {
						console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
					},
					setTexture: function() {
						console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
					},
					setTexture2D: function() {
						console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
					},
					setTextureCube: function() {
						console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
					},
					getActiveMipMapLevel: function() {
						console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
						return this.getActiveMipmapLevel()
					}
				});
				ja(Dd.prototype, {
					shadowMapEnabled: {
						get: function() {
							return this.shadowMap.enabled
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
							this.shadowMap.enabled = a
						}
					},
					shadowMapType: {
						get: function() {
							return this.shadowMap.type
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
							this.shadowMap.type = a
						}
					},
					shadowMapCullFace: {
						get: function() {
							console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
						},
						set: function() {
							console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
						}
					},
					context: {
						get: function() {
							console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
							return this.getContext()
						}
					}
				});
				ja(Md.prototype, {
					cullFace: {
						get: function() {
							console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
						},
						set: function() {
							console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
						}
					},
					renderReverseSided: {
						get: function() {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
						},
						set: function() {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
						}
					},
					renderSingleSided: {
						get: function() {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
						},
						set: function() {
							console.warn(
								"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
						}
					}
				});
				ja(qa.prototype, {
					activeCubeFace: {
						set: function() {
							console.warn(
								"THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
							)
						}
					},
					activeMipMapLevel: {
						set: function() {
							console.warn(
								"THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
							)
						}
					}
				});
				ja(n.prototype, {
					wrapS: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
							return this.texture.wrapS
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
							this.texture.wrapS = a
						}
					},
					wrapT: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
							return this.texture.wrapT
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
							this.texture.wrapT = a
						}
					},
					magFilter: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
							return this.texture.magFilter
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
							this.texture.magFilter = a
						}
					},
					minFilter: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
							return this.texture.minFilter
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
							this.texture.minFilter = a
						}
					},
					anisotropy: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
							return this.texture.anisotropy
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
							this.texture.anisotropy = a
						}
					},
					offset: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
							return this.texture.offset
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
							this.texture.offset = a
						}
					},
					repeat: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
							return this.texture.repeat
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
							this.texture.repeat = a
						}
					},
					format: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
							return this.texture.format
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
							this.texture.format = a
						}
					},
					type: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
							return this.texture.type
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
							this.texture.type = a
						}
					},
					generateMipmaps: {
						get: function() {
							console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
							return this.texture.generateMipmaps
						},
						set: function(a) {
							console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
							this.texture.generateMipmaps = a
						}
					}
				});
				ja(Cd.prototype, {
					standing: {
						set: function() {
							console.warn("THREE.WebVRManager: .standing has been removed.")
						}
					},
					userHeight: {
						set: function() {
							console.warn("THREE.WebVRManager: .userHeight has been removed.")
						}
					}
				});
				Cj.prototype.load = function(a) {
					console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
					var b = this;
					(new gf).load(a, function(a) {
						b.setBuffer(a)
					});
					return this
				};
				Zf.prototype.getData = function() {
					console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
					return this.getFrequencyData()
				};
				Da.prototype.updateCubeMap = function(a, b) {
					console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
					return this.update(a, b)
				};
				ih.crossOrigin = void 0;
				ih.loadTexture = function(a,
					b, c, d) {
					console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
					var e = new Qe;
					e.setCrossOrigin(this.crossOrigin);
					a = e.load(a, c, void 0, d);
					b && (a.mapping = b);
					return a
				};
				ih.loadTextureCube = function(a, b, c, d) {
					console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
					var e = new Pe;
					e.setCrossOrigin(this.crossOrigin);
					a = e.load(a, c, void 0, d);
					b && (a.mapping = b);
					return a
				};
				ih.loadCompressedTexture = function() {
					console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
				};
				ih.loadCompressedTextureCube = function() {
					console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
				};
				"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
					detail: {
						revision: "109"
					}
				}));
				a.ACESFilmicToneMapping = 5;
				a.AddEquation = 100;
				a.AddOperation = 2;
				a.AdditiveBlending = 2;
				a.AlphaFormat = 1021;
				a.AlwaysDepth = 1;
				a.AlwaysStencilFunc = 519;
				a.AmbientLight = Ze;
				a.AmbientLightProbe = Vf;
				a.AnimationClip = Gd;
				a.AnimationLoader = yf;
				a.AnimationMixer =
					ag;
				a.AnimationObjectGroup = Xg;
				a.AnimationUtils = sb;
				a.ArcCurve = Bj;
				a.ArrayCamera = ic;
				a.ArrowHelper = lg;
				a.Audio = Cj;
				a.AudioAnalyser = Zf;
				a.AudioContext = Fh;
				a.AudioListener = Xf;
				a.AudioLoader = gf;
				a.AxesHelper = Me;
				a.AxisHelper = function(a) {
					console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
					return new Me(a)
				};
				a.BackSide = 1;
				a.BasicDepthPacking = 3200;
				a.BasicShadowMap = 0;
				a.BinaryTextureLoader = function(a) {
					console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
					return new Oe(a)
				};
				a.Bone = Td;
				a.BooleanKeyframeTrack = De;
				a.BoundingBoxHelper = function(a, b) {
					console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
					return new kg(a, b)
				};
				a.Box2 = sg;
				a.Box3 = D;
				a.Box3Helper = Ie;
				a.BoxBufferGeometry = qk;
				a.BoxGeometry = bh;
				a.BoxHelper = kg;
				a.BufferAttribute = R;
				a.BufferGeometry = I;
				a.BufferGeometryLoader = ef;
				a.ByteType = 1010;
				a.Cache = ri;
				a.Camera = va;
				a.CameraHelper = He;
				a.CanvasRenderer = function() {
					console.error("THREE.CanvasRenderer has been removed")
				};
				a.CanvasTexture = Cc;
				a.CatmullRomCurve3 = Kb;
				a.CineonToneMapping = 4;
				a.CircleBufferGeometry = cd;
				a.CircleGeometry = Jd;
				a.ClampToEdgeWrapping = 1001;
				a.Clock = Wf;
				a.ClosedSplineCurve3 = th;
				a.Color = Q;
				a.ColorKeyframeTrack = Ee;
				a.CompressedTexture = gc;
				a.CompressedTextureLoader = zf;
				a.ConeBufferGeometry = Id;
				a.ConeGeometry = Fd;
				a.CubeCamera = Da;
				a.CubeGeometry = bh;
				a.CubeReflectionMapping = 301;
				a.CubeRefractionMapping = 302;
				a.CubeTexture = Ua;
				a.CubeTextureLoader = Pe;
				a.CubeUVReflectionMapping = 306;
				a.CubeUVRefractionMapping = 307;
				a.CubicBezierCurve = oe;
				a.CubicBezierCurve3 =
					nf;
				a.CubicInterpolant = Be;
				a.CullFaceBack = 1;
				a.CullFaceFront = 2;
				a.CullFaceFrontBack = 3;
				a.CullFaceNone = 0;
				a.Curve = oa;
				a.CurvePath = jg;
				a.CustomBlending = 5;
				a.CylinderBufferGeometry = ig;
				a.CylinderGeometry = fi;
				a.Cylindrical = oh;
				a.DataTexture = Ia;
				a.DataTexture2DArray = cb;
				a.DataTexture3D = db;
				a.DataTextureLoader = Oe;
				a.DecrementStencilOp = 7683;
				a.DecrementWrapStencilOp = 34056;
				a.DefaultLoadingManager = Oi;
				a.DepthFormat = 1026;
				a.DepthStencilFormat = 1027;
				a.DepthTexture = Dc;
				a.DirectionalLight = Ye;
				a.DirectionalLightHelper = Kj;
				a.DirectionalLightShadow =
					Xe;
				a.DiscreteInterpolant = Ce;
				a.DodecahedronBufferGeometry = tc;
				a.DodecahedronGeometry = fd;
				a.DoubleSide = 2;
				a.DstAlphaFactor = 206;
				a.DstColorFactor = 208;
				a.DynamicBufferAttribute = function(a, b) {
					console.warn(
						"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."
					);
					return (new R(a, b)).setDynamic(!0)
				};
				a.EdgesGeometry = Vc;
				a.EdgesHelper = function(a, b) {
					console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
					return new Sa(new Vc(a.geometry),
						new Ka({
							color: void 0 !== b ? b : 16777215
						}))
				};
				a.EllipseCurve = Xc;
				a.EqualDepth = 4;
				a.EqualStencilFunc = 514;
				a.EquirectangularReflectionMapping = 303;
				a.EquirectangularRefractionMapping = 304;
				a.Euler = A;
				a.EventDispatcher = b;
				a.ExtrudeBufferGeometry = lf;
				a.ExtrudeGeometry = ci;
				a.Face3 = M;
				a.Face4 = function(a, b, c, d, e, f, g) {
					console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
					return new M(a, b, c, e, f, g)
				};
				a.FaceColors = 1;
				a.FaceNormalsHelper = Fe;
				a.FileLoader = Hd;
				a.FlatShading = 1;
				a.Float32Attribute = function(a,
					b) {
					console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
					return new L(a, b)
				};
				a.Float32BufferAttribute = L;
				a.Float64Attribute = function(a, b) {
					console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
					return new ma(a, b)
				};
				a.Float64BufferAttribute = ma;
				a.FloatType = 1015;
				a.Fog = bd;
				a.FogExp2 = Pc;
				a.Font = Rf;
				a.FontLoader = Sf;
				a.FrontFaceDirectionCCW = 1;
				a.FrontFaceDirectionCW = 0;
				a.FrontSide = 0;
				a.Frustum = U;
				a.GammaEncoding = 3007;
				a.Geometry = T;
				a.GeometryUtils = {
					merge: function(a, b, c) {
						console.warn(
							"THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."
						);
						if (b.isMesh) {
							b.matrixAutoUpdate && b.updateMatrix();
							var d = b.matrix;
							b = b.geometry
						}
						a.merge(b, d, c)
					},
					center: function(a) {
						console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
						return a.center()
					}
				};
				a.GreaterDepth = 6;
				a.GreaterEqualDepth = 5;
				a.GreaterEqualStencilFunc = 518;
				a.GreaterStencilFunc = 516;
				a.GridHelper = uf;
				a.Group = Sb;
				a.HalfFloatType = 1016;
				a.HemisphereLight = Te;
				a.HemisphereLightHelper = Hj;
				a.HemisphereLightProbe = Tf;
				a.IcosahedronBufferGeometry = rc;
				a.IcosahedronGeometry = ad;
				a.ImageBitmapLoader = Pf;
				a.ImageLoader = Aj;
				a.ImageUtils = ih;
				a.ImmediateRenderObject = xe;
				a.IncrementStencilOp = 7682;
				a.IncrementWrapStencilOp = 34055;
				a.InstancedBufferAttribute = cf;
				a.InstancedBufferGeometry = bf;
				a.InstancedInterleavedBuffer = eg;
				a.InstancedMesh = Ud;
				a.Int16Attribute = function(a, b) {
					console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
					return new ba(a, b)
				};
				a.Int16BufferAttribute = ba;
				a.Int32Attribute = function(a, b) {
					console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
					return new ia(a, b)
				};
				a.Int32BufferAttribute = ia;
				a.Int8Attribute = function(a, b) {
					console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
					return new V(a, b)
				};
				a.Int8BufferAttribute = V;
				a.IntType = 1013;
				a.InterleavedBuffer = Db;
				a.InterleavedBufferAttribute = sc;
				a.Interpolant = Wc;
				a.InterpolateDiscrete =
					2300;
				a.InterpolateLinear = 2301;
				a.InterpolateSmooth = 2302;
				a.InvertStencilOp = 5386;
				a.JSONLoader = function() {
					console.error("THREE.JSONLoader has been removed.")
				};
				a.KeepStencilOp = 7680;
				a.KeyframeTrack = Ab;
				a.LOD = zc;
				a.LatheBufferGeometry = Sc;
				a.LatheGeometry = Ed;
				a.Layers = w;
				a.LensFlare = function() {
					console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
				};
				a.LessDepth = 2;
				a.LessEqualDepth = 3;
				a.LessEqualStencilFunc = 515;
				a.LessStencilFunc = 513;
				a.Light = Ta;
				a.LightProbe = te;
				a.LightProbeHelper = Ij;
				a.LightShadow =
					pf;
				a.Line = yb;
				a.Line3 = tg;
				a.LineBasicMaterial = Ka;
				a.LineCurve = pc;
				a.LineCurve3 = pe;
				a.LineDashedMaterial = mi;
				a.LineLoop = qd;
				a.LinePieces = 1;
				a.LineSegments = Sa;
				a.LineStrip = 0;
				a.LinearEncoding = 3E3;
				a.LinearFilter = 1006;
				a.LinearInterpolant = Ld;
				a.LinearMipMapLinearFilter = 1008;
				a.LinearMipMapNearestFilter = 1007;
				a.LinearMipmapLinearFilter = 1008;
				a.LinearMipmapNearestFilter = 1007;
				a.LinearToneMapping = 1;
				a.Loader = Qa;
				a.LoaderUtils = Dh;
				a.LoadingManager = xf;
				a.LogLuvEncoding = 3003;
				a.LoopOnce = 2200;
				a.LoopPingPong = 2202;
				a.LoopRepeat = 2201;
				a.LuminanceAlphaFormat = 1025;
				a.LuminanceFormat = 1024;
				a.MOUSE = {
					LEFT: 0,
					MIDDLE: 1,
					RIGHT: 2,
					ROTATE: 0,
					DOLLY: 1,
					PAN: 2
				};
				a.Material = F;
				a.MaterialLoader = af;
				a.Math = Ea;
				a.Matrix3 = k;
				a.Matrix4 = v;
				a.MaxEquation = 104;
				a.Mesh = ha;
				a.MeshBasicMaterial = S;
				a.MeshDepthMaterial = tb;
				a.MeshDistanceMaterial = ub;
				a.MeshFaceMaterial = function(a) {
					console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
					return a
				};
				a.MeshLambertMaterial = ki;
				a.MeshMatcapMaterial = li;
				a.MeshNormalMaterial = ji;
				a.MeshPhongMaterial = ne;
				a.MeshPhysicalMaterial =
					hi;
				a.MeshStandardMaterial = mf;
				a.MeshToonMaterial = ii;
				a.MinEquation = 103;
				a.MirroredRepeatWrapping = 1002;
				a.MixOperation = 1;
				a.MultiMaterial = function(a) {
					void 0 === a && (a = []);
					console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
					a.isMultiMaterial = !0;
					a.materials = a;
					a.clone = function() {
						return a.slice()
					};
					return a
				};
				a.MultiplyBlending = 4;
				a.MultiplyOperation = 0;
				a.NearestFilter = 1003;
				a.NearestMipMapLinearFilter = 1005;
				a.NearestMipMapNearestFilter = 1004;
				a.NearestMipmapLinearFilter = 1005;
				a.NearestMipmapNearestFilter =
					1004;
				a.NeverDepth = 0;
				a.NeverStencilFunc = 512;
				a.NoBlending = 0;
				a.NoColors = 0;
				a.NoToneMapping = 0;
				a.NormalBlending = 1;
				a.NotEqualDepth = 7;
				a.NotEqualStencilFunc = 517;
				a.NumberKeyframeTrack = id;
				a.Object3D = u;
				a.ObjectLoader = ff;
				a.ObjectSpaceNormalMap = 1;
				a.OctahedronBufferGeometry = ac;
				a.OctahedronGeometry = Tc;
				a.OneFactor = 201;
				a.OneMinusDstAlphaFactor = 207;
				a.OneMinusDstColorFactor = 209;
				a.OneMinusSrcAlphaFactor = 205;
				a.OneMinusSrcColorFactor = 203;
				a.OrthographicCamera = ce;
				a.PCFShadowMap = 1;
				a.PCFSoftShadowMap = 2;
				a.ParametricBufferGeometry =
					lc;
				a.ParametricGeometry = Fc;
				a.Particle = function(a) {
					console.warn("THREE.Particle has been renamed to THREE.Sprite.");
					return new xc(a)
				};
				a.ParticleBasicMaterial = function(a) {
					console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
					return new me(a)
				};
				a.ParticleSystem = function(a, b) {
					console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
					return new ec(a, b)
				};
				a.ParticleSystemMaterial = function(a) {
					console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
					return new me(a)
				};
				a.Path = se;
				a.PerspectiveCamera = Ja;
				a.Plane = za;
				a.PlaneBufferGeometry = Ba;
				a.PlaneGeometry = aa;
				a.PlaneHelper = Je;
				a.PointCloud = function(a, b) {
					console.warn("THREE.PointCloud has been renamed to THREE.Points.");
					return new ec(a, b)
				};
				a.PointCloudMaterial = function(a) {
					console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
					return new me(a)
				};
				a.PointLight = We;
				a.PointLightHelper = Fj;
				a.Points = ec;
				a.PointsMaterial = me;
				a.PolarGridHelper = vf;
				a.PolyhedronBufferGeometry = oc;
				a.PolyhedronGeometry =
					Mc;
				a.PositionalAudio = Yf;
				a.PositionalAudioHelper = Jj;
				a.PropertyBinding = Lb;
				a.PropertyMixer = $f;
				a.QuadraticBezierCurve = qe;
				a.QuadraticBezierCurve3 = of ;
				a.Quaternion = e;
				a.QuaternionKeyframeTrack = Pd;
				a.QuaternionLinearInterpolant = Ge;
				a.REVISION = "109";
				a.RGBADepthPacking = 3201;
				a.RGBAFormat = 1023;
				a.RGBA_ASTC_10x10_Format = 37819;
				a.RGBA_ASTC_10x5_Format = 37816;
				a.RGBA_ASTC_10x6_Format = 37817;
				a.RGBA_ASTC_10x8_Format = 37818;
				a.RGBA_ASTC_12x10_Format = 37820;
				a.RGBA_ASTC_12x12_Format = 37821;
				a.RGBA_ASTC_4x4_Format = 37808;
				a.RGBA_ASTC_5x4_Format =
					37809;
				a.RGBA_ASTC_5x5_Format = 37810;
				a.RGBA_ASTC_6x5_Format = 37811;
				a.RGBA_ASTC_6x6_Format = 37812;
				a.RGBA_ASTC_8x5_Format = 37813;
				a.RGBA_ASTC_8x6_Format = 37814;
				a.RGBA_ASTC_8x8_Format = 37815;
				a.RGBA_PVRTC_2BPPV1_Format = 35843;
				a.RGBA_PVRTC_4BPPV1_Format = 35842;
				a.RGBA_S3TC_DXT1_Format = 33777;
				a.RGBA_S3TC_DXT3_Format = 33778;
				a.RGBA_S3TC_DXT5_Format = 33779;
				a.RGBDEncoding = 3006;
				a.RGBEEncoding = 3002;
				a.RGBEFormat = 1023;
				a.RGBFormat = 1022;
				a.RGBM16Encoding = 3005;
				a.RGBM7Encoding = 3004;
				a.RGB_ETC1_Format = 36196;
				a.RGB_PVRTC_2BPPV1_Format =
					35841;
				a.RGB_PVRTC_4BPPV1_Format = 35840;
				a.RGB_S3TC_DXT1_Format = 33776;
				a.RawShaderMaterial = ed;
				a.Ray = B;
				a.Raycaster = dh;
				a.RectAreaLight = $e;
				a.RectAreaLightHelper = Gj;
				a.RedFormat = 1028;
				a.ReinhardToneMapping = 2;
				a.RepeatWrapping = 1E3;
				a.ReplaceStencilOp = 7681;
				a.ReverseSubtractEquation = 102;
				a.RingBufferGeometry = Lc;
				a.RingGeometry = wd;
				a.Scene = C;
				a.SceneUtils = {
					createMultiMaterialObject: function() {
						console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					detach: function() {
						console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					},
					attach: function() {
						console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
					}
				};
				a.ShaderChunk = Ca;
				a.ShaderLib = kf;
				a.ShaderMaterial = sa;
				a.ShadowMaterial = gi;
				a.Shape = hh;
				a.ShapeBufferGeometry = ei;
				a.ShapeGeometry = di;
				a.ShapePath = Qf;
				a.ShapeUtils = hg;
				a.ShortType = 1011;
				a.Skeleton = nd;
				a.SkeletonHelper = Ej;
				a.SkinnedMesh = Bc;
				a.SmoothShading = 2;
				a.Sphere = G;
				a.SphereBufferGeometry = gh;
				a.SphereGeometry = vd;
				a.Spherical = fh;
				a.SphericalHarmonics3 = hf;
				a.SphericalReflectionMapping = 305;
				a.Spline = zg;
				a.SplineCurve =
					re;
				a.SplineCurve3 = uh;
				a.SpotLight = Ve;
				a.SpotLightHelper = Dj;
				a.SpotLightShadow = Ue;
				a.Sprite = xc;
				a.SpriteMaterial = Eb;
				a.SrcAlphaFactor = 204;
				a.SrcAlphaSaturateFactor = 210;
				a.SrcColorFactor = 202;
				a.StereoCamera = Sg;
				a.StringKeyframeTrack = Ke;
				a.SubtractEquation = 101;
				a.SubtractiveBlending = 3;
				a.TOUCH = {
					ROTATE: 0,
					PAN: 1,
					DOLLY_PAN: 2,
					DOLLY_ROTATE: 3
				};
				a.TangentSpaceNormalMap = 0;
				a.TetrahedronBufferGeometry = nc;
				a.TetrahedronGeometry = Nc;
				a.TextBufferGeometry = Hc;
				a.TextGeometry = ud;
				a.Texture = l;
				a.TextureLoader = Qe;
				a.TorusBufferGeometry = Ac;
				a.TorusGeometry = kd;
				a.TorusKnotBufferGeometry = wc;
				a.TorusKnotGeometry = jd;
				a.Triangle = H;
				a.TriangleFanDrawMode = 2;
				a.TriangleStripDrawMode = 1;
				a.TrianglesDrawMode = 0;
				a.TubeBufferGeometry = cc;
				a.TubeGeometry = hd;
				a.UVMapping = 300;
				a.Uint16Attribute = function(a, b) {
					console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
					return new fa(a, b)
				};
				a.Uint16BufferAttribute = fa;
				a.Uint32Attribute = function(a, b) {
					console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
					return new da(a, b)
				};
				a.Uint32BufferAttribute = da;
				a.Uint8Attribute = function(a, b) {
					console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
					return new X(a, b)
				};
				a.Uint8BufferAttribute = X;
				a.Uint8ClampedAttribute = function(a, b) {
					console.warn(
						"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
					return new W(a, b)
				};
				a.Uint8ClampedBufferAttribute = W;
				a.Uncharted2ToneMapping = 3;
				a.Uniform = jf;
				a.UniformsLib = na;
				a.UniformsUtils = qj;
				a.UnsignedByteType = 1009;
				a.UnsignedInt248Type = 1020;
				a.UnsignedIntType = 1014;
				a.UnsignedShort4444Type = 1017;
				a.UnsignedShort5551Type = 1018;
				a.UnsignedShort565Type = 1019;
				a.UnsignedShortType = 1012;
				a.VSMShadowMap = 3;
				a.Vector2 = d;
				a.Vector3 = f;
				a.Vector4 = m;
				a.VectorKeyframeTrack = ld;
				a.Vertex = function(a, b, c) {
					console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
					return new f(a, b, c)
				};
				a.VertexColors = 2;
				a.VertexNormalsHelper = ze;
				a.VideoTexture = $d;
				a.WebGLMultisampleRenderTarget = r;
				a.WebGLRenderTarget = n;
				a.WebGLRenderTargetCube =
					qa;
				a.WebGLRenderer = Dd;
				a.WebGLUtils = Xd;
				a.WireframeGeometry = hc;
				a.WireframeHelper = function(a, b) {
					console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
					return new Sa(new hc(a.geometry), new Ka({
						color: void 0 !== b ? b : 16777215
					}))
				};
				a.WrapAroundEnding = 2402;
				a.XHRLoader = function(a) {
					console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
					return new Hd(a)
				};
				a.ZeroCurvatureEnding = 2400;
				a.ZeroFactor = 200;
				a.ZeroSlopeEnding = 2401;
				a.ZeroStencilOp = 0;
				a.sRGBEncoding = 3001;
				Object.defineProperty(a,
					"__esModule", {
						value: !0
					})
			})
		}),
		Co = fa(Bo);
	window.THREE && (Co = window.THREE);
	var da = Co;
	ah("getPrototypeOf", function() {
		return function(f) {
			return Un(Object(ie(f)))
		}
	});
	var gs = va.Object.getPrototypeOf,
		hs = ta(function(f) {
			f.exports = {
				"default": gs,
				__esModule: !0
			}
		}),
		Yb = fa(hs),
		is = ta(function(f, a) {
			a.__esModule = !0;
			a.default = function(a, c) {
				if (!(a instanceof c)) throw new TypeError("Cannot call a class as a function");
			}
		}),
		Xa = fa(is);
	W(W.S + W.F * !Hb, "Object", {
		defineProperty: Oc.f
	});
	var js = va.Object,
		ks = function(f, a, b) {
			return js.defineProperty(f,
				a, b)
		},
		oh = ta(function(f) {
			f.exports = {
				"default": ks,
				__esModule: !0
			}
		});
	fa(oh);
	var ls = ta(function(f, a) {
			a.__esModule = !0;
			var b = oh && oh.__esModule ? oh : {
				default: oh
			};
			a.default = function() {
				function a(a, c) {
					for (var d = 0; d < c.length; d++) {
						var e = c[d];
						e.enumerable = e.enumerable || !1;
						e.configurable = !0;
						"value" in e && (e.writable = !0);
						(0, b.default)(a, e.key, e)
					}
				}
				return function(b, c, f) {
					c && a(b.prototype, c);
					f && a(b, f);
					return b
				}
			}()
		}),
		jb = fa(ls),
		ms = ta(function(f, a) {
			a.__esModule = !0;
			var b = Fd && Fd.__esModule ? Fd : {
				default: Fd
			};
			a.default = function(a,
				d) {
				if (!a) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return !d || "object" !== ("undefined" === typeof d ? "undefined" : (0, b.default)(d)) && "function" !== typeof d ?
					a : d
			}
		}),
		Zb = fa(ms),
		ns = Object.setPrototypeOf || ("__proto__" in {} ? function(f, a, b) {
			try {
				b = Nc(Function.call, qj.f(Object.prototype, "__proto__").set, 2), b(f, []), a = !(f instanceof Array)
			} catch (c) {
				a = !0
			}
			return function(c, d) {
				Vb(c);
				if (!hb(d) && null !== d) throw TypeError(d + ": can't set as prototype!");
				a ? c.__proto__ = d : b(c, d);
				return c
			}
		}({},
			!1) : void 0);
	W(W.S, "Object", {
		setPrototypeOf: ns
	});
	var os = va.Object.setPrototypeOf,
		Do = ta(function(f) {
			f.exports = {
				"default": os,
				__esModule: !0
			}
		});
	fa(Do);
	var ps = ta(function(f, a) {
			function b(a) {
				return a && a.__esModule ? a : {
					default: a
				}
			}
			a.__esModule = !0;
			var c = b(Do),
				d = b(zo),
				e = b(Fd);
			a.default = function(a, b) {
				if ("function" !== typeof b && null !== b) throw new TypeError(
					"Super expression must either be null or a function, not " + ("undefined" === typeof b ? "undefined" : (0, e.default)
						(b)));
				a.prototype = (0, d.default)(b && b.prototype, {
					constructor: {
						value: a,
						enumerable: !1,
						writable: !0,
						configurable: !0
					}
				});
				b && (c.default ? (0, c.default)(a, b) : a.__proto__ = b)
			}
		}),
		$b = fa(ps);
	Mi(dc.prototype, {
		equals: function(f) {
			return this.lat === f.lat && this.lng === f.lng
		},
		clone: function() {
			return new dc(this.lat, this.lng)
		},
		getLngSpan: function(f) {
			f = Math.abs(f - this.lng);
			180 < f && (f = 360 - f);
			return f
		},
		sub: function(f) {
			return new dc(this.lat - f.lat, this.lng - f.lng)
		},
		toString: function() {
			return "Point"
		}
	});
	Mi(zc, {
		EARTHRADIUS: 6370996.81,
		MCBAND: [1.289059486E7, 8362377.87, 5591021, 3481989.83, 1678043.12,
			0
		],
		LLBAND: [75, 60, 45, 30, 15, 0],
		MC2LL: [
			[1.410526172116255E-8, 8.98305509648872E-6, -1.9939833816331, 200.9824383106796, -187.2403703815547,
				91.6087516669843, -23.38765649603339, 2.57121317296198, -.03801003308653, 1.73379812E7
			],
			[-7.435856389565537E-9, 8.983055097726239E-6, -.78625201886289, 96.32687599759846, -1.85204757529826, -
				59.36935905485877, 47.40033549296737, -16.50741931063887, 2.28786674699375, 1.026014486E7
			],
			[-3.030883460898826E-8, 8.98305509983578E-6, .30071316287616, 59.74293618442277, 7.357984074871, -
				25.38371002664745,
				13.45380521110908, -3.29883767235584, .32710905363475, 6856817.37
			],
			[-1.981981304930552E-8, 8.983055099779535E-6, .03278182852591, 40.31678527705744, .65659298677277, -
				4.44255534477492, .85341911805263, .12923347998204, -.04625736007561, 4482777.06
			],
			[3.09191371068437E-9, 8.983055096812155E-6, 6.995724062E-5, 23.10934304144901, -2.3663490511E-4, -.6321817810242,
				-.00663494467273, .03430082397953, -.00466043876332, 2555164.4
			],
			[2.890871144776878E-9, 8.983055095805407E-6, -3.068298E-8, 7.47137025468032, -3.53937994E-6, -.02145144861037,
				-1.234426596E-5, 1.0322952773E-4, -3.23890364E-6, 826088.5
			]
		],
		LL2MC: [
			[-.0015702102444, 111320.7020616939, 0x60e374c3105a3, -0x24bb4115e2e164, 0x5cc55543bb0ae8, -0x7ce070193f3784,
				0x5e7ca61ddf8150, -0x261a578d8b24d0, 0x665d60f3742ca, 82.5
			],
			[8.277824516172526E-4, 111320.7020463578, 6.477955746671607E8, -4.082003173641316E9, 1.077490566351142E10, -
				1.517187553151559E10, 1.205306533862167E10, -5.124939663577472E9, 9.133119359512032E8, 67.5
			],
			[.00337398766765, 111320.7020202162, 4481351.045890365, -2.339375119931662E7, 7.968221547186455E7,
				-1.159649932797253E8, 9.723671115602145E7, -4.366194633752821E7, 8477230.501135234, 52.5
			],
			[.00220636496208, 111320.7020209128, 51751.86112841131, 3796837.749470245, 992013.7397791013, -1221952.21711287,
				1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5
			],
			[-3.441963504368392E-4, 111320.7020576856, 278.2353980772752, 2485758.690035394, 6070.750963243378,
				54821.18345352118, 9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5
			],
			[-3.218135878613132E-4, 111320.7020701615, .00369383431289, 823725.6402795718,
				.46104986909093, 2351.343141331292, 1.58060784298199, 8.77738589078284, .37238884252424, 7.45
			]
		],
		getDistanceByMC: function(f, a) {
			if (!f || !a) return 0;
			f = this.convertMC2LL(f);
			if (!f) return 0;
			var b = this.toRadians(f.lng);
			f = this.toRadians(f.lat);
			a = this.convertMC2LL(a);
			if (!a) return 0;
			var c = this.toRadians(a.lng);
			a = this.toRadians(a.lat);
			return this.getDistance(b, c, f, a)
		},
		getDistanceByLL: function(f, a) {
			if (!f || !a) return 0;
			f.lng = this.getLoop(f.lng, -180, 180);
			f.lat = this.getRange(f.lat, -74, 74);
			a.lng = this.getLoop(a.lng, -180,
				180);
			a.lat = this.getRange(a.lat, -74, 74);
			var b = this.toRadians(f.lng);
			var c = this.toRadians(f.lat);
			f = this.toRadians(a.lng);
			a = this.toRadians(a.lat);
			return this.getDistance(b, f, c, a)
		},
		convertMC2LL: function(f) {
			if (null === f || void 0 === f) return new dc(0, 0);
			if (180 > f.lng && -180 < f.lng && 90 > f.lat && -90 < f.lat) return f;
			var a = new dc(Math.abs(f.lng), Math.abs(f.lat));
			for (var b = 0; b < this.MCBAND.length; b++)
				if (a.lat >= this.MCBAND[b]) {
					var c = this.MC2LL[b];
					break
				} f = this.convertor(f, c);
			return f = new dc(f.lng.toFixed(6), f.lat.toFixed(6))
		},
		convertLL2MC: function(f) {
			if (null === f || void 0 === f) return new dc(0, 0);
			if (180 < f.lng || -180 > f.lng || 90 < f.lat || -90 > f.lat) return f;
			f.lng = this.getLoop(f.lng, -180, 180);
			f.lat = this.getRange(f.lat, -74, 74);
			var a = new dc(f.lng, f.lat);
			for (var b = 0; b < this.LLBAND.length; b++)
				if (a.lat >= this.LLBAND[b]) {
					var c = this.LL2MC[b];
					break
				} if (!c)
				for (b = 0; b < this.LLBAND.length; b++)
					if (a.lat <= -this.LLBAND[b]) {
						c = this.LL2MC[b];
						break
					} f = this.convertor(f, c);
			return f = new dc(Number(f.lng.toFixed(2)), Number(f.lat.toFixed(2)))
		},
		convertor: function(f,
			a) {
			if (f && a) {
				var b = a[0] + a[1] * Math.abs(f.lng),
					c = Math.abs(f.lat) / a[9];
				a = a[2] + a[3] * c + a[4] * c * c + a[5] * c * c * c + a[6] * c * c * c * c + a[7] * c * c * c * c * c + a[8] *
					c * c * c * c * c * c;
				b *= 0 > f.lng ? -1 : 1;
				a *= 0 > f.lat ? -1 : 1;
				return new dc(b, a)
			}
		},
		getDistance: function(f, a, b, c) {
			return this.EARTHRADIUS * Math.acos(Math.sin(b) * Math.sin(c) + Math.cos(b) * Math.cos(c) * Math.cos(a - f))
		},
		toRadians: function(f) {
			return Math.PI * f / 180
		},
		toDegrees: function(f) {
			return 180 * f / Math.PI
		},
		getRange: function(f, a, b) {
			null != a && (f = Math.max(f, a));
			null != b && (f = Math.min(f, b));
			return f
		},
		getLoop: function(f, a, b) {
			for (; f > b;) f -= b - a;
			for (; f < a;) f += b - a;
			return f
		}
	});
	Mi(zc.prototype, {
		lngLatToMercator: function(f) {
			return zc.convertLL2MC(f)
		},
		lngLatToPoint: function(f) {
			f = zc.convertLL2MC(f);
			return new mm(f.lng, f.lat)
		},
		mercatorToLngLat: function(f) {
			return zc.convertMC2LL(f)
		},
		pointToLngLat: function(f) {
			f = new dc(f.x, f.y);
			return zc.convertMC2LL(f)
		},
		pointToPixel: function(f, a, b, c, d) {
			if (f) return f = this.lngLatToMercator(f, d), a = this.getZoomUnits(a), new mm(Math.round((f.lng - b.lng) / a +
				c.width / 2), Math.round((b.lat -
				f.lat) / a + c.height / 2))
		},
		pixelToPoint: function(f, a, b, c, d) {
			if (f) return a = this.getZoomUnits(a), f = new dc(b.lng + a * (f.x - c.width / 2), b.lat - a * (f.y - c.height /
				2)), this.mercatorToLngLat(f, d)
		},
		getZoomUnits: function(f) {
			return Math.pow(2, 18 - f)
		}
	});
	var qs = ta(function(f, a) {
			a.__esModule = !0;
			var b = jf && jf.__esModule ? jf : {
				default: jf
			};
			a.default = function(a) {
				if (Array.isArray(a)) {
					for (var c = 0, e = Array(a.length); c < a.length; c++) e[c] = a[c];
					return e
				}
				return (0, b.default)(a)
			}
		}),
		Eo = fa(qs);
	(function() {
		function f() {
			var a = 0 < arguments.length &&
				void 0 !== arguments[0] ? arguments[0] : {};
			Xa(this, f);
			this.options = a;
			this._initialize()
		}
		jb(f, [{
			key: "_initialize",
			value: function() {
				this.points = this.options.points
			}
		}, {
			key: "_normalizaCoord",
			value: function(a) {
				if (!a) return null;
				a instanceof Array && (a = {
					lng: Number(a[0]),
					lat: Number(a[1])
				});
				return zc.convertLL2MC(a)
			}
		}, {
			key: "setOptions",
			value: function() {
				this.options = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {};
				this._initialize()
			}
		}, {
			key: "getPoints",
			value: function(a) {
				for (var b = [], c = this.points, d = 0; d <
					c.length - 1; d++) {
					var e = this.getCurveByTwoPoints(this._normalizaCoord(c[d]), this._normalizaCoord(c[d + 1]), a);
					e && 0 < e.length && (b = b.concat(e))
				}
				return b
			}
		}, {
			key: "getCurveByTwoPoints",
			value: function(a, b) {
				var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : 20;
				if (!a || !b) return null;
				var d = [],
					e = 0;
				if (void 0 === ("undefined" === typeof b ? "undefined" : Ni(b))) "undefined" === typeof d || Ni(d);
				else {
					var f = parseFloat(a.lat),
						k = parseFloat(b.lat),
						l = parseFloat(a.lng),
						m = parseFloat(b.lng);
					m > l && 180 < parseFloat(m - l) && 0 > l && (l =
						parseFloat(360 + l), m = parseFloat(360 + m));
					var n = 0;
					if (k === f) {
						var r = 0;
						var p = l - m
					} else m === l ? (r = Math.PI / 2, p = f - k) : (r = Math.atan((k - f) / (m - l)), p = (k - f) / Math.sin(r));
					0 === n && (n = r + Math.PI / 5);
					p /= 2;
					r = p * Math.cos(n) + l;
					n = p * Math.sin(n) + f;
					for (p = 0; p < c + 1; p++) {
						var q = l * (1 - 2 * e + e * e) + r * (2 * e - 2 * e * e) + m * e * e,
							u = b.lng;
						d.push([0 > a.lng && 0 < u ? q - 360 : q, f * (1 - 2 * e + e * e) + n * (2 * e - 2 * e * e) + k * e * e]);
						e += 1 / c
					}
					return d
				}
			}
		}]);
		return f
	})();
	var Fo = function() {
			function f(a) {
				Xa(this, f);
				this.options = this.getCommonDefaultOptions();
				this.options = q(this.options, this.getDefaultOptions());
				this.autoUpdate = !1;
				this.options = q(this.options, a);
				this.options.data && (this.data = this.options.data, delete this.options.data)
			}
			jb(f, [{
				key: "getCommonDefaultOptions",
				value: function() {
					return {}
				}
			}, {
				key: "getDefaultOptions",
				value: function() {
					return {}
				}
			}, {
				key: "initialize",
				value: function(a) {}
			}, {
				key: "destroy",
				value: function() {
					this.onDestroy && this.onDestroy()
				}
			}, {
				key: "render",
				value: function() {}
			}, {
				key: "setData",
				value: function(a, b) {
					b = b || {};
					this.data = a;
					this.onDataChanged && this.onDataChanged(this.getData());
					this.onChanged &&
						this.onChanged(this.getOptions(), this.getData());
					!1 !== b.autoRender && this.webglLayer && this.webglLayer.render()
				}
			}, {
				key: "getData",
				value: function() {
					return this.data || []
				}
			}, {
				key: "setOptions",
				value: function(a) {
					a = a || {};
					var b = q({}, this.getOptions());
					q(this.options, a);
					this.onOptionsChanged && this.onOptionsChanged(this.getOptions(), b);
					this.onChanged && this.onChanged(this.getOptions(), this.getData());
					a.data ? (this.setData(a.data), delete a.data) : this.webglLayer && this.webglLayer.render()
				}
			}, {
				key: "getOptions",
				value: function() {
					return this.options || {}
				}
			}, {
				key: "onOptionsChanged",
				value: function(a, b) {}
			}, {
				key: "onDataChanged",
				value: function(a) {}
			}, {
				key: "onChanged",
				value: function(a, b) {}
			}, {
				key: "onDestroy",
				value: function() {}
			}, {
				key: "lnglatToMercator",
				value: function(a, b) {}
			}, {
				key: "setWebglLayer",
				value: function(a) {
					this.webglLayer = a
				}
			}, {
				key: "getWebglLayer",
				value: function() {
					return this.webglLayer
				}
			}, {
				key: "isRequestAnimation",
				value: function() {
					return this.autoUpdate
				}
			}]);
			return f
		}(),
		rs = rb("iterator"),
		ss = va.isIterable = function(f) {
			f = Object(f);
			return void 0 !== f[rs] ||
				"@@iterator" in f || Rc.hasOwnProperty(Zn(f))
		},
		sg = ta(function(f) {
			f.exports = {
				"default": ss,
				__esModule: !0
			}
		});
	fa(sg);
	var ts = va.getIterator = function(f) {
			var a = tl(f);
			if ("function" != typeof a) throw TypeError(f + " is not iterable!");
			return Vb(a.call(f))
		},
		tg = ta(function(f) {
			f.exports = {
				"default": ts,
				__esModule: !0
			}
		});
	fa(tg);
	var us = ta(function(f, a) {
			a.__esModule = !0;
			var b = sg && sg.__esModule ? sg : {
					default: sg
				},
				c = tg && tg.__esModule ? tg : {
					default: tg
				};
			a.default = function() {
				return function(a, e) {
					if (Array.isArray(a)) return a;
					if ((0, b.default)(Object(a))) {
						var d = [],
							f = !0,
							l = !1,
							m = void 0;
						try {
							for (var n = (0, c.default)(a), r; !(f = (r = n.next()).done) && (d.push(r.value), !e || d.length !== e); f = !
								0);
						} catch (v) {
							l = !0, m = v
						} finally {
							try {
								if (!f && n["return"]) n["return"]()
							} finally {
								if (l) throw m;
							}
						}
						return d
					}
					throw new TypeError("Invalid attempt to destructure non-iterable instance");
				}
			}()
		}),
		Nl = fa(us),
		Zc = {
			aliceblue: [240, 248, 255],
			antiquewhite: [250, 235, 215],
			aqua: [0, 255, 255],
			aquamarine: [127, 255, 212],
			azure: [240, 255, 255],
			beige: [245, 245, 220],
			bisque: [255, 228, 196],
			black: [0, 0, 0],
			blanchedalmond: [255,
				235, 205
			],
			blue: [0, 0, 255],
			blueviolet: [138, 43, 226],
			brown: [165, 42, 42],
			burlywood: [222, 184, 135],
			cadetblue: [95, 158, 160],
			chartreuse: [127, 255, 0],
			chocolate: [210, 105, 30],
			coral: [255, 127, 80],
			cornflowerblue: [100, 149, 237],
			cornsilk: [255, 248, 220],
			crimson: [220, 20, 60],
			cyan: [0, 255, 255],
			darkblue: [0, 0, 139],
			darkcyan: [0, 139, 139],
			darkgoldenrod: [184, 134, 11],
			darkgray: [169, 169, 169],
			darkgreen: [0, 100, 0],
			darkgrey: [169, 169, 169],
			darkkhaki: [189, 183, 107],
			darkmagenta: [139, 0, 139],
			darkolivegreen: [85, 107, 47],
			darkorange: [255, 140, 0],
			darkorchid: [153,
				50, 204
			],
			darkred: [139, 0, 0],
			darksalmon: [233, 150, 122],
			darkseagreen: [143, 188, 143],
			darkslateblue: [72, 61, 139],
			darkslategray: [47, 79, 79],
			darkslategrey: [47, 79, 79],
			darkturquoise: [0, 206, 209],
			darkviolet: [148, 0, 211],
			deeppink: [255, 20, 147],
			deepskyblue: [0, 191, 255],
			dimgray: [105, 105, 105],
			dimgrey: [105, 105, 105],
			dodgerblue: [30, 144, 255],
			firebrick: [178, 34, 34],
			floralwhite: [255, 250, 240],
			forestgreen: [34, 139, 34],
			fuchsia: [255, 0, 255],
			gainsboro: [220, 220, 220],
			ghostwhite: [248, 248, 255],
			gold: [255, 215, 0],
			goldenrod: [218, 165, 32],
			gray: [128,
				128, 128
			],
			green: [0, 128, 0],
			greenyellow: [173, 255, 47],
			grey: [128, 128, 128],
			honeydew: [240, 255, 240],
			hotpink: [255, 105, 180],
			indianred: [205, 92, 92],
			indigo: [75, 0, 130],
			ivory: [255, 255, 240],
			khaki: [240, 230, 140],
			lavender: [230, 230, 250],
			lavenderblush: [255, 240, 245],
			lawngreen: [124, 252, 0],
			lemonchiffon: [255, 250, 205],
			lightblue: [173, 216, 230],
			lightcoral: [240, 128, 128],
			lightcyan: [224, 255, 255],
			lightgoldenrodyellow: [250, 250, 210],
			lightgray: [211, 211, 211],
			lightgreen: [144, 238, 144],
			lightgrey: [211, 211, 211],
			lightpink: [255, 182, 193],
			lightsalmon: [255,
				160, 122
			],
			lightseagreen: [32, 178, 170],
			lightskyblue: [135, 206, 250],
			lightslategray: [119, 136, 153],
			lightslategrey: [119, 136, 153],
			lightsteelblue: [176, 196, 222],
			lightyellow: [255, 255, 224],
			lime: [0, 255, 0],
			limegreen: [50, 205, 50],
			linen: [250, 240, 230],
			magenta: [255, 0, 255],
			maroon: [128, 0, 0],
			mediumaquamarine: [102, 205, 170],
			mediumblue: [0, 0, 205],
			mediumorchid: [186, 85, 211],
			mediumpurple: [147, 112, 219],
			mediumseagreen: [60, 179, 113],
			mediumslateblue: [123, 104, 238],
			mediumspringgreen: [0, 250, 154],
			mediumturquoise: [72, 209, 204],
			mediumvioletred: [199,
				21, 133
			],
			midnightblue: [25, 25, 112],
			mintcream: [245, 255, 250],
			mistyrose: [255, 228, 225],
			moccasin: [255, 228, 181],
			navajowhite: [255, 222, 173],
			navy: [0, 0, 128],
			oldlace: [253, 245, 230],
			olive: [128, 128, 0],
			olivedrab: [107, 142, 35],
			orange: [255, 165, 0],
			orangered: [255, 69, 0],
			orchid: [218, 112, 214],
			palegoldenrod: [238, 232, 170],
			palegreen: [152, 251, 152],
			paleturquoise: [175, 238, 238],
			palevioletred: [219, 112, 147],
			papayawhip: [255, 239, 213],
			peachpuff: [255, 218, 185],
			peru: [205, 133, 63],
			pink: [255, 192, 203],
			plum: [221, 160, 221],
			powderblue: [176, 224,
				230
			],
			purple: [128, 0, 128],
			rebeccapurple: [102, 51, 153],
			red: [255, 0, 0],
			rosybrown: [188, 143, 143],
			royalblue: [65, 105, 225],
			saddlebrown: [139, 69, 19],
			salmon: [250, 128, 114],
			sandybrown: [244, 164, 96],
			seagreen: [46, 139, 87],
			seashell: [255, 245, 238],
			sienna: [160, 82, 45],
			silver: [192, 192, 192],
			skyblue: [135, 206, 235],
			slateblue: [106, 90, 205],
			slategray: [112, 128, 144],
			slategrey: [112, 128, 144],
			snow: [255, 250, 250],
			springgreen: [0, 255, 127],
			steelblue: [70, 130, 180],
			tan: [210, 180, 140],
			teal: [0, 128, 128],
			thistle: [216, 191, 216],
			tomato: [255, 99, 71],
			turquoise: [64,
				224, 208
			],
			violet: [238, 130, 238],
			wheat: [245, 222, 179],
			white: [255, 255, 255],
			whitesmoke: [245, 245, 245],
			yellow: [255, 255, 0],
			yellowgreen: [154, 205, 50]
		},
		vs = qj.f;
	ah("getOwnPropertyDescriptor", function() {
		return function(f, a) {
			return vs(mc(f), a)
		}
	});
	var ws = va.Object,
		xs = function(f, a) {
			return ws.getOwnPropertyDescriptor(f, a)
		},
		ys = ta(function(f) {
			f.exports = {
				"default": xs,
				__esModule: !0
			}
		}),
		zs = fa(ys),
		xe = ta(function(f) {
			var a = Array.prototype.concat,
				b = Array.prototype.slice,
				c = f.exports = function(c) {
					for (var d = [], f = 0, k = c.length; f <
						k; f++) {
						var l = c[f];
						var m = (m = l) && "string" !== typeof m ? m instanceof Array || Array.isArray(m) || 0 <= m.length && (m.splice instanceof Function ||
							zs(m, m.length - 1) && "String" !== m.constructor.name) : !1;
						m ? d = a.call(d, b.call(l)) : d.push(l)
					}
					return d
				};
			c.wrap = function(a) {
				return function() {
					return a(c(arguments))
				}
			}
		}),
		wh = ta(function(f) {
			function a(a, b, c) {
				return Math.min(Math.max(b, a), c)
			}

			function b(a) {
				a = a.toString(16).toUpperCase();
				return 2 > a.length ? "0" + a : a
			}
			var c = {},
				d;
			for (d in Zc) Zc.hasOwnProperty(d) && (c[Zc[d]] = d);
			var e = f.exports = {
				to: {},
				get: {}
			};
			e.get = function(a) {
				switch (a.substring(0, 3).toLowerCase()) {
					case "hsl":
						a = e.get.hsl(a);
						var b = "hsl";
						break;
					case "hwb":
						a = e.get.hwb(a);
						b = "hwb";
						break;
					default:
						a = e.get.rgb(a), b = "rgb"
				}
				return a ? {
					model: b,
					value: a
				} : null
			};
			e.get.rgb = function(b) {
				if (!b) return null;
				var c = /^#([a-f0-9]{3,4})$/i,
					d = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
					e = /^rgba?\(\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/,
					f = /(\D+)/,
					g = [0,
						0, 0, 1
					],
					p;
				if (p = b.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
					c = p[2];
					p = p[1];
					for (b = 0; 3 > b; b++) d = 2 * b, g[b] = parseInt(p.slice(d, d + 2), 16);
					c && (g[3] = Math.round(parseInt(c, 16) / 255 * 100) / 100)
				} else if (p = b.match(c)) {
					p = p[1];
					c = p[3];
					for (b = 0; 3 > b; b++) g[b] = parseInt(p[b] + p[b], 16);
					c && (g[3] = Math.round(parseInt(c + c, 16) / 255 * 100) / 100)
				} else if (p = b.match(d)) {
					for (b = 0; 3 > b; b++) g[b] = parseInt(p[b + 1], 0);
					p[4] && (g[3] = parseFloat(p[4]))
				} else if (p = b.match(e)) {
					for (b = 0; 3 > b; b++) g[b] = Math.round(2.55 * parseFloat(p[b + 1]));
					p[4] && (g[3] = parseFloat(p[4]))
				} else {
					if (p =
						b.match(f)) {
						if ("transparent" === p[1]) return [0, 0, 0, 0];
						g = Zc[p[1]];
						if (!g) return null;
						g[3] = 1;
						return g
					}
					return null
				}
				for (b = 0; 3 > b; b++) g[b] = a(g[b], 0, 255);
				g[3] = a(g[3], 0, 1);
				return g
			};
			e.get.hsl = function(b) {
				if (!b) return null;
				var c = b.match(
					/^hsla?\(\s*([+-]?(?:\d*\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
				);
				if (c) {
					var d = parseFloat(c[4]);
					b = (parseFloat(c[1]) + 360) % 360;
					var e = a(parseFloat(c[2]), 0, 100);
					c = a(parseFloat(c[3]), 0, 100);
					d = a(isNaN(d) ? 1 : d, 0, 1);
					return [b, e, c, d]
				}
				return null
			};
			e.get.hwb = function(b) {
				if (!b) return null;
				var c = b.match(
					/^hwb\(\s*([+-]?\d*[\.]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/
				);
				if (c) {
					var d = parseFloat(c[4]);
					b = (parseFloat(c[1]) % 360 + 360) % 360;
					var e = a(parseFloat(c[2]), 0, 100);
					c = a(parseFloat(c[3]), 0, 100);
					d = a(isNaN(d) ? 1 : d, 0, 1);
					return [b, e, c, d]
				}
				return null
			};
			e.to.hex = function() {
				var a = xe(arguments);
				return "#" + b(a[0]) + b(a[1]) + b(a[2]) + (1 > a[3] ? b(Math.round(255 * a[3])) : "")
			};
			e.to.rgb = function() {
				var a = xe(arguments);
				return 4 >
					a.length || 1 === a[3] ? "rgb(" + Math.round(a[0]) + ", " + Math.round(a[1]) + ", " + Math.round(a[2]) + ")" :
					"rgba(" + Math.round(a[0]) + ", " + Math.round(a[1]) + ", " + Math.round(a[2]) + ", " + a[3] + ")"
			};
			e.to.rgb.percent = function() {
				var a = xe(arguments),
					b = Math.round(a[0] / 255 * 100),
					c = Math.round(a[1] / 255 * 100),
					d = Math.round(a[2] / 255 * 100);
				return 4 > a.length || 1 === a[3] ? "rgb(" + b + "%, " + c + "%, " + d + "%)" : "rgba(" + b + "%, " + c + "%, " +
					d + "%, " + a[3] + ")"
			};
			e.to.hsl = function() {
				var a = xe(arguments);
				return 4 > a.length || 1 === a[3] ? "hsl(" + a[0] + ", " + a[1] + "%, " + a[2] +
					"%)" : "hsla(" + a[0] + ", " + a[1] + "%, " + a[2] + "%, " + a[3] + ")"
			};
			e.to.hwb = function() {
				var a = xe(arguments),
					b = "";
				4 <= a.length && 1 !== a[3] && (b = ", " + a[3]);
				return "hwb(" + a[0] + ", " + a[1] + "%, " + a[2] + "%" + b + ")"
			};
			e.to.keyword = function(a) {
				return c[a.slice(0, 3)]
			}
		}),
		ac = ta(function(f) {
			var a = {};
			for (d in Zc) Zc.hasOwnProperty(d) && (a[Zc[d]] = d);
			var b = f.exports = {
					rgb: {
						channels: 3,
						labels: "rgb"
					},
					hsl: {
						channels: 3,
						labels: "hsl"
					},
					hsv: {
						channels: 3,
						labels: "hsv"
					},
					hwb: {
						channels: 3,
						labels: "hwb"
					},
					cmyk: {
						channels: 4,
						labels: "cmyk"
					},
					xyz: {
						channels: 3,
						labels: "xyz"
					},
					lab: {
						channels: 3,
						labels: "lab"
					},
					lch: {
						channels: 3,
						labels: "lch"
					},
					hex: {
						channels: 1,
						labels: ["hex"]
					},
					keyword: {
						channels: 1,
						labels: ["keyword"]
					},
					ansi16: {
						channels: 1,
						labels: ["ansi16"]
					},
					ansi256: {
						channels: 1,
						labels: ["ansi256"]
					},
					hcg: {
						channels: 3,
						labels: ["h", "c", "g"]
					},
					apple: {
						channels: 3,
						labels: ["r16", "g16", "b16"]
					},
					gray: {
						channels: 1,
						labels: ["gray"]
					}
				},
				c;
			for (c in b)
				if (b.hasOwnProperty(c)) {
					if (!("channels" in b[c])) throw Error("missing channels property: " + c);
					if (!("labels" in b[c])) throw Error("missing channel labels property: " +
						c);
					if (b[c].labels.length !== b[c].channels) throw Error("channel and label counts mismatch: " + c);
					f = b[c].channels;
					var d = b[c].labels;
					delete b[c].channels;
					delete b[c].labels;
					Object.defineProperty(b[c], "channels", {
						value: f
					});
					Object.defineProperty(b[c], "labels", {
						value: d
					})
				} b.rgb.hsl = function(a) {
				var b = a[0] / 255,
					c = a[1] / 255,
					d = a[2] / 255;
				a = Math.min(b, c, d);
				var e = Math.max(b, c, d),
					f = e - a,
					r;
				e === a ? r = 0 : b === e ? r = (c - d) / f : c === e ? r = 2 + (d - b) / f : d === e && (r = 4 + (b - c) / f);
				r = Math.min(60 * r, 360);
				0 > r && (r += 360);
				b = (a + e) / 2;
				return [r, 100 * (e === a ?
					0 : .5 >= b ? f / (e + a) : f / (2 - e - a)), 100 * b]
			};
			b.rgb.hsv = function(a) {
				var b, c = a[0] / 255,
					d = a[1] / 255,
					e = a[2] / 255,
					f = Math.max(c, d, e);
				var r = f - Math.min(c, d, e);
				if (0 === r) var p = b = 0;
				else {
					b = r / f;
					a = (f - c) / 6 / r + .5;
					var q = (f - d) / 6 / r + .5;
					r = (f - e) / 6 / r + .5;
					c === f ? p = r - q : d === f ? p = 1 / 3 + a - r : e === f && (p = 2 / 3 + q - a);
					0 > p ? p += 1 : 1 < p && --p
				}
				return [360 * p, 100 * b, 100 * f]
			};
			b.rgb.hwb = function(a) {
				var c = a[0],
					d = a[1],
					e = a[2];
				a = b.rgb.hsl(a)[0];
				var f = 1 / 255 * Math.min(c, Math.min(d, e));
				e = 1 - 1 / 255 * Math.max(c, Math.max(d, e));
				return [a, 100 * f, 100 * e]
			};
			b.rgb.cmyk = function(a) {
				var b = a[0] /
					255,
					c = a[1] / 255;
				a = a[2] / 255;
				var d = Math.min(1 - b, 1 - c, 1 - a);
				return [100 * ((1 - b - d) / (1 - d) || 0), 100 * ((1 - c - d) / (1 - d) || 0), 100 * ((1 - a - d) / (1 - d) ||
					0), 100 * d]
			};
			b.rgb.keyword = function(b) {
				var c = a[b];
				if (c) return c;
				c = Infinity;
				var d;
				for (d in Zc)
					if (Zc.hasOwnProperty(d)) {
						var e = Zc[d];
						e = Math.pow(b[0] - e[0], 2) + Math.pow(b[1] - e[1], 2) + Math.pow(b[2] - e[2], 2);
						if (e < c) {
							c = e;
							var f = d
						}
					} return f
			};
			b.keyword.rgb = function(a) {
				return Zc[a]
			};
			b.rgb.xyz = function(a) {
				var b = a[0] / 255,
					c = a[1] / 255;
				a = a[2] / 255;
				b = .04045 < b ? Math.pow((b + .055) / 1.055, 2.4) : b / 12.92;
				c = .04045 < c ? Math.pow((c + .055) / 1.055, 2.4) : c / 12.92;
				a = .04045 < a ? Math.pow((a + .055) / 1.055, 2.4) : a / 12.92;
				return [100 * (.4124 * b + .3576 * c + .1805 * a), 100 * (.2126 * b + .7152 * c + .0722 * a), 100 * (.0193 * b +
					.1192 * c + .9505 * a)]
			};
			b.rgb.lab = function(a) {
				var c = b.rgb.xyz(a);
				a = c[0];
				var d = c[1];
				c = c[2];
				a /= 95.047;
				d /= 100;
				c /= 108.883;
				a = .008856 < a ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116;
				d = .008856 < d ? Math.pow(d, 1 / 3) : 7.787 * d + 16 / 116;
				c = .008856 < c ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116;
				return [116 * d - 16, 500 * (a - d), 200 * (d - c)]
			};
			b.hsl.rgb = function(a) {
				var b = a[0] / 360,
					c = a[1] / 100;
				a = a[2] / 100;
				if (0 === c) {
					var d = 255 * a;
					return [d, d, d]
				}
				c = .5 > a ? a * (1 + c) : a + c - a * c;
				a = 2 * a - c;
				var e = [0, 0, 0];
				for (var f = 0; 3 > f; f++) d = b + 1 / 3 * -(f - 1), 0 > d && d++, 1 < d && d--, d = 1 > 6 * d ? a + 6 * (c - a) *
					d : 1 > 2 * d ? c : 2 > 3 * d ? a + (c - a) * (2 / 3 - d) * 6 : a, e[f] = 255 * d;
				return e
			};
			b.hsl.hsv = function(a) {
				var b = a[0],
					c = a[1] / 100;
				a = a[2] / 100;
				var d = c,
					e = Math.max(a, .01);
				a *= 2;
				c *= 1 >= a ? a : 2 - a;
				d *= 1 >= e ? e : 2 - e;
				return [b, 100 * (0 === a ? 2 * d / (e + d) : 2 * c / (a + c)), (a + c) / 2 * 100]
			};
			b.hsv.rgb = function(a) {
				var b = a[0] / 60,
					c = a[1] / 100;
				a = a[2] / 100;
				var d = Math.floor(b) % 6,
					e = b - Math.floor(b);
				b = 255 * a * (1 - c);
				var f = 255 * a * (1 - c * e);
				c = 255 * a * (1 - c * (1 - e));
				a *= 255;
				switch (d) {
					case 0:
						return [a, c, b];
					case 1:
						return [f, a, b];
					case 2:
						return [b, a, c];
					case 3:
						return [b, f, a];
					case 4:
						return [c, b, a];
					case 5:
						return [a, b, f]
				}
			};
			b.hsv.hsl = function(a) {
				var b = a[0],
					c = a[1] / 100;
				a = a[2] / 100;
				var d = Math.max(a, .01);
				var e = (2 - c) * d;
				d = c * d / (1 >= e ? e : 2 - e) || 0;
				return [b, 100 * d, (2 - c) * a / 2 * 100]
			};
			b.hwb.rgb = function(a) {
				var b = a[0] / 360,
					c = a[1] / 100;
				a = a[2] / 100;
				var d = c + a;
				1 < d && (c /= d, a /= d);
				d = Math.floor(6 * b);
				a = 1 - a;
				b = 6 * b - d;
				0 !== (d & 1) && (b = 1 - b);
				b = c + b * (a - c);
				switch (d) {
					default:
					case 6:
					case 0:
						d =
							a;
						var e = b;
						break;
					case 1:
						d = b;
						e = a;
						break;
					case 2:
						d = c;
						e = a;
						c = b;
						break;
					case 3:
						d = c;
						e = b;
						c = a;
						break;
					case 4:
						d = b;
						e = c;
						c = a;
						break;
					case 5:
						d = a, e = c, c = b
				}
				return [255 * d, 255 * e, 255 * c]
			};
			b.cmyk.rgb = function(a) {
				var b = a[3] / 100;
				return [255 * (1 - Math.min(1, a[0] / 100 * (1 - b) + b)), 255 * (1 - Math.min(1, a[1] / 100 * (1 - b) + b)),
					255 * (1 - Math.min(1, a[2] / 100 * (1 - b) + b))
				]
			};
			b.xyz.rgb = function(a) {
				var b = a[0] / 100,
					c = a[1] / 100,
					d = a[2] / 100;
				a = 3.2406 * b + -1.5372 * c + -.4986 * d;
				var e = -.9689 * b + 1.8758 * c + .0415 * d;
				b = .0557 * b + -.204 * c + 1.057 * d;
				a = .0031308 < a ? 1.055 * Math.pow(a, 1 / 2.4) - .055 :
					12.92 * a;
				e = .0031308 < e ? 1.055 * Math.pow(e, 1 / 2.4) - .055 : 12.92 * e;
				b = .0031308 < b ? 1.055 * Math.pow(b, 1 / 2.4) - .055 : 12.92 * b;
				a = Math.min(Math.max(0, a), 1);
				e = Math.min(Math.max(0, e), 1);
				b = Math.min(Math.max(0, b), 1);
				return [255 * a, 255 * e, 255 * b]
			};
			b.xyz.lab = function(a) {
				var b = a[0],
					c = a[1];
				a = a[2];
				b /= 95.047;
				c /= 100;
				a /= 108.883;
				b = .008856 < b ? Math.pow(b, 1 / 3) : 7.787 * b + 16 / 116;
				c = .008856 < c ? Math.pow(c, 1 / 3) : 7.787 * c + 16 / 116;
				a = .008856 < a ? Math.pow(a, 1 / 3) : 7.787 * a + 16 / 116;
				return [116 * c - 16, 500 * (b - c), 200 * (c - a)]
			};
			b.lab.xyz = function(a) {
				var b = a[1],
					c = a[2];
				a = (a[0] + 16) / 116;
				b = b / 500 + a;
				c = a - c / 200;
				var d = Math.pow(a, 3),
					e = Math.pow(b, 3),
					f = Math.pow(c, 3);
				return [95.047 * (.008856 < e ? e : (b - 16 / 116) / 7.787), 100 * (.008856 < d ? d : (a - 16 / 116) / 7.787),
					108.883 * (.008856 < f ? f : (c - 16 / 116) / 7.787)
				]
			};
			b.lab.lch = function(a) {
				var b = a[0],
					c = a[1];
				a = a[2];
				var d = 360 * Math.atan2(a, c) / 2 / Math.PI;
				0 > d && (d += 360);
				return [b, Math.sqrt(c * c + a * a), d]
			};
			b.lch.lab = function(a) {
				var b = a[0],
					c = a[1];
				a = a[2] / 360 * 2 * Math.PI;
				return [b, c * Math.cos(a), c * Math.sin(a)]
			};
			b.rgb.ansi16 = function(a) {
				var c = a[0],
					d = a[1],
					e = a[2],
					f = 1 in arguments ?
					arguments[1] : b.rgb.hsv(a)[2];
				f = Math.round(f / 50);
				if (0 === f) return 30;
				c = 30 + (Math.round(e / 255) << 2 | Math.round(d / 255) << 1 | Math.round(c / 255));
				2 === f && (c += 60);
				return c
			};
			b.hsv.ansi16 = function(a) {
				return b.rgb.ansi16(b.hsv.rgb(a), a[2])
			};
			b.rgb.ansi256 = function(a) {
				var b = a[0],
					c = a[1];
				a = a[2];
				return b === c && c === a ? 8 > b ? 16 : 248 < b ? 231 : Math.round((b - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(
					b / 255 * 5) + 6 * Math.round(c / 255 * 5) + Math.round(a / 255 * 5)
			};
			b.ansi16.rgb = function(a) {
				var b = a % 10;
				if (0 === b || 7 === b) return 50 < a && (b += 3.5), b = b / 10.5 * 255, [b, b,
					b
				];
				a = .5 * (~~(50 < a) + 1);
				return [(b & 1) * a * 255, (b >> 1 & 1) * a * 255, (b >> 2 & 1) * a * 255]
			};
			b.ansi256.rgb = function(a) {
				if (232 <= a) {
					var b = 10 * (a - 232) + 8;
					return [b, b, b]
				}
				a -= 16;
				b = Math.floor(a / 36) / 5 * 255;
				var c = Math.floor((a %= 36) / 6) / 5 * 255;
				return [b, c, a % 6 / 5 * 255]
			};
			b.rgb.hex = function(a) {
				a = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16)
					.toUpperCase();
				return "000000".substring(a.length) + a
			};
			b.hex.rgb = function(a) {
				a = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
				if (!a) return [0, 0, 0];
				var b = a[0];
				3 === a[0].length && (b = b.split("").map(function(a) {
					return a + a
				}).join(""));
				a = parseInt(b, 16);
				return [a >> 16 & 255, a >> 8 & 255, a & 255]
			};
			b.rgb.hcg = function(a) {
				var b = a[0] / 255,
					c = a[1] / 255;
				a = a[2] / 255;
				var d = Math.max(Math.max(b, c), a),
					e = Math.min(Math.min(b, c), a),
					f = d - e;
				return [(0 >= f ? 0 : d === b ? (c - a) / f % 6 : d === c ? 2 + (a - b) / f : (b - c) / f + 8) / 6 % 1 * 360,
					100 * f, 100 * (1 > f ? e / (1 - f) : 0)
				]
			};
			b.hsl.hcg = function(a) {
				var b = a[1] / 100,
					c = a[2] / 100,
					d = 0;
				b = .5 > c ? 2 * b * c : 2 * b * (1 - c);
				1 > b && (d = (c - .5 * b) / (1 - b));
				return [a[0], 100 * b, 100 * d]
			};
			b.hsv.hcg = function(a) {
				var b = a[2] / 100,
					c = a[1] / 100 * b,
					d = 0;
				1 > c && (d = (b - c) / (1 - c));
				return [a[0], 100 * c, 100 * d]
			};
			b.hcg.rgb = function(a) {
				var b = a[1] / 100,
					c = a[2] / 100;
				if (0 === b) return [255 * c, 255 * c, 255 * c];
				var d = [0, 0, 0];
				a = a[0] / 360 % 1 * 6;
				var e = a % 1,
					f = 1 - e;
				switch (Math.floor(a)) {
					case 0:
						d[0] = 1;
						d[1] = e;
						d[2] = 0;
						break;
					case 1:
						d[0] = f;
						d[1] = 1;
						d[2] = 0;
						break;
					case 2:
						d[0] = 0;
						d[1] = 1;
						d[2] = e;
						break;
					case 3:
						d[0] = 0;
						d[1] = f;
						d[2] = 1;
						break;
					case 4:
						d[0] = e;
						d[1] = 0;
						d[2] = 1;
						break;
					default:
						d[0] = 1, d[1] = 0, d[2] = f
				}
				c *= 1 - b;
				return [255 * (b * d[0] + c), 255 * (b * d[1] + c), 255 * (b * d[2] + c)]
			};
			b.hcg.hsv = function(a) {
				var b =
					a[1] / 100,
					c = b + a[2] / 100 * (1 - b),
					d = 0;
				0 < c && (d = b / c);
				return [a[0], 100 * d, 100 * c]
			};
			b.hcg.hsl = function(a) {
				var b = a[1] / 100,
					c = a[2] / 100 * (1 - b) + .5 * b,
					d = 0;
				0 < c && .5 > c ? d = b / (2 * c) : .5 <= c && 1 > c && (d = b / (2 * (1 - c)));
				return [a[0], 100 * d, 100 * c]
			};
			b.hcg.hwb = function(a) {
				var b = a[1] / 100,
					c = b + a[2] / 100 * (1 - b);
				return [a[0], 100 * (c - b), 100 * (1 - c)]
			};
			b.hwb.hcg = function(a) {
				var b = 1 - a[2] / 100,
					c = b - a[1] / 100,
					d = 0;
				1 > c && (d = (b - c) / (1 - c));
				return [a[0], 100 * c, 100 * d]
			};
			b.apple.rgb = function(a) {
				return [a[0] / 65535 * 255, a[1] / 65535 * 255, a[2] / 65535 * 255]
			};
			b.rgb.apple = function(a) {
				return [a[0] /
					255 * 65535, a[1] / 255 * 65535, a[2] / 255 * 65535
				]
			};
			b.gray.rgb = function(a) {
				return [a[0] / 100 * 255, a[0] / 100 * 255, a[0] / 100 * 255]
			};
			b.gray.hsl = b.gray.hsv = function(a) {
				return [0, 0, a[0]]
			};
			b.gray.hwb = function(a) {
				return [0, 100, a[0]]
			};
			b.gray.cmyk = function(a) {
				return [0, 0, 0, a[0]]
			};
			b.gray.lab = function(a) {
				return [a[0], 0, 0]
			};
			b.gray.hex = function(a) {
				a = Math.round(a[0] / 100 * 255) & 255;
				a = ((a << 16) + (a << 8) + a).toString(16).toUpperCase();
				return "000000".substring(a.length) + a
			};
			b.rgb.gray = function(a) {
				return [(a[0] + a[1] + a[2]) / 3 / 255 * 100]
			}
		}),
		As = function(f) {
			for (var a = {}, b = Ha(ac), c = b.length, d = 0; d < c; d++) a[b[d]] = {
				distance: -1,
				parent: null
			};
			b = [f];
			for (a[f].distance = 0; b.length;) {
				f = b.pop();
				c = Ha(ac[f]);
				d = c.length;
				for (var e = 0; e < d; e++) {
					var g = c[e],
						k = a[g]; - 1 === k.distance && (k.distance = a[f].distance + 1, k.parent = f, b.unshift(g))
				}
			}
			b = {};
			f = Ha(a);
			c = f.length;
			for (d = 0; d < c; d++) {
				var l = f[d];
				if (null !== a[l].parent) {
					e = l;
					g = a;
					k = [g[l].parent, l];
					var m = ac[g[l].parent][l];
					for (l = g[l].parent; g[l].parent;) k.unshift(g[l].parent), m = qp(ac[g[l].parent][l], m), l = g[l].parent;
					m.conversion = k;
					b[e] = m
				}
			}
			return b
		},
		Id = {};
	Ha(ac).forEach(function(f) {
		Id[f] = {};
		Object.defineProperty(Id[f], "channels", {
			value: ac[f].channels
		});
		Object.defineProperty(Id[f], "labels", {
			value: ac[f].labels
		});
		var a = As(f);
		Ha(a).forEach(function(b) {
			var c = a[b];
			Id[f][b] = sp(c);
			Id[f][b].raw = rp(c)
		})
	});
	var Nb = Id,
		xh = [].slice,
		nm = ["keyword", "gray", "hex"],
		Zj = {};
	Ha(Nb).forEach(function(f) {
		Zj[xh.call(Nb[f].labels).sort().join("")] = f
	});
	var zg = {};
	mb.prototype = {
		toString: function() {
			return this.string()
		},
		toJSON: function() {
			return this[this.model]()
		},
		string: function(f) {
			var a =
				this.model in wh.to ? this : this.rgb();
			a = a.round("number" === typeof f ? f : 1);
			f = 1 === a.valpha ? a.color : a.color.concat(this.valpha);
			return wh.to[a.model](f)
		},
		percentString: function(f) {
			f = this.rgb().round("number" === typeof f ? f : 1);
			f = 1 === f.valpha ? f.color : f.color.concat(this.valpha);
			return wh.to.rgb.percent(f)
		},
		array: function() {
			return 1 === this.valpha ? this.color.slice() : this.color.concat(this.valpha)
		},
		object: function() {
			for (var f = {}, a = Nb[this.model].channels, b = Nb[this.model].labels, c = 0; c < a; c++) f[b[c]] = this.color[
				c];
			1 !== this.valpha && (f.alpha = this.valpha);
			return f
		},
		unitArray: function() {
			var f = this.rgb().color;
			f[0] /= 255;
			f[1] /= 255;
			f[2] /= 255;
			1 !== this.valpha && f.push(this.valpha);
			return f
		},
		unitObject: function() {
			var f = this.rgb().object();
			f.r /= 255;
			f.g /= 255;
			f.b /= 255;
			1 !== this.valpha && (f.alpha = this.valpha);
			return f
		},
		round: function(f) {
			f = Math.max(f || 0, 0);
			return new mb(this.color.map(tp(f)).concat(this.valpha), this.model)
		},
		alpha: function(f) {
			return arguments.length ? new mb(this.color.concat(Math.max(0, Math.min(1, f))), this.model) :
				this.valpha
		},
		red: qa("rgb", 0, Za(255)),
		green: qa("rgb", 1, Za(255)),
		blue: qa("rgb", 2, Za(255)),
		hue: qa(["hsl", "hsv", "hsl", "hwb", "hcg"], 0, function(f) {
			return (f % 360 + 360) % 360
		}),
		saturationl: qa("hsl", 1, Za(100)),
		lightness: qa("hsl", 2, Za(100)),
		saturationv: qa("hsv", 1, Za(100)),
		value: qa("hsv", 2, Za(100)),
		chroma: qa("hcg", 1, Za(100)),
		gray: qa("hcg", 2, Za(100)),
		white: qa("hwb", 1, Za(100)),
		wblack: qa("hwb", 2, Za(100)),
		cyan: qa("cmyk", 0, Za(100)),
		magenta: qa("cmyk", 1, Za(100)),
		yellow: qa("cmyk", 2, Za(100)),
		black: qa("cmyk", 3, Za(100)),
		x: qa("xyz",
			0, Za(100)),
		y: qa("xyz", 1, Za(100)),
		z: qa("xyz", 2, Za(100)),
		l: qa("lab", 0, Za(100)),
		a: qa("lab", 1),
		b: qa("lab", 2),
		keyword: function(f) {
			return arguments.length ? new mb(f) : Nb[this.model].keyword(this.color)
		},
		hex: function(f) {
			return arguments.length ? new mb(f) : wh.to.hex(this.rgb().round().color)
		},
		rgbNumber: function() {
			var f = this.rgb().color;
			return (f[0] & 255) << 16 | (f[1] & 255) << 8 | f[2] & 255
		},
		luminosity: function() {
			for (var f = this.rgb().color, a = [], b = 0; b < f.length; b++) {
				var c = f[b] / 255;
				a[b] = .03928 >= c ? c / 12.92 : Math.pow((c + .055) /
					1.055, 2.4)
			}
			return .2126 * a[0] + .7152 * a[1] + .0722 * a[2]
		},
		contrast: function(f) {
			var a = this.luminosity();
			f = f.luminosity();
			return a > f ? (a + .05) / (f + .05) : (f + .05) / (a + .05)
		},
		level: function(f) {
			f = this.contrast(f);
			return 7.1 <= f ? "AAA" : 4.5 <= f ? "AA" : ""
		},
		isDark: function() {
			var f = this.rgb().color;
			return 128 > (299 * f[0] + 587 * f[1] + 114 * f[2]) / 1E3
		},
		isLight: function() {
			return !this.isDark()
		},
		negate: function() {
			for (var f = this.rgb(), a = 0; 3 > a; a++) f.color[a] = 255 - f.color[a];
			return f
		},
		lighten: function(f) {
			var a = this.hsl();
			a.color[2] += a.color[2] *
				f;
			return a
		},
		darken: function(f) {
			var a = this.hsl();
			a.color[2] -= a.color[2] * f;
			return a
		},
		saturate: function(f) {
			var a = this.hsl();
			a.color[1] += a.color[1] * f;
			return a
		},
		desaturate: function(f) {
			var a = this.hsl();
			a.color[1] -= a.color[1] * f;
			return a
		},
		whiten: function(f) {
			var a = this.hwb();
			a.color[1] += a.color[1] * f;
			return a
		},
		blacken: function(f) {
			var a = this.hwb();
			a.color[2] += a.color[2] * f;
			return a
		},
		grayscale: function() {
			var f = this.rgb().color;
			f = .3 * f[0] + .59 * f[1] + .11 * f[2];
			return mb.rgb(f, f, f)
		},
		fade: function(f) {
			return this.alpha(this.valpha -
				this.valpha * f)
		},
		opaquer: function(f) {
			return this.alpha(this.valpha + this.valpha * f)
		},
		rotate: function(f) {
			var a = this.hsl(),
				b = a.color[0];
			b = (b + f) % 360;
			a.color[0] = 0 > b ? 360 + b : b;
			return a
		},
		mix: function(f, a) {
			if (!f || !f.rgb) throw Error('Argument to "mix" was not a Color instance, but rather an instance of ' + (
				"undefined" === typeof f ? "undefined" : Ni(f)));
			f = f.rgb();
			var b = this.rgb();
			a = void 0 === a ? .5 : a;
			var c = 2 * a - 1,
				d = f.alpha() - b.alpha();
			c = ((-1 === c * d ? c : (c + d) / (1 + c * d)) + 1) / 2;
			d = 1 - c;
			return mb.rgb(c * f.red() + d * b.red(), c * f.green() +
				d * b.green(), c * f.blue() + d * b.blue(), f.alpha() * a + b.alpha() * (1 - a))
		}
	};
	Ha(Nb).forEach(function(f) {
		if (-1 === nm.indexOf(f)) {
			var a = Nb[f].channels;
			mb.prototype[f] = function() {
				if (this.model === f) return new mb(this);
				if (arguments.length) return new mb(arguments, f);
				var b = "number" === typeof arguments[a] ? a : this.valpha;
				var c = Nb[this.model][f].raw(this.color);
				c = Array.isArray(c) ? c : [c];
				return new mb(c.concat(b), f)
			};
			mb[f] = function(b) {
				"number" === typeof b && (b = Yj(xh.call(arguments), a));
				return new mb(b, f)
			}
		}
	});
	var ye = function() {
		function f(a,
			b, c) {
			Xa(this, f);
			this.options = b;
			this.gl = a;
			c && (this.map = c.map);
			c = this.getVertexShader(b.vertexShader);
			var d = this.getFragmentShader(b.fragmentShader);
			b = a.createShader(a.VERTEX_SHADER);
			a.shaderSource(b, c);
			a.compileShader(b);
			a.getShaderParameter(b, a.COMPILE_STATUS) ? (c = a.createShader(a.FRAGMENT_SHADER), a.shaderSource(c, d), a.compileShader(
				c), a.getShaderParameter(c, a.COMPILE_STATUS) ? (d = a.createProgram(), a.attachShader(d, b), a.attachShader(d,
				c), a.deleteShader(b), a.deleteShader(c), a.linkProgram(d), a.getProgramParameter(d,
				a.LINK_STATUS) ? b = d : (b = "Shader program failed to link.  The error log is:" + a.getProgramInfoLog(d),
				console.error(b), b = -1)) : (b = "Fragment shader failed to compile.  The error log is:" + a.getShaderInfoLog(
				c), console.error(b), b = -1)) : (b = "Vertex shader failed to compile.  The error log is:" + a.getShaderInfoLog(
				b), console.error(b), b = -1);
			b = this.program = b;
			c = {};
			d = a.getProgramParameter(b, a.ACTIVE_ATTRIBUTES);
			for (var e = 0; e < d; e++) {
				var g = a.getActiveAttrib(b, e);
				c[g.name] = a.getAttribLocation(b, g.name)
			}
			e = {};
			g = {};
			for (var k =
					a.getProgramParameter(b, a.ACTIVE_UNIFORMS), l = 0; l < k; l++) {
				var m = a.getActiveUniform(b, l);
				e[m.name] = a.getUniformLocation(b, m.name);
				g[m.name] = m.type
			}
			this.parameter = a = {
				attributes: c,
				numAttributes: d,
				uniformsType: g,
				uniforms: e
			};
			this.attributes = a.attributes;
			this.uniforms = a.uniforms;
			this.parameter = a
		}
		jb(f, [{
			key: "getVertexShader",
			value: function(a) {
				var b = "";
				this.map && "cesium" === this.map.type && (b = "#define LOG_DEPTH\n");
				b +=
					"#ifdef LOG_DEPTH\nuniform float currentFrustumX;varying float v_depthFromNearPlusOne;\n#endif\nuniform vec2 MAPV_resolution;\n#if defined(PICK)\nuniform bool uIsPickRender;attribute vec3 aPickColor;uniform vec3 uPickedColor;varying vec4 vPickColor;uniform bool uEnablePicked;bool mapvIsPicked(){return uEnablePicked&&aPickColor==uPickedColor;}\n#endif\nvoid afterMain(){\n#if defined(LOG_DEPTH)\nv_depthFromNearPlusOne=(gl_Position.w-currentFrustumX)+1.0;gl_Position.z=clamp(gl_Position.z/gl_Position.w,-1.0,1.0)*gl_Position.w;\n#endif\n#if defined(PICK)\nvPickColor=vec4(aPickColor,0.0);if(mapvIsPicked()){vPickColor.a=1.0;}\n#endif\n}";
				a = this.getDefines() + b + a;
				a = a.replace("void main", "void originMain");
				return a + "void main() {originMain(); afterMain();}"
			}
		}, {
			key: "getFragmentShader",
			value: function(a) {
				var b = "";
				this.map && "cesium" === this.map.type && (b = "#define LOG_DEPTH\n");
				b +=
					"#if defined(LOG_DEPTH)\n#extension GL_EXT_frag_depth : enable\n#endif\nprecision highp float;uniform vec2 MAPV_resolution;\n#if defined(PICK)\nuniform bool uIsPickRender;varying vec4 vPickColor;bool mapvIsPicked(){return vPickColor.a==1.0;}\n#endif\n#if defined(LOG_DEPTH)\nuniform float oneOverLog2FarDepthFromNearPlusOne;uniform float farDepthFromNearPlusOne;varying float v_depthFromNearPlusOne;void writeLogDepth(float depth){if(depth<=0.9999999||depth>farDepthFromNearPlusOne){discard;}gl_FragDepthEXT=log2(depth)*oneOverLog2FarDepthFromNearPlusOne;}\n#endif\nvoid afterMain(){\n#if defined(PICK)\nif(uIsPickRender){gl_FragColor=vec4(vPickColor.rgb,1.0);return;}\n#endif\n#if defined(LOG_DEPTH)\nwriteLogDepth(v_depthFromNearPlusOne);\n#endif\n}";
				a = this.getDefines() + b + a;
				a = a.replace("void main", "void originMain");
				return a + "void main() {originMain(); afterMain();}"
			}
		}, {
			key: "getDefines",
			value: function() {
				var a = "",
					b = this.options.defines;
				if (b)
					for (var c = 0; c < b.length; c++) a += "#define " + b[c] + "\n";
				return a
			}
		}, {
			key: "use",
			value: function(a, b) {
				this.gl = a;
				a.useProgram(this.program);
				this.map && "cesium" === this.map.type && this.setUniforms({
					currentFrustumX: this.map.map.scene.camera.frustum.near,
					oneOverLog2FarDepthFromNearPlusOne: this.map.map.scene.context.uniformState.oneOverLog2FarDepthFromNearPlusOne,
					farDepthFromNearPlusOne: this.map.map.scene.context.uniformState.farDepthFromNearPlusOne
				});
				this.uniforms.MAPV_resolution && this.setUniforms({
					MAPV_resolution: [a.canvas.width, a.canvas.height]
				})
			}
		}, {
			key: "setUniform",
			value: function(a, b) {
				var c = this.gl,
					d = this.uniforms[a];
				if (d) switch (this.parameter.uniformsType[a]) {
					case c.FLOAT:
						c.uniform1f(d, b);
						break;
					case c.FLOAT_VEC2:
						c.uniform2f(d, b[0], b[1]);
						break;
					case c.FLOAT_VEC3:
						c.uniform3f(d, b[0], b[1], b[2]);
						break;
					case c.FLOAT_VEC4:
						c.uniform4f(d, b[0], b[1], b[2], b[3]);
						break;
					case c.SAMPLER_2D:
					case c.SAMPLER_CUBE:
						c.activeTexture(c["TEXTURE" + this.textureIndex]);
						c.uniform1i(d, this.textureIndex);
						c.bindTexture(c.TEXTURE_2D, b);
						this.textureIndex++;
						break;
					case c.INT:
					case c.BOOL:
						c.uniform1i(d, b);
						break;
					case c.INT_VEC2:
					case c.BOOL_VEC2:
						c.uniform2i(d, b[0], b[1]);
						break;
					case c.INT_VEC3:
					case c.BOOL_VEC3:
						c.uniform3i(d, b[0], b[1], b[2]);
						break;
					case c.INT_VEC4:
					case c.BOOL_VEC4:
						c.uniform4i(d, b[0], b[1], b[2], b[3]);
						break;
					case c.FLOAT_MAT2:
						c.uniformMatrix2fv(d, !1, b);
						break;
					case c.FLOAT_MAT3:
						c.uniformMatrix3fv(d,
							!1, b);
						break;
					case c.FLOAT_MAT4:
						c.uniformMatrix4fv(d, !1, b);
						break;
					default:
						console.error("Unrecognized uniform type: " + a)
				} else console.warn("Unrecognized uniform type: " + a)
			}
		}, {
			key: "setUniforms",
			value: function(a) {
				this.textureIndex = 0;
				for (var b in a) this.setUniform(b, a[b])
			}
		}]);
		return f
	}();
	(function() {
		function f(a) {
			Xa(this, f);
			this.options = a;
			this.gl = a.gl;
			this.savedState = [];
			this.currentState = this.getCurrentState()
		}
		jb(f, [{
			key: "setDefaultState",
			value: function() {
				this.setState()
			}
		}, {
			key: "getDefaultState",
			value: function() {
				return {
					blend: !1,
					depthTest: !1,
					cullFace: !1,
					depthMask: !0,
					stencilTest: !1
				}
			}
		}, {
			key: "getCurrentState",
			value: function() {
				var a = this.gl;
				return {
					blend: a.getParameter(a.BLEND),
					stencilTest: a.getParameter(a.STENCIL_TEST),
					depthTest: a.getParameter(a.DEPTH_TEST),
					cullFace: a.getParameter(a.CULL_FACE),
					depthMask: a.getParameter(a.DEPTH_WRITEMASK)
				}
			}
		}, {
			key: "save",
			value: function() {
				this.savedState.push(this.getCurrentState())
			}
		}, {
			key: "restore",
			value: function() {
				var a = this.savedState.pop();
				this.setState(a)
			}
		}, {
			key: "setState",
			value: function(a) {
				var b =
					this.gl,
					c = this.getCurrentState();
				a = q(this.getDefaultState(), a);
				a.blend !== c.blend && (a.blend ? b.enable(b.BLEND) : b.disable(b.BLEND));
				a.depthTest !== c.depthTest && (a.depthTest ? b.enable(b.DEPTH_TEST) : b.disable(b.DEPTH_TEST));
				a.cullFace !== c.cullFace && (a.cullFace ? b.enable(b.CULL_FACE) : b.disable(b.CULL_FACE));
				a.depthMask !== c.depthMask && (a.depthMask ? b.depthMask(!0) : b.depthMask(!1));
				this.currentState = a
			}
		}]);
		return f
	})();
	var Ol = function() {
			function f(a) {
				Xa(this, f);
				this.options = a;
				this.gl = a.gl;
				this.buffer = this.gl.createBuffer();
				a.data && this.updateData(a.data)
			}
			jb(f, [{
				key: "updateData",
				value: function(a) {
					var b = this.options,
						c = this.gl;
					this.bind();
					c.bufferData(c[b.target], a, c[b.usage])
				}
			}, {
				key: "bind",
				value: function(a) {
					a = a || this.gl;
					a.bindBuffer(a[this.options.target], this.buffer)
				}
			}, {
				key: "unBind",
				value: function(a) {
					a = a || this.gl;
					a.bindBuffer(a[this.options.target], null)
				}
			}, {
				key: "destroy",
				value: function() {
					this.buffer = null
				}
			}]);
			return f
		}(),
		Bs = {
			BYTE: 1,
			UNSIGNED_BYTE: 1,
			SHORT: 2,
			UNSIGNED_SHORT: 2,
			FLOAT: 4
		},
		Cs = function() {
			function f(a) {
				Xa(this,
					f);
				this.options = a;
				this.attributes = a.attributes;
				this.gl = a.gl;
				this.program = a.program;
				for (a = this.stride = 0; a < this.attributes.length; a++) this.stride += Bs[this.attributes[a].type] * this.attributes[
					a].size
			}
			jb(f, [{
				key: "setVertexAttribPointers",
				value: function() {
					for (var a = this.gl, b = this.program, c = 0; c < this.attributes.length; c++) {
						var d = this.attributes[c],
							e = b.attributes[d.name];
						void 0 !== e && (d.buffer.bind(a), a.vertexAttribPointer(e, d.size, a[d.type], d.normalize || !1, void 0 !==
								d.stride ? d.stride : this.stride, d.offset),
							a.enableVertexAttribArray(e))
					}
				}
			}, {
				key: "bind",
				value: function() {
					this.setVertexAttribPointers()
				}
			}, {
				key: "destroy",
				value: function() {}
			}]);
			return f
		}(),
		$c = function d(a, b, c) {
			Xa(this, d);
			b = b || a.canvas.width;
			c = c || a.canvas.height;
			var e = a.createFramebuffer(),
				g = a.createTexture();
			a.bindTexture(a.TEXTURE_2D, g);
			a.texImage2D(a.TEXTURE_2D, 0, a.RGBA, b, c, 0, a.RGBA, a.UNSIGNED_BYTE, null);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
			a.texParameteri(a.TEXTURE_2D,
				a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
			a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
			e.texture = g;
			var k = a.createRenderbuffer();
			a.bindRenderbuffer(a.RENDERBUFFER, k);
			a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, b, c);
			e.depthBuffer = k;
			a.bindFramebuffer(a.FRAMEBUFFER, e);
			a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, g, 0);
			a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, k);
			b = a.checkFramebufferStatus(a.FRAMEBUFFER);
			a.FRAMEBUFFER_COMPLETE ===
				b && (a.bindFramebuffer(a.FRAMEBUFFER, null), a.bindTexture(a.TEXTURE_2D, null), a.bindRenderbuffer(a.RENDERBUFFER,
					null), this.framebuffer = e)
		},
		ze = function() {
			function a(b) {
				Xa(this, a);
				this.options = {};
				q(this.options, b);
				this.vertex = [-1, 1, 0, -1, -1, 0, 1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
				this.sampleCoord = [0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0]
			}
			jb(a, [{
				key: "getOptions",
				value: function() {
					return this.options
				}
			}, {
				key: "onResize",
				value: function(a) {}
			}, {
				key: "render",
				value: function(a) {
					var b = a.gl;
					a = a.texture;
					var d = this.programSample;
					b.useProgram(d.program);
					var e = b.createBuffer();
					b.bindBuffer(b.ARRAY_BUFFER, e);
					var g = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
					b.bufferData(b.ARRAY_BUFFER, new Float32Array(g), b.STATIC_DRAW);
					b.enableVertexAttribArray(d.attributes.aPos);
					b.vertexAttribPointer(d.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
					e = b.createBuffer();
					b.bindBuffer(b.ARRAY_BUFFER, e);
					b.bufferData(b.ARRAY_BUFFER, new Float32Array([0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0]), b.STATIC_DRAW);
					b.enableVertexAttribArray(d.attributes.aTextureCoord);
					b.vertexAttribPointer(d.attributes.aTextureCoord,
						2, b.FLOAT, !1, 0, 0);
					b.activeTexture(b.TEXTURE0);
					b.bindTexture(b.TEXTURE_2D, a);
					b.uniform1i(d.uniforms.uSampler, 0);
					b.drawArrays(b.TRIANGLES, 0, g.length / 3)
				}
			}]);
			return a
		}();
	(function(a) {
		function b(a) {
			Xa(this, b);
			return Zb(this, (b.__proto__ || Yb(b)).call(this, a))
		}
		$b(b, a);
		jb(b, [{
			key: "getProgram",
			value: function(a) {
				this.programSample || (this.programSample = new ye(a, {
					vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(void){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
					fragmentShader: "precision highp float;uniform sampler2D uSampler;uniform vec2 canvasSize;varying vec2 vTextureCoord;vec4 fxaa_2_0(sampler2D tex,vec2 fragCoord,vec2 resolution,vec2 v_rgbNW,vec2 v_rgbNE,vec2 v_rgbSW,vec2 v_rgbSE,vec2 v_rgbM){vec4 color;mediump vec2 inverseVP=vec2(1.0/resolution.x,1.0/resolution.y);vec3 rgbNW=texture2D(tex,v_rgbNW).xyz;vec3 rgbNE=texture2D(tex,v_rgbNE).xyz;vec3 rgbSW=texture2D(tex,v_rgbSW).xyz;vec3 rgbSE=texture2D(tex,v_rgbSE).xyz;vec4 texColor=texture2D(tex,v_rgbM);vec3 rgbM=texColor.xyz;vec3 luma=vec3(0.299,0.587,0.114);float lumaNW=dot(rgbNW,luma);float lumaNE=dot(rgbNE,luma);float lumaSW=dot(rgbSW,luma);float lumaSE=dot(rgbSE,luma);float lumaM=dot(rgbM,luma);float lumaMin=min(lumaM,min(min(lumaNW,lumaNE),min(lumaSW,lumaSE)));float lumaMax=max(lumaM,max(max(lumaNW,lumaNE),max(lumaSW,lumaSE)));mediump vec2 dir;dir.x=-((lumaNW+lumaNE)-(lumaSW+lumaSE));dir.y=((lumaNW+lumaSW)-(lumaNE+lumaSE));float dirReduce=max((lumaNW+lumaNE+lumaSW+lumaSE)*(0.25*1.0/8.0),1.0/128.0);float rcpDirMin=1.0/(min(abs(dir.x),abs(dir.y))+dirReduce);dir=min(vec2(8.0,8.0),max(vec2(-8.0,-8.0),dir*rcpDirMin))*inverseVP;vec3 rgbA=0.5*(texture2D(tex,fragCoord*inverseVP+dir*(1.0/3.0-0.5)).xyz+texture2D(tex,fragCoord*inverseVP+dir*(2.0/3.0-0.5)).xyz);vec3 rgbB=rgbA*0.5+0.25*(texture2D(tex,fragCoord*inverseVP+dir*-0.5).xyz+texture2D(tex,fragCoord*inverseVP+dir*0.5).xyz);float lumaB=dot(rgbB,luma);if((lumaB<lumaMin)||(lumaB>lumaMax)){color=vec4(rgbA,texColor.a);}else{color=vec4(rgbB,texColor.a);}return color;}void texcoords_3_1(vec2 fragCoord,vec2 resolution,out vec2 v_rgbNW,out vec2 v_rgbNE,out vec2 v_rgbSW,out vec2 v_rgbSE,out vec2 v_rgbM){vec2 inverseVP=1.0/resolution.xy;v_rgbNW=(fragCoord+vec2(-1.0,-1.0))*inverseVP;v_rgbNE=(fragCoord+vec2(1.0,-1.0))*inverseVP;v_rgbSW=(fragCoord+vec2(-1.0,1.0))*inverseVP;v_rgbSE=(fragCoord+vec2(1.0,1.0))*inverseVP;v_rgbM=vec2(fragCoord*inverseVP);}vec4 apply_1_2(sampler2D tex,vec2 fragCoord,vec2 resolution){mediump vec2 v_rgbNW;mediump vec2 v_rgbNE;mediump vec2 v_rgbSW;mediump vec2 v_rgbSE;mediump vec2 v_rgbM;texcoords_3_1(fragCoord,resolution,v_rgbNW,v_rgbNE,v_rgbSW,v_rgbSE,v_rgbM);return fxaa_2_0(tex,fragCoord,resolution,v_rgbNW,v_rgbNE,v_rgbSW,v_rgbSE,v_rgbM);}void main(void){vec2 fragCoord=vTextureCoord*canvasSize;gl_FragColor=apply_1_2(uSampler,fragCoord,canvasSize);}"
				}));
				return this.programSample
			}
		}, {
			key: "render",
			value: function(a) {
				var b = a.gl;
				a = a.texture;
				this.getOptions();
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				var c = this.getProgram(b);
				b.useProgram(c.program);
				var g = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, g);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.vertex), b.STATIC_DRAW);
				b.enableVertexAttribArray(c.attributes.aPos);
				b.vertexAttribPointer(c.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				g = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, g);
				b.bufferData(b.ARRAY_BUFFER,
					new Float32Array(this.sampleCoord), b.STATIC_DRAW);
				b.enableVertexAttribArray(c.attributes.aTextureCoord);
				b.vertexAttribPointer(c.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, a);
				b.uniform1i(c.uniforms.uSampler, 1);
				b.uniform2fv(c.uniforms.canvasSize, [b.canvas.width, b.canvas.height]);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.bindBuffer(b.ARRAY_BUFFER, null);
				b.useProgram(null)
			}
		}]);
		return b
	})(ze);
	(function(a) {
		function b(a) {
			Xa(this, b);
			return Zb(this,
				(b.__proto__ || Yb(b)).call(this, a))
		}
		$b(b, a);
		jb(b, [{
			key: "getProgram",
			value: function(a) {
				this.programSample || (this.programSample = new ye(a, {
						vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
						fragmentShader: "precision mediump float;uniform sampler2D uSampler;varying vec2 vTextureCoord;void main(){float fStep=1.0/512.0;vec4 sample11=texture2D(uSampler,vec2(vTextureCoord.s-1.0*fStep,vTextureCoord.t+1.0*fStep));vec4 sample12=texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t+1.0*fStep));vec4 sample13=texture2D(uSampler,vec2(vTextureCoord.s+1.0*fStep,vTextureCoord.t+1.0*fStep));vec4 sample21=texture2D(uSampler,vec2(vTextureCoord.s-1.0*fStep,vTextureCoord.t));vec4 sample22=texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));vec4 sample23=texture2D(uSampler,vec2(vTextureCoord.s+1.0*fStep,vTextureCoord.t));vec4 sample31=texture2D(uSampler,vec2(vTextureCoord.s-1.0*fStep,vTextureCoord.t-1.0*fStep));vec4 sample32=texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t-1.0*fStep));vec4 sample33=texture2D(uSampler,vec2(vTextureCoord.s+1.0*fStep,vTextureCoord.t-1.0*fStep));vec4 blurSample=(sample11+sample12+sample13+sample21+2.0*sample22+sample23+sample31+sample32+sample33)/10.0;gl_FragColor=blurSample;}"
					}),
					this.vertexBuffer = new Ol({
						gl: a,
						target: "ARRAY_BUFFER",
						usage: "STATIC_DRAW"
					}), this.sampleBuffer = new Ol({
						gl: a,
						target: "ARRAY_BUFFER",
						usage: "STATIC_DRAW"
					}), this.vertexBuffer.updateData(new Float32Array(this.vertex)), this.sampleBuffer.updateData(new Float32Array(
						this.sampleCoord)), this.vertexArray = new Cs({
						gl: a,
						program: this.programSample,
						attributes: [{
							stride: 12,
							name: "aPos",
							buffer: this.vertexBuffer,
							size: 3,
							type: "FLOAT",
							offset: 0
						}, {
							stride: 8,
							name: "aTextureCoord",
							buffer: this.sampleBuffer,
							size: 2,
							type: "FLOAT",
							offset: 0
						}]
					}));
				return this.programSample
			}
		}, {
			key: "render",
			value: function(a) {
				var b = a.gl;
				a = a.texture;
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				var c = this.getProgram(b);
				c.use(b);
				this.vertexArray.bind();
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, a);
				b.uniform1i(c.uniforms.uSampler, 1);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3)
			}
		}]);
		return b
	})(ze);
	(function(a) {
		function b(a) {
			Xa(this, b);
			return Zb(this, (b.__proto__ || Yb(b)).call(this, a))
		}
		$b(b, a);
		jb(b, [{
			key: "getProgram",
			value: function(a) {
				this.programBright ||
					(this.programBright = new ye(a, {
						vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
						fragmentShader: "precision mediump float;uniform sampler2D uSampler;uniform float threshold;varying vec2 vTextureCoord;void main(){vec4 color=texture2D(uSampler,vTextureCoord);vec4 lightColor=max(vec4(0.0),(color-(1.0-threshold)/5.0));float brightness=dot(color.rgb,vec3(0.2126,0.7152,0.0722));if(brightness>threshold){color=lightColor;}else{color=vec4(0.0);}gl_FragColor=color;}"
					}));
				this.programBloom || (this.programBloom = new ye(a, {
					vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
					fragmentShader: "precision mediump float;uniform sampler2D uSampler;uniform bool isVertical;uniform vec2 canvasSize;uniform float blurSize;uniform float devicePixelRatio;varying vec2 vTextureCoord;void main(){float weight[10];weight[0]=0.2270270270;weight[1]=0.1945945946;weight[2]=0.1216216216;weight[3]=0.1135135135;weight[4]=0.0972972973;weight[5]=0.0608108108;weight[6]=0.0540540541;weight[7]=0.0270270270;weight[8]=0.0162162162;weight[9]=0.0081081081;vec2 offset=vec2(blurSize/canvasSize.x,blurSize/canvasSize.y)*devicePixelRatio;vec4 result=texture2D(uSampler,vTextureCoord)*weight[0];if(isVertical){for(int i=1;i<10;++i){result+=texture2D(uSampler,vTextureCoord+vec2(0.0,offset.y*float(i)))*weight[i];result+=texture2D(uSampler,vTextureCoord-vec2(0.0,offset.y*float(i)))*weight[i];}}else{for(int i=1;i<10;++i){result+=texture2D(uSampler,vTextureCoord+vec2(offset.x*float(i),0.0))*weight[i];result+=texture2D(uSampler,vTextureCoord-vec2(offset.x*float(i),0.0))*weight[i];}}gl_FragColor=result;}"
				}));
				this.programResult || (this.programResult = new ye(a, {
					vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
					fragmentShader: "precision mediump float;uniform sampler2D originalTexture;uniform sampler2D bloomTexture;varying vec2 vTextureCoord;void main(){vec4 color=texture2D(originalTexture,vTextureCoord);vec4 bloomColor=texture2D(bloomTexture,vTextureCoord);color+=bloomColor;gl_FragColor=color;}"
				}));
				return {
					programBright: this.programBright,
					programBloom: this.programBloom,
					programResult: this.programResult
				}
			}
		}, {
			key: "onResize",
			value: function(a) {
				this.collectBrightBuffer = new $c(a);
				this.bloomBuffer = new $c(a)
			}
		}, {
			key: "getExtraFbo",
			value: function(a) {
				this.collectBrightBuffer || (this.collectBrightBuffer = new $c(a));
				this.bloomBuffer || (this.bloomBuffer = new $c(a));
				return {
					collectBrightBuffer: this.collectBrightBuffer.framebuffer,
					bloomBuffer: this.bloomBuffer.framebuffer
				}
			}
		}, {
			key: "render",
			value: function(a) {
				var b = a.gl,
					c = a.texture;
				a = a.fbo;
				var g = this.getOptions();
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				var k = this.getProgram(b),
					l = k.programBright,
					m = k.programBloom;
				k = k.programResult;
				var n = this.getExtraFbo(b),
					r = n.collectBrightBuffer;
				n = n.bloomBuffer;
				var p = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, p);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.vertex), b.STATIC_DRAW);
				b.enableVertexAttribArray(l.attributes.aPos);
				b.vertexAttribPointer(l.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(m.attributes.aPos);
				b.vertexAttribPointer(m.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(k.attributes.aPos);
				b.vertexAttribPointer(k.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				p = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, p);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.sampleCoord), b.STATIC_DRAW);
				b.enableVertexAttribArray(l.attributes.aTextureCoord);
				b.vertexAttribPointer(l.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(m.attributes.aTextureCoord);
				b.vertexAttribPointer(m.attributes.aTextureCoord,
					2, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(k.attributes.aTextureCoord);
				b.vertexAttribPointer(k.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.useProgram(l.program);
				b.bindFramebuffer(b.FRAMEBUFFER, r);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, c);
				b.uniform1i(l.uniforms.uSampler, 1);
				b.uniform1f(l.uniforms.threshold, g.threshold || 0);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.useProgram(m.program);
				b.bindFramebuffer(b.FRAMEBUFFER,
					n);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, r.texture);
				b.uniform1i(m.uniforms.uSampler, 1);
				b.uniform1i(m.uniforms.isVertical, !0);
				b.uniform1f(m.uniforms.blurSize, g.blurSize || 2);
				b.uniform1f(m.uniforms.devicePixelRatio, window.devicePixelRatio);
				b.uniform2fv(m.uniforms.canvasSize, [b.canvas.width, b.canvas.height]);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.useProgram(m.program);
				b.bindFramebuffer(b.FRAMEBUFFER, r);
				b.clearColor(0,
					0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, n.texture);
				b.uniform1i(m.uniforms.uSampler, 1);
				b.uniform1i(m.uniforms.isVertical, !1);
				b.uniform1f(m.uniforms.blurSize, g.blurSize || 2);
				b.uniform1f(m.uniforms.devicePixelRatio, window.devicePixelRatio);
				b.uniform2fv(m.uniforms.canvasSize, [b.canvas.width, b.canvas.height]);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.useProgram(k.program);
				b.bindFramebuffer(b.FRAMEBUFFER, a);
				b.clearColor(0, 0, 0,
					0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, c);
				b.uniform1i(k.uniforms.originalTexture, 1);
				b.activeTexture(b.TEXTURE0);
				b.bindTexture(b.TEXTURE_2D, r.texture);
				b.uniform1i(k.uniforms.bloomTexture, 0);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.bindBuffer(b.ARRAY_BUFFER, null);
				b.useProgram(null)
			}
		}]);
		return b
	})(ze);
	(function(a) {
		function b(a) {
			Xa(this, b);
			return Zb(this, (b.__proto__ || Yb(b)).call(this, a))
		}
		$b(b, a);
		jb(b, [{
			key: "getProgram",
			value: function(a) {
				this.programBright ||
					(this.programBright = new ye(a, {
						vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
						fragmentShader: "precision mediump float;uniform sampler2D uSampler;uniform float threshold;varying vec2 vTextureCoord;void main(){vec4 color=texture2D(uSampler,vTextureCoord);vec4 lightColor=max(vec4(0.0),(color-threshold));gl_FragColor=lightColor;}"
					}));
				this.programBloom || (this.programBloom = new ye(a, {
					vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
					fragmentShader: "precision mediump float;uniform sampler2D uSampler;uniform bool isVertical;uniform vec2 canvasSize;uniform float blurSize;uniform float devicePixelRatio;varying vec2 vTextureCoord;void main(){float weight[10];weight[0]=0.2270270270;weight[1]=0.1945945946;weight[2]=0.1216216216;weight[3]=0.1135135135;weight[4]=0.0972972973;weight[5]=0.0608108108;weight[6]=0.0540540541;weight[7]=0.0270270270;weight[8]=0.0162162162;weight[9]=0.0081081081;vec2 offset=vec2(blurSize/canvasSize.x,blurSize/canvasSize.y)*devicePixelRatio;vec4 result=texture2D(uSampler,vTextureCoord)*weight[0];if(isVertical){for(int i=1;i<10;++i){result+=texture2D(uSampler,vTextureCoord+vec2(0.0,offset.y*float(i)))*weight[i];result+=texture2D(uSampler,vTextureCoord-vec2(0.0,offset.y*float(i)))*weight[i];}}else{for(int i=1;i<10;++i){result+=texture2D(uSampler,vTextureCoord+vec2(offset.x*float(i),0.0))*weight[i];result+=texture2D(uSampler,vTextureCoord-vec2(offset.x*float(i),0.0))*weight[i];}}gl_FragColor=result;}"
				}));
				this.programResult || (this.programResult = new ye(a, {
					vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
					fragmentShader: "precision mediump float;uniform sampler2D originalTexture;uniform sampler2D bloomTexture;uniform float toneScale;varying vec2 vTextureCoord;void main(){vec4 color=texture2D(originalTexture,vTextureCoord)*toneScale;vec4 bloomColor=texture2D(bloomTexture,vTextureCoord);color+=bloomColor;gl_FragColor=color;}"
				}));
				return {
					programBright: this.programBright,
					programBloom: this.programBloom,
					programResult: this.programResult
				}
			}
		}, {
			key: "onResize",
			value: function(a) {
				this.collectBrightBuffer = new $c(a);
				this.bloomBuffer = new $c(a)
			}
		}, {
			key: "getExtraFbo",
			value: function(a) {
				this.collectBrightBuffer || (this.collectBrightBuffer = new $c(a));
				this.bloomBuffer || (this.bloomBuffer = new $c(a));
				return {
					collectBrightBuffer: this.collectBrightBuffer.framebuffer,
					bloomBuffer: this.bloomBuffer.framebuffer
				}
			}
		}, {
			key: "render",
			value: function(a) {
				var b = a.gl,
					c = a.texture;
				a = a.fbo;
				var g = this.getOptions(),
					k = "clarity" in g ? g.clarity : 1;
				k = Math.max(0, k);
				k = Math.min(1, k);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				var l = this.getProgram(b),
					m = l.programBright,
					n = l.programBloom;
				l = l.programResult;
				var r = this.getExtraFbo(b),
					p = r.collectBrightBuffer;
				r = r.bloomBuffer;
				var q = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, q);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.vertex), b.STATIC_DRAW);
				b.enableVertexAttribArray(m.attributes.aPos);
				b.vertexAttribPointer(m.attributes.aPos,
					3, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(n.attributes.aPos);
				b.vertexAttribPointer(n.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(l.attributes.aPos);
				b.vertexAttribPointer(l.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				q = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, q);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.sampleCoord), b.STATIC_DRAW);
				b.enableVertexAttribArray(m.attributes.aTextureCoord);
				b.vertexAttribPointer(m.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(n.attributes.aTextureCoord);
				b.vertexAttribPointer(n.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.enableVertexAttribArray(l.attributes.aTextureCoord);
				b.vertexAttribPointer(l.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.useProgram(m.program);
				b.bindFramebuffer(b.FRAMEBUFFER, p);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, c);
				b.uniform1i(m.uniforms.uSampler, 1);
				b.uniform1f(m.uniforms.threshold, g.threshold || 0);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length /
					3);
				b.useProgram(n.program);
				b.bindFramebuffer(b.FRAMEBUFFER, r);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, p.texture);
				b.uniform1i(n.uniforms.uSampler, 1);
				b.uniform1i(n.uniforms.isVertical, !0);
				b.uniform1f(n.uniforms.blurSize, g.blurSize || 2);
				b.uniform1f(n.uniforms.devicePixelRatio, window.devicePixelRatio);
				b.uniform2fv(n.uniforms.canvasSize, [b.canvas.width, b.canvas.height]);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.useProgram(n.program);
				b.bindFramebuffer(b.FRAMEBUFFER, p);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, r.texture);
				b.uniform1i(n.uniforms.uSampler, 1);
				b.uniform1i(n.uniforms.isVertical, !1);
				b.uniform1f(n.uniforms.blurSize, g.blurSize || 2);
				b.uniform1f(n.uniforms.devicePixelRatio, window.devicePixelRatio);
				b.uniform2fv(n.uniforms.canvasSize, [b.canvas.width, b.canvas.height]);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.useProgram(l.program);
				b.bindFramebuffer(b.FRAMEBUFFER,
					a);
				b.clearColor(0, 0, 0, 0);
				b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, c);
				b.uniform1i(l.uniforms.originalTexture, 1);
				b.uniform1f(l.uniforms.toneScale, k);
				b.activeTexture(b.TEXTURE0);
				b.bindTexture(b.TEXTURE_2D, p.texture);
				b.uniform1i(l.uniforms.bloomTexture, 0);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3);
				b.bindBuffer(b.ARRAY_BUFFER, null);
				b.useProgram(null)
			}
		}]);
		return b
	})(ze);
	(function(a) {
		function b(a) {
			Xa(this, b);
			return Zb(this, (b.__proto__ ||
				Yb(b)).call(this, a))
		}
		$b(b, a);
		jb(b, [{
			key: "getProgram",
			value: function(a) {
				this.programSample || (this.programSample = new ye(a, {
					vertexShader: "attribute vec3 aPos;attribute vec2 aTextureCoord;varying vec2 vTextureCoord;void main(){vTextureCoord=aTextureCoord;gl_Position=vec4(aPos,1.0);}",
					fragmentShader: "precision mediump float;uniform sampler2D uSampler;uniform vec2 canvasSize;varying vec2 vTextureCoord;void main(){float fStep=1.0/312.0;vec4 sample11=texture2D(uSampler,vec2(vTextureCoord.s-1.0*fStep,vTextureCoord.t+1.0*fStep));vec4 sample12=texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t+1.0*fStep));vec4 sample13=texture2D(uSampler,vec2(vTextureCoord.s+1.0*fStep,vTextureCoord.t+1.0*fStep));vec4 sample21=texture2D(uSampler,vec2(vTextureCoord.s-1.0*fStep,vTextureCoord.t));vec4 sample22=texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));vec4 sample23=texture2D(uSampler,vec2(vTextureCoord.s+1.0*fStep,vTextureCoord.t));vec4 sample31=texture2D(uSampler,vec2(vTextureCoord.s-1.0*fStep,vTextureCoord.t-1.0*fStep));vec4 sample32=texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t-1.0*fStep));vec4 sample33=texture2D(uSampler,vec2(vTextureCoord.s+1.0*fStep,vTextureCoord.t-1.0*fStep));vec4 blurSample=(sample11+sample12+sample13+sample21+2.0*sample22+sample23+sample31+sample32+sample33)/10.0;float desX=abs((gl_FragCoord.x-canvasSize.x/2.0)/(canvasSize.x/2.0));float desY=abs((gl_FragCoord.y-canvasSize.y/2.0)/(canvasSize.y/2.0));float factor=max(desX,desY);gl_FragColor=(sample22*(1.0-factor)+blurSample*factor);}"
				}));
				return this.programSample
			}
		}, {
			key: "render",
			value: function(a) {
				var b = a.gl;
				a = a.texture;
				var c = this.getProgram(b);
				b.useProgram(c.program);
				var g = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, g);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.vertex), b.STATIC_DRAW);
				b.enableVertexAttribArray(c.attributes.aPos);
				b.vertexAttribPointer(c.attributes.aPos, 3, b.FLOAT, !1, 0, 0);
				g = b.createBuffer();
				b.bindBuffer(b.ARRAY_BUFFER, g);
				b.bufferData(b.ARRAY_BUFFER, new Float32Array(this.sampleCoord), b.STATIC_DRAW);
				b.enableVertexAttribArray(c.attributes.aTextureCoord);
				b.vertexAttribPointer(c.attributes.aTextureCoord, 2, b.FLOAT, !1, 0, 0);
				b.activeTexture(b.TEXTURE1);
				b.bindTexture(b.TEXTURE_2D, a);
				b.uniform1i(c.uniforms.uSampler, 1);
				b.uniform2fv(c.uniforms.canvasSize, [b.canvas.width, b.canvas.height]);
				b.drawArrays(b.TRIANGLES, 0, this.vertex.length / 3)
			}
		}]);
		return b
	})(ze);
	(function() {
		function a(b) {
			Xa(this, a);
			this.gl = b;
			this.effects = [];
			this.initFbo()
		}
		jb(a, [{
			key: "addEffect",
			value: function(a) {
				this.effects.push(a)
			}
		}, {
			key: "removeEffect",
			value: function(a) {}
		}, {
			key: "setEffects",
			value: function(a) {
				this.effects =
					a
			}
		}, {
			key: "onResize",
			value: function() {
				this.initFbo();
				var a = this.gl,
					c = this.effects;
				if (c && 1 < c.length)
					for (var d = 1; d < c.length; d++) {
						var e = c[d];
						e.onResize && e.onResize(a)
					}
			}
		}, {
			key: "initFbo",
			value: function() {
				var a = this.gl;
				this.fbo = [new $c(a), new $c(a)]
			}
		}, {
			key: "destroy",
			value: function() {
				this.effects = [];
				this.fbo = [];
				this.gl = null
			}
		}, {
			key: "render",
			value: function() {
				var a = this.gl,
					c = this.effects;
				if (c && 0 < c.length)
					for (var d = {}, e = 0; e < c.length; e++) {
						var g = this.fbo[e % 2].framebuffer;
						e === c.length - 1 && (g = null);
						a.bindFramebuffer(a.FRAMEBUFFER,
							g);
						var k = [0, 0, 0, 0];
						a.clearColor(k[0], k[1], k[2], k[3]);
						a.clear(a.COLOR_BUFFER_BIT | a.DEPTH_BUFFER_BIT);
						c[e].render({
							isPickRender: !1,
							gl: a,
							texture: d.texture,
							fbo: g
						});
						d = g
					}
			}
		}]);
		return a
	})();
	var Go = function(a) {
			function b(a) {
				Xa(this, b);
				a = Zb(this, (b.__proto__ || Yb(b)).call(this, a));
				a.layerType = "ThreeLayer";
				return a
			}
			$b(b, a);
			jb(b, [{
				key: "initialize",
				value: function(a) {
					this.getOptions();
					var b = this.webglLayer.map.map;
					"three" === this.webglLayer.map.type ? (this.camera = b.camera, this.scene = b.scene) : (this.camera = new da
						.Camera,
						this.scene = new da.Scene);
					this.world = new da.Group;
					this.scene.add(this.world);
					"three" !== this.webglLayer.map.type && (this.camera.matrixAutoUpdate = !1, this.world.matrixAutoUpdate = !1,
						this.renderer = new da.WebGLRenderer({
							alpha: !0,
							antialias: !0,
							canvas: a.canvas,
							context: a
						}), this.renderer.autoClear = !1)
				}
			}, {
				key: "add",
				value: function(a, b) {
					var c = this.getOptions();
					this.scene.add(a);
					var d = [0, 0];
					!0 === c.enabledPointOffset && (d = this.getPointOffset());
					b ? (c = new da.Group, c.isGeoGroup = !0, c.object = a, c.point = b, c.add(a), c.position.x =
						b.lng - d[0], c.position.y = b.lat - d[1], c.position.z = a.position.z, this.world.add(c)) : this.world.add(
						a);
					this.update()
				}
			}, {
				key: "update",
				value: function() {
					this.webglLayer.render()
				}
			}, {
				key: "getCamera",
				value: function() {
					return this.camera
				}
			}, {
				key: "getScene",
				value: function() {
					return this.scene
				}
			}, {
				key: "getRenderer",
				value: function() {
					return this.renderer
				}
			}, {
				key: "getWorld",
				value: function() {
					return this.world
				}
			}, {
				key: "updatePoint",
				value: function(a, b) {
					for (var c = this.world.children, d = 0; d < c.length; d++)
						if (c[d].isGeoGroup && c[d].object ===
							a) {
							var k = c[d];
							k.position.x = b.lng;
							k.position.y = b.lat;
							k.position.z = a.position.z
						}
				}
			}, {
				key: "remove",
				value: function(a) {
					this.world.remove(a);
					for (var b = this.world.children, c = 0; c < b.length; c++) b[c].children && 0 < b[c].children.length && b[c]
						.children[0] === a && this.world.remove(b[c]);
					this.update()
				}
			}, {
				key: "updateCamera",
				value: function() {
					var a = this.world,
						b = this.map.getZoomUnits();
					a = a.children;
					for (var e = 0; e < a.length; e++) a[e].point && a[e].scale.set(b, b, b)
				}
			}, {
				key: "render",
				value: function(a) {
					var b = this.getOptions();
					if (a) {
						if (!this.webglLayer.map.map.camera) {
							//this.updateCamera();
							var c = this.getPointOffset(),
								g = (new da.Matrix4).fromArray(a.viewMatrix);
							this.camera.projectionMatrix = (new da.Matrix4).fromArray(a.projectionMatrix);
							!0 === b.enabledPointOffset ? this.world.matrix = g : (a = (new da.Matrix4).makeTranslation(-c[0], -c[1], 0),
								this.world.matrix = g.multiply(a));
							this.renderer.state.reset();
							this.postProcessing ? this.postProcessing.render() : this.renderer.render(this.scene, this.camera)
						}
					} else this.update()
				}
			}]);
			return b
		}(function(a) {
			function b(a) {
				Xa(this, b);
				a = Zb(this, (b.__proto__ || Yb(b)).call(this,
					a));
				a.pickedColor = [-1, -1, -1];
				return a
			}
			$b(b, a);
			jb(b, [{
				key: "getCommonDefaultOptions",
				value: function() {
					return {
						zIndex: 0,
						repeat: !1,
						enablePicked: !1,
						autoSelect: !1,
						selectedIndex: -1,
						selectedColor: "rgba(20, 20, 200, 1.0)"
					}
				}
			}, {
				key: "commonInitialize",
				value: function(a) {
					var b = this.getOptions();
					this.gl = a;
					b.enablePicked && (this.pickBuffer = new Ol({
						gl: a,
						target: "ARRAY_BUFFER",
						usage: "STATIC_DRAW"
					}))
				}
			}, {
				key: "getCommonAttributes",
				value: function() {
					var a = [];
					this.getOptions().enablePicked && a.push({
						name: "aPickColor",
						buffer: this.pickBuffer,
						size: 3,
						type: "FLOAT",
						stride: 12,
						offset: 0
					});
					return a
				}
			}, {
				key: "normizedColor",
				value: function(a) {
					var b = a;
					a instanceof Array || (b = mb(a).unitArray());
					void 0 === b[3] && (b[3] = 1);
					return b
				}
			}, {
				key: "normizedPoint",
				value: function(a) {
					if (!a || !a[0] || !a[1]) return [0, 0, 0];
					var b = this.getPointOffset(),
						c = Number(a[0]),
						g = Number(a[1]); - 180 <= c && 180 >= c && -90 <= g && 90 >= g && (g = this.webglLayer.map.lnglatToMercator(
						c, g), c = g[0], g = g[1]);
					var k = Number(a[2]) || 0;
					this.webglLayer && "cesium" === this.webglLayer.options.mapType && window.Cesium ? (c = this.convertLngLat([
							c,
							g
						]), k = window.Cesium.Cartesian3.fromDegrees(c[0], c[1], k), c = k.x, g = k.y, k = k.z) : this.webglLayer &&
						"bmapgl" === this.webglLayer.options.mapType && "B_EARTH_MAP" === this.webglLayer.map.map.mapType && (c =
							this.convertLngLat([c, g]), k = this.webglLayer.map.map.getEarth().scene.fromLatLngToXYZ({
								lng: c[0],
								lat: c[1]
							}), c = k.x, g = k.y, k = k.z);
					return 3 < a.length ? [c - b[0], g - b[1], k].concat(Eo(a.slice(3))) : [c - b[0], g - b[1], k]
				}
			}, {
				key: "convertLngLat",
				value: function(a) {
					return [a[0] / 2.003750834E7 * 180, 180 / Math.PI * (2 * Math.atan(Math.exp(a[1] / 2.003750834E7 *
						180 * Math.PI / 180)) - Math.PI / 2)]
				}
			}, {
				key: "getPointOffset",
				value: function() {
					var a = [0, 0],
						b = this.getOptions();
					this.webglLayer && this.webglLayer.options.pointOffset ? a = this.webglLayer.options.pointOffset : b.pointOffset &&
						(a = b.pointOffset);
					return a
				}
			}, {
				key: "indexToRgb",
				value: function(a) {
					a++;
					var b = Math.floor(a / 65536);
					a -= 65536 * b;
					var c = Math.floor(a / 256);
					return [a - 256 * c, c, b]
				}
			}, {
				key: "rgbToIndex",
				value: function(a) {
					return a[0] + 256 * a[1] + 65536 * a[2] - 1
				}
			}, {
				key: "getCommonUniforms",
				value: function(a) {
					a = a.isPickRender;
					var b = this.getOptions(),
						c = {};
					if (b.enablePicked) {
						var g = 0 <= b.selectedIndex ? b.selectedIndex : -1;
						g = b.autoSelect ? this.pickedColor : this.indexToRgb(g);
						c = q(c, {
							uSelectedColor: this.normizedColor(b.selectedColor),
							uEnablePicked: b.enablePicked,
							uPickedColor: g.map(function(a) {
								return a / 255
							}),
							uIsPickRender: !!a
						})
					}
					return c
				}
			}, {
				key: "pick",
				value: function(a, b) {
					var c = this.gl;
					this.webglLayer.saveFramebuffer();
					this.webglLayer.bindFramebuffer(this.webglLayer.pickFBO);
					this.webglLayer.clear();
					this.render({
						gl: c,
						isPickRender: !0,
						matrix: this.webglLayer.matrix,
						projectionMatrix: this.webglLayer.projectionMatrix,
						viewMatrix: this.webglLayer.viewMatrix,
						orthoMatrix: this.webglLayer.orthoMatrix
					});
					var d = new Uint8Array(4);
					c.readPixels(a * window.devicePixelRatio, c.canvas.height - b * window.devicePixelRatio, 1, 1, c.RGBA, c.UNSIGNED_BYTE,
						d);
					a = this.rgbToIndex(d);
					b = this.getData();
					this.pickedColor = [d[0], d[1], d[2]];
					this.webglLayer.restoreFramebuffer();
					return {
						dataIndex: a,
						dataItem: b[a]
					}
				}
			}, {
				key: "setGLState",
				value: function(a) {
					this.webglLayer.stateManager.setState(a)
				}
			}, {
				key: "addMultipleCoords",
				value: function(a, b, e) {
					if (!this.options.repeat || !this.webglLayer || "bmapgl" !== this.webglLayer.options.mapType ||
						"B_EARTH_MAP" === this.webglLayer.map.map.mapType) return [a];
					var c = this.webglLayer.map.map;
					b = b || c.getZoom();
					var d = e ? c.worldSize(b) : 4.007545274461451E7;
					b = function(a) {
						return [
							[a[0] - d, a[1], a[2] || 0],
							[a[0] + d, a[1], a[2] || 0]
						]
					};
					if (a instanceof Array && !(a[0] instanceof Array)) return b = b(a), b = Nl(b, 2), [a, b[0], b[1]];
					if (a instanceof Array && a[0] instanceof Array && !(a[0][0] instanceof Array)) {
						e = [];
						c = [];
						for (var l =
								0; l < a.length; l++) {
							var m = b(a[l]);
							m = Nl(m, 2);
							var n = m[1];
							e.push(m[0]);
							c.push(n)
						}
						return [a, e, c]
					}
					e = [];
					c = [];
					for (l = 0; l < a.length; l++) {
						m = [];
						n = [];
						for (var r = 0; r < a[l].length; r++) {
							var p = b(a[l][r]);
							p = Nl(p, 2);
							var q = p[1];
							m.push(p[0]);
							n.push(q)
						}
						e.push(m);
						c.push(n)
					}
					return [a, e, c]
				}
			}]);
			return b
		}(Fo)),
		Pl = function(a) {
			function b(a) {
				Xa(this, b);
				var c = Zb(this, (b.__proto__ || Yb(b)).call(this, a));
				c.layerType = "threeLayer";
				c.setOptions(a);
				return c
			}
			$b(b, a);
			jb(b, [{
				key: "setWebglLayer",
				value: function(a) {
					a.threeLayer || (a.threeLayer = new Go({
						enabledPointOffset: !0,
						webglLayer: a
					}));
					this.threeLayer = a.threeLayer
				}
			}, {
				key: "getPointOffset",
				value: function() {
					return this.threeLayer.getPointOffset()
				}
			}, {
				key: "getThreeLayer",
				value: function() {
					return this.threeLayer
				}
			}]);
			return b
		}(Fo);
	void 0 === Na && (Number.EPSILON = Math.pow(2, -52));
	void 0 === Dk && (Number.isInteger = function(a) {
		return "number" === typeof a && isFinite(a) && Math.floor(a) === a
	});
	void 0 === Lg && (Math.sign = function(a) {
		return 0 > a ? -1 : 0 < a ? 1 : +a
	});
	!1 === "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
		get: function() {
			return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
		}
	});
	void 0 === q && (Object.assign = function(a) {
		if (void 0 === a || null === a) throw new TypeError("Cannot convert undefined or null to object");
		for (var b = Object(a), c = 1; c < arguments.length; c++) {
			var d = arguments[c];
			if (void 0 !== d && null !== d)
				for (var e in d) Object.prototype.hasOwnProperty.call(d, e) && (b[e] = d[e])
		}
		return b
	});
	q(nb.prototype, {
		addEventListener: function(a, b) {
			void 0 === this._listeners && (this._listeners = {});
			var c = this._listeners;
			void 0 === c[a] && (c[a] = []); - 1 === c[a].indexOf(b) && c[a].push(b)
		},
		hasEventListener: function(a,
			b) {
			if (void 0 === this._listeners) return !1;
			var c = this._listeners;
			return void 0 !== c[a] && -1 !== c[a].indexOf(b)
		},
		removeEventListener: function(a, b) {
			void 0 !== this._listeners && (a = this._listeners[a], void 0 !== a && (b = a.indexOf(b), -1 !== b && a.splice(b,
				1)))
		},
		dispatchEvent: function(a) {
			if (void 0 !== this._listeners) {
				var b = this._listeners[a.type];
				if (void 0 !== b) {
					a.target = this;
					b = b.slice(0);
					for (var c = 0, d = b.length; c < d; c++) b[c].call(this, a)
				}
			}
		}
	});
	for (var Ga = [], ph = 0; 256 > ph; ph++) Ga[ph] = (16 > ph ? "0" : "") + ph.toString(16);
	var ha = {
		DEG2RAD: Math.PI /
			180,
		RAD2DEG: 180 / Math.PI,
		generateUUID: function() {
			var a = 4294967295 * Math.random() | 0,
				b = 4294967295 * Math.random() | 0,
				c = 4294967295 * Math.random() | 0,
				d = 4294967295 * Math.random() | 0;
			return (Ga[a & 255] + Ga[a >> 8 & 255] + Ga[a >> 16 & 255] + Ga[a >> 24 & 255] + "-" + Ga[b & 255] + Ga[b >> 8 &
				255] + "-" + Ga[b >> 16 & 15 | 64] + Ga[b >> 24 & 255] + "-" + Ga[c & 63 | 128] + Ga[c >> 8 & 255] + "-" + Ga[
				c >> 16 & 255] + Ga[c >> 24 & 255] + Ga[d & 255] + Ga[d >> 8 & 255] + Ga[d >> 16 & 255] + Ga[d >> 24 & 255]).toUpperCase()
		},
		clamp: function(a, b, c) {
			return Math.max(b, Math.min(c, a))
		},
		euclideanModulo: function(a, b) {
			return (a %
				b + b) % b
		},
		mapLinear: function(a, b, c, d, e) {
			return d + (a - b) * (e - d) / (c - b)
		},
		lerp: function(a, b, c) {
			return (1 - c) * a + c * b
		},
		smoothstep: function(a, b, c) {
			if (a <= b) return 0;
			if (a >= c) return 1;
			a = (a - b) / (c - b);
			return a * a * (3 - 2 * a)
		},
		smootherstep: function(a, b, c) {
			if (a <= b) return 0;
			if (a >= c) return 1;
			a = (a - b) / (c - b);
			return a * a * a * (a * (6 * a - 15) + 10)
		},
		randInt: function(a, b) {
			return a + Math.floor(Math.random() * (b - a + 1))
		},
		randFloat: function(a, b) {
			return a + Math.random() * (b - a)
		},
		randFloatSpread: function(a) {
			return a * (.5 - Math.random())
		},
		degToRad: function(a) {
			return a *
				ha.DEG2RAD
		},
		radToDeg: function(a) {
			return a * ha.RAD2DEG
		},
		isPowerOfTwo: function(a) {
			return 0 === (a & a - 1) && 0 !== a
		},
		ceilPowerOfTwo: function(a) {
			return Math.pow(2, Math.ceil(Math.log(a) / Math.LN2))
		},
		floorPowerOfTwo: function(a) {
			return Math.pow(2, Math.floor(Math.log(a) / Math.LN2))
		}
	};
	ja(B.prototype, {
		width: {
			get: function() {
				return this.x
			},
			set: function(a) {
				this.x = a
			}
		},
		height: {
			get: function() {
				return this.y
			},
			set: function(a) {
				this.y = a
			}
		}
	});
	q(B.prototype, {
		isVector2: !0,
		set: function(a, b) {
			this.x = a;
			this.y = b;
			return this
		},
		setScalar: function(a) {
			this.y =
				this.x = a;
			return this
		},
		setX: function(a) {
			this.x = a;
			return this
		},
		setY: function(a) {
			this.y = a;
			return this
		},
		setComponent: function(a, b) {
			switch (a) {
				case 0:
					this.x = b;
					break;
				case 1:
					this.y = b;
					break;
				default:
					throw Error("index is out of range: " + a);
			}
			return this
		},
		getComponent: function(a) {
			switch (a) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				default:
					throw Error("index is out of range: " + a);
			}
		},
		clone: function() {
			return new this.constructor(this.x, this.y)
		},
		copy: function(a) {
			this.x = a.x;
			this.y = a.y;
			return this
		},
		add: function(a,
			b) {
			if (void 0 !== b) return console.warn(
				"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a,
				b);
			this.x += a.x;
			this.y += a.y;
			return this
		},
		addScalar: function(a) {
			this.x += a;
			this.y += a;
			return this
		},
		addVectors: function(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			return this
		},
		addScaledVector: function(a, b) {
			this.x += a.x * b;
			this.y += a.y * b;
			return this
		},
		sub: function(a, b) {
			if (void 0 !== b) return console.warn(
					"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
				this.subVectors(a, b);
			this.x -= a.x;
			this.y -= a.y;
			return this
		},
		subScalar: function(a) {
			this.x -= a;
			this.y -= a;
			return this
		},
		subVectors: function(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			return this
		},
		multiply: function(a) {
			this.x *= a.x;
			this.y *= a.y;
			return this
		},
		multiplyScalar: function(a) {
			this.x *= a;
			this.y *= a;
			return this
		},
		divide: function(a) {
			this.x /= a.x;
			this.y /= a.y;
			return this
		},
		divideScalar: function(a) {
			return this.multiplyScalar(1 / a)
		},
		applyMatrix3: function(a) {
			var b = this.x,
				c = this.y;
			a = a.elements;
			this.x = a[0] * b + a[3] * c + a[6];
			this.y =
				a[1] * b + a[4] * c + a[7];
			return this
		},
		min: function(a) {
			this.x = Math.min(this.x, a.x);
			this.y = Math.min(this.y, a.y);
			return this
		},
		max: function(a) {
			this.x = Math.max(this.x, a.x);
			this.y = Math.max(this.y, a.y);
			return this
		},
		clamp: function(a, b) {
			this.x = Math.max(a.x, Math.min(b.x, this.x));
			this.y = Math.max(a.y, Math.min(b.y, this.y));
			return this
		},
		clampScalar: function(a, b) {
			this.x = Math.max(a, Math.min(b, this.x));
			this.y = Math.max(a, Math.min(b, this.y));
			return this
		},
		clampLength: function(a, b) {
			var c = this.length();
			return this.divideScalar(c ||
				1).multiplyScalar(Math.max(a, Math.min(b, c)))
		},
		floor: function() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			return this
		},
		ceil: function() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			return this
		},
		round: function() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			return this
		},
		roundToZero: function() {
			this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
			return this
		},
		negate: function() {
			this.x = -this.x;
			this.y = -this.y;
			return this
		},
		dot: function(a) {
			return this.x *
				a.x + this.y * a.y
		},
		cross: function(a) {
			return this.x * a.y - this.y * a.x
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y)
		},
		manhattanLength: function() {
			return Math.abs(this.x) + Math.abs(this.y)
		},
		normalize: function() {
			return this.divideScalar(this.length() || 1)
		},
		angle: function() {
			var a = Math.atan2(this.y, this.x);
			0 > a && (a += 2 * Math.PI);
			return a
		},
		distanceTo: function(a) {
			return Math.sqrt(this.distanceToSquared(a))
		},
		distanceToSquared: function(a) {
			var b =
				this.x - a.x;
			a = this.y - a.y;
			return b * b + a * a
		},
		manhattanDistanceTo: function(a) {
			return Math.abs(this.x - a.x) + Math.abs(this.y - a.y)
		},
		setLength: function(a) {
			return this.normalize().multiplyScalar(a)
		},
		lerp: function(a, b) {
			this.x += (a.x - this.x) * b;
			this.y += (a.y - this.y) * b;
			return this
		},
		lerpVectors: function(a, b, c) {
			return this.subVectors(b, a).multiplyScalar(c).add(a)
		},
		equals: function(a) {
			return a.x === this.x && a.y === this.y
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			this.x = a[b];
			this.y = a[b + 1];
			return this
		},
		toArray: function(a,
			b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			a[b] = this.x;
			a[b + 1] = this.y;
			return a
		},
		fromBufferAttribute: function(a, b, c) {
			void 0 !== c && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
			this.x = a.getX(b);
			this.y = a.getY(b);
			return this
		},
		rotateAround: function(a, b) {
			var c = Math.cos(b);
			b = Math.sin(b);
			var d = this.x - a.x,
				e = this.y - a.y;
			this.x = d * c - e * b + a.x;
			this.y = d * b + e * c + a.y;
			return this
		}
	});
	q(vb, {
		slerp: function(a, b, c, d) {
			return c.copy(a).slerp(b, d)
		},
		slerpFlat: function(a, b, c, d, e, g, k) {
			var l = c[d + 0],
				m = c[d + 1],
				n = c[d + 2];
			c = c[d + 3];
			d = e[g + 0];
			var r = e[g + 1],
				p = e[g + 2];
			e = e[g + 3];
			if (c !== e || l !== d || m !== r || n !== p) {
				g = 1 - k;
				var q = l * d + m * r + n * p + c * e,
					u = 0 <= q ? 1 : -1,
					z = 1 - q * q;
				z > Na && (z = Math.sqrt(z), q = Math.atan2(z, q * u), g = Math.sin(g * q) / z, k = Math.sin(k * q) / z);
				u *= k;
				l = l * g + d * u;
				m = m * g + r * u;
				n = n * g + p * u;
				c = c * g + e * u;
				g === 1 - k && (k = 1 / Math.sqrt(l * l + m * m + n * n + c * c), l *= k, m *= k, n *= k, c *= k)
			}
			a[b] = l;
			a[b + 1] = m;
			a[b + 2] = n;
			a[b + 3] = c
		}
	});
	ja(vb.prototype, {
		x: {
			get: function() {
				return this._x
			},
			set: function(a) {
				this._x = a;
				this._onChangeCallback()
			}
		},
		y: {
			get: function() {
				return this._y
			},
			set: function(a) {
				this._y = a;
				this._onChangeCallback()
			}
		},
		z: {
			get: function() {
				return this._z
			},
			set: function(a) {
				this._z = a;
				this._onChangeCallback()
			}
		},
		w: {
			get: function() {
				return this._w
			},
			set: function(a) {
				this._w = a;
				this._onChangeCallback()
			}
		}
	});
	q(vb.prototype, {
		isQuaternion: !0,
		set: function(a, b, c, d) {
			this._x = a;
			this._y = b;
			this._z = c;
			this._w = d;
			this._onChangeCallback();
			return this
		},
		clone: function() {
			return new this.constructor(this._x, this._y, this._z, this._w)
		},
		copy: function(a) {
			this._x = a.x;
			this._y = a.y;
			this._z = a.z;
			this._w =
				a.w;
			this._onChangeCallback();
			return this
		},
		setFromEuler: function(a, b) {
			if (!a || !a.isEuler) throw Error(
				"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
			var c = a._x,
				d = a._y,
				e = a._z;
			a = a.order;
			var g = Math.cos,
				k = Math.sin,
				l = g(c / 2),
				m = g(d / 2);
			g = g(e / 2);
			c = k(c / 2);
			d = k(d / 2);
			e = k(e / 2);
			"XYZ" === a ? (this._x = c * m * g + l * d * e, this._y = l * d * g - c * m * e, this._z = l * m * e + c * d * g,
					this._w = l * m * g - c * d * e) : "YXZ" === a ? (this._x = c * m * g + l * d * e, this._y = l * d * g - c * m *
					e, this._z = l * m * e - c * d * g, this._w = l * m * g + c * d * e) : "ZXY" ===
				a ? (this._x = c * m * g - l * d * e, this._y = l * d * g + c * m * e, this._z = l * m * e + c * d * g, this._w =
					l * m * g - c * d * e) : "ZYX" === a ? (this._x = c * m * g - l * d * e, this._y = l * d * g + c * m * e, this
					._z = l * m * e - c * d * g, this._w = l * m * g + c * d * e) : "YZX" === a ? (this._x = c * m * g + l * d * e,
					this._y = l * d * g + c * m * e, this._z = l * m * e - c * d * g, this._w = l * m * g - c * d * e) : "XZY" ===
				a && (this._x = c * m * g - l * d * e, this._y = l * d * g - c * m * e, this._z = l * m * e + c * d * g, this._w =
					l * m * g + c * d * e);
			!1 !== b && this._onChangeCallback();
			return this
		},
		setFromAxisAngle: function(a, b) {
			b /= 2;
			var c = Math.sin(b);
			this._x = a.x * c;
			this._y = a.y * c;
			this._z = a.z *
				c;
			this._w = Math.cos(b);
			this._onChangeCallback();
			return this
		},
		setFromRotationMatrix: function(a) {
			var b = a.elements,
				c = b[0];
			a = b[4];
			var d = b[8],
				e = b[1],
				g = b[5],
				k = b[9],
				l = b[2],
				m = b[6];
			b = b[10];
			var n = c + g + b;
			0 < n ? (c = .5 / Math.sqrt(n + 1), this._w = .25 / c, this._x = (m - k) * c, this._y = (d - l) * c, this._z = (
				e - a) * c) : c > g && c > b ? (c = 2 * Math.sqrt(1 + c - g - b), this._w = (m - k) / c, this._x = .25 * c,
				this._y = (a + e) / c, this._z = (d + l) / c) : g > b ? (c = 2 * Math.sqrt(1 + g - c - b), this._w = (d - l) /
				c, this._x = (a + e) / c, this._y = .25 * c, this._z = (k + m) / c) : (c = 2 * Math.sqrt(1 + b - c - g), this._w =
				(e -
					a) / c, this._x = (d + l) / c, this._y = (k + m) / c, this._z = .25 * c);
			this._onChangeCallback();
			return this
		},
		setFromUnitVectors: function(a, b) {
			var c = a.dot(b) + 1;
			1E-6 > c ? (c = 0, Math.abs(a.x) > Math.abs(a.z) ? (this._x = -a.y, this._y = a.x, this._z = 0) : (this._x = 0,
				this._y = -a.z, this._z = a.y)) : (this._x = a.y * b.z - a.z * b.y, this._y = a.z * b.x - a.x * b.z, this._z =
				a.x * b.y - a.y * b.x);
			this._w = c;
			return this.normalize()
		},
		angleTo: function(a) {
			return 2 * Math.acos(Math.abs(ha.clamp(this.dot(a), -1, 1)))
		},
		rotateTowards: function(a, b) {
			var c = this.angleTo(a);
			if (0 === c) return this;
			this.slerp(a, Math.min(1, b / c));
			return this
		},
		inverse: function() {
			return this.conjugate()
		},
		conjugate: function() {
			this._x *= -1;
			this._y *= -1;
			this._z *= -1;
			this._onChangeCallback();
			return this
		},
		dot: function(a) {
			return this._x * a._x + this._y * a._y + this._z * a._z + this._w * a._w
		},
		lengthSq: function() {
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
		},
		length: function() {
			return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
		},
		normalize: function() {
			var a = this.length();
			0 === a ? (this._z =
				this._y = this._x = 0, this._w = 1) : (a = 1 / a, this._x *= a, this._y *= a, this._z *= a, this._w *= a);
			this._onChangeCallback();
			return this
		},
		multiply: function(a, b) {
			return void 0 !== b ? (console.warn(
					"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
				this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
		},
		premultiply: function(a) {
			return this.multiplyQuaternions(a, this)
		},
		multiplyQuaternions: function(a, b) {
			var c = a._x,
				d = a._y,
				e = a._z;
			a = a._w;
			var g = b._x,
				k = b._y,
				l = b._z;
			b = b._w;
			this._x = c * b + a * g + d * l - e * k;
			this._y = d * b + a * k + e * g - c * l;
			this._z = e * b + a * l + c * k - d * g;
			this._w = a * b - c * g - d * k - e * l;
			this._onChangeCallback();
			return this
		},
		slerp: function(a, b) {
			if (0 === b) return this;
			if (1 === b) return this.copy(a);
			var c = this._x,
				d = this._y,
				e = this._z,
				g = this._w,
				k = g * a._w + c * a._x + d * a._y + e * a._z;
			0 > k ? (this._w = -a._w, this._x = -a._x, this._y = -a._y, this._z = -a._z, k = -k) : this.copy(a);
			if (1 <= k) return this._w = g, this._x = c, this._y = d, this._z = e, this;
			a = 1 - k * k;
			if (a <= Na) return k = 1 - b, this._w = k * g + b * this._w, this._x = k * c + b * this._x, this._y =
				k * d + b * this._y, this._z = k * e + b * this._z, this.normalize(), this._onChangeCallback(), this;
			a = Math.sqrt(a);
			var l = Math.atan2(a, k);
			k = Math.sin((1 - b) * l) / a;
			b = Math.sin(b * l) / a;
			this._w = g * k + this._w * b;
			this._x = c * k + this._x * b;
			this._y = d * k + this._y * b;
			this._z = e * k + this._z * b;
			this._onChangeCallback();
			return this
		},
		equals: function(a) {
			return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			this._x = a[b];
			this._y = a[b + 1];
			this._z = a[b + 2];
			this._w = a[b + 3];
			this._onChangeCallback();
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			a[b] = this._x;
			a[b + 1] = this._y;
			a[b + 2] = this._z;
			a[b + 3] = this._w;
			return a
		},
		_onChange: function(a) {
			this._onChangeCallback = a;
			return this
		},
		_onChangeCallback: function() {}
	});
	var Ql = new u,
		Ho = new vb;
	q(u.prototype, {
		isVector3: !0,
		set: function(a, b, c) {
			this.x = a;
			this.y = b;
			this.z = c;
			return this
		},
		setScalar: function(a) {
			this.z = this.y = this.x = a;
			return this
		},
		setX: function(a) {
			this.x = a;
			return this
		},
		setY: function(a) {
			this.y = a;
			return this
		},
		setZ: function(a) {
			this.z =
				a;
			return this
		},
		setComponent: function(a, b) {
			switch (a) {
				case 0:
					this.x = b;
					break;
				case 1:
					this.y = b;
					break;
				case 2:
					this.z = b;
					break;
				default:
					throw Error("index is out of range: " + a);
			}
			return this
		},
		getComponent: function(a) {
			switch (a) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				default:
					throw Error("index is out of range: " + a);
			}
		},
		clone: function() {
			return new this.constructor(this.x, this.y, this.z)
		},
		copy: function(a) {
			this.x = a.x;
			this.y = a.y;
			this.z = a.z;
			return this
		},
		add: function(a, b) {
			if (void 0 !== b) return console.warn(
					"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
				this.addVectors(a, b);
			this.x += a.x;
			this.y += a.y;
			this.z += a.z;
			return this
		},
		addScalar: function(a) {
			this.x += a;
			this.y += a;
			this.z += a;
			return this
		},
		addVectors: function(a, b) {
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			return this
		},
		addScaledVector: function(a, b) {
			this.x += a.x * b;
			this.y += a.y * b;
			this.z += a.z * b;
			return this
		},
		sub: function(a, b) {
			if (void 0 !== b) return console.warn(
				"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a,
				b);
			this.x -= a.x;
			this.y -= a.y;
			this.z -= a.z;
			return this
		},
		subScalar: function(a) {
			this.x -= a;
			this.y -= a;
			this.z -= a;
			return this
		},
		subVectors: function(a, b) {
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			return this
		},
		multiply: function(a, b) {
			if (void 0 !== b) return console.warn(
				"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(
				a, b);
			this.x *= a.x;
			this.y *= a.y;
			this.z *= a.z;
			return this
		},
		multiplyScalar: function(a) {
			this.x *= a;
			this.y *= a;
			this.z *= a;
			return this
		},
		multiplyVectors: function(a, b) {
			this.x = a.x *
				b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
			return this
		},
		applyEuler: function(a) {
			a && a.isEuler || console.error(
				"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
			return this.applyQuaternion(Ho.setFromEuler(a))
		},
		applyAxisAngle: function(a, b) {
			return this.applyQuaternion(Ho.setFromAxisAngle(a, b))
		},
		applyMatrix3: function(a) {
			var b = this.x,
				c = this.y,
				d = this.z;
			a = a.elements;
			this.x = a[0] * b + a[3] * c + a[6] * d;
			this.y = a[1] * b + a[4] * c + a[7] * d;
			this.z = a[2] * b + a[5] * c + a[8] * d;
			return this
		},
		applyMatrix4: function(a) {
			var b =
				this.x,
				c = this.y,
				d = this.z;
			a = a.elements;
			var e = 1 / (a[3] * b + a[7] * c + a[11] * d + a[15]);
			this.x = (a[0] * b + a[4] * c + a[8] * d + a[12]) * e;
			this.y = (a[1] * b + a[5] * c + a[9] * d + a[13]) * e;
			this.z = (a[2] * b + a[6] * c + a[10] * d + a[14]) * e;
			return this
		},
		applyQuaternion: function(a) {
			var b = this.x,
				c = this.y,
				d = this.z,
				e = a.x,
				g = a.y,
				k = a.z;
			a = a.w;
			var l = a * b + g * d - k * c,
				m = a * c + k * b - e * d,
				n = a * d + e * c - g * b;
			b = -e * b - g * c - k * d;
			this.x = l * a + b * -e + m * -k - n * -g;
			this.y = m * a + b * -g + n * -e - l * -k;
			this.z = n * a + b * -k + l * -g - m * -e;
			return this
		},
		project: function(a) {
			return this.applyMatrix4(a.matrixWorldInverse).applyMatrix4(a.projectionMatrix)
		},
		unproject: function(a) {
			return this.applyMatrix4(a.projectionMatrixInverse).applyMatrix4(a.matrixWorld)
		},
		transformDirection: function(a) {
			var b = this.x,
				c = this.y,
				d = this.z;
			a = a.elements;
			this.x = a[0] * b + a[4] * c + a[8] * d;
			this.y = a[1] * b + a[5] * c + a[9] * d;
			this.z = a[2] * b + a[6] * c + a[10] * d;
			return this.normalize()
		},
		divide: function(a) {
			this.x /= a.x;
			this.y /= a.y;
			this.z /= a.z;
			return this
		},
		divideScalar: function(a) {
			return this.multiplyScalar(1 / a)
		},
		min: function(a) {
			this.x = Math.min(this.x, a.x);
			this.y = Math.min(this.y, a.y);
			this.z = Math.min(this.z,
				a.z);
			return this
		},
		max: function(a) {
			this.x = Math.max(this.x, a.x);
			this.y = Math.max(this.y, a.y);
			this.z = Math.max(this.z, a.z);
			return this
		},
		clamp: function(a, b) {
			this.x = Math.max(a.x, Math.min(b.x, this.x));
			this.y = Math.max(a.y, Math.min(b.y, this.y));
			this.z = Math.max(a.z, Math.min(b.z, this.z));
			return this
		},
		clampScalar: function(a, b) {
			this.x = Math.max(a, Math.min(b, this.x));
			this.y = Math.max(a, Math.min(b, this.y));
			this.z = Math.max(a, Math.min(b, this.z));
			return this
		},
		clampLength: function(a, b) {
			var c = this.length();
			return this.divideScalar(c ||
				1).multiplyScalar(Math.max(a, Math.min(b, c)))
		},
		floor: function() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			return this
		},
		ceil: function() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			return this
		},
		round: function() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			return this
		},
		roundToZero: function() {
			this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
			this.z =
				0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
			return this
		},
		negate: function() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			return this
		},
		dot: function(a) {
			return this.x * a.x + this.y * a.y + this.z * a.z
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z * this.z
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		},
		manhattanLength: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
		},
		normalize: function() {
			return this.divideScalar(this.length() || 1)
		},
		setLength: function(a) {
			return this.normalize().multiplyScalar(a)
		},
		lerp: function(a, b) {
			this.x += (a.x - this.x) * b;
			this.y += (a.y - this.y) * b;
			this.z += (a.z - this.z) * b;
			return this
		},
		lerpVectors: function(a, b, c) {
			return this.subVectors(b, a).multiplyScalar(c).add(a)
		},
		cross: function(a, b) {
			return void 0 !== b ? (console.warn(
				"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(
				a, b)) : this.crossVectors(this, a)
		},
		crossVectors: function(a, b) {
			var c = a.x,
				d = a.y;
			a = a.z;
			var e = b.x,
				g = b.y;
			b = b.z;
			this.x = d * b - a * g;
			this.y = a * e - c * b;
			this.z = c * g - d * e;
			return this
		},
		projectOnVector: function(a) {
			var b = a.dot(this) / a.lengthSq();
			return this.copy(a).multiplyScalar(b)
		},
		projectOnPlane: function(a) {
			Ql.copy(this).projectOnVector(a);
			return this.sub(Ql)
		},
		reflect: function(a) {
			return this.sub(Ql.copy(a).multiplyScalar(2 * this.dot(a)))
		},
		angleTo: function(a) {
			var b = Math.sqrt(this.lengthSq() * a.lengthSq());
			0 === b && console.error("THREE.Vector3: angleTo() can't handle zero length vectors.");
			a = this.dot(a) / b;
			return Math.acos(ha.clamp(a, -1, 1))
		},
		distanceTo: function(a) {
			return Math.sqrt(this.distanceToSquared(a))
		},
		distanceToSquared: function(a) {
			var b = this.x - a.x,
				c = this.y - a.y;
			a = this.z - a.z;
			return b * b + c * c + a * a
		},
		manhattanDistanceTo: function(a) {
			return Math.abs(this.x - a.x) + Math.abs(this.y - a.y) + Math.abs(this.z - a.z)
		},
		setFromSpherical: function(a) {
			return this.setFromSphericalCoords(a.radius, a.phi, a.theta)
		},
		setFromSphericalCoords: function(a, b, c) {
			var d = Math.sin(b) * a;
			this.x = d * Math.sin(c);
			this.y = Math.cos(b) * a;
			this.z = d * Math.cos(c);
			return this
		},
		setFromCylindrical: function(a) {
			return this.setFromCylindricalCoords(a.radius, a.theta,
				a.y)
		},
		setFromCylindricalCoords: function(a, b, c) {
			this.x = a * Math.sin(b);
			this.y = c;
			this.z = a * Math.cos(b);
			return this
		},
		setFromMatrixPosition: function(a) {
			a = a.elements;
			this.x = a[12];
			this.y = a[13];
			this.z = a[14];
			return this
		},
		setFromMatrixScale: function(a) {
			var b = this.setFromMatrixColumn(a, 0).length(),
				c = this.setFromMatrixColumn(a, 1).length();
			a = this.setFromMatrixColumn(a, 2).length();
			this.x = b;
			this.y = c;
			this.z = a;
			return this
		},
		setFromMatrixColumn: function(a, b) {
			return this.fromArray(a.elements, 4 * b)
		},
		equals: function(a) {
			return a.x ===
				this.x && a.y === this.y && a.z === this.z
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			this.x = a[b];
			this.y = a[b + 1];
			this.z = a[b + 2];
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			a[b] = this.x;
			a[b + 1] = this.y;
			a[b + 2] = this.z;
			return a
		},
		fromBufferAttribute: function(a, b, c) {
			void 0 !== c && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
			this.x = a.getX(b);
			this.y = a.getY(b);
			this.z = a.getZ(b);
			return this
		}
	});
	var ad = new u;
	q(kb.prototype, {
		isMatrix3: !0,
		set: function(a, b, c, d,
			e, g, k, l, m) {
			var n = this.elements;
			n[0] = a;
			n[1] = d;
			n[2] = k;
			n[3] = b;
			n[4] = e;
			n[5] = l;
			n[6] = c;
			n[7] = g;
			n[8] = m;
			return this
		},
		identity: function() {
			this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
			return this
		},
		clone: function() {
			return (new this.constructor).fromArray(this.elements)
		},
		copy: function(a) {
			var b = this.elements;
			a = a.elements;
			b[0] = a[0];
			b[1] = a[1];
			b[2] = a[2];
			b[3] = a[3];
			b[4] = a[4];
			b[5] = a[5];
			b[6] = a[6];
			b[7] = a[7];
			b[8] = a[8];
			return this
		},
		setFromMatrix4: function(a) {
			a = a.elements;
			this.set(a[0], a[4], a[8], a[1], a[5], a[9], a[2], a[6], a[10]);
			return this
		},
		applyToBufferAttribute: function(a) {
			for (var b = 0, c = a.count; b < c; b++) ad.x = a.getX(b), ad.y = a.getY(b), ad.z = a.getZ(b), ad.applyMatrix3(
				this), a.setXYZ(b, ad.x, ad.y, ad.z);
			return a
		},
		multiply: function(a) {
			return this.multiplyMatrices(this, a)
		},
		premultiply: function(a) {
			return this.multiplyMatrices(a, this)
		},
		multiplyMatrices: function(a, b) {
			var c = a.elements,
				d = b.elements;
			b = this.elements;
			a = c[0];
			var e = c[3],
				g = c[6],
				k = c[1],
				l = c[4],
				m = c[7],
				n = c[2],
				r = c[5];
			c = c[8];
			var p = d[0],
				q = d[3],
				u = d[6],
				z = d[1],
				C = d[4],
				D = d[7],
				K = d[2],
				G = d[5];
			d = d[8];
			b[0] = a * p + e * z + g * K;
			b[3] = a * q + e * C + g * G;
			b[6] = a * u + e * D + g * d;
			b[1] = k * p + l * z + m * K;
			b[4] = k * q + l * C + m * G;
			b[7] = k * u + l * D + m * d;
			b[2] = n * p + r * z + c * K;
			b[5] = n * q + r * C + c * G;
			b[8] = n * u + r * D + c * d;
			return this
		},
		multiplyScalar: function(a) {
			var b = this.elements;
			b[0] *= a;
			b[3] *= a;
			b[6] *= a;
			b[1] *= a;
			b[4] *= a;
			b[7] *= a;
			b[2] *= a;
			b[5] *= a;
			b[8] *= a;
			return this
		},
		determinant: function() {
			var a = this.elements,
				b = a[0],
				c = a[1],
				d = a[2],
				e = a[3],
				g = a[4],
				k = a[5],
				l = a[6],
				m = a[7];
			a = a[8];
			return b * g * a - b * k * m - c * e * a + c * k * l + d * e * m - d * g * l
		},
		getInverse: function(a, b) {
			a && a.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
			var c = a.elements;
			a = this.elements;
			var d = c[0],
				e = c[1],
				g = c[2],
				k = c[3],
				l = c[4],
				m = c[5],
				n = c[6],
				r = c[7];
			c = c[8];
			var p = c * l - m * r,
				q = m * n - c * k,
				u = r * k - l * n,
				z = d * p + e * q + g * u;
			if (0 === z) {
				if (!0 === b) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
				console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
				return this.identity()
			}
			b = 1 / z;
			a[0] = p * b;
			a[1] = (g * r - c * e) * b;
			a[2] = (m * e - g * l) * b;
			a[3] = q * b;
			a[4] = (c * d - g * n) * b;
			a[5] = (g * k - m * d) * b;
			a[6] = u * b;
			a[7] = (e * n - r * d) * b;
			a[8] = (l * d - e * k) * b;
			return this
		},
		transpose: function() {
			var a = this.elements;
			var b = a[1];
			a[1] = a[3];
			a[3] = b;
			b = a[2];
			a[2] = a[6];
			a[6] = b;
			b = a[5];
			a[5] = a[7];
			a[7] = b;
			return this
		},
		getNormalMatrix: function(a) {
			return this.setFromMatrix4(a).getInverse(this).transpose()
		},
		transposeIntoArray: function(a) {
			var b = this.elements;
			a[0] = b[0];
			a[1] = b[3];
			a[2] = b[6];
			a[3] = b[1];
			a[4] = b[4];
			a[5] = b[7];
			a[6] = b[2];
			a[7] = b[5];
			a[8] = b[8];
			return this
		},
		setUvTransform: function(a, b, c, d, e, g, k) {
			var l = Math.cos(e);
			e = Math.sin(e);
			this.set(c * l, c * e, -c * (l * g + e * k) + g + a, -d * e, d * l, -d * (-e * g + l * k) + k +
				b, 0, 0, 1)
		},
		scale: function(a, b) {
			var c = this.elements;
			c[0] *= a;
			c[3] *= a;
			c[6] *= a;
			c[1] *= b;
			c[4] *= b;
			c[7] *= b;
			return this
		},
		rotate: function(a) {
			var b = Math.cos(a);
			a = Math.sin(a);
			var c = this.elements,
				d = c[0],
				e = c[3],
				g = c[6],
				k = c[1],
				l = c[4],
				m = c[7];
			c[0] = b * d + a * k;
			c[3] = b * e + a * l;
			c[6] = b * g + a * m;
			c[1] = -a * d + b * k;
			c[4] = -a * e + b * l;
			c[7] = -a * g + b * m;
			return this
		},
		translate: function(a, b) {
			var c = this.elements;
			c[0] += a * c[2];
			c[3] += a * c[5];
			c[6] += a * c[8];
			c[1] += b * c[2];
			c[4] += b * c[5];
			c[7] += b * c[8];
			return this
		},
		equals: function(a) {
			var b = this.elements;
			a = a.elements;
			for (var c = 0; 9 > c; c++)
				if (b[c] !== a[c]) return !1;
			return !0
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			for (var c = 0; 9 > c; c++) this.elements[c] = a[c + b];
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			var c = this.elements;
			a[b] = c[0];
			a[b + 1] = c[1];
			a[b + 2] = c[2];
			a[b + 3] = c[3];
			a[b + 4] = c[4];
			a[b + 5] = c[5];
			a[b + 6] = c[6];
			a[b + 7] = c[7];
			a[b + 8] = c[8];
			return a
		}
	});
	var Jd, rc = {
			getDataURL: function(a) {
				if ("undefined" == typeof HTMLCanvasElement) return a.src;
				if (!(a instanceof HTMLCanvasElement)) {
					void 0 === Jd && (Jd = document.createElementNS("http://www.w3.org/1999/xhtml",
						"canvas"));
					Jd.width = a.width;
					Jd.height = a.height;
					var b = Jd.getContext("2d");
					a instanceof ImageData ? b.putImageData(a, 0, 0) : b.drawImage(a, 0, 0, a.width, a.height);
					a = Jd
				}
				return 2048 < a.width || 2048 < a.height ? a.toDataURL("image/jpeg", .6) : a.toDataURL("image/png")
			}
		},
		up = 0;
	pa.DEFAULT_IMAGE = void 0;
	pa.DEFAULT_MAPPING = 300;
	pa.prototype = q(p(nb.prototype), {
		constructor: pa,
		isTexture: !0,
		updateMatrix: function() {
			this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center
				.x, this.center.y)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.name = a.name;
			this.image = a.image;
			this.mipmaps = a.mipmaps.slice(0);
			this.mapping = a.mapping;
			this.wrapS = a.wrapS;
			this.wrapT = a.wrapT;
			this.magFilter = a.magFilter;
			this.minFilter = a.minFilter;
			this.anisotropy = a.anisotropy;
			this.format = a.format;
			this.type = a.type;
			this.offset.copy(a.offset);
			this.repeat.copy(a.repeat);
			this.center.copy(a.center);
			this.rotation = a.rotation;
			this.matrixAutoUpdate = a.matrixAutoUpdate;
			this.matrix.copy(a.matrix);
			this.generateMipmaps =
				a.generateMipmaps;
			this.premultiplyAlpha = a.premultiplyAlpha;
			this.flipY = a.flipY;
			this.unpackAlignment = a.unpackAlignment;
			this.encoding = a.encoding;
			return this
		},
		toJSON: function(a) {
			var b = void 0 === a || "string" === typeof a;
			if (!b && void 0 !== a.textures[this.uuid]) return a.textures[this.uuid];
			var c = {
				metadata: {
					version: 4.5,
					type: "Texture",
					generator: "Texture.toJSON"
				},
				uuid: this.uuid,
				name: this.name,
				mapping: this.mapping,
				repeat: [this.repeat.x, this.repeat.y],
				offset: [this.offset.x, this.offset.y],
				center: [this.center.x, this.center.y],
				rotation: this.rotation,
				wrap: [this.wrapS, this.wrapT],
				format: this.format,
				type: this.type,
				encoding: this.encoding,
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
				flipY: this.flipY,
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
			};
			if (void 0 !== this.image) {
				var d = this.image;
				void 0 === d.uuid && (d.uuid = ha.generateUUID());
				if (!b && void 0 === a.images[d.uuid]) {
					if (Array.isArray(d)) {
						var e = [];
						for (var g = 0, k = d.length; g < k; g++) e.push(rc.getDataURL(d[g]))
					} else e = rc.getDataURL(d);
					a.images[d.uuid] = {
						uuid: d.uuid,
						url: e
					}
				}
				c.image = d.uuid
			}
			b || (a.textures[this.uuid] = c);
			return c
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		},
		transformUv: function(a) {
			if (300 !== this.mapping) return a;
			a.applyMatrix3(this.matrix);
			if (0 > a.x || 1 < a.x) switch (this.wrapS) {
				case 1E3:
					a.x -= Math.floor(a.x);
					break;
				case 1001:
					a.x = 0 > a.x ? 0 : 1;
					break;
				case 1002:
					a.x = 1 === Math.abs(Math.floor(a.x) % 2) ? Math.ceil(a.x) - a.x : a.x - Math.floor(a.x)
			}
			if (0 > a.y || 1 < a.y) switch (this.wrapT) {
				case 1E3:
					a.y -= Math.floor(a.y);
					break;
				case 1001:
					a.y =
						0 > a.y ? 0 : 1;
					break;
				case 1002:
					a.y = 1 === Math.abs(Math.floor(a.y) % 2) ? Math.ceil(a.y) - a.y : a.y - Math.floor(a.y)
			}
			this.flipY && (a.y = 1 - a.y);
			return a
		}
	});
	Object.defineProperty(pa.prototype, "needsUpdate", {
		set: function(a) {
			!0 === a && this.version++
		}
	});
	ja(za.prototype, {
		width: {
			get: function() {
				return this.z
			},
			set: function(a) {
				this.z = a
			}
		},
		height: {
			get: function() {
				return this.w
			},
			set: function(a) {
				this.w = a
			}
		}
	});
	q(za.prototype, {
		isVector4: !0,
		set: function(a, b, c, d) {
			this.x = a;
			this.y = b;
			this.z = c;
			this.w = d;
			return this
		},
		setScalar: function(a) {
			this.w =
				this.z = this.y = this.x = a;
			return this
		},
		setX: function(a) {
			this.x = a;
			return this
		},
		setY: function(a) {
			this.y = a;
			return this
		},
		setZ: function(a) {
			this.z = a;
			return this
		},
		setW: function(a) {
			this.w = a;
			return this
		},
		setComponent: function(a, b) {
			switch (a) {
				case 0:
					this.x = b;
					break;
				case 1:
					this.y = b;
					break;
				case 2:
					this.z = b;
					break;
				case 3:
					this.w = b;
					break;
				default:
					throw Error("index is out of range: " + a);
			}
			return this
		},
		getComponent: function(a) {
			switch (a) {
				case 0:
					return this.x;
				case 1:
					return this.y;
				case 2:
					return this.z;
				case 3:
					return this.w;
				default:
					throw Error("index is out of range: " +
						a);
			}
		},
		clone: function() {
			return new this.constructor(this.x, this.y, this.z, this.w)
		},
		copy: function(a) {
			this.x = a.x;
			this.y = a.y;
			this.z = a.z;
			this.w = void 0 !== a.w ? a.w : 1;
			return this
		},
		add: function(a, b) {
			if (void 0 !== b) return console.warn(
				"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(a,
				b);
			this.x += a.x;
			this.y += a.y;
			this.z += a.z;
			this.w += a.w;
			return this
		},
		addScalar: function(a) {
			this.x += a;
			this.y += a;
			this.z += a;
			this.w += a;
			return this
		},
		addVectors: function(a, b) {
			this.x = a.x +
				b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
			return this
		},
		addScaledVector: function(a, b) {
			this.x += a.x * b;
			this.y += a.y * b;
			this.z += a.z * b;
			this.w += a.w * b;
			return this
		},
		sub: function(a, b) {
			if (void 0 !== b) return console.warn(
				"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(a,
				b);
			this.x -= a.x;
			this.y -= a.y;
			this.z -= a.z;
			this.w -= a.w;
			return this
		},
		subScalar: function(a) {
			this.x -= a;
			this.y -= a;
			this.z -= a;
			this.w -= a;
			return this
		},
		subVectors: function(a, b) {
			this.x = a.x - b.x;
			this.y =
				a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
			return this
		},
		multiplyScalar: function(a) {
			this.x *= a;
			this.y *= a;
			this.z *= a;
			this.w *= a;
			return this
		},
		applyMatrix4: function(a) {
			var b = this.x,
				c = this.y,
				d = this.z,
				e = this.w;
			a = a.elements;
			this.x = a[0] * b + a[4] * c + a[8] * d + a[12] * e;
			this.y = a[1] * b + a[5] * c + a[9] * d + a[13] * e;
			this.z = a[2] * b + a[6] * c + a[10] * d + a[14] * e;
			this.w = a[3] * b + a[7] * c + a[11] * d + a[15] * e;
			return this
		},
		divideScalar: function(a) {
			return this.multiplyScalar(1 / a)
		},
		setAxisAngleFromQuaternion: function(a) {
			this.w = 2 * Math.acos(a.w);
			var b = Math.sqrt(1 -
				a.w * a.w);
			1E-4 > b ? (this.x = 1, this.z = this.y = 0) : (this.x = a.x / b, this.y = a.y / b, this.z = a.z / b);
			return this
		},
		setAxisAngleFromRotationMatrix: function(a) {
			a = a.elements;
			var b = a[0];
			var c = a[4];
			var d = a[8],
				e = a[1],
				g = a[5],
				k = a[9];
			var l = a[2];
			var m = a[6];
			var n = a[10];
			if (.01 > Math.abs(c - e) && .01 > Math.abs(d - l) && .01 > Math.abs(k - m)) {
				if (.1 > Math.abs(c + e) && .1 > Math.abs(d + l) && .1 > Math.abs(k + m) && .1 > Math.abs(b + g + n - 3)) return this
					.set(1, 0, 0, 0), this;
				a = Math.PI;
				b = (b + 1) / 2;
				g = (g + 1) / 2;
				n = (n + 1) / 2;
				c = (c + e) / 4;
				d = (d + l) / 4;
				k = (k + m) / 4;
				b > g && b > n ? .01 > b ? (m = 0, c =
					l = .707106781) : (m = Math.sqrt(b), l = c / m, c = d / m) : g > n ? .01 > g ? (m = .707106781, l = 0, c =
					.707106781) : (l = Math.sqrt(g), m = c / l, c = k / l) : .01 > n ? (l = m = .707106781, c = 0) : (c = Math.sqrt(
					n), m = d / c, l = k / c);
				this.set(m, l, c, a);
				return this
			}
			a = Math.sqrt((m - k) * (m - k) + (d - l) * (d - l) + (e - c) * (e - c));
			.001 > Math.abs(a) && (a = 1);
			this.x = (m - k) / a;
			this.y = (d - l) / a;
			this.z = (e - c) / a;
			this.w = Math.acos((b + g + n - 1) / 2);
			return this
		},
		min: function(a) {
			this.x = Math.min(this.x, a.x);
			this.y = Math.min(this.y, a.y);
			this.z = Math.min(this.z, a.z);
			this.w = Math.min(this.w, a.w);
			return this
		},
		max: function(a) {
			this.x = Math.max(this.x, a.x);
			this.y = Math.max(this.y, a.y);
			this.z = Math.max(this.z, a.z);
			this.w = Math.max(this.w, a.w);
			return this
		},
		clamp: function(a, b) {
			this.x = Math.max(a.x, Math.min(b.x, this.x));
			this.y = Math.max(a.y, Math.min(b.y, this.y));
			this.z = Math.max(a.z, Math.min(b.z, this.z));
			this.w = Math.max(a.w, Math.min(b.w, this.w));
			return this
		},
		clampScalar: function(a, b) {
			this.x = Math.max(a, Math.min(b, this.x));
			this.y = Math.max(a, Math.min(b, this.y));
			this.z = Math.max(a, Math.min(b, this.z));
			this.w = Math.max(a, Math.min(b,
				this.w));
			return this
		},
		clampLength: function(a, b) {
			var c = this.length();
			return this.divideScalar(c || 1).multiplyScalar(Math.max(a, Math.min(b, c)))
		},
		floor: function() {
			this.x = Math.floor(this.x);
			this.y = Math.floor(this.y);
			this.z = Math.floor(this.z);
			this.w = Math.floor(this.w);
			return this
		},
		ceil: function() {
			this.x = Math.ceil(this.x);
			this.y = Math.ceil(this.y);
			this.z = Math.ceil(this.z);
			this.w = Math.ceil(this.w);
			return this
		},
		round: function() {
			this.x = Math.round(this.x);
			this.y = Math.round(this.y);
			this.z = Math.round(this.z);
			this.w =
				Math.round(this.w);
			return this
		},
		roundToZero: function() {
			this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
			this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
			this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
			this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
			return this
		},
		negate: function() {
			this.x = -this.x;
			this.y = -this.y;
			this.z = -this.z;
			this.w = -this.w;
			return this
		},
		dot: function(a) {
			return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
		},
		lengthSq: function() {
			return this.x * this.x + this.y * this.y + this.z *
				this.z + this.w * this.w
		},
		length: function() {
			return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
		},
		manhattanLength: function() {
			return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
		},
		normalize: function() {
			return this.divideScalar(this.length() || 1)
		},
		setLength: function(a) {
			return this.normalize().multiplyScalar(a)
		},
		lerp: function(a, b) {
			this.x += (a.x - this.x) * b;
			this.y += (a.y - this.y) * b;
			this.z += (a.z - this.z) * b;
			this.w += (a.w - this.w) * b;
			return this
		},
		lerpVectors: function(a, b, c) {
			return this.subVectors(b,
				a).multiplyScalar(c).add(a)
		},
		equals: function(a) {
			return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			this.x = a[b];
			this.y = a[b + 1];
			this.z = a[b + 2];
			this.w = a[b + 3];
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			a[b] = this.x;
			a[b + 1] = this.y;
			a[b + 2] = this.z;
			a[b + 3] = this.w;
			return a
		},
		fromBufferAttribute: function(a, b, c) {
			void 0 !== c && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
			this.x = a.getX(b);
			this.y = a.getY(b);
			this.z = a.getZ(b);
			this.w = a.getW(b);
			return this
		}
	});
	Oa.prototype = q(p(nb.prototype), {
		constructor: Oa,
		isWebGLRenderTarget: !0,
		setSize: function(a, b) {
			if (this.width !== a || this.height !== b) this.width = a, this.height = b, this.texture.image.width = a, this.texture
				.image.height = b, this.dispose();
			this.viewport.set(0, 0, a, b);
			this.scissor.set(0, 0, a, b)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.width = a.width;
			this.height = a.height;
			this.viewport.copy(a.viewport);
			this.texture = a.texture.clone();
			this.depthBuffer = a.depthBuffer;
			this.stencilBuffer = a.stencilBuffer;
			this.depthTexture = a.depthTexture;
			return this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	});
	om.prototype = q(p(Oa.prototype), {
		constructor: om,
		isWebGLMultisampleRenderTarget: !0,
		copy: function(a) {
			Oa.prototype.copy.call(this, a);
			this.samples = a.samples;
			return this
		}
	});
	var bc = new u,
		$a = new ua,
		Ds = new u(0, 0, 0),
		Es = new u(1, 1, 1),
		bd = new u,
		wi = new u,
		Cb = new u;
	q(ua.prototype, {
		isMatrix4: !0,
		set: function(a, b, c, d, e, g, k, l, m, n, r, p, q, u, z, C) {
			var v =
				this.elements;
			v[0] = a;
			v[4] = b;
			v[8] = c;
			v[12] = d;
			v[1] = e;
			v[5] = g;
			v[9] = k;
			v[13] = l;
			v[2] = m;
			v[6] = n;
			v[10] = r;
			v[14] = p;
			v[3] = q;
			v[7] = u;
			v[11] = z;
			v[15] = C;
			return this
		},
		identity: function() {
			this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this
		},
		clone: function() {
			return (new ua).fromArray(this.elements)
		},
		copy: function(a) {
			var b = this.elements;
			a = a.elements;
			b[0] = a[0];
			b[1] = a[1];
			b[2] = a[2];
			b[3] = a[3];
			b[4] = a[4];
			b[5] = a[5];
			b[6] = a[6];
			b[7] = a[7];
			b[8] = a[8];
			b[9] = a[9];
			b[10] = a[10];
			b[11] = a[11];
			b[12] = a[12];
			b[13] = a[13];
			b[14] = a[14];
			b[15] = a[15];
			return this
		},
		copyPosition: function(a) {
			var b = this.elements;
			a = a.elements;
			b[12] = a[12];
			b[13] = a[13];
			b[14] = a[14];
			return this
		},
		extractBasis: function(a, b, c) {
			a.setFromMatrixColumn(this, 0);
			b.setFromMatrixColumn(this, 1);
			c.setFromMatrixColumn(this, 2);
			return this
		},
		makeBasis: function(a, b, c) {
			this.set(a.x, b.x, c.x, 0, a.y, b.y, c.y, 0, a.z, b.z, c.z, 0, 0, 0, 0, 1);
			return this
		},
		extractRotation: function(a) {
			var b = this.elements,
				c = a.elements,
				d = 1 / bc.setFromMatrixColumn(a, 0).length(),
				e = 1 / bc.setFromMatrixColumn(a, 1).length();
			a = 1 / bc.setFromMatrixColumn(a,
				2).length();
			b[0] = c[0] * d;
			b[1] = c[1] * d;
			b[2] = c[2] * d;
			b[3] = 0;
			b[4] = c[4] * e;
			b[5] = c[5] * e;
			b[6] = c[6] * e;
			b[7] = 0;
			b[8] = c[8] * a;
			b[9] = c[9] * a;
			b[10] = c[10] * a;
			b[11] = 0;
			b[12] = 0;
			b[13] = 0;
			b[14] = 0;
			b[15] = 1;
			return this
		},
		makeRotationFromEuler: function(a) {
			a && a.isEuler || console.error(
				"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
			var b = this.elements,
				c = a.x,
				d = a.y,
				e = a.z,
				g = Math.cos(c);
			c = Math.sin(c);
			var k = Math.cos(d);
			d = Math.sin(d);
			var l = Math.cos(e);
			e = Math.sin(e);
			if ("XYZ" === a.order) {
				a =
					g * l;
				var m = g * e,
					n = c * l,
					r = c * e;
				b[0] = k * l;
				b[4] = -k * e;
				b[8] = d;
				b[1] = m + n * d;
				b[5] = a - r * d;
				b[9] = -c * k;
				b[2] = r - a * d;
				b[6] = n + m * d;
				b[10] = g * k
			} else "YXZ" === a.order ? (a = k * l, m = k * e, n = d * l, r = d * e, b[0] = a + r * c, b[4] = n * c - m, b[8] =
					g * d, b[1] = g * e, b[5] = g * l, b[9] = -c, b[2] = m * c - n, b[6] = r + a * c, b[10] = g * k) : "ZXY" ===
				a.order ? (a = k * l, m = k * e, n = d * l, r = d * e, b[0] = a - r * c, b[4] = -g * e, b[8] = n + m * c, b[1] =
					m + n * c, b[5] = g * l, b[9] = r - a * c, b[2] = -g * d, b[6] = c, b[10] = g * k) : "ZYX" === a.order ? (a =
					g * l, m = g * e, n = c * l, r = c * e, b[0] = k * l, b[4] = n * d - m, b[8] = a * d + r, b[1] = k * e, b[5] =
					r * d + a, b[9] = m * d - n, b[2] = -d, b[6] = c *
					k, b[10] = g * k) : "YZX" === a.order ? (a = g * k, m = g * d, n = c * k, r = c * d, b[0] = k * l, b[4] = r -
					a * e, b[8] = n * e + m, b[1] = e, b[5] = g * l, b[9] = -c * l, b[2] = -d * l, b[6] = m * e + n, b[10] = a - r *
					e) : "XZY" === a.order && (a = g * k, m = g * d, n = c * k, r = c * d, b[0] = k * l, b[4] = -e, b[8] = d * l,
					b[1] = a * e + r, b[5] = g * l, b[9] = m * e - n, b[2] = n * e - m, b[6] = c * l, b[10] = r * e + a);
			b[3] = 0;
			b[7] = 0;
			b[11] = 0;
			b[12] = 0;
			b[13] = 0;
			b[14] = 0;
			b[15] = 1;
			return this
		},
		makeRotationFromQuaternion: function(a) {
			return this.compose(Ds, a, Es)
		},
		lookAt: function(a, b, c) {
			var d = this.elements;
			Cb.subVectors(a, b);
			0 === Cb.lengthSq() && (Cb.z = 1);
			Cb.normalize();
			bd.crossVectors(c, Cb);
			0 === bd.lengthSq() && (1 === Math.abs(c.z) ? Cb.x += 1E-4 : Cb.z += 1E-4, Cb.normalize(), bd.crossVectors(c, Cb));
			bd.normalize();
			wi.crossVectors(Cb, bd);
			d[0] = bd.x;
			d[4] = wi.x;
			d[8] = Cb.x;
			d[1] = bd.y;
			d[5] = wi.y;
			d[9] = Cb.y;
			d[2] = bd.z;
			d[6] = wi.z;
			d[10] = Cb.z;
			return this
		},
		multiply: function(a, b) {
			return void 0 !== b ? (console.warn(
				"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(
				a, b)) : this.multiplyMatrices(this, a)
		},
		premultiply: function(a) {
			return this.multiplyMatrices(a,
				this)
		},
		multiplyMatrices: function(a, b) {
			var c = a.elements,
				d = b.elements;
			b = this.elements;
			a = c[0];
			var e = c[4],
				g = c[8],
				k = c[12],
				l = c[1],
				m = c[5],
				n = c[9],
				r = c[13],
				p = c[2],
				q = c[6],
				u = c[10],
				z = c[14],
				C = c[3],
				D = c[7],
				K = c[11];
			c = c[15];
			var G = d[0],
				B = d[4],
				H = d[8],
				Q = d[12],
				F = d[1],
				J = d[5],
				N = d[9],
				M = d[13],
				P = d[2],
				R = d[6],
				S = d[10],
				V = d[14],
				W = d[3],
				X = d[7],
				ba = d[11];
			d = d[15];
			b[0] = a * G + e * F + g * P + k * W;
			b[4] = a * B + e * J + g * R + k * X;
			b[8] = a * H + e * N + g * S + k * ba;
			b[12] = a * Q + e * M + g * V + k * d;
			b[1] = l * G + m * F + n * P + r * W;
			b[5] = l * B + m * J + n * R + r * X;
			b[9] = l * H + m * N + n * S + r * ba;
			b[13] = l * Q + m * M + n * V + r * d;
			b[2] = p * G + q * F + u * P + z * W;
			b[6] = p * B + q * J + u * R + z * X;
			b[10] = p * H + q * N + u * S + z * ba;
			b[14] = p * Q + q * M + u * V + z * d;
			b[3] = C * G + D * F + K * P + c * W;
			b[7] = C * B + D * J + K * R + c * X;
			b[11] = C * H + D * N + K * S + c * ba;
			b[15] = C * Q + D * M + K * V + c * d;
			return this
		},
		multiplyScalar: function(a) {
			var b = this.elements;
			b[0] *= a;
			b[4] *= a;
			b[8] *= a;
			b[12] *= a;
			b[1] *= a;
			b[5] *= a;
			b[9] *= a;
			b[13] *= a;
			b[2] *= a;
			b[6] *= a;
			b[10] *= a;
			b[14] *= a;
			b[3] *= a;
			b[7] *= a;
			b[11] *= a;
			b[15] *= a;
			return this
		},
		applyToBufferAttribute: function(a) {
			for (var b = 0, c = a.count; b < c; b++) bc.x = a.getX(b), bc.y = a.getY(b), bc.z = a.getZ(b), bc.applyMatrix4(
					this),
				a.setXYZ(b, bc.x, bc.y, bc.z);
			return a
		},
		determinant: function() {
			var a = this.elements,
				b = a[0],
				c = a[4],
				d = a[8],
				e = a[12],
				g = a[1],
				k = a[5],
				l = a[9],
				m = a[13],
				n = a[2],
				r = a[6],
				p = a[10],
				q = a[14];
			return a[3] * (+e * l * r - d * m * r - e * k * p + c * m * p + d * k * q - c * l * q) + a[7] * (+b * l * q - b *
				m * p + e * g * p - d * g * q + d * m * n - e * l * n) + a[11] * (+b * m * r - b * k * q - e * g * r + c * g *
				q + e * k * n - c * m * n) + a[15] * (-d * k * n - b * l * r + b * k * p + d * g * r - c * g * p + c * l * n)
		},
		transpose: function() {
			var a = this.elements;
			var b = a[1];
			a[1] = a[4];
			a[4] = b;
			b = a[2];
			a[2] = a[8];
			a[8] = b;
			b = a[6];
			a[6] = a[9];
			a[9] = b;
			b = a[3];
			a[3] = a[12];
			a[12] = b;
			b = a[7];
			a[7] = a[13];
			a[13] = b;
			b = a[11];
			a[11] = a[14];
			a[14] = b;
			return this
		},
		setPosition: function(a, b, c) {
			var d = this.elements;
			a.isVector3 ? (d[12] = a.x, d[13] = a.y, d[14] = a.z) : (d[12] = a, d[13] = b, d[14] = c);
			return this
		},
		getInverse: function(a, b) {
			var c = this.elements,
				d = a.elements;
			a = d[0];
			var e = d[1],
				g = d[2],
				k = d[3],
				l = d[4],
				m = d[5],
				n = d[6],
				r = d[7],
				p = d[8],
				q = d[9],
				u = d[10],
				z = d[11],
				C = d[12],
				D = d[13],
				K = d[14];
			d = d[15];
			var G = q * K * r - D * u * r + D * n * z - m * K * z - q * n * d + m * u * d,
				B = C * u * r - p * K * r - C * n * z + l * K * z + p * n * d - l * u * d,
				H = p * D * r - C * q * r + C * m * z - l * D * z - p * m * d + l * q * d,
				Q = C * q * n - p * D *
				n - C * m * u + l * D * u + p * m * K - l * q * K,
				F = a * G + e * B + g * H + k * Q;
			if (0 === F) {
				if (!0 === b) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
				console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
				return this.identity()
			}
			b = 1 / F;
			c[0] = G * b;
			c[1] = (D * u * k - q * K * k - D * g * z + e * K * z + q * g * d - e * u * d) * b;
			c[2] = (m * K * k - D * n * k + D * g * r - e * K * r - m * g * d + e * n * d) * b;
			c[3] = (q * n * k - m * u * k - q * g * r + e * u * r + m * g * z - e * n * z) * b;
			c[4] = B * b;
			c[5] = (p * K * k - C * u * k + C * g * z - a * K * z - p * g * d + a * u * d) * b;
			c[6] = (C * n * k - l * K * k - C * g * r + a * K * r + l * g * d - a * n * d) * b;
			c[7] = (l * u * k - p * n * k + p * g * r - a * u * r - l * g * z + a * n * z) * b;
			c[8] = H * b;
			c[9] = (C * q * k - p * D * k - C * e * z + a * D * z + p * e * d - a * q * d) * b;
			c[10] = (l * D * k - C * m * k + C * e * r - a * D * r - l * e * d + a * m * d) * b;
			c[11] = (p * m * k - l * q * k - p * e * r + a * q * r + l * e * z - a * m * z) * b;
			c[12] = Q * b;
			c[13] = (p * D * g - C * q * g + C * e * u - a * D * u - p * e * K + a * q * K) * b;
			c[14] = (C * m * g - l * D * g - C * e * n + a * D * n + l * e * K - a * m * K) * b;
			c[15] = (l * q * g - p * m * g + p * e * n - a * q * n - l * e * u + a * m * u) * b;
			return this
		},
		scale: function(a) {
			var b = this.elements,
				c = a.x,
				d = a.y;
			a = a.z;
			b[0] *= c;
			b[4] *= d;
			b[8] *= a;
			b[1] *= c;
			b[5] *= d;
			b[9] *= a;
			b[2] *= c;
			b[6] *= d;
			b[10] *= a;
			b[3] *= c;
			b[7] *= d;
			b[11] *=
				a;
			return this
		},
		getMaxScaleOnAxis: function() {
			var a = this.elements;
			return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] *
				a[8] + a[9] * a[9] + a[10] * a[10]))
		},
		makeTranslation: function(a, b, c) {
			this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
			return this
		},
		makeRotationX: function(a) {
			var b = Math.cos(a);
			a = Math.sin(a);
			this.set(1, 0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
			return this
		},
		makeRotationY: function(a) {
			var b = Math.cos(a);
			a = Math.sin(a);
			this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
			return this
		},
		makeRotationZ: function(a) {
			var b =
				Math.cos(a);
			a = Math.sin(a);
			this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
			return this
		},
		makeRotationAxis: function(a, b) {
			var c = Math.cos(b);
			b = Math.sin(b);
			var d = 1 - c,
				e = a.x,
				g = a.y;
			a = a.z;
			var k = d * e,
				l = d * g;
			this.set(k * e + c, k * g - b * a, k * a + b * g, 0, k * g + b * a, l * g + c, l * a - b * e, 0, k * a - b * g,
				l * a + b * e, d * a * a + c, 0, 0, 0, 0, 1);
			return this
		},
		makeScale: function(a, b, c) {
			this.set(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
			return this
		},
		makeShear: function(a, b, c) {
			this.set(1, b, c, 0, a, 1, c, 0, a, b, 1, 0, 0, 0, 0, 1);
			return this
		},
		compose: function(a, b, c) {
			var d = this.elements,
				e =
				b._x,
				g = b._y,
				k = b._z,
				l = b._w,
				m = e + e,
				n = g + g,
				r = k + k;
			b = e * m;
			var p = e * n;
			e *= r;
			var q = g * n;
			g *= r;
			k *= r;
			m *= l;
			n *= l;
			l *= r;
			r = c.x;
			var u = c.y;
			c = c.z;
			d[0] = (1 - (q + k)) * r;
			d[1] = (p + l) * r;
			d[2] = (e - n) * r;
			d[3] = 0;
			d[4] = (p - l) * u;
			d[5] = (1 - (b + k)) * u;
			d[6] = (g + m) * u;
			d[7] = 0;
			d[8] = (e + n) * c;
			d[9] = (g - m) * c;
			d[10] = (1 - (b + q)) * c;
			d[11] = 0;
			d[12] = a.x;
			d[13] = a.y;
			d[14] = a.z;
			d[15] = 1;
			return this
		},
		decompose: function(a, b, c) {
			var d = this.elements,
				e = bc.set(d[0], d[1], d[2]).length(),
				g = bc.set(d[4], d[5], d[6]).length(),
				k = bc.set(d[8], d[9], d[10]).length();
			0 > this.determinant() && (e = -e);
			a.x = d[12];
			a.y = d[13];
			a.z = d[14];
			$a.copy(this);
			a = 1 / e;
			d = 1 / g;
			var l = 1 / k;
			$a.elements[0] *= a;
			$a.elements[1] *= a;
			$a.elements[2] *= a;
			$a.elements[4] *= d;
			$a.elements[5] *= d;
			$a.elements[6] *= d;
			$a.elements[8] *= l;
			$a.elements[9] *= l;
			$a.elements[10] *= l;
			b.setFromRotationMatrix($a);
			c.x = e;
			c.y = g;
			c.z = k;
			return this
		},
		makePerspective: function(a, b, c, d, e, g) {
			void 0 === g && console.warn(
				"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
			var k = this.elements;
			k[0] = 2 * e / (b - a);
			k[4] = 0;
			k[8] =
				(b + a) / (b - a);
			k[12] = 0;
			k[1] = 0;
			k[5] = 2 * e / (c - d);
			k[9] = (c + d) / (c - d);
			k[13] = 0;
			k[2] = 0;
			k[6] = 0;
			k[10] = -(g + e) / (g - e);
			k[14] = -2 * g * e / (g - e);
			k[3] = 0;
			k[7] = 0;
			k[11] = -1;
			k[15] = 0;
			return this
		},
		makeOrthographic: function(a, b, c, d, e, g) {
			var k = this.elements,
				l = 1 / (b - a),
				m = 1 / (c - d),
				n = 1 / (g - e);
			k[0] = 2 * l;
			k[4] = 0;
			k[8] = 0;
			k[12] = -((b + a) * l);
			k[1] = 0;
			k[5] = 2 * m;
			k[9] = 0;
			k[13] = -((c + d) * m);
			k[2] = 0;
			k[6] = 0;
			k[10] = -2 * n;
			k[14] = -((g + e) * n);
			k[3] = 0;
			k[7] = 0;
			k[11] = 0;
			k[15] = 1;
			return this
		},
		equals: function(a) {
			var b = this.elements;
			a = a.elements;
			for (var c = 0; 16 > c; c++)
				if (b[c] !== a[c]) return !1;
			return !0
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			for (var c = 0; 16 > c; c++) this.elements[c] = a[c + b];
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			var c = this.elements;
			a[b] = c[0];
			a[b + 1] = c[1];
			a[b + 2] = c[2];
			a[b + 3] = c[3];
			a[b + 4] = c[4];
			a[b + 5] = c[5];
			a[b + 6] = c[6];
			a[b + 7] = c[7];
			a[b + 8] = c[8];
			a[b + 9] = c[9];
			a[b + 10] = c[10];
			a[b + 11] = c[11];
			a[b + 12] = c[12];
			a[b + 13] = c[13];
			a[b + 14] = c[14];
			a[b + 15] = c[15];
			return a
		}
	});
	var Io = new ua,
		Jo = new vb;
	Ac.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
	Ac.DefaultOrder = "XYZ";
	ja(Ac.prototype, {
		x: {
			get: function() {
				return this._x
			},
			set: function(a) {
				this._x = a;
				this._onChangeCallback()
			}
		},
		y: {
			get: function() {
				return this._y
			},
			set: function(a) {
				this._y = a;
				this._onChangeCallback()
			}
		},
		z: {
			get: function() {
				return this._z
			},
			set: function(a) {
				this._z = a;
				this._onChangeCallback()
			}
		},
		order: {
			get: function() {
				return this._order
			},
			set: function(a) {
				this._order = a;
				this._onChangeCallback()
			}
		}
	});
	q(Ac.prototype, {
		isEuler: !0,
		set: function(a, b, c, d) {
			this._x = a;
			this._y = b;
			this._z = c;
			this._order = d || this._order;
			this._onChangeCallback();
			return this
		},
		clone: function() {
			return new this.constructor(this._x, this._y, this._z, this._order)
		},
		copy: function(a) {
			this._x = a._x;
			this._y = a._y;
			this._z = a._z;
			this._order = a._order;
			this._onChangeCallback();
			return this
		},
		setFromRotationMatrix: function(a, b, c) {
			var d = ha.clamp,
				e = a.elements;
			a = e[0];
			var g = e[4],
				k = e[8],
				l = e[1],
				m = e[5],
				n = e[9],
				r = e[2],
				p = e[6];
			e = e[10];
			b = b || this._order;
			"XYZ" === b ? (this._y = Math.asin(d(k, -1, 1)), .9999999 > Math.abs(k) ? (this._x = Math.atan2(-n, e), this._z =
					Math.atan2(-g, a)) : (this._x = Math.atan2(p, m), this._z =
					0)) : "YXZ" === b ? (this._x = Math.asin(-d(n, -1, 1)), .9999999 > Math.abs(n) ? (this._y = Math.atan2(k, e),
					this._z = Math.atan2(l, m)) : (this._y = Math.atan2(-r, a), this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(
					d(p, -1, 1)), .9999999 > Math.abs(p) ? (this._y = Math.atan2(-r, e), this._z = Math.atan2(-g, m)) : (this._y =
					0, this._z = Math.atan2(l, a))) : "ZYX" === b ? (this._y = Math.asin(-d(r, -1, 1)), .9999999 > Math.abs(r) ? (
					this._x = Math.atan2(p, e), this._z = Math.atan2(l, a)) : (this._x = 0, this._z = Math.atan2(-g, m))) : "YZX" ===
				b ? (this._z = Math.asin(d(l, -1, 1)), .9999999 >
					Math.abs(l) ? (this._x = Math.atan2(-n, m), this._y = Math.atan2(-r, a)) : (this._x = 0, this._y = Math.atan2(
						k, e))) : "XZY" === b ? (this._z = Math.asin(-d(g, -1, 1)), .9999999 > Math.abs(g) ? (this._x = Math.atan2(p,
					m), this._y = Math.atan2(k, a)) : (this._x = Math.atan2(-n, e), this._y = 0)) : console.warn(
					"THREE.Euler: .setFromRotationMatrix() given unsupported order: " + b);
			this._order = b;
			!1 !== c && this._onChangeCallback();
			return this
		},
		setFromQuaternion: function(a, b, c) {
			Io.makeRotationFromQuaternion(a);
			return this.setFromRotationMatrix(Io, b, c)
		},
		setFromVector3: function(a, b) {
			return this.set(a.x, a.y, a.z, b || this._order)
		},
		reorder: function(a) {
			Jo.setFromEuler(this);
			return this.setFromQuaternion(Jo, a)
		},
		equals: function(a) {
			return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
		},
		fromArray: function(a) {
			this._x = a[0];
			this._y = a[1];
			this._z = a[2];
			void 0 !== a[3] && (this._order = a[3]);
			this._onChangeCallback();
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			a[b] = this._x;
			a[b + 1] = this._y;
			a[b + 2] = this._z;
			a[b + 3] = this._order;
			return a
		},
		toVector3: function(a) {
			return a ? a.set(this._x, this._y, this._z) : new u(this._x, this._y, this._z)
		},
		_onChange: function(a) {
			this._onChangeCallback = a;
			return this
		},
		_onChangeCallback: function() {}
	});
	q(pm.prototype, {
		set: function(a) {
			this.mask = 1 << a | 0
		},
		enable: function(a) {
			this.mask = this.mask | 1 << a | 0
		},
		enableAll: function() {
			this.mask = -1
		},
		toggle: function(a) {
			this.mask ^= 1 << a | 0
		},
		disable: function(a) {
			this.mask &= ~(1 << a | 0)
		},
		disableAll: function() {
			this.mask = 0
		},
		test: function(a) {
			return 0 !== (this.mask & a.mask)
		}
	});
	var vp =
		0,
		Ko = new u,
		cd = new vb,
		Kd = new ua,
		xi = new u,
		uf = new u,
		Fs = new u,
		Gs = new vb,
		Lo = new u(1, 0, 0),
		Mo = new u(0, 1, 0),
		No = new u(0, 0, 1),
		Hs = {
			type: "added"
		},
		Is = {
			type: "removed"
		};
	P.DefaultUp = new u(0, 1, 0);
	P.DefaultMatrixAutoUpdate = !0;
	P.prototype = q(p(nb.prototype), {
		constructor: P,
		isObject3D: !0,
		onBeforeRender: function() {},
		onAfterRender: function() {},
		applyMatrix: function(a) {
			this.matrixAutoUpdate && this.updateMatrix();
			this.matrix.premultiply(a);
			this.matrix.decompose(this.position, this.quaternion, this.scale)
		},
		applyQuaternion: function(a) {
			this.quaternion.premultiply(a);
			return this
		},
		setRotationFromAxisAngle: function(a, b) {
			this.quaternion.setFromAxisAngle(a, b)
		},
		setRotationFromEuler: function(a) {
			this.quaternion.setFromEuler(a, !0)
		},
		setRotationFromMatrix: function(a) {
			this.quaternion.setFromRotationMatrix(a)
		},
		setRotationFromQuaternion: function(a) {
			this.quaternion.copy(a)
		},
		rotateOnAxis: function(a, b) {
			cd.setFromAxisAngle(a, b);
			this.quaternion.multiply(cd);
			return this
		},
		rotateOnWorldAxis: function(a, b) {
			cd.setFromAxisAngle(a, b);
			this.quaternion.premultiply(cd);
			return this
		},
		rotateX: function(a) {
			return this.rotateOnAxis(Lo,
				a)
		},
		rotateY: function(a) {
			return this.rotateOnAxis(Mo, a)
		},
		rotateZ: function(a) {
			return this.rotateOnAxis(No, a)
		},
		translateOnAxis: function(a, b) {
			Ko.copy(a).applyQuaternion(this.quaternion);
			this.position.add(Ko.multiplyScalar(b));
			return this
		},
		translateX: function(a) {
			return this.translateOnAxis(Lo, a)
		},
		translateY: function(a) {
			return this.translateOnAxis(Mo, a)
		},
		translateZ: function(a) {
			return this.translateOnAxis(No, a)
		},
		localToWorld: function(a) {
			return a.applyMatrix4(this.matrixWorld)
		},
		worldToLocal: function(a) {
			return a.applyMatrix4(Kd.getInverse(this.matrixWorld))
		},
		lookAt: function(a, b, c) {
			a.isVector3 ? xi.copy(a) : xi.set(a, b, c);
			a = this.parent;
			this.updateWorldMatrix(!0, !1);
			uf.setFromMatrixPosition(this.matrixWorld);
			this.isCamera || this.isLight ? Kd.lookAt(uf, xi, this.up) : Kd.lookAt(xi, uf, this.up);
			this.quaternion.setFromRotationMatrix(Kd);
			a && (Kd.extractRotation(a.matrixWorld), cd.setFromRotationMatrix(Kd), this.quaternion.premultiply(cd.inverse()))
		},
		add: function(a) {
			if (1 < arguments.length) {
				for (var b = 0; b < arguments.length; b++) this.add(arguments[b]);
				return this
			}
			if (a === this) return console.error("THREE.Object3D.add: object can't be added as a child of itself.",
				a), this;
			a && a.isObject3D ? (null !== a.parent && a.parent.remove(a), a.parent = this, this.children.push(a), a.dispatchEvent(
				Hs)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", a);
			return this
		},
		remove: function(a) {
			if (1 < arguments.length) {
				for (var b = 0; b < arguments.length; b++) this.remove(arguments[b]);
				return this
			}
			b = this.children.indexOf(a); - 1 !== b && (a.parent = null, this.children.splice(b, 1), a.dispatchEvent(Is));
			return this
		},
		attach: function(a) {
			this.updateWorldMatrix(!0, !1);
			Kd.getInverse(this.matrixWorld);
			null !== a.parent && (a.parent.updateWorldMatrix(!0, !1), Kd.multiply(a.parent.matrixWorld));
			a.applyMatrix(Kd);
			a.updateWorldMatrix(!1, !1);
			this.add(a);
			return this
		},
		getObjectById: function(a) {
			return this.getObjectByProperty("id", a)
		},
		getObjectByName: function(a) {
			return this.getObjectByProperty("name", a)
		},
		getObjectByProperty: function(a, b) {
			if (this[a] === b) return this;
			for (var c = 0, d = this.children.length; c < d; c++) {
				var e = this.children[c].getObjectByProperty(a, b);
				if (void 0 !== e) return e
			}
		},
		getWorldPosition: function(a) {
			void 0 ===
				a && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), a = new u);
			this.updateMatrixWorld(!0);
			return a.setFromMatrixPosition(this.matrixWorld)
		},
		getWorldQuaternion: function(a) {
			void 0 === a && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), a = new vb);
			this.updateMatrixWorld(!0);
			this.matrixWorld.decompose(uf, a, Fs);
			return a
		},
		getWorldScale: function(a) {
			void 0 === a && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), a = new u);
			this.updateMatrixWorld(!0);
			this.matrixWorld.decompose(uf, Gs, a);
			return a
		},
		getWorldDirection: function(a) {
			void 0 === a && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), a = new u);
			this.updateMatrixWorld(!0);
			var b = this.matrixWorld.elements;
			return a.set(b[8], b[9], b[10]).normalize()
		},
		raycast: function() {},
		traverse: function(a) {
			a(this);
			for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverse(a)
		},
		traverseVisible: function(a) {
			if (!1 !== this.visible) {
				a(this);
				for (var b = this.children, c = 0, d = b.length; c < d; c++) b[c].traverseVisible(a)
			}
		},
		traverseAncestors: function(a) {
			var b = this.parent;
			null !== b && (a(b), b.traverseAncestors(a))
		},
		updateMatrix: function() {
			this.matrix.compose(this.position, this.quaternion, this.scale);
			this.matrixWorldNeedsUpdate = !0
		},
		updateMatrixWorld: function(a) {
			this.matrixAutoUpdate && this.updateMatrix();
			if (this.matrixWorldNeedsUpdate || a) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld
				.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, a = !0;
			for (var b = this.children, c =
					0, d = b.length; c < d; c++) b[c].updateMatrixWorld(a)
		},
		updateWorldMatrix: function(a, b) {
			var c = this.parent;
			!0 === a && null !== c && c.updateWorldMatrix(!0, !1);
			this.matrixAutoUpdate && this.updateMatrix();
			null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,
				this.matrix);
			if (!0 === b)
				for (a = this.children, b = 0, c = a.length; b < c; b++) a[b].updateWorldMatrix(!1, !0)
		},
		toJSON: function(a) {
			function b(b, c) {
				void 0 === b[c.uuid] && (b[c.uuid] = c.toJSON(a));
				return c.uuid
			}

			function c(a) {
				var b = [],
					c;
				for (c in a) {
					var d = a[c];
					delete d.metadata;
					b.push(d)
				}
				return b
			}
			var d = void 0 === a || "string" === typeof a,
				e = {};
			d && (a = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {}
			}, e.metadata = {
				version: 4.5,
				type: "Object",
				generator: "Object3D.toJSON"
			});
			var g = {};
			g.uuid = this.uuid;
			g.type = this.type;
			"" !== this.name && (g.name = this.name);
			!0 === this.castShadow && (g.castShadow = !0);
			!0 === this.receiveShadow && (g.receiveShadow = !0);
			!1 === this.visible && (g.visible = !1);
			!1 === this.frustumCulled && (g.frustumCulled = !1);
			0 !== this.renderOrder &&
				(g.renderOrder = this.renderOrder);
			"{}" !== Rd(this.userData) && (g.userData = this.userData);
			g.layers = this.layers.mask;
			g.matrix = this.matrix.toArray();
			!1 === this.matrixAutoUpdate && (g.matrixAutoUpdate = !1);
			this.isMesh && 0 !== this.drawMode && (g.drawMode = this.drawMode);
			if (this.isMesh || this.isLine || this.isPoints) {
				g.geometry = b(a.geometries, this.geometry);
				var k = this.geometry.parameters;
				if (void 0 !== k && void 0 !== k.shapes)
					if (k = k.shapes, Array.isArray(k))
						for (var l = 0, m = k.length; l < m; l++) b(a.shapes, k[l]);
					else b(a.shapes, k)
			}
			if (void 0 !==
				this.material)
				if (Array.isArray(this.material)) {
					k = [];
					l = 0;
					for (m = this.material.length; l < m; l++) k.push(b(a.materials, this.material[l]));
					g.material = k
				} else g.material = b(a.materials, this.material);
			if (0 < this.children.length)
				for (g.children = [], l = 0; l < this.children.length; l++) g.children.push(this.children[l].toJSON(a).object);
			if (d) {
				d = c(a.geometries);
				l = c(a.materials);
				m = c(a.textures);
				var n = c(a.images);
				k = c(a.shapes);
				0 < d.length && (e.geometries = d);
				0 < l.length && (e.materials = l);
				0 < m.length && (e.textures = m);
				0 < n.length && (e.images =
					n);
				0 < k.length && (e.shapes = k)
			}
			e.object = g;
			return e
		},
		clone: function(a) {
			return (new this.constructor).copy(this, a)
		},
		copy: function(a, b) {
			void 0 === b && (b = !0);
			this.name = a.name;
			this.up.copy(a.up);
			this.position.copy(a.position);
			this.quaternion.copy(a.quaternion);
			this.scale.copy(a.scale);
			this.matrix.copy(a.matrix);
			this.matrixWorld.copy(a.matrixWorld);
			this.matrixAutoUpdate = a.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = a.matrixWorldNeedsUpdate;
			this.layers.mask = a.layers.mask;
			this.visible = a.visible;
			this.castShadow =
				a.castShadow;
			this.receiveShadow = a.receiveShadow;
			this.frustumCulled = a.frustumCulled;
			this.renderOrder = a.renderOrder;
			this.userData = JSON.parse(Rd(a.userData));
			if (!0 === b)
				for (b = 0; b < a.children.length; b++) this.add(a.children[b].clone());
			return this
		}
	});
	Bg.prototype = q(p(P.prototype), {
		constructor: Bg,
		isScene: !0,
		copy: function(a, b) {
			P.prototype.copy.call(this, a, b);
			null !== a.background && (this.background = a.background.clone());
			null !== a.fog && (this.fog = a.fog.clone());
			null !== a.overrideMaterial && (this.overrideMaterial =
				a.overrideMaterial.clone());
			this.autoUpdate = a.autoUpdate;
			this.matrixAutoUpdate = a.matrixAutoUpdate;
			return this
		},
		toJSON: function(a) {
			var b = P.prototype.toJSON.call(this, a);
			null !== this.background && (b.object.background = this.background.toJSON(a));
			null !== this.fog && (b.object.fog = this.fog.toJSON());
			return b
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	});
	var Ae = [new u, new u, new u, new u, new u, new u, new u, new u],
		dd = new u,
		ed = new u,
		Be = new u,
		Ld = new u,
		Db = new u,
		sc = new u,
		fd = new u,
		vf = new u,
		yi = new u,
		zi = new u,
		Bc = new u;
	q(Sd.prototype, {
		isBox3: !0,
		set: function(a, b) {
			this.min.copy(a);
			this.max.copy(b);
			return this
		},
		setFromArray: function(a) {
			for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, g = -Infinity, k = -Infinity, l = 0, m = a.length; l <
				m; l += 3) {
				var n = a[l],
					r = a[l + 1],
					p = a[l + 2];
				n < b && (b = n);
				r < c && (c = r);
				p < d && (d = p);
				n > e && (e = n);
				r > g && (g = r);
				p > k && (k = p)
			}
			this.min.set(b, c, d);
			this.max.set(e, g, k);
			return this
		},
		setFromBufferAttribute: function(a) {
			for (var b = Infinity, c = Infinity, d = Infinity, e = -Infinity, g = -Infinity, k = -Infinity, l = 0, m = a.count; l <
				m; l++) {
				var n = a.getX(l),
					r = a.getY(l),
					p = a.getZ(l);
				n < b && (b = n);
				r < c && (c = r);
				p < d && (d = p);
				n > e && (e = n);
				r > g && (g = r);
				p > k && (k = p)
			}
			this.min.set(b, c, d);
			this.max.set(e, g, k);
			return this
		},
		setFromPoints: function(a) {
			this.makeEmpty();
			for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
			return this
		},
		setFromCenterAndSize: function(a, b) {
			b = dd.copy(b).multiplyScalar(.5);
			this.min.copy(a).sub(b);
			this.max.copy(a).add(b);
			return this
		},
		setFromObject: function(a) {
			this.makeEmpty();
			return this.expandByObject(a)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.min.copy(a.min);
			this.max.copy(a.max);
			return this
		},
		makeEmpty: function() {
			this.min.x = this.min.y = this.min.z = Infinity;
			this.max.x = this.max.y = this.max.z = -Infinity;
			return this
		},
		isEmpty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
		},
		getCenter: function(a) {
			void 0 === a && (console.warn("THREE.Box3: .getCenter() target is now required"), a = new u);
			return this.isEmpty() ? a.set(0, 0, 0) : a.addVectors(this.min, this.max).multiplyScalar(.5)
		},
		getSize: function(a) {
			void 0 ===
				a && (console.warn("THREE.Box3: .getSize() target is now required"), a = new u);
			return this.isEmpty() ? a.set(0, 0, 0) : a.subVectors(this.max, this.min)
		},
		expandByPoint: function(a) {
			this.min.min(a);
			this.max.max(a);
			return this
		},
		expandByVector: function(a) {
			this.min.sub(a);
			this.max.add(a);
			return this
		},
		expandByScalar: function(a) {
			this.min.addScalar(-a);
			this.max.addScalar(a);
			return this
		},
		expandByObject: function(a) {
			var b;
			a.updateWorldMatrix(!1, !1);
			var c = a.geometry;
			if (void 0 !== c)
				if (c.isGeometry) {
					var d = c.vertices;
					c = 0;
					for (b =
						d.length; c < b; c++) dd.copy(d[c]), dd.applyMatrix4(a.matrixWorld), this.expandByPoint(dd)
				} else if (c.isBufferGeometry && (d = c.attributes.position, void 0 !== d))
				for (c = 0, b = d.count; c < b; c++) dd.fromBufferAttribute(d, c).applyMatrix4(a.matrixWorld), this.expandByPoint(
					dd);
			a = a.children;
			c = 0;
			for (b = a.length; c < b; c++) this.expandByObject(a[c]);
			return this
		},
		containsPoint: function(a) {
			return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z >
				this.max.z ? !1 : !0
		},
		containsBox: function(a) {
			return this.min.x <=
				a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z &&
				a.max.z <= this.max.z
		},
		getParameter: function(a, b) {
			void 0 === b && (console.warn("THREE.Box3: .getParameter() target is now required"), b = new u);
			return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z -
				this.min.z) / (this.max.z - this.min.z))
		},
		intersectsBox: function(a) {
			return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z <
				this.min.z ||
				a.min.z > this.max.z ? !1 : !0
		},
		intersectsSphere: function(a) {
			this.clampPoint(a.center, dd);
			return dd.distanceToSquared(a.center) <= a.radius * a.radius
		},
		intersectsPlane: function(a) {
			if (0 < a.normal.x) {
				var b = a.normal.x * this.min.x;
				var c = a.normal.x * this.max.x
			} else b = a.normal.x * this.max.x, c = a.normal.x * this.min.x;
			0 < a.normal.y ? (b += a.normal.y * this.min.y, c += a.normal.y * this.max.y) : (b += a.normal.y * this.max.y, c +=
				a.normal.y * this.min.y);
			0 < a.normal.z ? (b += a.normal.z * this.min.z, c += a.normal.z * this.max.z) : (b += a.normal.z * this.max.z,
				c += a.normal.z * this.min.z);
			return b <= -a.constant && c >= -a.constant
		},
		intersectsTriangle: function(a) {
			if (this.isEmpty()) return !1;
			this.getCenter(vf);
			yi.subVectors(this.max, vf);
			ed.subVectors(a.a, vf);
			Be.subVectors(a.b, vf);
			Ld.subVectors(a.c, vf);
			Db.subVectors(Be, ed);
			sc.subVectors(Ld, Be);
			fd.subVectors(ed, Ld);
			a = [0, -Db.z, Db.y, 0, -sc.z, sc.y, 0, -fd.z, fd.y, Db.z, 0, -Db.x, sc.z, 0, -sc.x, fd.z, 0, -fd.x, -Db.y, Db.x,
				0, -sc.y, sc.x, 0, -fd.y, fd.x, 0
			];
			if (!ak(a, ed, Be, Ld, yi)) return !1;
			a = [1, 0, 0, 0, 1, 0, 0, 0, 1];
			if (!ak(a, ed, Be, Ld, yi)) return !1;
			zi.crossVectors(Db, sc);
			a = [zi.x, zi.y, zi.z];
			return ak(a, ed, Be, Ld, yi)
		},
		clampPoint: function(a, b) {
			void 0 === b && (console.warn("THREE.Box3: .clampPoint() target is now required"), b = new u);
			return b.copy(a).clamp(this.min, this.max)
		},
		distanceToPoint: function(a) {
			return dd.copy(a).clamp(this.min, this.max).sub(a).length()
		},
		getBoundingSphere: function(a) {
			void 0 === a && console.error("THREE.Box3: .getBoundingSphere() target is now required");
			this.getCenter(a.center);
			a.radius = .5 * this.getSize(dd).length();
			return a
		},
		intersect: function(a) {
			this.min.max(a.min);
			this.max.min(a.max);
			this.isEmpty() && this.makeEmpty();
			return this
		},
		union: function(a) {
			this.min.min(a.min);
			this.max.max(a.max);
			return this
		},
		applyMatrix4: function(a) {
			if (this.isEmpty()) return this;
			Ae[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(a);
			Ae[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(a);
			Ae[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(a);
			Ae[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(a);
			Ae[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(a);
			Ae[5].set(this.max.x,
				this.min.y, this.max.z).applyMatrix4(a);
			Ae[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(a);
			Ae[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(a);
			this.setFromPoints(Ae);
			return this
		},
		translate: function(a) {
			this.min.add(a);
			this.max.add(a);
			return this
		},
		equals: function(a) {
			return a.min.equals(this.min) && a.max.equals(this.max)
		}
	});
	var Js = new Sd;
	q(Ne.prototype, {
		set: function(a, b) {
			this.center.copy(a);
			this.radius = b;
			return this
		},
		setFromPoints: function(a, b) {
			var c = this.center;
			void 0 !== b ? c.copy(b) : Js.setFromPoints(a).getCenter(c);
			for (var d = b = 0, e = a.length; d < e; d++) b = Math.max(b, c.distanceToSquared(a[d]));
			this.radius = Math.sqrt(b);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.center.copy(a.center);
			this.radius = a.radius;
			return this
		},
		empty: function() {
			return 0 >= this.radius
		},
		containsPoint: function(a) {
			return a.distanceToSquared(this.center) <= this.radius * this.radius
		},
		distanceToPoint: function(a) {
			return a.distanceTo(this.center) - this.radius
		},
		intersectsSphere: function(a) {
			var b = this.radius + a.radius;
			return a.center.distanceToSquared(this.center) <= b * b
		},
		intersectsBox: function(a) {
			return a.intersectsSphere(this)
		},
		intersectsPlane: function(a) {
			return Math.abs(a.distanceToPoint(this.center)) <= this.radius
		},
		clampPoint: function(a, b) {
			var c = this.center.distanceToSquared(a);
			void 0 === b && (console.warn("THREE.Sphere: .clampPoint() target is now required"), b = new u);
			b.copy(a);
			c > this.radius * this.radius && (b.sub(this.center).normalize(), b.multiplyScalar(this.radius).add(this.center));
			return b
		},
		getBoundingBox: function(a) {
			void 0 ===
				a && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), a = new Sd);
			a.set(this.center, this.center);
			a.expandByScalar(this.radius);
			return a
		},
		applyMatrix4: function(a) {
			this.center.applyMatrix4(a);
			this.radius *= a.getMaxScaleOnAxis();
			return this
		},
		translate: function(a) {
			this.center.add(a);
			return this
		},
		equals: function(a) {
			return a.center.equals(this.center) && a.radius === this.radius
		}
	});
	var tb = new u,
		Rl = new u,
		Ai = new u,
		Eb = new u,
		Sl = new u,
		qh = new u,
		Tl = new u;
	q(wf.prototype, {
		set: function(a, b) {
			this.origin.copy(a);
			this.direction.copy(b);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.origin.copy(a.origin);
			this.direction.copy(a.direction);
			return this
		},
		at: function(a, b) {
			void 0 === b && (console.warn("THREE.Ray: .at() target is now required"), b = new u);
			return b.copy(this.direction).multiplyScalar(a).add(this.origin)
		},
		lookAt: function(a) {
			this.direction.copy(a).sub(this.origin).normalize();
			return this
		},
		recast: function(a) {
			this.origin.copy(this.at(a, tb));
			return this
		},
		closestPointToPoint: function(a,
			b) {
			void 0 === b && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), b = new u);
			b.subVectors(a, this.origin);
			a = b.dot(this.direction);
			return 0 > a ? b.copy(this.origin) : b.copy(this.direction).multiplyScalar(a).add(this.origin)
		},
		distanceToPoint: function(a) {
			return Math.sqrt(this.distanceSqToPoint(a))
		},
		distanceSqToPoint: function(a) {
			var b = tb.subVectors(a, this.origin).dot(this.direction);
			if (0 > b) return this.origin.distanceToSquared(a);
			tb.copy(this.direction).multiplyScalar(b).add(this.origin);
			return tb.distanceToSquared(a)
		},
		distanceSqToSegment: function(a, b, c, d) {
			Rl.copy(a).add(b).multiplyScalar(.5);
			Ai.copy(b).sub(a).normalize();
			Eb.copy(this.origin).sub(Rl);
			var e = .5 * a.distanceTo(b),
				g = -this.direction.dot(Ai),
				k = Eb.dot(this.direction),
				l = -Eb.dot(Ai),
				m = Eb.lengthSq(),
				n = Math.abs(1 - g * g);
			if (0 < n) {
				a = g * l - k;
				b = g * k - l;
				var r = e * n;
				0 <= a ? b >= -r ? b <= r ? (e = 1 / n, a *= e, b *= e, g = a * (a + g * b + 2 * k) + b * (g * a + b + 2 * l) +
						m) : (b = e, a = Math.max(0, -(g * b + k)), g = -a * a + b * (b + 2 * l) + m) : (b = -e, a = Math.max(0, -(g *
						b + k)), g = -a * a + b * (b + 2 * l) + m) : b <= -r ? (a = Math.max(0,
						-(-g * e + k)), b = 0 < a ? -e : Math.min(Math.max(-e, -l), e), g = -a * a + b * (b + 2 * l) + m) : b <= r ?
					(a = 0, b = Math.min(Math.max(-e, -l), e), g = b * (b + 2 * l) + m) : (a = Math.max(0, -(g * e + k)), b = 0 <
						a ? e : Math.min(Math.max(-e, -l), e), g = -a * a + b * (b + 2 * l) + m)
			} else b = 0 < g ? -e : e, a = Math.max(0, -(g * b + k)), g = -a * a + b * (b + 2 * l) + m;
			c && c.copy(this.direction).multiplyScalar(a).add(this.origin);
			d && d.copy(Ai).multiplyScalar(b).add(Rl);
			return g
		},
		intersectSphere: function(a, b) {
			tb.subVectors(a.center, this.origin);
			var c = tb.dot(this.direction),
				d = tb.dot(tb) - c * c;
			a = a.radius * a.radius;
			if (d > a) return null;
			a = Math.sqrt(a - d);
			d = c - a;
			c += a;
			return 0 > d && 0 > c ? null : 0 > d ? this.at(c, b) : this.at(d, b)
		},
		intersectsSphere: function(a) {
			return this.distanceSqToPoint(a.center) <= a.radius * a.radius
		},
		distanceToPlane: function(a) {
			var b = a.normal.dot(this.direction);
			if (0 === b) return 0 === a.distanceToPoint(this.origin) ? 0 : null;
			a = -(this.origin.dot(a.normal) + a.constant) / b;
			return 0 <= a ? a : null
		},
		intersectPlane: function(a, b) {
			a = this.distanceToPlane(a);
			return null === a ? null : this.at(a, b)
		},
		intersectsPlane: function(a) {
			var b = a.distanceToPoint(this.origin);
			return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
		},
		intersectBox: function(a, b) {
			var c = 1 / this.direction.x;
			var d = 1 / this.direction.y;
			var e = 1 / this.direction.z,
				g = this.origin;
			if (0 <= c) {
				var k = (a.min.x - g.x) * c;
				c *= a.max.x - g.x
			} else k = (a.max.x - g.x) * c, c *= a.min.x - g.x;
			if (0 <= d) {
				var l = (a.min.y - g.y) * d;
				d *= a.max.y - g.y
			} else l = (a.max.y - g.y) * d, d *= a.min.y - g.y;
			if (k > d || l > c) return null;
			if (l > k || k !== k) k = l;
			if (d < c || c !== c) c = d;
			0 <= e ? (l = (a.min.z - g.z) * e, a = (a.max.z - g.z) * e) : (l = (a.max.z - g.z) * e, a = (a.min.z - g.z) * e);
			if (k > a || l > c) return null;
			if (l > k || k !== k) k = l;
			if (a < c || c !== c) c = a;
			return 0 > c ? null : this.at(0 <= k ? k : c, b)
		},
		intersectsBox: function(a) {
			return null !== this.intersectBox(a, tb)
		},
		intersectTriangle: function(a, b, c, d, e) {
			Sl.subVectors(b, a);
			qh.subVectors(c, a);
			Tl.crossVectors(Sl, qh);
			b = this.direction.dot(Tl);
			if (0 < b) {
				if (d) return null;
				d = 1
			} else if (0 > b) d = -1, b = -b;
			else return null;
			Eb.subVectors(this.origin, a);
			a = d * this.direction.dot(qh.crossVectors(Eb, qh));
			if (0 > a) return null;
			c = d * this.direction.dot(Sl.cross(Eb));
			if (0 > c || a + c > b) return null;
			a = -d * Eb.dot(Tl);
			return 0 > a ? null : this.at(a / b, e)
		},
		applyMatrix4: function(a) {
			this.origin.applyMatrix4(a);
			this.direction.transformDirection(a);
			return this
		},
		equals: function(a) {
			return a.origin.equals(this.origin) && a.direction.equals(this.direction)
		}
	});
	var gd = new u,
		ub = new u,
		Ul = new u,
		Md = new u,
		Ce = new u,
		De = new u,
		Oo = new u,
		Vl = new u,
		Wl = new u,
		Xl = new u;
	q(ob, {
		getNormal: function(a, b, c, d) {
			void 0 === d && (console.warn("THREE.Triangle: .getNormal() target is now required"), d = new u);
			d.subVectors(c, b);
			gd.subVectors(a, b);
			d.cross(gd);
			a = d.lengthSq();
			return 0 < a ? d.multiplyScalar(1 / Math.sqrt(a)) : d.set(0, 0, 0)
		},
		getBarycoord: function(a, b, c, d, e) {
			gd.subVectors(d, b);
			ub.subVectors(c, b);
			Ul.subVectors(a, b);
			a = gd.dot(gd);
			b = gd.dot(ub);
			c = gd.dot(Ul);
			var g = ub.dot(ub);
			d = ub.dot(Ul);
			var k = a * g - b * b;
			void 0 === e && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), e = new u);
			if (0 === k) return e.set(-2, -1, -1);
			k = 1 / k;
			g = (g * c - b * d) * k;
			a = (a * d - b * c) * k;
			return e.set(1 - g - a, a, g)
		},
		containsPoint: function(a, b, c, d) {
			ob.getBarycoord(a, b, c, d, Md);
			return 0 <= Md.x && 0 <= Md.y && 1 >=
				Md.x + Md.y
		},
		getUV: function(a, b, c, d, e, g, k, l) {
			this.getBarycoord(a, b, c, d, Md);
			l.set(0, 0);
			l.addScaledVector(e, Md.x);
			l.addScaledVector(g, Md.y);
			l.addScaledVector(k, Md.z);
			return l
		},
		isFrontFacing: function(a, b, c, d) {
			gd.subVectors(c, b);
			ub.subVectors(a, b);
			return 0 > gd.cross(ub).dot(d) ? !0 : !1
		}
	});
	q(ob.prototype, {
		set: function(a, b, c) {
			this.a.copy(a);
			this.b.copy(b);
			this.c.copy(c);
			return this
		},
		setFromPointsAndIndices: function(a, b, c, d) {
			this.a.copy(a[b]);
			this.b.copy(a[c]);
			this.c.copy(a[d]);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.a.copy(a.a);
			this.b.copy(a.b);
			this.c.copy(a.c);
			return this
		},
		getArea: function() {
			gd.subVectors(this.c, this.b);
			ub.subVectors(this.a, this.b);
			return .5 * gd.cross(ub).length()
		},
		getMidpoint: function(a) {
			void 0 === a && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), a = new u);
			return a.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
		},
		getNormal: function(a) {
			return ob.getNormal(this.a, this.b, this.c, a)
		},
		getPlane: function(a) {
			void 0 === a && (console.warn("THREE.Triangle: .getPlane() target is now required"),
				a = new u);
			return a.setFromCoplanarPoints(this.a, this.b, this.c)
		},
		getBarycoord: function(a, b) {
			return ob.getBarycoord(a, this.a, this.b, this.c, b)
		},
		getUV: function(a, b, c, d, e) {
			return ob.getUV(a, this.a, this.b, this.c, b, c, d, e)
		},
		containsPoint: function(a) {
			return ob.containsPoint(a, this.a, this.b, this.c)
		},
		isFrontFacing: function(a) {
			return ob.isFrontFacing(this.a, this.b, this.c, a)
		},
		intersectsBox: function(a) {
			return a.intersectsTriangle(this)
		},
		closestPointToPoint: function(a, b) {
			void 0 === b && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"),
				b = new u);
			var c = this.a,
				d = this.b,
				e = this.c;
			Ce.subVectors(d, c);
			De.subVectors(e, c);
			Vl.subVectors(a, c);
			var g = Ce.dot(Vl),
				k = De.dot(Vl);
			if (0 >= g && 0 >= k) return b.copy(c);
			Wl.subVectors(a, d);
			var l = Ce.dot(Wl),
				m = De.dot(Wl);
			if (0 <= l && m <= l) return b.copy(d);
			var n = g * m - l * k;
			if (0 >= n && 0 <= g && 0 >= l) return d = g / (g - l), b.copy(c).addScaledVector(Ce, d);
			Xl.subVectors(a, e);
			a = Ce.dot(Xl);
			var r = De.dot(Xl);
			if (0 <= r && a <= r) return b.copy(e);
			g = a * k - g * r;
			if (0 >= g && 0 <= k && 0 >= r) return n = k / (k - r), b.copy(c).addScaledVector(De, n);
			k = l * r - a * m;
			if (0 >= k && 0 <=
				m - l && 0 <= a - r) return Oo.subVectors(e, d), n = (m - l) / (m - l + (a - r)), b.copy(d).addScaledVector(Oo,
				n);
			e = 1 / (k + g + n);
			d = g * e;
			n *= e;
			return b.copy(c).addScaledVector(Ce, d).addScaledVector(De, n)
		},
		equals: function(a) {
			return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
		}
	});
	var Ks = {
			aliceblue: 15792383,
			antiquewhite: 16444375,
			aqua: 65535,
			aquamarine: 8388564,
			azure: 15794175,
			beige: 16119260,
			bisque: 16770244,
			black: 0,
			blanchedalmond: 16772045,
			blue: 255,
			blueviolet: 9055202,
			brown: 10824234,
			burlywood: 14596231,
			cadetblue: 6266528,
			chartreuse: 8388352,
			chocolate: 13789470,
			coral: 16744272,
			cornflowerblue: 6591981,
			cornsilk: 16775388,
			crimson: 14423100,
			cyan: 65535,
			darkblue: 139,
			darkcyan: 35723,
			darkgoldenrod: 12092939,
			darkgray: 11119017,
			darkgreen: 25600,
			darkgrey: 11119017,
			darkkhaki: 12433259,
			darkmagenta: 9109643,
			darkolivegreen: 5597999,
			darkorange: 16747520,
			darkorchid: 10040012,
			darkred: 9109504,
			darksalmon: 15308410,
			darkseagreen: 9419919,
			darkslateblue: 4734347,
			darkslategray: 3100495,
			darkslategrey: 3100495,
			darkturquoise: 52945,
			darkviolet: 9699539,
			deeppink: 16716947,
			deepskyblue: 49151,
			dimgray: 6908265,
			dimgrey: 6908265,
			dodgerblue: 2003199,
			firebrick: 11674146,
			floralwhite: 16775920,
			forestgreen: 2263842,
			fuchsia: 16711935,
			gainsboro: 14474460,
			ghostwhite: 16316671,
			gold: 16766720,
			goldenrod: 14329120,
			gray: 8421504,
			green: 32768,
			greenyellow: 11403055,
			grey: 8421504,
			honeydew: 15794160,
			hotpink: 16738740,
			indianred: 13458524,
			indigo: 4915330,
			ivory: 16777200,
			khaki: 15787660,
			lavender: 15132410,
			lavenderblush: 16773365,
			lawngreen: 8190976,
			lemonchiffon: 16775885,
			lightblue: 11393254,
			lightcoral: 15761536,
			lightcyan: 14745599,
			lightgoldenrodyellow: 16448210,
			lightgray: 13882323,
			lightgreen: 9498256,
			lightgrey: 13882323,
			lightpink: 16758465,
			lightsalmon: 16752762,
			lightseagreen: 2142890,
			lightskyblue: 8900346,
			lightslategray: 7833753,
			lightslategrey: 7833753,
			lightsteelblue: 11584734,
			lightyellow: 16777184,
			lime: 65280,
			limegreen: 3329330,
			linen: 16445670,
			magenta: 16711935,
			maroon: 8388608,
			mediumaquamarine: 6737322,
			mediumblue: 205,
			mediumorchid: 12211667,
			mediumpurple: 9662683,
			mediumseagreen: 3978097,
			mediumslateblue: 8087790,
			mediumspringgreen: 64154,
			mediumturquoise: 4772300,
			mediumvioletred: 13047173,
			midnightblue: 1644912,
			mintcream: 16121850,
			mistyrose: 16770273,
			moccasin: 16770229,
			navajowhite: 16768685,
			navy: 128,
			oldlace: 16643558,
			olive: 8421376,
			olivedrab: 7048739,
			orange: 16753920,
			orangered: 16729344,
			orchid: 14315734,
			palegoldenrod: 15657130,
			palegreen: 10025880,
			paleturquoise: 11529966,
			palevioletred: 14381203,
			papayawhip: 16773077,
			peachpuff: 16767673,
			peru: 13468991,
			pink: 16761035,
			plum: 14524637,
			powderblue: 11591910,
			purple: 8388736,
			rebeccapurple: 6697881,
			red: 16711680,
			rosybrown: 12357519,
			royalblue: 4286945,
			saddlebrown: 9127187,
			salmon: 16416882,
			sandybrown: 16032864,
			seagreen: 3050327,
			seashell: 16774638,
			sienna: 10506797,
			silver: 12632256,
			skyblue: 8900331,
			slateblue: 6970061,
			slategray: 7372944,
			slategrey: 7372944,
			snow: 16775930,
			springgreen: 65407,
			steelblue: 4620980,
			tan: 13808780,
			teal: 32896,
			thistle: 14204888,
			tomato: 16737095,
			turquoise: 4251856,
			violet: 15631086,
			wheat: 16113331,
			white: 16777215,
			whitesmoke: 16119285,
			yellow: 16776960,
			yellowgreen: 10145074
		},
		Mb = {
			h: 0,
			s: 0,
			l: 0
		},
		Vj = {
			h: 0,
			s: 0,
			l: 0
		};
	q(S.prototype, {
		isColor: !0,
		r: 1,
		g: 1,
		b: 1,
		set: function(a) {
			a && a.isColor ?
				this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
			return this
		},
		setScalar: function(a) {
			this.b = this.g = this.r = a;
			return this
		},
		setHex: function(a) {
			a = Math.floor(a);
			this.r = (a >> 16 & 255) / 255;
			this.g = (a >> 8 & 255) / 255;
			this.b = (a & 255) / 255;
			return this
		},
		setRGB: function(a, b, c) {
			this.r = a;
			this.g = b;
			this.b = c;
			return this
		},
		setHSL: function(a, b, c) {
			a = ha.euclideanModulo(a, 1);
			b = ha.clamp(b, 0, 1);
			c = ha.clamp(c, 0, 1);
			0 === b ? this.r = this.g = this.b = c : (b = .5 >= c ? c * (1 + b) : c + b - c * b, c = 2 * c - b, this.r = Oi(
					c, b, a + 1 / 3), this.g =
				Oi(c, b, a), this.b = Oi(c, b, a - 1 / 3));
			return this
		},
		setStyle: function(a) {
			function b(b) {
				void 0 !== b && 1 > parseFloat(b) && console.warn("THREE.Color: Alpha component of " + a + " will be ignored.")
			}
			var c;
			if (c = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(a)) {
				var d = c[2];
				switch (c[1]) {
					case "rgb":
					case "rgba":
						if (c = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(255,
								parseInt(c[1], 10)) / 255, this.g = Math.min(255, parseInt(c[2], 10)) / 255, this.b = Math.min(255,
								parseInt(c[3], 10)) / 255, b(c[5]),
							this;
						if (c = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) return this.r = Math.min(
							100, parseInt(c[1], 10)) / 100, this.g = Math.min(100, parseInt(c[2], 10)) / 100, this.b = Math.min(100,
							parseInt(c[3], 10)) / 100, b(c[5]), this;
						break;
					case "hsl":
					case "hsla":
						if (c = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(d)) {
							d = parseFloat(c[1]) / 360;
							var e = parseInt(c[2], 10) / 100,
								g = parseInt(c[3], 10) / 100;
							b(c[5]);
							return this.setHSL(d, e, g)
						}
				}
			} else if (c = /^#([A-Fa-f0-9]+)$/.exec(a)) {
				c =
					c[1];
				d = c.length;
				if (3 === d) return this.r = parseInt(c.charAt(0) + c.charAt(0), 16) / 255, this.g = parseInt(c.charAt(1) + c.charAt(
					1), 16) / 255, this.b = parseInt(c.charAt(2) + c.charAt(2), 16) / 255, this;
				if (6 === d) return this.r = parseInt(c.charAt(0) + c.charAt(1), 16) / 255, this.g = parseInt(c.charAt(2) + c.charAt(
					3), 16) / 255, this.b = parseInt(c.charAt(4) + c.charAt(5), 16) / 255, this
			}
			a && 0 < a.length && (c = Ks[a], void 0 !== c ? this.setHex(c) : console.warn("THREE.Color: Unknown color " + a));
			return this
		},
		clone: function() {
			return new this.constructor(this.r,
				this.g, this.b)
		},
		copy: function(a) {
			this.r = a.r;
			this.g = a.g;
			this.b = a.b;
			return this
		},
		copyGammaToLinear: function(a, b) {
			void 0 === b && (b = 2);
			this.r = Math.pow(a.r, b);
			this.g = Math.pow(a.g, b);
			this.b = Math.pow(a.b, b);
			return this
		},
		copyLinearToGamma: function(a, b) {
			void 0 === b && (b = 2);
			b = 0 < b ? 1 / b : 1;
			this.r = Math.pow(a.r, b);
			this.g = Math.pow(a.g, b);
			this.b = Math.pow(a.b, b);
			return this
		},
		convertGammaToLinear: function(a) {
			this.copyGammaToLinear(this, a);
			return this
		},
		convertLinearToGamma: function(a) {
			this.copyLinearToGamma(this, a);
			return this
		},
		copySRGBToLinear: function(a) {
			this.r = yh(a.r);
			this.g = yh(a.g);
			this.b = yh(a.b);
			return this
		},
		copyLinearToSRGB: function(a) {
			this.r = zh(a.r);
			this.g = zh(a.g);
			this.b = zh(a.b);
			return this
		},
		convertSRGBToLinear: function() {
			this.copySRGBToLinear(this);
			return this
		},
		convertLinearToSRGB: function() {
			this.copyLinearToSRGB(this);
			return this
		},
		getHex: function() {
			return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
		},
		getHexString: function() {
			return ("000000" + this.getHex().toString(16)).slice(-6)
		},
		getHSL: function(a) {
			void 0 === a && (console.warn("THREE.Color: .getHSL() target is now required"),
				a = {
					h: 0,
					s: 0,
					l: 0
				});
			var b = this.r,
				c = this.g,
				d = this.b,
				e = Math.max(b, c, d),
				g = Math.min(b, c, d),
				k, l = (g + e) / 2;
			if (g === e) g = k = 0;
			else {
				var m = e - g;
				g = .5 >= l ? m / (e + g) : m / (2 - e - g);
				switch (e) {
					case b:
						k = (c - d) / m + (c < d ? 6 : 0);
						break;
					case c:
						k = (d - b) / m + 2;
						break;
					case d:
						k = (b - c) / m + 4
				}
				k /= 6
			}
			a.h = k;
			a.s = g;
			a.l = l;
			return a
		},
		getStyle: function() {
			return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
		},
		offsetHSL: function(a, b, c) {
			this.getHSL(Mb);
			Mb.h += a;
			Mb.s += b;
			Mb.l += c;
			this.setHSL(Mb.h, Mb.s, Mb.l);
			return this
		},
		add: function(a) {
			this.r += a.r;
			this.g +=
				a.g;
			this.b += a.b;
			return this
		},
		addColors: function(a, b) {
			this.r = a.r + b.r;
			this.g = a.g + b.g;
			this.b = a.b + b.b;
			return this
		},
		addScalar: function(a) {
			this.r += a;
			this.g += a;
			this.b += a;
			return this
		},
		sub: function(a) {
			this.r = Math.max(0, this.r - a.r);
			this.g = Math.max(0, this.g - a.g);
			this.b = Math.max(0, this.b - a.b);
			return this
		},
		multiply: function(a) {
			this.r *= a.r;
			this.g *= a.g;
			this.b *= a.b;
			return this
		},
		multiplyScalar: function(a) {
			this.r *= a;
			this.g *= a;
			this.b *= a;
			return this
		},
		lerp: function(a, b) {
			this.r += (a.r - this.r) * b;
			this.g += (a.g - this.g) * b;
			this.b +=
				(a.b - this.b) * b;
			return this
		},
		lerpHSL: function(a, b) {
			this.getHSL(Mb);
			a.getHSL(Vj);
			a = ha.lerp(Mb.h, Vj.h, b);
			var c = ha.lerp(Mb.s, Vj.s, b);
			b = ha.lerp(Mb.l, Vj.l, b);
			this.setHSL(a, c, b);
			return this
		},
		equals: function(a) {
			return a.r === this.r && a.g === this.g && a.b === this.b
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			this.r = a[b];
			this.g = a[b + 1];
			this.b = a[b + 2];
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			a[b] = this.r;
			a[b + 1] = this.g;
			a[b + 2] = this.b;
			return a
		},
		toJSON: function() {
			return this.getHex()
		}
	});
	q(Ah.prototype, {
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.a = a.a;
			this.b = a.b;
			this.c = a.c;
			this.normal.copy(a.normal);
			this.color.copy(a.color);
			this.materialIndex = a.materialIndex;
			for (var b = 0, c = a.vertexNormals.length; b < c; b++) this.vertexNormals[b] = a.vertexNormals[b].clone();
			b = 0;
			for (c = a.vertexColors.length; b < c; b++) this.vertexColors[b] = a.vertexColors[b].clone();
			return this
		}
	});
	var wp = 0;
	ia.prototype = q(p(nb.prototype), {
		constructor: ia,
		isMaterial: !0,
		onBeforeCompile: function() {},
		setValues: function(a) {
			if (void 0 !==
				a)
				for (var b in a) {
					var c = a[b];
					if (void 0 === c) console.warn("THREE.Material: '" + b + "' parameter is undefined.");
					else if ("shading" === b) console.warn("THREE." + this.type +
						": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === c ? !0 : !1;
					else {
						var d = this[b];
						void 0 === d ? console.warn("THREE." + this.type + ": '" + b + "' is not a property of this material.") : d &&
							d.isColor ? d.set(c) : d && d.isVector3 && c && c.isVector3 ? d.copy(c) : this[b] = c
					}
				}
		},
		toJSON: function(a) {
			function b(a) {
				var b = [],
					c;
				for (c in a) {
					var d =
						a[c];
					delete d.metadata;
					b.push(d)
				}
				return b
			}
			var c = void 0 === a || "string" === typeof a;
			c && (a = {
				textures: {},
				images: {}
			});
			var d = {
				metadata: {
					version: 4.5,
					type: "Material",
					generator: "Material.toJSON"
				}
			};
			d.uuid = this.uuid;
			d.type = this.type;
			"" !== this.name && (d.name = this.name);
			this.color && this.color.isColor && (d.color = this.color.getHex());
			void 0 !== this.roughness && (d.roughness = this.roughness);
			void 0 !== this.metalness && (d.metalness = this.metalness);
			this.sheen && this.sheen.isColor && (d.sheen = this.sheen.getHex());
			this.emissive &&
				this.emissive.isColor && (d.emissive = this.emissive.getHex());
			this.emissiveIntensity && 1 !== this.emissiveIntensity && (d.emissiveIntensity = this.emissiveIntensity);
			this.specular && this.specular.isColor && (d.specular = this.specular.getHex());
			void 0 !== this.shininess && (d.shininess = this.shininess);
			void 0 !== this.clearcoat && (d.clearcoat = this.clearcoat);
			void 0 !== this.clearcoatRoughness && (d.clearcoatRoughness = this.clearcoatRoughness);
			this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (d.clearcoatNormalMap =
				this.clearcoatNormalMap.toJSON(a).uuid, d.clearcoatNormalScale = this.clearcoatNormalScale.toArray());
			this.map && this.map.isTexture && (d.map = this.map.toJSON(a).uuid);
			this.matcap && this.matcap.isTexture && (d.matcap = this.matcap.toJSON(a).uuid);
			this.alphaMap && this.alphaMap.isTexture && (d.alphaMap = this.alphaMap.toJSON(a).uuid);
			this.lightMap && this.lightMap.isTexture && (d.lightMap = this.lightMap.toJSON(a).uuid);
			this.aoMap && this.aoMap.isTexture && (d.aoMap = this.aoMap.toJSON(a).uuid, d.aoMapIntensity = this.aoMapIntensity);
			this.bumpMap && this.bumpMap.isTexture && (d.bumpMap = this.bumpMap.toJSON(a).uuid, d.bumpScale = this.bumpScale);
			this.normalMap && this.normalMap.isTexture && (d.normalMap = this.normalMap.toJSON(a).uuid, d.normalMapType =
				this.normalMapType, d.normalScale = this.normalScale.toArray());
			this.displacementMap && this.displacementMap.isTexture && (d.displacementMap = this.displacementMap.toJSON(a).uuid,
				d.displacementScale = this.displacementScale, d.displacementBias = this.displacementBias);
			this.roughnessMap && this.roughnessMap.isTexture &&
				(d.roughnessMap = this.roughnessMap.toJSON(a).uuid);
			this.metalnessMap && this.metalnessMap.isTexture && (d.metalnessMap = this.metalnessMap.toJSON(a).uuid);
			this.emissiveMap && this.emissiveMap.isTexture && (d.emissiveMap = this.emissiveMap.toJSON(a).uuid);
			this.specularMap && this.specularMap.isTexture && (d.specularMap = this.specularMap.toJSON(a).uuid);
			this.envMap && this.envMap.isTexture && (d.envMap = this.envMap.toJSON(a).uuid, d.reflectivity = this.reflectivity,
				d.refractionRatio = this.refractionRatio, void 0 !== this.combine &&
				(d.combine = this.combine), void 0 !== this.envMapIntensity && (d.envMapIntensity = this.envMapIntensity));
			this.gradientMap && this.gradientMap.isTexture && (d.gradientMap = this.gradientMap.toJSON(a).uuid);
			void 0 !== this.size && (d.size = this.size);
			void 0 !== this.sizeAttenuation && (d.sizeAttenuation = this.sizeAttenuation);
			1 !== this.blending && (d.blending = this.blending);
			!0 === this.flatShading && (d.flatShading = this.flatShading);
			0 !== this.side && (d.side = this.side);
			0 !== this.vertexColors && (d.vertexColors = this.vertexColors);
			1 > this.opacity &&
				(d.opacity = this.opacity);
			!0 === this.transparent && (d.transparent = this.transparent);
			d.depthFunc = this.depthFunc;
			d.depthTest = this.depthTest;
			d.depthWrite = this.depthWrite;
			d.stencilWrite = this.stencilWrite;
			d.stencilWriteMask = this.stencilWriteMask;
			d.stencilFunc = this.stencilFunc;
			d.stencilRef = this.stencilRef;
			d.stencilFuncMask = this.stencilFuncMask;
			d.stencilFail = this.stencilFail;
			d.stencilZFail = this.stencilZFail;
			d.stencilZPass = this.stencilZPass;
			this.rotation && 0 !== this.rotation && (d.rotation = this.rotation);
			!0 === this.polygonOffset &&
				(d.polygonOffset = !0);
			0 !== this.polygonOffsetFactor && (d.polygonOffsetFactor = this.polygonOffsetFactor);
			0 !== this.polygonOffsetUnits && (d.polygonOffsetUnits = this.polygonOffsetUnits);
			this.linewidth && 1 !== this.linewidth && (d.linewidth = this.linewidth);
			void 0 !== this.dashSize && (d.dashSize = this.dashSize);
			void 0 !== this.gapSize && (d.gapSize = this.gapSize);
			void 0 !== this.scale && (d.scale = this.scale);
			!0 === this.dithering && (d.dithering = !0);
			0 < this.alphaTest && (d.alphaTest = this.alphaTest);
			!0 === this.premultipliedAlpha && (d.premultipliedAlpha =
				this.premultipliedAlpha);
			!0 === this.wireframe && (d.wireframe = this.wireframe);
			1 < this.wireframeLinewidth && (d.wireframeLinewidth = this.wireframeLinewidth);
			"round" !== this.wireframeLinecap && (d.wireframeLinecap = this.wireframeLinecap);
			"round" !== this.wireframeLinejoin && (d.wireframeLinejoin = this.wireframeLinejoin);
			!0 === this.morphTargets && (d.morphTargets = !0);
			!0 === this.morphNormals && (d.morphNormals = !0);
			!0 === this.skinning && (d.skinning = !0);
			!1 === this.visible && (d.visible = !1);
			!1 === this.toneMapped && (d.toneMapped = !1);
			"{}" !== Rd(this.userData) && (d.userData = this.userData);
			c && (c = b(a.textures), a = b(a.images), 0 < c.length && (d.textures = c), 0 < a.length && (d.images = a));
			return d
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.name = a.name;
			this.fog = a.fog;
			this.blending = a.blending;
			this.side = a.side;
			this.flatShading = a.flatShading;
			this.vertexColors = a.vertexColors;
			this.opacity = a.opacity;
			this.transparent = a.transparent;
			this.blendSrc = a.blendSrc;
			this.blendDst = a.blendDst;
			this.blendEquation = a.blendEquation;
			this.blendSrcAlpha = a.blendSrcAlpha;
			this.blendDstAlpha = a.blendDstAlpha;
			this.blendEquationAlpha = a.blendEquationAlpha;
			this.depthFunc = a.depthFunc;
			this.depthTest = a.depthTest;
			this.depthWrite = a.depthWrite;
			this.stencilWrite = a.stencilWrite;
			this.stencilWriteMask = a.stencilWriteMask;
			this.stencilFunc = a.stencilFunc;
			this.stencilRef = a.stencilRef;
			this.stencilFuncMask = a.stencilFuncMask;
			this.stencilFail = a.stencilFail;
			this.stencilZFail = a.stencilZFail;
			this.stencilZPass = a.stencilZPass;
			this.colorWrite = a.colorWrite;
			this.precision =
				a.precision;
			this.polygonOffset = a.polygonOffset;
			this.polygonOffsetFactor = a.polygonOffsetFactor;
			this.polygonOffsetUnits = a.polygonOffsetUnits;
			this.dithering = a.dithering;
			this.alphaTest = a.alphaTest;
			this.premultipliedAlpha = a.premultipliedAlpha;
			this.visible = a.visible;
			this.toneMapped = a.toneMapped;
			this.userData = JSON.parse(Rd(a.userData));
			this.clipShadows = a.clipShadows;
			this.clipIntersection = a.clipIntersection;
			var b = a.clippingPlanes,
				c = null;
			if (null !== b) {
				var d = b.length;
				c = Array(d);
				for (var e = 0; e !== d; ++e) c[e] = b[e].clone()
			}
			this.clippingPlanes =
				c;
			this.shadowSide = a.shadowSide;
			return this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	});
	Ob.prototype = p(ia.prototype);
	Ob.prototype.constructor = Ob;
	Ob.prototype.isMeshBasicMaterial = !0;
	Ob.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.map = a.map;
		this.lightMap = a.lightMap;
		this.lightMapIntensity = a.lightMapIntensity;
		this.aoMap = a.aoMap;
		this.aoMapIntensity = a.aoMapIntensity;
		this.specularMap = a.specularMap;
		this.alphaMap = a.alphaMap;
		this.envMap = a.envMap;
		this.combine =
			a.combine;
		this.reflectivity = a.reflectivity;
		this.refractionRatio = a.refractionRatio;
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		this.wireframeLinecap = a.wireframeLinecap;
		this.wireframeLinejoin = a.wireframeLinejoin;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		return this
	};
	Object.defineProperty(F.prototype, "needsUpdate", {
		set: function(a) {
			!0 === a && this.version++
		}
	});
	q(F.prototype, {
		isBufferAttribute: !0,
		onUploadCallback: function() {},
		setDynamic: function(a) {
			this.dynamic =
				a;
			return this
		},
		copy: function(a) {
			this.name = a.name;
			this.array = new a.array.constructor(a.array);
			this.itemSize = a.itemSize;
			this.count = a.count;
			this.normalized = a.normalized;
			this.dynamic = a.dynamic;
			return this
		},
		copyAt: function(a, b, c) {
			a *= this.itemSize;
			c *= b.itemSize;
			for (var d = 0, e = this.itemSize; d < e; d++) this.array[a + d] = b.array[c + d];
			return this
		},
		copyArray: function(a) {
			this.array.set(a);
			return this
		},
		copyColorsArray: function(a) {
			for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
				var g = a[d];
				void 0 === g && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",
					d), g = new S);
				b[c++] = g.r;
				b[c++] = g.g;
				b[c++] = g.b
			}
			return this
		},
		copyVector2sArray: function(a) {
			for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
				var g = a[d];
				void 0 === g && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", d), g = new B);
				b[c++] = g.x;
				b[c++] = g.y
			}
			return this
		},
		copyVector3sArray: function(a) {
			for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
				var g = a[d];
				void 0 === g && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", d), g = new u);
				b[c++] = g.x;
				b[c++] = g.y;
				b[c++] = g.z
			}
			return this
		},
		copyVector4sArray: function(a) {
			for (var b = this.array, c = 0, d = 0, e = a.length; d < e; d++) {
				var g = a[d];
				void 0 === g && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", d), g = new za);
				b[c++] = g.x;
				b[c++] = g.y;
				b[c++] = g.z;
				b[c++] = g.w
			}
			return this
		},
		set: function(a, b) {
			void 0 === b && (b = 0);
			this.array.set(a, b);
			return this
		},
		getX: function(a) {
			return this.array[a * this.itemSize]
		},
		setX: function(a, b) {
			this.array[a * this.itemSize] = b;
			return this
		},
		getY: function(a) {
			return this.array[a * this.itemSize +
				1]
		},
		setY: function(a, b) {
			this.array[a * this.itemSize + 1] = b;
			return this
		},
		getZ: function(a) {
			return this.array[a * this.itemSize + 2]
		},
		setZ: function(a, b) {
			this.array[a * this.itemSize + 2] = b;
			return this
		},
		getW: function(a) {
			return this.array[a * this.itemSize + 3]
		},
		setW: function(a, b) {
			this.array[a * this.itemSize + 3] = b;
			return this
		},
		setXY: function(a, b, c) {
			a *= this.itemSize;
			this.array[a + 0] = b;
			this.array[a + 1] = c;
			return this
		},
		setXYZ: function(a, b, c, d) {
			a *= this.itemSize;
			this.array[a + 0] = b;
			this.array[a + 1] = c;
			this.array[a + 2] = d;
			return this
		},
		setXYZW: function(a, b, c, d, e) {
			a *= this.itemSize;
			this.array[a + 0] = b;
			this.array[a + 1] = c;
			this.array[a + 2] = d;
			this.array[a + 3] = e;
			return this
		},
		onUpload: function(a) {
			this.onUploadCallback = a;
			return this
		},
		clone: function() {
			return (new this.constructor(this.array, this.itemSize)).copy(this)
		},
		toJSON: function() {
			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call(this.array),
				normalized: this.normalized
			}
		}
	});
	Bh.prototype = p(F.prototype);
	Bh.prototype.constructor = Bh;
	Ch.prototype = p(F.prototype);
	Ch.prototype.constructor = Ch;
	Dh.prototype = p(F.prototype);
	Dh.prototype.constructor = Dh;
	Eh.prototype = p(F.prototype);
	Eh.prototype.constructor = Eh;
	xf.prototype = p(F.prototype);
	xf.prototype.constructor = xf;
	bk.prototype = p(F.prototype);
	bk.prototype.constructor = bk;
	yf.prototype = p(F.prototype);
	yf.prototype.constructor = yf;
	N.prototype = p(F.prototype);
	N.prototype.constructor = N;
	Pi.prototype = p(F.prototype);
	Pi.prototype.constructor = Pi;
	q(qm.prototype, {
		computeGroups: function(a) {
			var b = [],
				c = void 0;
			a = a.faces;
			for (var d = 0; d <
				a.length; d++) {
				var e = a[d];
				if (e.materialIndex !== c) {
					c = e.materialIndex;
					void 0 !== g && (g.count = 3 * d - g.start, b.push(g));
					var g = {
						start: 3 * d,
						materialIndex: c
					}
				}
			}
			void 0 !== g && (g.count = 3 * d - g.start, b.push(g));
			this.groups = b
		},
		fromGeometry: function(a) {
			var b = a.faces,
				c = a.vertices,
				d = a.faceVertexUvs,
				e = d[0] && 0 < d[0].length,
				g = d[1] && 0 < d[1].length,
				k = a.morphTargets,
				l = k.length;
			if (0 < l) {
				var m = [];
				for (var n = 0; n < l; n++) m[n] = {
					name: k[n].name,
					data: []
				};
				this.morphTargets.position = m
			}
			var r = a.morphNormals,
				p = r.length;
			if (0 < p) {
				var q = [];
				for (n = 0; n <
					p; n++) q[n] = {
					name: r[n].name,
					data: []
				};
				this.morphTargets.normal = q
			}
			var u = a.skinIndices,
				z = a.skinWeights,
				C = u.length === c.length,
				D = z.length === c.length;
			0 < c.length && 0 === b.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
			for (n = 0; n < b.length; n++) {
				var K = b[n];
				this.vertices.push(c[K.a], c[K.b], c[K.c]);
				var G = K.vertexNormals;
				3 === G.length ? this.normals.push(G[0], G[1], G[2]) : (G = K.normal, this.normals.push(G, G, G));
				G = K.vertexColors;
				3 === G.length ? this.colors.push(G[0], G[1], G[2]) : (G = K.color,
					this.colors.push(G, G, G));
				!0 === e && (G = d[0][n], void 0 !== G ? this.uvs.push(G[0], G[1], G[2]) : (console.warn(
					"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", n), this.uvs.push(new B, new B, new B)));
				!0 === g && (G = d[1][n], void 0 !== G ? this.uvs2.push(G[0], G[1], G[2]) : (console.warn(
					"THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", n), this.uvs2.push(new B, new B, new B)));
				for (G = 0; G < l; G++) {
					var F = k[G].vertices;
					m[G].data.push(F[K.a], F[K.b], F[K.c])
				}
				for (G = 0; G < p; G++) F = r[G].vertexNormals[n], q[G].data.push(F.a,
					F.b, F.c);
				C && this.skinIndices.push(u[K.a], u[K.b], u[K.c]);
				D && this.skinWeights.push(z[K.a], z[K.b], z[K.c])
			}
			this.computeGroups(a);
			this.verticesNeedUpdate = a.verticesNeedUpdate;
			this.normalsNeedUpdate = a.normalsNeedUpdate;
			this.colorsNeedUpdate = a.colorsNeedUpdate;
			this.uvsNeedUpdate = a.uvsNeedUpdate;
			this.groupsNeedUpdate = a.groupsNeedUpdate;
			null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
			null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
			return this
		}
	});
	var xp = 1,
		Nd = new ua,
		Yl =
		new P,
		rh = new u,
		tc = new Sd,
		Zl = new Sd,
		uc = new u;
	J.prototype = q(p(nb.prototype), {
		constructor: J,
		isBufferGeometry: !0,
		getIndex: function() {
			return this.index
		},
		setIndex: function(a) {
			Array.isArray(a) ? this.index = new(65535 < rm(a) ? yf : xf)(a, 1) : this.index = a
		},
		addAttribute: function(a, b, c) {
			return b && b.isBufferAttribute || b && b.isInterleavedBufferAttribute ? "index" === a ? (console.warn(
				"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(b), this) : this.setAttribute(
				a, b) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
				this.addAttribute(a, new F(b, c)))
		},
		getAttribute: function(a) {
			return this.attributes[a]
		},
		setAttribute: function(a, b) {
			this.attributes[a] = b;
			return this
		},
		removeAttribute: function(a) {
			delete this.attributes[a];
			return this
		},
		addGroup: function(a, b, c) {
			this.groups.push({
				start: a,
				count: b,
				materialIndex: void 0 !== c ? c : 0
			})
		},
		clearGroups: function() {
			this.groups = []
		},
		setDrawRange: function(a, b) {
			this.drawRange.start = a;
			this.drawRange.count = b
		},
		applyMatrix: function(a) {
			var b = this.attributes.position;
			void 0 !== b && (a.applyToBufferAttribute(b),
				b.needsUpdate = !0);
			var c = this.attributes.normal;
			void 0 !== c && (b = (new kb).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0);
			c = this.attributes.tangent;
			void 0 !== c && (b = (new kb).getNormalMatrix(a), b.applyToBufferAttribute(c), c.needsUpdate = !0);
			null !== this.boundingBox && this.computeBoundingBox();
			null !== this.boundingSphere && this.computeBoundingSphere();
			return this
		},
		rotateX: function(a) {
			Nd.makeRotationX(a);
			this.applyMatrix(Nd);
			return this
		},
		rotateY: function(a) {
			Nd.makeRotationY(a);
			this.applyMatrix(Nd);
			return this
		},
		rotateZ: function(a) {
			Nd.makeRotationZ(a);
			this.applyMatrix(Nd);
			return this
		},
		translate: function(a, b, c) {
			Nd.makeTranslation(a, b, c);
			this.applyMatrix(Nd);
			return this
		},
		scale: function(a, b, c) {
			Nd.makeScale(a, b, c);
			this.applyMatrix(Nd);
			return this
		},
		lookAt: function(a) {
			Yl.lookAt(a);
			Yl.updateMatrix();
			this.applyMatrix(Yl.matrix);
			return this
		},
		center: function() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(rh).negate();
			this.translate(rh.x, rh.y, rh.z);
			return this
		},
		setFromObject: function(a) {
			var b = a.geometry;
			if (a.isPoints || a.isLine) {
				a = new N(3 * b.vertices.length, 3);
				var c = new N(3 * b.colors.length, 3);
				this.addAttribute("position", a.copyVector3sArray(b.vertices));
				this.addAttribute("color", c.copyColorsArray(b.colors));
				b.lineDistances && b.lineDistances.length === b.vertices.length && (a = new N(b.lineDistances.length, 1), this.addAttribute(
					"lineDistance", a.copyArray(b.lineDistances)));
				null !== b.boundingSphere && (this.boundingSphere = b.boundingSphere.clone());
				null !== b.boundingBox && (this.boundingBox = b.boundingBox.clone())
			} else a.isMesh &&
				b && b.isGeometry && this.fromGeometry(b);
			return this
		},
		setFromPoints: function(a) {
			for (var b = [], c = 0, d = a.length; c < d; c++) {
				var e = a[c];
				b.push(e.x, e.y, e.z || 0)
			}
			this.addAttribute("position", new N(b, 3));
			return this
		},
		updateFromObject: function(a) {
			var b = a.geometry;
			if (a.isMesh) {
				var c = b.__directGeometry;
				!0 === b.elementsNeedUpdate && (c = void 0, b.elementsNeedUpdate = !1);
				if (void 0 === c) return this.fromGeometry(b);
				c.verticesNeedUpdate = b.verticesNeedUpdate;
				c.normalsNeedUpdate = b.normalsNeedUpdate;
				c.colorsNeedUpdate = b.colorsNeedUpdate;
				c.uvsNeedUpdate = b.uvsNeedUpdate;
				c.groupsNeedUpdate = b.groupsNeedUpdate;
				b.verticesNeedUpdate = !1;
				b.normalsNeedUpdate = !1;
				b.colorsNeedUpdate = !1;
				b.uvsNeedUpdate = !1;
				b.groupsNeedUpdate = !1;
				b = c
			}!0 === b.verticesNeedUpdate && (c = this.attributes.position, void 0 !== c && (c.copyVector3sArray(b.vertices),
				c.needsUpdate = !0), b.verticesNeedUpdate = !1);
			!0 === b.normalsNeedUpdate && (c = this.attributes.normal, void 0 !== c && (c.copyVector3sArray(b.normals), c.needsUpdate = !
				0), b.normalsNeedUpdate = !1);
			!0 === b.colorsNeedUpdate && (c = this.attributes.color,
				void 0 !== c && (c.copyColorsArray(b.colors), c.needsUpdate = !0), b.colorsNeedUpdate = !1);
			b.uvsNeedUpdate && (c = this.attributes.uv, void 0 !== c && (c.copyVector2sArray(b.uvs), c.needsUpdate = !0), b.uvsNeedUpdate = !
				1);
			b.lineDistancesNeedUpdate && (c = this.attributes.lineDistance, void 0 !== c && (c.copyArray(b.lineDistances), c
				.needsUpdate = !0), b.lineDistancesNeedUpdate = !1);
			b.groupsNeedUpdate && (b.computeGroups(a.geometry), this.groups = b.groups, b.groupsNeedUpdate = !1);
			return this
		},
		fromGeometry: function(a) {
			a.__directGeometry = (new qm).fromGeometry(a);
			return this.fromDirectGeometry(a.__directGeometry)
		},
		fromDirectGeometry: function(a) {
			var b = new Float32Array(3 * a.vertices.length);
			this.addAttribute("position", (new F(b, 3)).copyVector3sArray(a.vertices));
			0 < a.normals.length && (b = new Float32Array(3 * a.normals.length), this.addAttribute("normal", (new F(b, 3)).copyVector3sArray(
				a.normals)));
			0 < a.colors.length && (b = new Float32Array(3 * a.colors.length), this.addAttribute("color", (new F(b, 3)).copyColorsArray(
				a.colors)));
			0 < a.uvs.length && (b = new Float32Array(2 * a.uvs.length),
				this.addAttribute("uv", (new F(b, 2)).copyVector2sArray(a.uvs)));
			0 < a.uvs2.length && (b = new Float32Array(2 * a.uvs2.length), this.addAttribute("uv2", (new F(b, 2)).copyVector2sArray(
				a.uvs2)));
			this.groups = a.groups;
			for (var c in a.morphTargets) {
				b = [];
				for (var d = a.morphTargets[c], e = 0, g = d.length; e < g; e++) {
					var k = d[e],
						l = new N(3 * k.data.length, 3);
					l.name = k.name;
					b.push(l.copyVector3sArray(k.data))
				}
				this.morphAttributes[c] = b
			}
			0 < a.skinIndices.length && (c = new N(4 * a.skinIndices.length, 4), this.addAttribute("skinIndex", c.copyVector4sArray(
				a.skinIndices)));
			0 < a.skinWeights.length && (c = new N(4 * a.skinWeights.length, 4), this.addAttribute("skinWeight", c.copyVector4sArray(
				a.skinWeights)));
			null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
			null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
			return this
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new Sd);
			var a = this.attributes.position,
				b = this.morphAttributes.position;
			if (void 0 !== a) {
				if (this.boundingBox.setFromBufferAttribute(a), b) {
					a = 0;
					for (var c = b.length; a <
						c; a++) tc.setFromBufferAttribute(b[a]), this.boundingBox.expandByPoint(tc.min), this.boundingBox.expandByPoint(
						tc.max)
				}
			} else this.boundingBox.makeEmpty();
			(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error(
				'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
				this)
		},
		computeBoundingSphere: function() {
			null === this.boundingSphere && (this.boundingSphere = new Ne);
			var a = this.attributes.position,
				b = this.morphAttributes.position;
			if (a) {
				var c = this.boundingSphere.center;
				tc.setFromBufferAttribute(a);
				if (b)
					for (var d = 0, e = b.length; d < e; d++) {
						var g = b[d];
						Zl.setFromBufferAttribute(g);
						tc.expandByPoint(Zl.min);
						tc.expandByPoint(Zl.max)
					}
				tc.getCenter(c);
				var k = 0;
				d = 0;
				for (e = a.count; d < e; d++) uc.fromBufferAttribute(a, d), k = Math.max(k, c.distanceToSquared(uc));
				if (b)
					for (d = 0, e = b.length; d < e; d++) {
						g = b[d];
						a = 0;
						for (var l = g.count; a < l; a++) uc.fromBufferAttribute(g, a), k = Math.max(k, c.distanceToSquared(uc))
					}
				this.boundingSphere.radius =
					Math.sqrt(k);
				isNaN(this.boundingSphere.radius) && console.error(
					'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
					this)
			}
		},
		computeFaceNormals: function() {},
		computeVertexNormals: function() {
			var a = this.index,
				b = this.attributes;
			if (b.position) {
				var c = b.position.array;
				if (void 0 === b.normal) this.addAttribute("normal", new F(new Float32Array(c.length), 3));
				else
					for (var d = b.normal.array, e = 0, g = d.length; e < g; e++) d[e] = 0;
				d = b.normal.array;
				var k =
					new u,
					l = new u,
					m = new u,
					n = new u,
					r = new u;
				if (a) {
					var p = a.array;
					e = 0;
					for (g = a.count; e < g; e += 3) {
						a = 3 * p[e + 0];
						var q = 3 * p[e + 1];
						var w = 3 * p[e + 2];
						k.fromArray(c, a);
						l.fromArray(c, q);
						m.fromArray(c, w);
						n.subVectors(m, l);
						r.subVectors(k, l);
						n.cross(r);
						d[a] += n.x;
						d[a + 1] += n.y;
						d[a + 2] += n.z;
						d[q] += n.x;
						d[q + 1] += n.y;
						d[q + 2] += n.z;
						d[w] += n.x;
						d[w + 1] += n.y;
						d[w + 2] += n.z
					}
				} else
					for (e = 0, g = c.length; e < g; e += 9) k.fromArray(c, e), l.fromArray(c, e + 3), m.fromArray(c, e + 6), n.subVectors(
							m, l), r.subVectors(k, l), n.cross(r), d[e] = n.x, d[e + 1] = n.y, d[e + 2] = n.z, d[e + 3] =
						n.x, d[e + 4] = n.y, d[e + 5] = n.z, d[e + 6] = n.x, d[e + 7] = n.y, d[e + 8] = n.z;
				this.normalizeNormals();
				b.normal.needsUpdate = !0
			}
		},
		merge: function(a, b) {
			if (a && a.isBufferGeometry) {
				void 0 === b && (b = 0, console.warn(
					"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."
				));
				var c = this.attributes,
					d;
				for (d in c)
					if (void 0 !== a.attributes[d]) {
						var e = c[d].array,
							g = a.attributes[d],
							k = g.array,
							l = g.itemSize * b;
						g = Math.min(k.length, e.length - l);
						for (var m =
								0; m < g; m++, l++) e[l] = k[m]
					} return this
			}
			console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", a)
		},
		normalizeNormals: function() {
			for (var a = this.attributes.normal, b = 0, c = a.count; b < c; b++) uc.x = a.getX(b), uc.y = a.getY(b), uc.z =
				a.getZ(b), uc.normalize(), a.setXYZ(b, uc.x, uc.y, uc.z)
		},
		toNonIndexed: function() {
			function a(a, b) {
				var c = a.array;
				a = a.itemSize;
				for (var d = new c.constructor(b.length * a), e, g = 0, k = 0, l = b.length; k < l; k++) {
					e = b[k] * a;
					for (var m = 0; m < a; m++) d[g++] = c[e++]
				}
				return new F(d,
					a)
			}
			if (null === this.index) return console.warn(
				"THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
			var b = new J,
				c = this.index.array,
				d = this.attributes,
				e;
			for (e in d) {
				var g = d[e];
				g = a(g, c);
				b.addAttribute(e, g)
			}
			var k = this.morphAttributes;
			for (e in k) {
				var l = [],
					m = k[e];
				d = 0;
				for (var n = m.length; d < n; d++) g = m[d], g = a(g, c), l.push(g);
				b.morphAttributes[e] = l
			}
			c = this.groups;
			d = 0;
			for (e = c.length; d < e; d++) g = c[d], b.addGroup(g.start, g.count, g.materialIndex);
			return b
		},
		toJSON: function() {
			var a = {
				metadata: {
					version: 4.5,
					type: "BufferGeometry",
					generator: "BufferGeometry.toJSON"
				}
			};
			a.uuid = this.uuid;
			a.type = this.type;
			"" !== this.name && (a.name = this.name);
			0 < Ha(this.userData).length && (a.userData = this.userData);
			if (void 0 !== this.parameters) {
				var b = this.parameters;
				for (n in b) void 0 !== b[n] && (a[n] = b[n]);
				return a
			}
			a.data = {
				attributes: {}
			};
			b = this.index;
			null !== b && (a.data.index = {
				type: b.array.constructor.name,
				array: Array.prototype.slice.call(b.array)
			});
			var c = this.attributes;
			for (n in c) {
				b = c[n];
				var d = b.toJSON();
				"" !== b.name && (d.name = b.name);
				a.data.attributes[n] = d
			}
			c = {};
			var e = !1;
			for (n in this.morphAttributes) {
				for (var g = this.morphAttributes[n], k = [], l = 0, m = g.length; l < m; l++) b = g[l], d = b.toJSON(), "" !==
					b.name && (d.name = b.name), k.push(d);
				0 < k.length && (c[n] = k, e = !0)
			}
			e && (a.data.morphAttributes = c);
			var n = this.groups;
			0 < n.length && (a.data.groups = JSON.parse(Rd(n)));
			n = this.boundingSphere;
			null !== n && (a.data.boundingSphere = {
				center: n.center.toArray(),
				radius: n.radius
			});
			return a
		},
		clone: function() {
			return (new J).copy(this)
		},
		copy: function(a) {
			var b;
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingSphere = this.boundingBox = null;
			this.name = a.name;
			var c = a.index;
			null !== c && this.setIndex(c.clone());
			c = a.attributes;
			for (k in c) this.addAttribute(k, c[k].clone());
			var d = a.morphAttributes;
			for (k in d) {
				var e = [],
					g = d[k];
				c = 0;
				for (b = g.length; c < b; c++) e.push(g[c].clone());
				this.morphAttributes[k] = e
			}
			var k = a.groups;
			c = 0;
			for (b = k.length; c < b; c++) d = k[c], this.addGroup(d.start, d.count, d.materialIndex);
			k = a.boundingBox;
			null !== k && (this.boundingBox = k.clone());
			k = a.boundingSphere;
			null !== k && (this.boundingSphere = k.clone());
			this.drawRange.start = a.drawRange.start;
			this.drawRange.count = a.drawRange.count;
			this.userData = a.userData;
			return this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	});
	var Po = new ua,
		hd = new wf,
		$l = new Ne,
		nd = new u,
		Td = new u,
		Ud = new u,
		tm = new u,
		um = new u,
		vm = new u,
		Si = new u,
		Fh = new u,
		Ti = new u,
		od = new B,
		pd = new B,
		Cg = new B,
		zf = new u,
		Qi = new u;
	Wa.prototype = q(p(P.prototype), {
		constructor: Wa,
		isMesh: !0,
		setDrawMode: function(a) {
			this.drawMode = a
		},
		copy: function(a) {
			P.prototype.copy.call(this,
				a);
			this.drawMode = a.drawMode;
			void 0 !== a.morphTargetInfluences && (this.morphTargetInfluences = a.morphTargetInfluences.slice());
			void 0 !== a.morphTargetDictionary && (this.morphTargetDictionary = q({}, a.morphTargetDictionary));
			return this
		},
		updateMorphTargets: function() {
			var a = this.geometry;
			if (a.isBufferGeometry) {
				a = a.morphAttributes;
				var b = Ha(a);
				if (0 < b.length) {
					var c = a[b[0]];
					if (void 0 !== c)
						for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a = 0, b = c.length; a < b; a++) {
							var d = c[a].name || String(a);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[d] = a
						}
				}
			} else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error(
				"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
		},
		raycast: function(a, b) {
			var c = this.geometry,
				d = this.material,
				e = this.matrixWorld;
			if (void 0 !== d && (null === c.boundingSphere && c.computeBoundingSphere(), $l.copy(c.boundingSphere), $l.applyMatrix4(
					e), !1 !== a.ray.intersectsSphere($l) && (Po.getInverse(e), hd.copy(a.ray).applyMatrix4(Po), null === c.boundingBox ||
					!1 !== hd.intersectsBox(c.boundingBox))))
				if (c.isBufferGeometry) {
					var g =
						c.index;
					e = c.attributes.position;
					var k = c.morphAttributes.position,
						l = c.attributes.uv,
						m = c.attributes.uv2,
						n = c.groups,
						r = c.drawRange,
						p, q;
					if (null !== g)
						if (Array.isArray(d)) {
							var u = 0;
							for (p = n.length; u < p; u++) {
								var z = n[u];
								var C = d[z.materialIndex];
								var D = Math.max(z.start, r.start);
								for (q = c = Math.min(z.start + z.count, r.start + r.count); D < q; D += 3) {
									c = g.getX(D);
									var K = g.getX(D + 1);
									var G = g.getX(D + 2);
									if (c = Ri(this, C, a, hd, e, k, l, m, c, K, G)) c.faceIndex = Math.floor(D / 3), c.face.materialIndex = z
										.materialIndex, b.push(c)
								}
							}
						} else
							for (D = Math.max(0,
									r.start), c = Math.min(g.count, r.start + r.count), u = D, p = c; u < p; u += 3) {
								if (c = g.getX(u), K = g.getX(u + 1), G = g.getX(u + 2), c = Ri(this, d, a, hd, e, k, l, m, c, K, G)) c.faceIndex =
									Math.floor(u / 3), b.push(c)
							} else if (void 0 !== e)
								if (Array.isArray(d))
									for (u = 0, p = n.length; u < p; u++)
										for (z = n[u], C = d[z.materialIndex], D = Math.max(z.start, r.start), q = c = Math.min(z.start + z.count,
												r.start + r.count); D < q; D += 3) {
											if (c = D, K = D + 1, G = D + 2, c = Ri(this, C, a, hd, e, k, l, m, c, K, G)) c.faceIndex = Math.floor(D /
												3), c.face.materialIndex = z.materialIndex, b.push(c)
										} else
											for (D = Math.max(0,
													r.start), c = Math.min(e.count, r.start + r.count), u = D, p = c; u < p; u += 3)
												if (c = u, K = u + 1, G = u + 2, c = Ri(this, d, a, hd, e, k, l, m, c, K, G)) c.faceIndex = Math.floor(
													u / 3), b.push(c)
				} else if (c.isGeometry)
				for (e = Array.isArray(d), k = c.vertices, l = c.faces, c = c.faceVertexUvs[0], 0 < c.length && (g = c), u = 0,
					p = l.length; u < p; u++)
					if (z = l[u], c = e ? d[z.materialIndex] : d, void 0 !== c && (m = k[z.a], n = k[z.b], r = k[z.c], c = sm(this,
							c, a, hd, m, n, r, zf))) g && g[u] && (C = g[u], od.copy(C[0]), pd.copy(C[1]), Cg.copy(C[2]), c.uv = ob.getUV(
							zf, m, n, r, od, pd, Cg, new B)), c.face = z, c.faceIndex =
						u, b.push(c)
		},
		clone: function() {
			return (new this.constructor(this.geometry, this.material)).copy(this)
		}
	});
	var yp = 0,
		Od = new ua,
		am = new P,
		Bi = new u;
	R.prototype = q(p(nb.prototype), {
		constructor: R,
		isGeometry: !0,
		applyMatrix: function(a) {
			for (var b = (new kb).getNormalMatrix(a), c = 0, d = this.vertices.length; c < d; c++) this.vertices[c].applyMatrix4(
				a);
			c = 0;
			for (d = this.faces.length; c < d; c++) {
				a = this.faces[c];
				a.normal.applyMatrix3(b).normalize();
				for (var e = 0, g = a.vertexNormals.length; e < g; e++) a.vertexNormals[e].applyMatrix3(b).normalize()
			}
			null !==
				this.boundingBox && this.computeBoundingBox();
			null !== this.boundingSphere && this.computeBoundingSphere();
			this.normalsNeedUpdate = this.verticesNeedUpdate = !0;
			return this
		},
		rotateX: function(a) {
			Od.makeRotationX(a);
			this.applyMatrix(Od);
			return this
		},
		rotateY: function(a) {
			Od.makeRotationY(a);
			this.applyMatrix(Od);
			return this
		},
		rotateZ: function(a) {
			Od.makeRotationZ(a);
			this.applyMatrix(Od);
			return this
		},
		translate: function(a, b, c) {
			Od.makeTranslation(a, b, c);
			this.applyMatrix(Od);
			return this
		},
		scale: function(a, b, c) {
			Od.makeScale(a,
				b, c);
			this.applyMatrix(Od);
			return this
		},
		lookAt: function(a) {
			am.lookAt(a);
			am.updateMatrix();
			this.applyMatrix(am.matrix);
			return this
		},
		fromBufferGeometry: function(a) {
			function b(a, b, d, e) {
				var g = void 0 === l ? [] : [c.colors[a].clone(), c.colors[b].clone(), c.colors[d].clone()],
					r = void 0 === k ? [] : [(new u).fromArray(k, 3 * a), (new u).fromArray(k, 3 * b), (new u).fromArray(k, 3 * d)];
				e = new Ah(a, b, d, r, g, e);
				c.faces.push(e);
				void 0 !== m && c.faceVertexUvs[0].push([(new B).fromArray(m, 2 * a), (new B).fromArray(m, 2 * b), (new B).fromArray(
					m,
					2 * d)]);
				void 0 !== n && c.faceVertexUvs[1].push([(new B).fromArray(n, 2 * a), (new B).fromArray(n, 2 * b), (new B).fromArray(
					n, 2 * d)])
			}
			var c = this,
				d = null !== a.index ? a.index.array : void 0,
				e = a.attributes;
			if (void 0 === e.position) return console.error(
				"THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this;
			var g = e.position.array,
				k = void 0 !== e.normal ? e.normal.array : void 0,
				l = void 0 !== e.color ? e.color.array : void 0,
				m = void 0 !== e.uv ? e.uv.array : void 0,
				n = void 0 !== e.uv2 ? e.uv2.array : void 0;
			void 0 !==
				n && (this.faceVertexUvs[1] = []);
			for (e = 0; e < g.length; e += 3) c.vertices.push((new u).fromArray(g, e)), void 0 !== l && c.colors.push((new S)
				.fromArray(l, e));
			var r = a.groups;
			if (0 < r.length)
				for (e = 0; e < r.length; e++) {
					g = r[e];
					var p = g.start,
						q = p;
					for (p += g.count; q < p; q += 3) void 0 !== d ? b(d[q], d[q + 1], d[q + 2], g.materialIndex) : b(q, q + 1, q +
						2, g.materialIndex)
				} else if (void 0 !== d)
					for (e = 0; e < d.length; e += 3) b(d[e], d[e + 1], d[e + 2]);
				else
					for (e = 0; e < g.length / 3; e += 3) b(e, e + 1, e + 2);
			this.computeFaceNormals();
			null !== a.boundingBox && (this.boundingBox = a.boundingBox.clone());
			null !== a.boundingSphere && (this.boundingSphere = a.boundingSphere.clone());
			return this
		},
		center: function() {
			this.computeBoundingBox();
			this.boundingBox.getCenter(Bi).negate();
			this.translate(Bi.x, Bi.y, Bi.z);
			return this
		},
		normalize: function() {
			this.computeBoundingSphere();
			var a = this.boundingSphere.center,
				b = this.boundingSphere.radius;
			b = 0 === b ? 1 : 1 / b;
			var c = new ua;
			c.set(b, 0, 0, -b * a.x, 0, b, 0, -b * a.y, 0, 0, b, -b * a.z, 0, 0, 0, 1);
			this.applyMatrix(c);
			return this
		},
		computeFaceNormals: function() {
			for (var a = new u, b = new u, c = 0, d = this.faces.length; c <
				d; c++) {
				var e = this.faces[c],
					g = this.vertices[e.a],
					k = this.vertices[e.b];
				a.subVectors(this.vertices[e.c], k);
				b.subVectors(g, k);
				a.cross(b);
				a.normalize();
				e.normal.copy(a)
			}
		},
		computeVertexNormals: function(a) {
			void 0 === a && (a = !0);
			var b;
			var c = Array(this.vertices.length);
			var d = 0;
			for (b = this.vertices.length; d < b; d++) c[d] = new u;
			if (a) {
				var e = new u,
					g = new u;
				a = 0;
				for (d = this.faces.length; a < d; a++) {
					b = this.faces[a];
					var k = this.vertices[b.a];
					var l = this.vertices[b.b];
					var m = this.vertices[b.c];
					e.subVectors(m, l);
					g.subVectors(k, l);
					e.cross(g);
					c[b.a].add(e);
					c[b.b].add(e);
					c[b.c].add(e)
				}
			} else
				for (this.computeFaceNormals(), a = 0, d = this.faces.length; a < d; a++) b = this.faces[a], c[b.a].add(b.normal),
					c[b.b].add(b.normal), c[b.c].add(b.normal);
			d = 0;
			for (b = this.vertices.length; d < b; d++) c[d].normalize();
			a = 0;
			for (d = this.faces.length; a < d; a++) b = this.faces[a], k = b.vertexNormals, 3 === k.length ? (k[0].copy(c[b.a]),
				k[1].copy(c[b.b]), k[2].copy(c[b.c])) : (k[0] = c[b.a].clone(), k[1] = c[b.b].clone(), k[2] = c[b.c].clone());
			0 < this.faces.length && (this.normalsNeedUpdate = !0)
		},
		computeFlatVertexNormals: function() {
			var a;
			this.computeFaceNormals();
			var b = 0;
			for (a = this.faces.length; b < a; b++) {
				var c = this.faces[b];
				var d = c.vertexNormals;
				3 === d.length ? (d[0].copy(c.normal), d[1].copy(c.normal), d[2].copy(c.normal)) : (d[0] = c.normal.clone(), d[
					1] = c.normal.clone(), d[2] = c.normal.clone())
			}
			0 < this.faces.length && (this.normalsNeedUpdate = !0)
		},
		computeMorphNormals: function() {
			var a, b;
			var c = 0;
			for (b = this.faces.length; c < b; c++) {
				var d = this.faces[c];
				d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) :
					d.__originalFaceNormal = d.normal.clone();
				d.__originalVertexNormals || (d.__originalVertexNormals = []);
				var e = 0;
				for (a = d.vertexNormals.length; e < a; e++) d.__originalVertexNormals[e] ? d.__originalVertexNormals[e].copy(d
					.vertexNormals[e]) : d.__originalVertexNormals[e] = d.vertexNormals[e].clone()
			}
			var g = new R;
			g.faces = this.faces;
			e = 0;
			for (a = this.morphTargets.length; e < a; e++) {
				if (!this.morphNormals[e]) {
					this.morphNormals[e] = {};
					this.morphNormals[e].faceNormals = [];
					this.morphNormals[e].vertexNormals = [];
					d = this.morphNormals[e].faceNormals;
					var k = this.morphNormals[e].vertexNormals;
					c = 0;
					for (b = this.faces.length; c < b; c++) {
						var l = new u;
						var m = {
							a: new u,
							b: new u,
							c: new u
						};
						d.push(l);
						k.push(m)
					}
				}
				k = this.morphNormals[e];
				g.vertices = this.morphTargets[e].vertices;
				g.computeFaceNormals();
				g.computeVertexNormals();
				c = 0;
				for (b = this.faces.length; c < b; c++) d = this.faces[c], l = k.faceNormals[c], m = k.vertexNormals[c], l.copy(
					d.normal), m.a.copy(d.vertexNormals[0]), m.b.copy(d.vertexNormals[1]), m.c.copy(d.vertexNormals[2])
			}
			c = 0;
			for (b = this.faces.length; c < b; c++) d = this.faces[c],
				d.normal = d.__originalFaceNormal, d.vertexNormals = d.__originalVertexNormals
		},
		computeBoundingBox: function() {
			null === this.boundingBox && (this.boundingBox = new Sd);
			this.boundingBox.setFromPoints(this.vertices)
		},
		computeBoundingSphere: function() {
			null === this.boundingSphere && (this.boundingSphere = new Ne);
			this.boundingSphere.setFromPoints(this.vertices)
		},
		merge: function(a, b, c) {
			if (a && a.isGeometry) {
				var d, e = this.vertices.length,
					g = this.vertices,
					k = a.vertices,
					l = this.faces,
					m = a.faces,
					n = this.colors,
					r = a.colors;
				void 0 === c &&
					(c = 0);
				void 0 !== b && (d = (new kb).getNormalMatrix(b));
				for (var p = 0, q = k.length; p < q; p++) {
					var u = k[p].clone();
					void 0 !== b && u.applyMatrix4(b);
					g.push(u)
				}
				p = 0;
				for (q = r.length; p < q; p++) n.push(r[p].clone());
				p = 0;
				for (q = m.length; p < q; p++) {
					k = m[p];
					var z = k.vertexNormals;
					r = k.vertexColors;
					n = new Ah(k.a + e, k.b + e, k.c + e);
					n.normal.copy(k.normal);
					void 0 !== d && n.normal.applyMatrix3(d).normalize();
					b = 0;
					for (g = z.length; b < g; b++) u = z[b].clone(), void 0 !== d && u.applyMatrix3(d).normalize(), n.vertexNormals
						.push(u);
					n.color.copy(k.color);
					b = 0;
					for (g =
						r.length; b < g; b++) u = r[b], n.vertexColors.push(u.clone());
					n.materialIndex = k.materialIndex + c;
					l.push(n)
				}
				p = 0;
				for (q = a.faceVertexUvs.length; p < q; p++)
					for (c = a.faceVertexUvs[p], void 0 === this.faceVertexUvs[p] && (this.faceVertexUvs[p] = []), b = 0, g = c.length; b <
						g; b++) {
						d = c[b];
						e = [];
						l = 0;
						for (m = d.length; l < m; l++) e.push(d[l].clone());
						this.faceVertexUvs[p].push(e)
					}
			} else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", a)
		},
		mergeMesh: function(a) {
			a && a.isMesh ? (a.matrixAutoUpdate && a.updateMatrix(),
				this.merge(a.geometry, a.matrix)) : console.error(
				"THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", a)
		},
		mergeVertices: function() {
			var a = {},
				b = [],
				c = [],
				d = Math.pow(10, 4),
				e;
			var g = 0;
			for (e = this.vertices.length; g < e; g++) {
				var k = this.vertices[g];
				k = Math.round(k.x * d) + "_" + Math.round(k.y * d) + "_" + Math.round(k.z * d);
				void 0 === a[k] ? (a[k] = g, b.push(this.vertices[g]), c[g] = b.length - 1) : c[g] = c[a[k]]
			}
			a = [];
			g = 0;
			for (e = this.faces.length; g < e; g++)
				for (d = this.faces[g], d.a = c[d.a], d.b = c[d.b], d.c = c[d.c], d = [d.a, d.b, d.c], k = 0; 3 >
					k; k++)
					if (d[k] === d[(k + 1) % 3]) {
						a.push(g);
						break
					} for (g = a.length - 1; 0 <= g; g--)
				for (d = a[g], this.faces.splice(d, 1), c = 0, e = this.faceVertexUvs.length; c < e; c++) this.faceVertexUvs[c]
					.splice(d, 1);
			g = this.vertices.length - b.length;
			this.vertices = b;
			return g
		},
		setFromPoints: function(a) {
			this.vertices = [];
			for (var b = 0, c = a.length; b < c; b++) {
				var d = a[b];
				this.vertices.push(new u(d.x, d.y, d.z || 0))
			}
			return this
		},
		sortFacesByMaterialIndex: function() {
			for (var a = this.faces, b = a.length, c = 0; c < b; c++) a[c]._id = c;
			a.sort(function(a, b) {
				return a.materialIndex -
					b.materialIndex
			});
			var d = this.faceVertexUvs[0],
				e = this.faceVertexUvs[1],
				g, k;
			d && d.length === b && (g = []);
			e && e.length === b && (k = []);
			for (c = 0; c < b; c++) {
				var l = a[c]._id;
				g && g.push(d[l]);
				k && k.push(e[l])
			}
			g && (this.faceVertexUvs[0] = g);
			k && (this.faceVertexUvs[1] = k)
		},
		toJSON: function() {
			function a(a, b, c) {
				return c ? a | 1 << b : a & ~(1 << b)
			}

			function b(a) {
				var b = a.x.toString() + a.y.toString() + a.z.toString();
				if (void 0 !== n[b]) return n[b];
				n[b] = m.length / 3;
				m.push(a.x, a.y, a.z);
				return n[b]
			}

			function c(a) {
				var b = a.r.toString() + a.g.toString() + a.b.toString();
				if (void 0 !== p[b]) return p[b];
				p[b] = r.length;
				r.push(a.getHex());
				return p[b]
			}

			function d(a) {
				var b = a.x.toString() + a.y.toString();
				if (void 0 !== u[b]) return u[b];
				u[b] = q.length / 2;
				q.push(a.x, a.y);
				return u[b]
			}
			var e = {
				metadata: {
					version: 4.5,
					type: "Geometry",
					generator: "Geometry.toJSON"
				}
			};
			e.uuid = this.uuid;
			e.type = this.type;
			"" !== this.name && (e.name = this.name);
			if (void 0 !== this.parameters) {
				var g = this.parameters,
					k;
				for (k in g) void 0 !== g[k] && (e[k] = g[k]);
				return e
			}
			g = [];
			for (k = 0; k < this.vertices.length; k++) {
				var l = this.vertices[k];
				g.push(l.x, l.y, l.z)
			}
			l = [];
			var m = [],
				n = {},
				r = [],
				p = {},
				q = [],
				u = {};
			for (k = 0; k < this.faces.length; k++) {
				var z = this.faces[k],
					C = void 0 !== this.faceVertexUvs[0][k],
					D = 0 < z.normal.length(),
					B = 0 < z.vertexNormals.length,
					G = 1 !== z.color.r || 1 !== z.color.g || 1 !== z.color.b,
					F = 0 < z.vertexColors.length,
					H = 0;
				H = a(H, 0, 0);
				H = a(H, 1, !0);
				H = a(H, 2, !1);
				H = a(H, 3, C);
				H = a(H, 4, D);
				H = a(H, 5, B);
				H = a(H, 6, G);
				H = a(H, 7, F);
				l.push(H);
				l.push(z.a, z.b, z.c);
				l.push(z.materialIndex);
				C && (C = this.faceVertexUvs[0][k], l.push(d(C[0]), d(C[1]), d(C[2])));
				D && l.push(b(z.normal));
				B && (D = z.vertexNormals, l.push(b(D[0]), b(D[1]), b(D[2])));
				G && l.push(c(z.color));
				F && (z = z.vertexColors, l.push(c(z[0]), c(z[1]), c(z[2])))
			}
			e.data = {};
			e.data.vertices = g;
			e.data.normals = m;
			0 < r.length && (e.data.colors = r);
			0 < q.length && (e.data.uvs = [q]);
			e.data.faces = l;
			return e
		},
		clone: function() {
			return (new R).copy(this)
		},
		copy: function(a) {
			var b, c, d;
			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [
				[]
			];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingSphere = this.boundingBox = null;
			this.name = a.name;
			var e = a.vertices;
			var g = 0;
			for (b = e.length; g < b; g++) this.vertices.push(e[g].clone());
			e = a.colors;
			g = 0;
			for (b = e.length; g < b; g++) this.colors.push(e[g].clone());
			e = a.faces;
			g = 0;
			for (b = e.length; g < b; g++) this.faces.push(e[g].clone());
			g = 0;
			for (b = a.faceVertexUvs.length; g < b; g++) {
				var k = a.faceVertexUvs[g];
				void 0 === this.faceVertexUvs[g] && (this.faceVertexUvs[g] = []);
				e = 0;
				for (c = k.length; e < c; e++) {
					var l = k[e],
						m = [];
					var n = 0;
					for (d = l.length; n < d; n++) m.push(l[n].clone());
					this.faceVertexUvs[g].push(m)
				}
			}
			n = a.morphTargets;
			g = 0;
			for (b = n.length; g < b; g++) {
				d = {};
				d.name = n[g].name;
				if (void 0 !== n[g].vertices)
					for (d.vertices = [], e = 0, c = n[g].vertices.length; e < c; e++) d.vertices.push(n[g].vertices[e].clone());
				if (void 0 !== n[g].normals)
					for (d.normals = [], e = 0, c = n[g].normals.length; e < c; e++) d.normals.push(n[g].normals[e].clone());
				this.morphTargets.push(d)
			}
			n = a.morphNormals;
			g = 0;
			for (b = n.length; g < b; g++) {
				d = {};
				if (void 0 !== n[g].vertexNormals)
					for (d.vertexNormals = [], e = 0, c = n[g].vertexNormals.length; e < c; e++) k =
						n[g].vertexNormals[e], l = {}, l.a = k.a.clone(), l.b = k.b.clone(), l.c = k.c.clone(), d.vertexNormals.push(
							l);
				if (void 0 !== n[g].faceNormals)
					for (d.faceNormals = [], e = 0, c = n[g].faceNormals.length; e < c; e++) d.faceNormals.push(n[g].faceNormals[e]
						.clone());
				this.morphNormals.push(d)
			}
			e = a.skinWeights;
			g = 0;
			for (b = e.length; g < b; g++) this.skinWeights.push(e[g].clone());
			e = a.skinIndices;
			g = 0;
			for (b = e.length; g < b; g++) this.skinIndices.push(e[g].clone());
			e = a.lineDistances;
			g = 0;
			for (b = e.length; g < b; g++) this.lineDistances.push(e[g]);
			g = a.boundingBox;
			null !== g && (this.boundingBox = g.clone());
			g = a.boundingSphere;
			null !== g && (this.boundingSphere = g.clone());
			this.elementsNeedUpdate = a.elementsNeedUpdate;
			this.verticesNeedUpdate = a.verticesNeedUpdate;
			this.uvsNeedUpdate = a.uvsNeedUpdate;
			this.normalsNeedUpdate = a.normalsNeedUpdate;
			this.colorsNeedUpdate = a.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = a.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = a.groupsNeedUpdate;
			return this
		},
		dispose: function() {
			this.dispatchEvent({
				type: "dispose"
			})
		}
	});
	var Ls = function(a) {
			function b(a,
				d, e, g, k, l) {
				Xa(this, b);
				var c = Zb(this, (b.__proto__ || Yb(b)).call(this));
				c.type = "BoxGeometry";
				c.parameters = {
					width: a,
					height: d,
					depth: e,
					widthSegments: g,
					heightSegments: k,
					depthSegments: l
				};
				c.fromBufferGeometry(new Gh(a, d, e, g, k, l));
				c.mergeVertices();
				return c
			}
			$b(b, a);
			return b
		}(R),
		Gh = function(a) {
			function b(a, d, e, g, k, l) {
				function c(a, b, c, d, e, g, k, l, m, n, v) {
					var A = g / m,
						G = k / n,
						B = g / 2,
						K = k / 2,
						H = l / 2;
					k = m + 1;
					var F = n + 1,
						Q = g = 0,
						J, L, M = new u;
					for (L = 0; L < F; L++) {
						var N = L * G - K;
						for (J = 0; J < k; J++) M[a] = (J * A - B) * d, M[b] = N * e, M[c] = H, q.push(M.x, M.y,
								M.z), M[a] = 0, M[b] = 0, M[c] = 0 < l ? 1 : -1, w.push(M.x, M.y, M.z), z.push(J / m), z.push(1 - L / n), g +=
							1
					}
					for (L = 0; L < n; L++)
						for (J = 0; J < m; J++) a = C + J + k * (L + 1), b = C + (J + 1) + k * (L + 1), c = C + (J + 1) + k * L, p.push(
							C + J + k * L, a, c), p.push(a, b, c), Q += 6;
					r.addGroup(D, Q, v);
					D += Q;
					C += g
				}
				Xa(this, b);
				var n = Zb(this, (b.__proto__ || Yb(b)).call(this));
				n.type = "BoxBufferGeometry";
				n.parameters = {
					width: a,
					height: d,
					depth: e,
					widthSegments: g,
					heightSegments: k,
					depthSegments: l
				};
				var r = n;
				a = a || 1;
				d = d || 1;
				e = e || 1;
				g = Math.floor(g) || 1;
				k = Math.floor(k) || 1;
				l = Math.floor(l) || 1;
				var p = [],
					q = [],
					w = [],
					z = [],
					C = 0,
					D = 0;
				c("z", "y", "x", -1, -1, e, d, a, l, k, 0);
				c("z", "y", "x", 1, -1, e, d, -a, l, k, 1);
				c("x", "z", "y", 1, 1, a, e, d, g, l, 2);
				c("x", "z", "y", 1, -1, a, e, -d, g, l, 3);
				c("x", "y", "z", 1, -1, a, d, e, g, k, 4);
				c("x", "y", "z", -1, -1, a, d, -e, g, k, 5);
				n.setIndex(p);
				n.addAttribute("position", new N(q, 3));
				n.addAttribute("normal", new N(w, 3));
				n.addAttribute("uv", new N(z, 2));
				return n
			}
			$b(b, a);
			return b
		}(J),
		Ee = {
			clone: qd,
			merge: Gb
		};
	Ia.prototype = p(ia.prototype);
	Ia.prototype.constructor = Ia;
	Ia.prototype.isShaderMaterial = !0;
	Ia.prototype.copy = function(a) {
		ia.prototype.copy.call(this,
			a);
		this.fragmentShader = a.fragmentShader;
		this.vertexShader = a.vertexShader;
		this.uniforms = qd(a.uniforms);
		this.defines = q({}, a.defines);
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		this.lights = a.lights;
		this.clipping = a.clipping;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.morphNormals = a.morphNormals;
		this.extensions = a.extensions;
		return this
	};
	Ia.prototype.toJSON = function(a) {
		var b = ia.prototype.toJSON.call(this, a);
		b.uniforms = {};
		for (var c in this.uniforms) {
			var d =
				this.uniforms[c].value;
			b.uniforms[c] = d && d.isTexture ? {
				type: "t",
				value: d.toJSON(a).uuid
			} : d && d.isColor ? {
				type: "c",
				value: d.getHex()
			} : d && d.isVector2 ? {
				type: "v2",
				value: d.toArray()
			} : d && d.isVector3 ? {
				type: "v3",
				value: d.toArray()
			} : d && d.isVector4 ? {
				type: "v4",
				value: d.toArray()
			} : d && d.isMatrix3 ? {
				type: "m3",
				value: d.toArray()
			} : d && d.isMatrix4 ? {
				type: "m4",
				value: d.toArray()
			} : {
				value: d
			}
		}
		0 < Ha(this.defines).length && (b.defines = this.defines);
		b.vertexShader = this.vertexShader;
		b.fragmentShader = this.fragmentShader;
		a = {};
		for (var e in this.extensions) !0 ===
			this.extensions[e] && (a[e] = !0);
		0 < Ha(a).length && (b.extensions = a);
		return b
	};
	Vd.prototype = q(p(P.prototype), {
		constructor: Vd,
		isCamera: !0,
		copy: function(a, b) {
			P.prototype.copy.call(this, a, b);
			this.matrixWorldInverse.copy(a.matrixWorldInverse);
			this.projectionMatrix.copy(a.projectionMatrix);
			this.projectionMatrixInverse.copy(a.projectionMatrixInverse);
			return this
		},
		getWorldDirection: function(a) {
			void 0 === a && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), a = new u);
			this.updateMatrixWorld(!0);
			var b = this.matrixWorld.elements;
			return a.set(-b[8], -b[9], -b[10]).normalize()
		},
		updateMatrixWorld: function(a) {
			P.prototype.updateMatrixWorld.call(this, a);
			this.matrixWorldInverse.getInverse(this.matrixWorld)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		}
	});
	ab.prototype = q(p(Vd.prototype), {
		constructor: ab,
		isPerspectiveCamera: !0,
		copy: function(a, b) {
			Vd.prototype.copy.call(this, a, b);
			this.fov = a.fov;
			this.zoom = a.zoom;
			this.near = a.near;
			this.far = a.far;
			this.focus = a.focus;
			this.aspect = a.aspect;
			this.view =
				null === a.view ? null : q({}, a.view);
			this.filmGauge = a.filmGauge;
			this.filmOffset = a.filmOffset;
			return this
		},
		setFocalLength: function(a) {
			a = .5 * this.getFilmHeight() / a;
			this.fov = 2 * ha.RAD2DEG * Math.atan(a);
			this.updateProjectionMatrix()
		},
		getFocalLength: function() {
			var a = Math.tan(.5 * ha.DEG2RAD * this.fov);
			return .5 * this.getFilmHeight() / a
		},
		getEffectiveFOV: function() {
			return 2 * ha.RAD2DEG * Math.atan(Math.tan(.5 * ha.DEG2RAD * this.fov) / this.zoom)
		},
		getFilmWidth: function() {
			return this.filmGauge * Math.min(this.aspect, 1)
		},
		getFilmHeight: function() {
			return this.filmGauge /
				Math.max(this.aspect, 1)
		},
		setViewOffset: function(a, b, c, d, e, g) {
			this.aspect = a / b;
			null === this.view && (this.view = {
				enabled: !0,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			});
			this.view.enabled = !0;
			this.view.fullWidth = a;
			this.view.fullHeight = b;
			this.view.offsetX = c;
			this.view.offsetY = d;
			this.view.width = e;
			this.view.height = g;
			this.updateProjectionMatrix()
		},
		clearViewOffset: function() {
			null !== this.view && (this.view.enabled = !1);
			this.updateProjectionMatrix()
		},
		updateProjectionMatrix: function() {
			var a = this.near,
				b = a * Math.tan(.5 * ha.DEG2RAD * this.fov) / this.zoom,
				c = 2 * b,
				d = this.aspect * c,
				e = -.5 * d,
				g = this.view;
			if (null !== this.view && this.view.enabled) {
				var k = g.fullWidth,
					l = g.fullHeight;
				e += g.offsetX * d / k;
				b -= g.offsetY * c / l;
				d *= g.width / k;
				c *= g.height / l
			}
			g = this.filmOffset;
			0 !== g && (e += a * g / this.getFilmWidth());
			this.projectionMatrix.makePerspective(e, e + d, b, b - c, a, this.far);
			this.projectionMatrixInverse.getInverse(this.projectionMatrix)
		},
		toJSON: function(a) {
			a = P.prototype.toJSON.call(this, a);
			a.object.fov = this.fov;
			a.object.zoom = this.zoom;
			a.object.near = this.near;
			a.object.far = this.far;
			a.object.focus = this.focus;
			a.object.aspect = this.aspect;
			null !== this.view && (a.object.view = q({}, this.view));
			a.object.filmGauge = this.filmGauge;
			a.object.filmOffset = this.filmOffset;
			return a
		}
	});
	Oe.prototype = p(P.prototype);
	Oe.prototype.constructor = Oe;
	ec.prototype = p(Oa.prototype);
	ec.prototype.constructor = ec;
	ec.prototype.isWebGLRenderTargetCube = !0;
	ec.prototype.fromEquirectangularTexture = function(a, b) {
		this.texture.type = b.type;
		this.texture.format = b.format;
		this.texture.encoding =
			b.encoding;
		var c = new Bg,
			d = new Ia({
				type: "CubemapFromEquirect",
				uniforms: qd({
					tEquirect: {
						value: null
					}
				}),
				vertexShader: "varying vec3 vWorldDirection;\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
				fragmentShader: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}",
				side: 1,
				blending: 0
			});
		d.uniforms.tEquirect.value = b;
		b = new Wa(new Gh(5, 5, 5), d);
		c.add(b);
		d = new Oe(1, 10, 1);
		d.renderTarget = this;
		d.renderTarget.texture.name = "CubeCameraTexture";
		d.update(a, c);
		b.geometry.dispose();
		b.material.dispose();
		return this
	};
	Dg.prototype = p(pa.prototype);
	Dg.prototype.constructor = Dg;
	Dg.prototype.isDataTexture = !0;
	var bm = new u,
		Ms = new u,
		Ns = new kb;
	q(Wd.prototype, {
		isPlane: !0,
		set: function(a, b) {
			this.normal.copy(a);
			this.constant = b;
			return this
		},
		setComponents: function(a, b, c, d) {
			this.normal.set(a,
				b, c);
			this.constant = d;
			return this
		},
		setFromNormalAndCoplanarPoint: function(a, b) {
			this.normal.copy(a);
			this.constant = -b.dot(this.normal);
			return this
		},
		setFromCoplanarPoints: function(a, b, c) {
			b = bm.subVectors(c, b).cross(Ms.subVectors(a, b)).normalize();
			this.setFromNormalAndCoplanarPoint(b, a);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.normal.copy(a.normal);
			this.constant = a.constant;
			return this
		},
		normalize: function() {
			var a = 1 / this.normal.length();
			this.normal.multiplyScalar(a);
			this.constant *= a;
			return this
		},
		negate: function() {
			this.constant *= -1;
			this.normal.negate();
			return this
		},
		distanceToPoint: function(a) {
			return this.normal.dot(a) + this.constant
		},
		distanceToSphere: function(a) {
			return this.distanceToPoint(a.center) - a.radius
		},
		projectPoint: function(a, b) {
			void 0 === b && (console.warn("THREE.Plane: .projectPoint() target is now required"), b = new u);
			return b.copy(this.normal).multiplyScalar(-this.distanceToPoint(a)).add(a)
		},
		intersectLine: function(a, b) {
			void 0 === b && (console.warn("THREE.Plane: .intersectLine() target is now required"),
				b = new u);
			var c = a.delta(bm),
				d = this.normal.dot(c);
			if (0 === d) {
				if (0 === this.distanceToPoint(a.start)) return b.copy(a.start)
			} else if (d = -(a.start.dot(this.normal) + this.constant) / d, !(0 > d || 1 < d)) return b.copy(c).multiplyScalar(
				d).add(a.start)
		},
		intersectsLine: function(a) {
			var b = this.distanceToPoint(a.start);
			a = this.distanceToPoint(a.end);
			return 0 > b && 0 < a || 0 > a && 0 < b
		},
		intersectsBox: function(a) {
			return a.intersectsPlane(this)
		},
		intersectsSphere: function(a) {
			return a.intersectsPlane(this)
		},
		coplanarPoint: function(a) {
			void 0 ===
				a && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), a = new u);
			return a.copy(this.normal).multiplyScalar(-this.constant)
		},
		applyMatrix4: function(a, b) {
			b = b || Ns.getNormalMatrix(a);
			a = this.coplanarPoint(bm).applyMatrix4(a);
			b = this.normal.applyMatrix3(b).normalize();
			this.constant = -a.dot(b);
			return this
		},
		translate: function(a) {
			this.constant -= a.dot(this.normal);
			return this
		},
		equals: function(a) {
			return a.normal.equals(this.normal) && a.constant === this.constant
		}
	});
	var id = new Ne,
		Wj = new u;
	q(Ui.prototype, {
		set: function(a, b, c, d, e, g) {
			var k = this.planes;
			k[0].copy(a);
			k[1].copy(b);
			k[2].copy(c);
			k[3].copy(d);
			k[4].copy(e);
			k[5].copy(g);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			for (var b = this.planes, c = 0; 6 > c; c++) b[c].copy(a.planes[c]);
			return this
		},
		setFromMatrix: function(a) {
			var b = this.planes,
				c = a.elements;
			a = c[0];
			var d = c[1],
				e = c[2],
				g = c[3],
				k = c[4],
				l = c[5],
				m = c[6],
				n = c[7],
				r = c[8],
				p = c[9],
				q = c[10],
				u = c[11],
				z = c[12],
				C = c[13],
				D = c[14];
			c = c[15];
			b[0].setComponents(g - a, n - k, u - r, c - z).normalize();
			b[1].setComponents(g + a, n + k, u + r, c + z).normalize();
			b[2].setComponents(g + d, n + l, u + p, c + C).normalize();
			b[3].setComponents(g - d, n - l, u - p, c - C).normalize();
			b[4].setComponents(g - e, n - m, u - q, c - D).normalize();
			b[5].setComponents(g + e, n + m, u + q, c + D).normalize();
			return this
		},
		intersectsObject: function(a) {
			var b = a.geometry;
			null === b.boundingSphere && b.computeBoundingSphere();
			id.copy(b.boundingSphere).applyMatrix4(a.matrixWorld);
			return this.intersectsSphere(id)
		},
		intersectsSprite: function(a) {
			id.center.set(0, 0, 0);
			id.radius = .7071067811865476;
			id.applyMatrix4(a.matrixWorld);
			return this.intersectsSphere(id)
		},
		intersectsSphere: function(a) {
			var b = this.planes,
				c = a.center;
			a = -a.radius;
			for (var d = 0; 6 > d; d++)
				if (b[d].distanceToPoint(c) < a) return !1;
			return !0
		},
		intersectsBox: function(a) {
			for (var b = this.planes, c = 0; 6 > c; c++) {
				var d = b[c];
				Wj.x = 0 < d.normal.x ? a.max.x : a.min.x;
				Wj.y = 0 < d.normal.y ? a.max.y : a.min.y;
				Wj.z = 0 < d.normal.z ? a.max.z : a.min.z;
				if (0 > d.distanceToPoint(Wj)) return !1
			}
			return !0
		},
		containsPoint: function(a) {
			for (var b = this.planes, c = 0; 6 > c; c++)
				if (0 > b[c].distanceToPoint(a)) return !1;
			return !0
		}
	});
	var ma = {
			alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
			alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
			alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
			aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
			aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
			begin_vertex: "vec3 transformed = vec3( position );",
			beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
			bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif",
			bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
			clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
			clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
			clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
			clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
			color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
			color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
			color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
			color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
			common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}",
			cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
			defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\ttransformedNormal = mat3( instanceMatrix ) * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
			displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
			displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
			emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
			emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
			encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
			encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
			envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
			envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
			envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
			envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
			envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
			envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
			fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
			fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
			fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
			fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
			gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
			lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
			lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
			lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
			lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
			lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
			lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
			lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = clamp( clearcoatRoughness, 0.04, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif",
			lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
			lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( pointLight.shadow, directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( spotLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectLight.color *= all( bvec3( directionalLight.shadow, directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
			lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif",
			lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
			logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 1.0 ? log2( vFragDepth ) * logDepthBufFC * 0.5 : gl_FragCoord.z;\n#endif",
			logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
			logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
			logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
			map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
			map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
			map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
			map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
			metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
			metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
			morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
			morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
			morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
			normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
			normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, normalScale, normalMap );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
			normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec2 normalScale, in sampler2D normalMap ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy *= normalScale;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tbool frontFacing = dot( cross( S, T ), N ) > 0.0;\n\t\t\tmapN.xy *= ( float( frontFacing ) * 2.0 - 1.0 );\n\t\t#else\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif",
			clearcoat_normal_fragment_begin: "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
			clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 vTBN = mat3( tangent, bitangent, clearcoatNormal );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = clearcoatNormalScale * mapN.xy;\n\t\tclearcoatNormal = normalize( vTBN * mapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatNormalScale, clearcoatNormalMap );\n\t#endif\n#endif",
			clearcoat_normalmap_pars_fragment: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
			packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 encodeHalfRGBA ( vec2 v ) {\n\tvec4 encoded = vec4( 0.0 );\n\tconst vec2 offset = vec2( 1.0 / 255.0, 0.0 );\n\tencoded.xy = vec2( v.x, fract( v.x * 255.0 ) );\n\tencoded.xy = encoded.xy - ( encoded.yy * offset );\n\tencoded.zw = vec2( v.y, fract( v.y * 255.0 ) );\n\tencoded.zw = encoded.zw - ( encoded.ww * offset );\n\treturn encoded;\n}\nvec2 decodeHalfRGBA( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
			premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
			project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
			dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
			dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
			roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
			roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
			shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn decodeHalfRGBA( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = ( floor( uv * size - 0.5 ) + 0.5 ) * texelSize;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
			shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
			shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
			shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= all( bvec2( directionalLight.shadow, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= all( bvec2( spotLight.shadow, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= all( bvec2( pointLight.shadow, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
			skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
			skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
			skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
			skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
			specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
			specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
			tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
			tonemapping_pars_fragment: "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
			uv_pars_fragment: "#ifdef USE_UV\n\tvarying vec2 vUv;\n#endif",
			uv_pars_vertex: "#ifdef USE_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
			uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
			uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
			uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
			uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
			worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
			background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
			background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
			cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
			cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
			depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
			depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
			distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
			distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
			equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
			equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
			linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
			meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
			meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
			meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
			meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
			meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
			meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
			normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
			points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
			shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
			shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
			sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
			sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
		},
		V = {
			common: {
				diffuse: {
					value: new S(15658734)
				},
				opacity: {
					value: 1
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new kb
				},
				alphaMap: {
					value: null
				}
			},
			specularmap: {
				specularMap: {
					value: null
				}
			},
			envmap: {
				envMap: {
					value: null
				},
				flipEnvMap: {
					value: -1
				},
				reflectivity: {
					value: 1
				},
				refractionRatio: {
					value: .98
				},
				maxMipLevel: {
					value: 0
				}
			},
			aomap: {
				aoMap: {
					value: null
				},
				aoMapIntensity: {
					value: 1
				}
			},
			lightmap: {
				lightMap: {
					value: null
				},
				lightMapIntensity: {
					value: 1
				}
			},
			emissivemap: {
				emissiveMap: {
					value: null
				}
			},
			bumpmap: {
				bumpMap: {
					value: null
				},
				bumpScale: {
					value: 1
				}
			},
			normalmap: {
				normalMap: {
					value: null
				},
				normalScale: {
					value: new B(1, 1)
				}
			},
			displacementmap: {
				displacementMap: {
					value: null
				},
				displacementScale: {
					value: 1
				},
				displacementBias: {
					value: 0
				}
			},
			roughnessmap: {
				roughnessMap: {
					value: null
				}
			},
			metalnessmap: {
				metalnessMap: {
					value: null
				}
			},
			gradientmap: {
				gradientMap: {
					value: null
				}
			},
			fog: {
				fogDensity: {
					value: 2.5E-4
				},
				fogNear: {
					value: 1
				},
				fogFar: {
					value: 2E3
				},
				fogColor: {
					value: new S(16777215)
				}
			},
			lights: {
				ambientLightColor: {
					value: []
				},
				lightProbe: {
					value: []
				},
				directionalLights: {
					value: [],
					properties: {
						direction: {},
						color: {},
						shadow: {},
						shadowBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				directionalShadowMap: {
					value: []
				},
				directionalShadowMatrix: {
					value: []
				},
				spotLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						direction: {},
						distance: {},
						coneCos: {},
						penumbraCos: {},
						decay: {},
						shadow: {},
						shadowBias: {},
						shadowRadius: {},
						shadowMapSize: {}
					}
				},
				spotShadowMap: {
					value: []
				},
				spotShadowMatrix: {
					value: []
				},
				pointLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						decay: {},
						distance: {},
						shadow: {},
						shadowBias: {},
						shadowRadius: {},
						shadowMapSize: {},
						shadowCameraNear: {},
						shadowCameraFar: {}
					}
				},
				pointShadowMap: {
					value: []
				},
				pointShadowMatrix: {
					value: []
				},
				hemisphereLights: {
					value: [],
					properties: {
						direction: {},
						skyColor: {},
						groundColor: {}
					}
				},
				rectAreaLights: {
					value: [],
					properties: {
						color: {},
						position: {},
						width: {},
						height: {}
					}
				}
			},
			points: {
				diffuse: {
					value: new S(15658734)
				},
				opacity: {
					value: 1
				},
				size: {
					value: 1
				},
				scale: {
					value: 1
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new kb
				}
			},
			sprite: {
				diffuse: {
					value: new S(15658734)
				},
				opacity: {
					value: 1
				},
				center: {
					value: new B(.5, .5)
				},
				rotation: {
					value: 0
				},
				map: {
					value: null
				},
				uvTransform: {
					value: new kb
				}
			}
		},
		Yd = {
			basic: {
				uniforms: Gb([V.common, V.specularmap, V.envmap, V.aomap, V.lightmap, V.fog]),
				vertexShader: ma.meshbasic_vert,
				fragmentShader: ma.meshbasic_frag
			},
			lambert: {
				uniforms: Gb([V.common, V.specularmap, V.envmap, V.aomap, V.lightmap, V.emissivemap, V.fog, V.lights, {
					emissive: {
						value: new S(0)
					}
				}]),
				vertexShader: ma.meshlambert_vert,
				fragmentShader: ma.meshlambert_frag
			},
			phong: {
				uniforms: Gb([V.common, V.specularmap, V.envmap, V.aomap, V.lightmap, V.emissivemap, V.bumpmap, V.normalmap, V.displacementmap,
					V.gradientmap, V.fog, V.lights,
					{
						emissive: {
							value: new S(0)
						},
						specular: {
							value: new S(1118481)
						},
						shininess: {
							value: 30
						}
					}
				]),
				vertexShader: ma.meshphong_vert,
				fragmentShader: ma.meshphong_frag
			},
			standard: {
				uniforms: Gb([V.common, V.envmap, V.aomap, V.lightmap, V.emissivemap, V.bumpmap, V.normalmap, V.displacementmap, V
					.roughnessmap, V.metalnessmap, V.fog, V.lights, {
						emissive: {
							value: new S(0)
						},
						roughness: {
							value: .5
						},
						metalness: {
							value: .5
						},
						envMapIntensity: {
							value: 1
						}
					}
				]),
				vertexShader: ma.meshphysical_vert,
				fragmentShader: ma.meshphysical_frag
			},
			matcap: {
				uniforms: Gb([V.common,
					V.bumpmap, V.normalmap, V.displacementmap, V.fog, {
						matcap: {
							value: null
						}
					}
				]),
				vertexShader: ma.meshmatcap_vert,
				fragmentShader: ma.meshmatcap_frag
			},
			points: {
				uniforms: Gb([V.points, V.fog]),
				vertexShader: ma.points_vert,
				fragmentShader: ma.points_frag
			},
			dashed: {
				uniforms: Gb([V.common, V.fog, {
					scale: {
						value: 1
					},
					dashSize: {
						value: 1
					},
					totalSize: {
						value: 2
					}
				}]),
				vertexShader: ma.linedashed_vert,
				fragmentShader: ma.linedashed_frag
			},
			depth: {
				uniforms: Gb([V.common, V.displacementmap]),
				vertexShader: ma.depth_vert,
				fragmentShader: ma.depth_frag
			},
			normal: {
				uniforms: Gb([V.common, V.bumpmap, V.normalmap, V.displacementmap, {
					opacity: {
						value: 1
					}
				}]),
				vertexShader: ma.normal_vert,
				fragmentShader: ma.normal_frag
			},
			sprite: {
				uniforms: Gb([V.sprite, V.fog]),
				vertexShader: ma.sprite_vert,
				fragmentShader: ma.sprite_frag
			},
			background: {
				uniforms: {
					uvTransform: {
						value: new kb
					},
					t2D: {
						value: null
					}
				},
				vertexShader: ma.background_vert,
				fragmentShader: ma.background_frag
			},
			cube: {
				uniforms: {
					tCube: {
						value: null
					},
					tFlip: {
						value: -1
					},
					opacity: {
						value: 1
					}
				},
				vertexShader: ma.cube_vert,
				fragmentShader: ma.cube_frag
			},
			equirect: {
				uniforms: {
					tEquirect: {
						value: null
					}
				},
				vertexShader: ma.equirect_vert,
				fragmentShader: ma.equirect_frag
			},
			distanceRGBA: {
				uniforms: Gb([V.common, V.displacementmap, {
					referencePosition: {
						value: new u
					},
					nearDistance: {
						value: 1
					},
					farDistance: {
						value: 1E3
					}
				}]),
				vertexShader: ma.distanceRGBA_vert,
				fragmentShader: ma.distanceRGBA_frag
			},
			shadow: {
				uniforms: Gb([V.lights, V.fog, {
					color: {
						value: new S(0)
					},
					opacity: {
						value: 1
					}
				}]),
				vertexShader: ma.shadow_vert,
				fragmentShader: ma.shadow_frag
			}
		};
	Yd.physical = {
		uniforms: Gb([Yd.standard.uniforms,
			{
				transparency: {
					value: 0
				},
				clearcoat: {
					value: 0
				},
				clearcoatRoughness: {
					value: 0
				},
				sheen: {
					value: new S(0)
				},
				clearcoatNormalScale: {
					value: new B(1, 1)
				},
				clearcoatNormalMap: {
					value: null
				}
			}
		]),
		vertexShader: ma.meshphysical_vert,
		fragmentShader: ma.meshphysical_frag
	};
	Af.prototype = p(R.prototype);
	Af.prototype.constructor = Af;
	Xd.prototype = p(J.prototype);
	Xd.prototype.constructor = Xd;
	rd.prototype = p(pa.prototype);
	rd.prototype.constructor = rd;
	rd.prototype.isCubeTexture = !0;
	Object.defineProperty(rd.prototype, "images", {
		get: function() {
			return this.image
		},
		set: function(a) {
			this.image = a
		}
	});
	Pe.prototype = p(pa.prototype);
	Pe.prototype.constructor = Pe;
	Pe.prototype.isDataTexture2DArray = !0;
	Qe.prototype = p(pa.prototype);
	Qe.prototype.constructor = Qe;
	Qe.prototype.isDataTexture3D = !0;
	var Cm = new pa,
		Up = new Pe,
		Wp = new Qe,
		Dm = new rd,
		wm = [],
		ym = [],
		Bm = new Float32Array(16),
		Am = new Float32Array(9),
		zm = new Float32Array(4);
	Em.prototype.updateCache = function(a) {
		var b = this.cache;
		a instanceof Float32Array && b.length !== a.length && (this.cache = new Float32Array(a.length));
		Pb(b, a)
	};
	Fm.prototype.setValue =
		function(a, b, c) {
			for (var d = this.seq, e = 0, g = d.length; e !== g; ++e) {
				var k = d[e];
				k.setValue(a, b[k.id], c)
			}
		};
	var Wi = /([\w\d_]+)(\])?(\[|\.)?/g;
	Re.prototype.setValue = function(a, b, c, d) {
		b = this.map[b];
		void 0 !== b && b.setValue(a, c, d)
	};
	Re.prototype.setOptional = function(a, b, c) {
		b = b[c];
		void 0 !== b && this.setValue(a, c, b)
	};
	Re.upload = function(a, b, c, d) {
		for (var e = 0, g = b.length; e !== g; ++e) {
			var k = b[e],
				l = c[k.id];
			!1 !== l.needsUpdate && k.setValue(a, l.value, d)
		}
	};
	Re.seqWithValue = function(a, b) {
		for (var c = [], d = 0, e = a.length; d !== e; ++d) {
			var g =
				a[d];
			g.id in b && c.push(g)
		}
		return c
	};
	var Aq = 0,
		Xi = /^[ \t]*#include +<([\w\d./]+)>/gm,
		Nm = /#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
		Jq = 0;
	Zd.prototype = p(ia.prototype);
	Zd.prototype.constructor = Zd;
	Zd.prototype.isMeshDepthMaterial = !0;
	Zd.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.depthPacking = a.depthPacking;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.map = a.map;
		this.alphaMap = a.alphaMap;
		this.displacementMap = a.displacementMap;
		this.displacementScale = a.displacementScale;
		this.displacementBias = a.displacementBias;
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		return this
	};
	$d.prototype = p(ia.prototype);
	$d.prototype.constructor = $d;
	$d.prototype.isMeshDistanceMaterial = !0;
	$d.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.referencePosition.copy(a.referencePosition);
		this.nearDistance = a.nearDistance;
		this.farDistance = a.farDistance;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.map =
			a.map;
		this.alphaMap = a.alphaMap;
		this.displacementMap = a.displacementMap;
		this.displacementScale = a.displacementScale;
		this.displacementBias = a.displacementBias;
		return this
	};
	ek.prototype = q(p(Oa.prototype), {
		constructor: ek,
		isWebGLMultiviewRenderTarget: !0,
		copy: function(a) {
			Oa.prototype.copy.call(this, a);
			this.numViews = a.numViews;
			return this
		},
		setNumViews: function(a) {
			this.numViews !== a && (this.numViews = a, this.dispose());
			return this
		}
	});
	Hg.prototype = q(p(P.prototype), {
		constructor: Hg,
		isGroup: !0
	});
	Yi.prototype = q(p(ab.prototype), {
		constructor: Yi,
		isArrayCamera: !0
	});
	var Um = new u,
		Vm = new u;
	q(fk.prototype, nb.prototype);
	q(Wm.prototype, nb.prototype);
	q(gk.prototype, {
		isFogExp2: !0,
		clone: function() {
			return new gk(this.color, this.density)
		},
		toJSON: function() {
			return {
				type: "FogExp2",
				color: this.color.getHex(),
				density: this.density
			}
		}
	});
	q(hk.prototype, {
		isFog: !0,
		clone: function() {
			return new hk(this.color, this.near, this.far)
		},
		toJSON: function() {
			return {
				type: "Fog",
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			}
		}
	});
	Object.defineProperty(gc.prototype,
		"needsUpdate", {
			set: function(a) {
				!0 === a && this.version++
			}
		});
	q(gc.prototype, {
		isInterleavedBuffer: !0,
		onUploadCallback: function() {},
		setDynamic: function(a) {
			this.dynamic = a;
			return this
		},
		copy: function(a) {
			this.array = new a.array.constructor(a.array);
			this.count = a.count;
			this.stride = a.stride;
			this.dynamic = a.dynamic;
			return this
		},
		copyAt: function(a, b, c) {
			a *= this.stride;
			c *= b.stride;
			for (var d = 0, e = this.stride; d < e; d++) this.array[a + d] = b.array[c + d];
			return this
		},
		set: function(a, b) {
			void 0 === b && (b = 0);
			this.array.set(a, b);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		onUpload: function(a) {
			this.onUploadCallback = a;
			return this
		}
	});
	ja(Kh.prototype, {
		count: {
			get: function() {
				return this.data.count
			}
		},
		array: {
			get: function() {
				return this.data.array
			}
		}
	});
	q(Kh.prototype, {
		isInterleavedBufferAttribute: !0,
		setX: function(a, b) {
			this.data.array[a * this.data.stride + this.offset] = b;
			return this
		},
		setY: function(a, b) {
			this.data.array[a * this.data.stride + this.offset + 1] = b;
			return this
		},
		setZ: function(a, b) {
			this.data.array[a * this.data.stride + this.offset +
				2] = b;
			return this
		},
		setW: function(a, b) {
			this.data.array[a * this.data.stride + this.offset + 3] = b;
			return this
		},
		getX: function(a) {
			return this.data.array[a * this.data.stride + this.offset]
		},
		getY: function(a) {
			return this.data.array[a * this.data.stride + this.offset + 1]
		},
		getZ: function(a) {
			return this.data.array[a * this.data.stride + this.offset + 2]
		},
		getW: function(a) {
			return this.data.array[a * this.data.stride + this.offset + 3]
		},
		setXY: function(a, b, c) {
			a = a * this.data.stride + this.offset;
			this.data.array[a + 0] = b;
			this.data.array[a + 1] = c;
			return this
		},
		setXYZ: function(a, b, c, d) {
			a = a * this.data.stride + this.offset;
			this.data.array[a + 0] = b;
			this.data.array[a + 1] = c;
			this.data.array[a + 2] = d;
			return this
		},
		setXYZW: function(a, b, c, d, e) {
			a = a * this.data.stride + this.offset;
			this.data.array[a + 0] = b;
			this.data.array[a + 1] = c;
			this.data.array[a + 2] = d;
			this.data.array[a + 3] = e;
			return this
		}
	});
	Cc.prototype = p(ia.prototype);
	Cc.prototype.constructor = Cc;
	Cc.prototype.isSpriteMaterial = !0;
	Cc.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.map =
			a.map;
		this.rotation = a.rotation;
		this.sizeAttenuation = a.sizeAttenuation;
		return this
	};
	var Se, Fe = new u,
		Ge = new u,
		Pd = new u,
		Ig = new B,
		ae = new B,
		Zm = new ua,
		Ci = new u,
		He = new u,
		Di = new u,
		Qo = new B,
		cm = new B,
		Ro = new B;
	ik.prototype = q(p(P.prototype), {
		constructor: ik,
		isSprite: !0,
		raycast: function(a, b) {
			null === a.camera && console.error(
				'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
			Ge.setFromMatrixScale(this.matrixWorld);
			Zm.copy(a.camera.matrixWorld);
			this.modelViewMatrix.multiplyMatrices(a.camera.matrixWorldInverse,
				this.matrixWorld);
			Pd.setFromMatrixPosition(this.modelViewMatrix);
			a.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && Ge.multiplyScalar(-Pd.z);
			var c = this.material.rotation;
			if (0 !== c) {
				var d = Math.cos(c);
				var e = Math.sin(c)
			}
			c = this.center;
			Cf(Ci.set(-.5, -.5, 0), Pd, c, Ge, e, d);
			Cf(He.set(.5, -.5, 0), Pd, c, Ge, e, d);
			Cf(Di.set(.5, .5, 0), Pd, c, Ge, e, d);
			Qo.set(0, 0);
			cm.set(1, 0);
			Ro.set(1, 1);
			var g = a.ray.intersectTriangle(Ci, He, Di, !1, Fe);
			if (null === g && (Cf(He.set(-.5, .5, 0), Pd, c, Ge, e, d), cm.set(0, 1), g = a.ray.intersectTriangle(Ci,
					Di, He, !1, Fe), null === g)) return;
			e = a.ray.origin.distanceTo(Fe);
			e < a.near || e > a.far || b.push({
				distance: e,
				point: Fe.clone(),
				uv: ob.getUV(Fe, Ci, He, Di, Qo, cm, Ro, new B),
				face: null,
				object: this
			})
		},
		clone: function() {
			return (new this.constructor(this.material)).copy(this)
		},
		copy: function(a) {
			P.prototype.copy.call(this, a);
			void 0 !== a.center && this.center.copy(a.center);
			return this
		}
	});
	var Ei = new u,
		So = new u;
	Zi.prototype = q(p(P.prototype), {
		constructor: Zi,
		isLOD: !0,
		copy: function(a) {
			P.prototype.copy.call(this, a, !1);
			a = a.levels;
			for (var b =
					0, c = a.length; b < c; b++) {
				var d = a[b];
				this.addLevel(d.object.clone(), d.distance)
			}
			return this
		},
		addLevel: function(a, b) {
			void 0 === b && (b = 0);
			b = Math.abs(b);
			for (var c = this.levels, d = 0; d < c.length && !(b < c[d].distance); d++);
			c.splice(d, 0, {
				distance: b,
				object: a
			});
			this.add(a);
			return this
		},
		getObjectForDistance: function(a) {
			for (var b = this.levels, c = 1, d = b.length; c < d && !(a < b[c].distance); c++);
			return b[c - 1].object
		},
		raycast: function(a, b) {
			Ei.setFromMatrixPosition(this.matrixWorld);
			var c = a.ray.origin.distanceTo(Ei);
			this.getObjectForDistance(c).raycast(a,
				b)
		},
		update: function(a) {
			var b = this.levels;
			if (1 < b.length) {
				Ei.setFromMatrixPosition(a.matrixWorld);
				So.setFromMatrixPosition(this.matrixWorld);
				a = Ei.distanceTo(So);
				b[0].object.visible = !0;
				for (var c = 1, d = b.length; c < d; c++)
					if (a >= b[c].distance) b[c - 1].object.visible = !1, b[c].object.visible = !0;
					else break;
				for (; c < d; c++) b[c].object.visible = !1
			}
		},
		toJSON: function(a) {
			a = P.prototype.toJSON.call(this, a);
			a.object.levels = [];
			for (var b = this.levels, c = 0, d = b.length; c < d; c++) {
				var e = b[c];
				a.object.levels.push({
					object: e.object.uuid,
					distance: e.distance
				})
			}
			return a
		}
	});
	$i.prototype = q(p(Wa.prototype), {
		constructor: $i,
		isSkinnedMesh: !0,
		bind: function(a, b) {
			this.skeleton = a;
			void 0 === b && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), b = this.matrixWorld);
			this.bindMatrix.copy(b);
			this.bindMatrixInverse.getInverse(b)
		},
		pose: function() {
			this.skeleton.pose()
		},
		normalizeSkinWeights: function() {
			for (var a = new za, b = this.geometry.attributes.skinWeight, c = 0, d = b.count; c < d; c++) {
				a.x = b.getX(c);
				a.y = b.getY(c);
				a.z = b.getZ(c);
				a.w = b.getW(c);
				var e = 1 /
					a.manhattanLength();
				Infinity !== e ? a.multiplyScalar(e) : a.set(1, 0, 0, 0);
				b.setXYZW(c, a.x, a.y, a.z, a.w)
			}
		},
		updateMatrixWorld: function(a) {
			Wa.prototype.updateMatrixWorld.call(this, a);
			"attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ?
				this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " +
					this.bindMode)
		},
		clone: function() {
			return (new this.constructor(this.geometry, this.material)).copy(this)
		}
	});
	var To = new ua,
		Os = new ua;
	q(jk.prototype, {
		calculateInverses: function() {
			this.boneInverses = [];
			for (var a = 0, b = this.bones.length; a < b; a++) {
				var c = new ua;
				this.bones[a] && c.getInverse(this.bones[a].matrixWorld);
				this.boneInverses.push(c)
			}
		},
		pose: function() {
			var a, b;
			var c = 0;
			for (b = this.bones.length; c < b; c++)(a = this.bones[c]) && a.matrixWorld.getInverse(this.boneInverses[c]);
			c = 0;
			for (b = this.bones.length; c < b; c++)
				if (a = this.bones[c]) a.parent && a.parent.isBone ? (a.matrix.getInverse(a.parent.matrixWorld), a.matrix.multiply(
						a.matrixWorld)) :
					a.matrix.copy(a.matrixWorld), a.matrix.decompose(a.position, a.quaternion, a.scale)
		},
		update: function() {
			for (var a = this.bones, b = this.boneInverses, c = this.boneMatrices, d = this.boneTexture, e = 0, g = a.length; e <
				g; e++) To.multiplyMatrices(a[e] ? a[e].matrixWorld : Os, b[e]), To.toArray(c, 16 * e);
			void 0 !== d && (d.needsUpdate = !0)
		},
		clone: function() {
			return new jk(this.bones, this.boneInverses)
		},
		getBoneByName: function(a) {
			for (var b = 0, c = this.bones.length; b < c; b++) {
				var d = this.bones[b];
				if (d.name === a) return d
			}
		}
	});
	$m.prototype = q(p(P.prototype), {
		constructor: $m,
		isBone: !0
	});
	an.prototype = q(p(Wa.prototype), {
		constructor: an,
		isInstancedMesh: !0,
		raycast: function() {},
		setMatrixAt: function(a, b) {
			b.toArray(this.instanceMatrix.array, 16 * a)
		},
		updateMorphTargets: function() {}
	});
	Aa.prototype = p(ia.prototype);
	Aa.prototype.constructor = Aa;
	Aa.prototype.isLineBasicMaterial = !0;
	Aa.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.linewidth = a.linewidth;
		this.linecap = a.linecap;
		this.linejoin = a.linejoin;
		return this
	};
	var Uo = new u,
		Vo =
		new u,
		Wo = new ua,
		ug = new wf,
		Ie = new Ne;
	Pa.prototype = q(p(P.prototype), {
		constructor: Pa,
		isLine: !0,
		computeLineDistances: function() {
			var a = this.geometry;
			if (a.isBufferGeometry)
				if (null === a.index) {
					for (var b = a.attributes.position, c = [0], d = 1, e = b.count; d < e; d++) Uo.fromBufferAttribute(b, d - 1),
						Vo.fromBufferAttribute(b, d), c[d] = c[d - 1], c[d] += Uo.distanceTo(Vo);
					a.addAttribute("lineDistance", new N(c, 1))
				} else console.warn(
					"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
			else if (a.isGeometry)
				for (b =
					a.vertices, c = a.lineDistances, c[0] = 0, d = 1, e = b.length; d < e; d++) c[d] = c[d - 1], c[d] += b[d - 1].distanceTo(
					b[d]);
			return this
		},
		raycast: function(a, b) {
			var c = a.linePrecision,
				d = this.geometry,
				e = this.matrixWorld;
			null === d.boundingSphere && d.computeBoundingSphere();
			Ie.copy(d.boundingSphere);
			Ie.applyMatrix4(e);
			Ie.radius += c;
			if (!1 !== a.ray.intersectsSphere(Ie)) {
				Wo.getInverse(e);
				ug.copy(a.ray).applyMatrix4(Wo);
				c /= (this.scale.x + this.scale.y + this.scale.z) / 3;
				c *= c;
				var g = new u,
					k = new u;
				e = new u;
				var l = new u,
					m = this && this.isLineSegments ?
					2 : 1;
				if (d.isBufferGeometry) {
					var n = d.index,
						r = d.attributes.position.array;
					if (null !== n) {
						n = n.array;
						d = 0;
						for (var p = n.length - 1; d < p; d += m) {
							var q = n[d + 1];
							g.fromArray(r, 3 * n[d]);
							k.fromArray(r, 3 * q);
							q = ug.distanceSqToSegment(g, k, l, e);
							q > c || (l.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(l), q < a.near || q > a.far || b.push({
								distance: q,
								point: e.clone().applyMatrix4(this.matrixWorld),
								index: d,
								face: null,
								faceIndex: null,
								object: this
							}))
						}
					} else
						for (d = 0, p = r.length / 3 - 1; d < p; d += m) g.fromArray(r, 3 * d), k.fromArray(r, 3 * d + 3), q = ug.distanceSqToSegment(
							g,
							k, l, e), q > c || (l.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(l), q < a.near || q > a.far ||
							b.push({
								distance: q,
								point: e.clone().applyMatrix4(this.matrixWorld),
								index: d,
								face: null,
								faceIndex: null,
								object: this
							}))
				} else if (d.isGeometry)
					for (g = d.vertices, k = g.length, d = 0; d < k - 1; d += m) q = ug.distanceSqToSegment(g[d], g[d + 1], l, e),
						q > c || (l.applyMatrix4(this.matrixWorld), q = a.ray.origin.distanceTo(l), q < a.near || q > a.far || b.push({
							distance: q,
							point: e.clone().applyMatrix4(this.matrixWorld),
							index: d,
							face: null,
							faceIndex: null,
							object: this
						}))
			}
		},
		clone: function() {
			return (new this.constructor(this.geometry, this.material)).copy(this)
		}
	});
	var vg = new u,
		Fi = new u;
	Ra.prototype = q(p(Pa.prototype), {
		constructor: Ra,
		isLineSegments: !0,
		computeLineDistances: function() {
			var a = this.geometry;
			if (a.isBufferGeometry)
				if (null === a.index) {
					for (var b = a.attributes.position, c = [], d = 0, e = b.count; d < e; d += 2) vg.fromBufferAttribute(b, d),
						Fi.fromBufferAttribute(b, d + 1), c[d] = 0 === d ? 0 : c[d - 1], c[d + 1] = c[d] + vg.distanceTo(Fi);
					a.addAttribute("lineDistance", new N(c, 1))
				} else console.warn(
					"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
			else if (a.isGeometry)
				for (b = a.vertices, c = a.lineDistances, d = 0, e = b.length; d < e; d += 2) vg.copy(b[d]), Fi.copy(b[d + 1]),
					c[d] = 0 === d ? 0 : c[d - 1], c[d + 1] = c[d] + vg.distanceTo(Fi);
			return this
		}
	});
	kk.prototype = q(p(Pa.prototype), {
		constructor: kk,
		isLineLoop: !0
	});
	Dc.prototype = p(ia.prototype);
	Dc.prototype.constructor = Dc;
	Dc.prototype.isPointsMaterial = !0;
	Dc.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.map = a.map;
		this.size = a.size;
		this.sizeAttenuation = a.sizeAttenuation;
		this.morphTargets =
			a.morphTargets;
		return this
	};
	var Xo = new ua,
		aj = new wf,
		Je = new Ne,
		sh = new u;
	lk.prototype = q(p(P.prototype), {
		constructor: lk,
		isPoints: !0,
		raycast: function(a, b) {
			var c = this.geometry,
				d = this.matrixWorld,
				e = a.params.Points.threshold;
			null === c.boundingSphere && c.computeBoundingSphere();
			Je.copy(c.boundingSphere);
			Je.applyMatrix4(d);
			Je.radius += e;
			if (!1 !== a.ray.intersectsSphere(Je))
				if (Xo.getInverse(d), aj.copy(a.ray).applyMatrix4(Xo), e /= (this.scale.x + this.scale.y + this.scale.z) / 3, e *=
					e, c.isBufferGeometry) {
					var g = c.index;
					c =
						c.attributes.position.array;
					if (null !== g) {
						var k = g.array;
						g = 0;
						for (var l = k.length; g < l; g++) {
							var m = k[g];
							sh.fromArray(c, 3 * m);
							mk(sh, m, e, d, a, b, this)
						}
					} else
						for (g = 0, k = c.length / 3; g < k; g++) sh.fromArray(c, 3 * g), mk(sh, g, e, d, a, b, this)
				} else
					for (c = c.vertices, g = 0, k = c.length; g < k; g++) mk(c[g], g, e, d, a, b, this)
		},
		updateMorphTargets: function() {
			var a = this.geometry;
			if (a.isBufferGeometry) {
				a = a.morphAttributes;
				var b = Ha(a);
				if (0 < b.length) {
					var c = a[b[0]];
					if (void 0 !== c)
						for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, a =
							0, b = c.length; a < b; a++) {
							var d = c[a].name || String(a);
							this.morphTargetInfluences.push(0);
							this.morphTargetDictionary[d] = a
						}
				}
			} else a = a.morphTargets, void 0 !== a && 0 < a.length && console.error(
				"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
		},
		clone: function() {
			return (new this.constructor(this.geometry, this.material)).copy(this)
		}
	});
	bn.prototype = q(p(pa.prototype), {
		constructor: bn,
		isVideoTexture: !0,
		update: function() {
			var a = this.image;
			a.readyState >= a.HAVE_CURRENT_DATA &&
				(this.needsUpdate = !0)
		}
	});
	be.prototype = p(pa.prototype);
	be.prototype.constructor = be;
	be.prototype.isCompressedTexture = !0;
	Lh.prototype = p(pa.prototype);
	Lh.prototype.constructor = Lh;
	Lh.prototype.isCanvasTexture = !0;
	Mh.prototype = p(pa.prototype);
	Mh.prototype.constructor = Mh;
	Mh.prototype.isDepthTexture = !0;
	Nh.prototype = p(J.prototype);
	Nh.prototype.constructor = Nh;
	bj.prototype = p(R.prototype);
	bj.prototype.constructor = bj;
	Te.prototype = p(J.prototype);
	Te.prototype.constructor = Te;
	cj.prototype = p(R.prototype);
	cj.prototype.constructor =
		cj;
	Rb.prototype = p(J.prototype);
	Rb.prototype.constructor = Rb;
	Df.prototype = p(R.prototype);
	Df.prototype.constructor = Df;
	Ue.prototype = p(Rb.prototype);
	Ue.prototype.constructor = Ue;
	Ef.prototype = p(R.prototype);
	Ef.prototype.constructor = Ef;
	Ec.prototype = p(Rb.prototype);
	Ec.prototype.constructor = Ec;
	dj.prototype = p(R.prototype);
	dj.prototype.constructor = dj;
	Ve.prototype = p(Rb.prototype);
	Ve.prototype.constructor = Ve;
	Jg.prototype = p(R.prototype);
	Jg.prototype.constructor = Jg;
	Ff.prototype = p(Rb.prototype);
	Ff.prototype.constructor =
		Ff;
	Gf.prototype = p(R.prototype);
	Gf.prototype.constructor = Gf;
	Hf.prototype = p(J.prototype);
	Hf.prototype.constructor = Hf;
	Hf.prototype.toJSON = function() {
		var a = J.prototype.toJSON.call(this);
		a.path = this.parameters.path.toJSON();
		return a
	};
	Kg.prototype = p(R.prototype);
	Kg.prototype.constructor = Kg;
	We.prototype = p(J.prototype);
	We.prototype.constructor = We;
	If.prototype = p(R.prototype);
	If.prototype.constructor = If;
	ce.prototype = p(J.prototype);
	ce.prototype.constructor = ce;
	var Ps = {
			triangulate: function(a, b, c) {
				c = c || 2;
				var d =
					b && b.length,
					e = d ? b[0] * c : a.length,
					g = cn(a, 0, e, c, !0),
					k = [];
				if (!g || g.next === g.prev) return k;
				var l;
				if (d) {
					var m = c;
					d = [];
					var n;
					var r = 0;
					for (n = b.length; r < n; r++) {
						var p = b[r] * m;
						var q = r < n - 1 ? b[r + 1] * m : a.length;
						p = cn(a, p, q, m, !1);
						p === p.next && (p.steiner = !0);
						d.push(Sq(p))
					}
					d.sort(Qq);
					for (r = 0; r < d.length; r++) {
						b = d[r];
						m = g;
						if (m = Rq(b, m)) b = fn(m, b), Ye(b, b.next);
						g = Ye(g, g.next)
					}
				}
				if (a.length > 80 * c) {
					var u = l = a[0];
					var z = d = a[1];
					for (m = c; m < e; m += c) r = a[m], b = a[m + 1], r < u && (u = r), b < z && (z = b), r > l && (l = r), b > d &&
						(d = b);
					l = Math.max(l - u, d - z);
					l = 0 !== l ? 1 / l :
						0
				}
				Ze(g, k, c, u, z, l);
				return k
			}
		},
		Sb = {
			area: function(a) {
				for (var b = a.length, c = 0, d = b - 1, e = 0; e < b; d = e++) c += a[d].x * a[e].y - a[e].x * a[d].y;
				return .5 * c
			},
			isClockWise: function(a) {
				return 0 > Sb.area(a)
			},
			triangulateShape: function(a, b) {
				var c = [],
					d = [],
					e = [];
				gn(a);
				hn(c, a);
				var g = a.length;
				b.forEach(gn);
				for (a = 0; a < b.length; a++) d.push(g), g += b[a].length, hn(c, b[a]);
				b = Ps.triangulate(c, d);
				for (a = 0; a < b.length; a += 3) e.push(b.slice(a, a + 3));
				return e
			}
		};
	Jf.prototype = p(R.prototype);
	Jf.prototype.constructor = Jf;
	Jf.prototype.toJSON = function() {
		var a =
			R.prototype.toJSON.call(this);
		return jn(this.parameters.shapes, this.parameters.options, a)
	};
	de.prototype = p(J.prototype);
	de.prototype.constructor = de;
	de.prototype.toJSON = function() {
		var a = J.prototype.toJSON.call(this);
		return jn(this.parameters.shapes, this.parameters.options, a)
	};
	var Tq = {
		generateTopUV: function(a, b, c, d, e) {
			a = b[3 * d];
			d = b[3 * d + 1];
			var g = b[3 * e];
			e = b[3 * e + 1];
			return [new B(b[3 * c], b[3 * c + 1]), new B(a, d), new B(g, e)]
		},
		generateSideWallUV: function(a, b, c, d, e, g) {
			a = b[3 * c];
			var k = b[3 * c + 1];
			c = b[3 * c + 2];
			var l = b[3 *
					d],
				m = b[3 * d + 1];
			d = b[3 * d + 2];
			var n = b[3 * e],
				r = b[3 * e + 1];
			e = b[3 * e + 2];
			var p = b[3 * g],
				q = b[3 * g + 1];
			b = b[3 * g + 2];
			return .01 > Math.abs(k - m) ? [new B(a, 1 - c), new B(l, 1 - d), new B(n, 1 - e), new B(p, 1 - b)] : [new B(k, 1 -
				c), new B(m, 1 - d), new B(r, 1 - e), new B(q, 1 - b)]
		}
	};
	Mg.prototype = p(R.prototype);
	Mg.prototype.constructor = Mg;
	af.prototype = p(de.prototype);
	af.prototype.constructor = af;
	Ng.prototype = p(R.prototype);
	Ng.prototype.constructor = Ng;
	Fc.prototype = p(J.prototype);
	Fc.prototype.constructor = Fc;
	Ph.prototype = p(R.prototype);
	Ph.prototype.constructor =
		Ph;
	bf.prototype = p(J.prototype);
	bf.prototype.constructor = bf;
	Og.prototype = p(R.prototype);
	Og.prototype.constructor = Og;
	cf.prototype = p(J.prototype);
	cf.prototype.constructor = cf;
	Kf.prototype = p(R.prototype);
	Kf.prototype.constructor = Kf;
	Kf.prototype.toJSON = function() {
		var a = R.prototype.toJSON.call(this);
		return kn(this.parameters.shapes, a)
	};
	td.prototype = p(J.prototype);
	td.prototype.constructor = td;
	td.prototype.toJSON = function() {
		var a = J.prototype.toJSON.call(this);
		return kn(this.parameters.shapes, a)
	};
	Pg.prototype =
		p(J.prototype);
	Pg.prototype.constructor = Pg;
	df.prototype = p(R.prototype);
	df.prototype.constructor = df;
	ic.prototype = p(J.prototype);
	ic.prototype.constructor = ic;
	Qg.prototype = p(df.prototype);
	Qg.prototype.constructor = Qg;
	fj.prototype = p(ic.prototype);
	fj.prototype.constructor = fj;
	Lf.prototype = p(R.prototype);
	Lf.prototype.constructor = Lf;
	ef.prototype = p(J.prototype);
	ef.prototype.constructor = ef;
	var Fb = Ag({
		WireframeGeometry: Nh,
		ParametricGeometry: bj,
		ParametricBufferGeometry: Te,
		TetrahedronGeometry: Df,
		TetrahedronBufferGeometry: Ue,
		OctahedronGeometry: Ef,
		OctahedronBufferGeometry: Ec,
		IcosahedronGeometry: dj,
		IcosahedronBufferGeometry: Ve,
		DodecahedronGeometry: Jg,
		DodecahedronBufferGeometry: Ff,
		PolyhedronGeometry: cj,
		PolyhedronBufferGeometry: Rb,
		TubeGeometry: Gf,
		TubeBufferGeometry: Hf,
		TorusKnotGeometry: Kg,
		TorusKnotBufferGeometry: We,
		TorusGeometry: If,
		TorusBufferGeometry: ce,
		TextGeometry: Mg,
		TextBufferGeometry: af,
		SphereGeometry: Ng,
		SphereBufferGeometry: Fc,
		RingGeometry: Ph,
		RingBufferGeometry: bf,
		PlaneGeometry: Af,
		PlaneBufferGeometry: Xd,
		LatheGeometry: Og,
		LatheBufferGeometry: cf,
		ShapeGeometry: Kf,
		ShapeBufferGeometry: td,
		ExtrudeGeometry: Jf,
		ExtrudeBufferGeometry: de,
		EdgesGeometry: Pg,
		ConeGeometry: Qg,
		ConeBufferGeometry: fj,
		CylinderGeometry: df,
		CylinderBufferGeometry: ic,
		CircleGeometry: Lf,
		CircleBufferGeometry: ef,
		BoxGeometry: Ls,
		BoxBufferGeometry: Gh
	});
	Mf.prototype = p(ia.prototype);
	Mf.prototype.constructor = Mf;
	Mf.prototype.isShadowMaterial = !0;
	Mf.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		return this
	};
	ff.prototype = p(Ia.prototype);
	ff.prototype.constructor = ff;
	ff.prototype.isRawShaderMaterial = !0;
	ee.prototype = p(ia.prototype);
	ee.prototype.constructor = ee;
	ee.prototype.isMeshStandardMaterial = !0;
	ee.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.defines = {
			STANDARD: ""
		};
		this.color.copy(a.color);
		this.roughness = a.roughness;
		this.metalness = a.metalness;
		this.map = a.map;
		this.lightMap = a.lightMap;
		this.lightMapIntensity = a.lightMapIntensity;
		this.aoMap = a.aoMap;
		this.aoMapIntensity = a.aoMapIntensity;
		this.emissive.copy(a.emissive);
		this.emissiveMap =
			a.emissiveMap;
		this.emissiveIntensity = a.emissiveIntensity;
		this.bumpMap = a.bumpMap;
		this.bumpScale = a.bumpScale;
		this.normalMap = a.normalMap;
		this.normalMapType = a.normalMapType;
		this.normalScale.copy(a.normalScale);
		this.displacementMap = a.displacementMap;
		this.displacementScale = a.displacementScale;
		this.displacementBias = a.displacementBias;
		this.roughnessMap = a.roughnessMap;
		this.metalnessMap = a.metalnessMap;
		this.alphaMap = a.alphaMap;
		this.envMap = a.envMap;
		this.envMapIntensity = a.envMapIntensity;
		this.refractionRatio =
			a.refractionRatio;
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		this.wireframeLinecap = a.wireframeLinecap;
		this.wireframeLinejoin = a.wireframeLinejoin;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.morphNormals = a.morphNormals;
		return this
	};
	Nf.prototype = p(ee.prototype);
	Nf.prototype.constructor = Nf;
	Nf.prototype.isMeshPhysicalMaterial = !0;
	Nf.prototype.copy = function(a) {
		ee.prototype.copy.call(this, a);
		this.defines = {
			STANDARD: "",
			PHYSICAL: ""
		};
		this.reflectivity = a.reflectivity;
		this.clearcoat = a.clearcoat;
		this.clearcoatRoughness = a.clearcoatRoughness;
		this.sheen = a.sheen ? (this.sheen || new S).copy(a.sheen) : null;
		this.clearcoatNormalMap = a.clearcoatNormalMap;
		this.clearcoatNormalScale.copy(a.clearcoatNormalScale);
		this.transparency = a.transparency;
		return this
	};
	Gc.prototype = p(ia.prototype);
	Gc.prototype.constructor = Gc;
	Gc.prototype.isMeshPhongMaterial = !0;
	Gc.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.specular.copy(a.specular);
		this.shininess =
			a.shininess;
		this.map = a.map;
		this.lightMap = a.lightMap;
		this.lightMapIntensity = a.lightMapIntensity;
		this.aoMap = a.aoMap;
		this.aoMapIntensity = a.aoMapIntensity;
		this.emissive.copy(a.emissive);
		this.emissiveMap = a.emissiveMap;
		this.emissiveIntensity = a.emissiveIntensity;
		this.bumpMap = a.bumpMap;
		this.bumpScale = a.bumpScale;
		this.normalMap = a.normalMap;
		this.normalMapType = a.normalMapType;
		this.normalScale.copy(a.normalScale);
		this.displacementMap = a.displacementMap;
		this.displacementScale = a.displacementScale;
		this.displacementBias =
			a.displacementBias;
		this.specularMap = a.specularMap;
		this.alphaMap = a.alphaMap;
		this.envMap = a.envMap;
		this.combine = a.combine;
		this.reflectivity = a.reflectivity;
		this.refractionRatio = a.refractionRatio;
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		this.wireframeLinecap = a.wireframeLinecap;
		this.wireframeLinejoin = a.wireframeLinejoin;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.morphNormals = a.morphNormals;
		return this
	};
	Of.prototype = p(Gc.prototype);
	Of.prototype.constructor =
		Of;
	Of.prototype.isMeshToonMaterial = !0;
	Of.prototype.copy = function(a) {
		Gc.prototype.copy.call(this, a);
		this.gradientMap = a.gradientMap;
		return this
	};
	ud.prototype = p(ia.prototype);
	ud.prototype.constructor = ud;
	ud.prototype.isMeshNormalMaterial = !0;
	ud.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.bumpMap = a.bumpMap;
		this.bumpScale = a.bumpScale;
		this.normalMap = a.normalMap;
		this.normalMapType = a.normalMapType;
		this.normalScale.copy(a.normalScale);
		this.displacementMap = a.displacementMap;
		this.displacementScale =
			a.displacementScale;
		this.displacementBias = a.displacementBias;
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.morphNormals = a.morphNormals;
		return this
	};
	Hc.prototype = p(ia.prototype);
	Hc.prototype.constructor = Hc;
	Hc.prototype.isMeshLambertMaterial = !0;
	Hc.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.color.copy(a.color);
		this.map = a.map;
		this.lightMap = a.lightMap;
		this.lightMapIntensity = a.lightMapIntensity;
		this.aoMap = a.aoMap;
		this.aoMapIntensity = a.aoMapIntensity;
		this.emissive.copy(a.emissive);
		this.emissiveMap = a.emissiveMap;
		this.emissiveIntensity = a.emissiveIntensity;
		this.specularMap = a.specularMap;
		this.alphaMap = a.alphaMap;
		this.envMap = a.envMap;
		this.combine = a.combine;
		this.reflectivity = a.reflectivity;
		this.refractionRatio = a.refractionRatio;
		this.wireframe = a.wireframe;
		this.wireframeLinewidth = a.wireframeLinewidth;
		this.wireframeLinecap = a.wireframeLinecap;
		this.wireframeLinejoin = a.wireframeLinejoin;
		this.skinning =
			a.skinning;
		this.morphTargets = a.morphTargets;
		this.morphNormals = a.morphNormals;
		return this
	};
	vd.prototype = p(ia.prototype);
	vd.prototype.constructor = vd;
	vd.prototype.isMeshMatcapMaterial = !0;
	vd.prototype.copy = function(a) {
		ia.prototype.copy.call(this, a);
		this.defines = {
			MATCAP: ""
		};
		this.color.copy(a.color);
		this.matcap = a.matcap;
		this.map = a.map;
		this.bumpMap = a.bumpMap;
		this.bumpScale = a.bumpScale;
		this.normalMap = a.normalMap;
		this.normalMapType = a.normalMapType;
		this.normalScale.copy(a.normalScale);
		this.displacementMap =
			a.displacementMap;
		this.displacementScale = a.displacementScale;
		this.displacementBias = a.displacementBias;
		this.alphaMap = a.alphaMap;
		this.skinning = a.skinning;
		this.morphTargets = a.morphTargets;
		this.morphNormals = a.morphNormals;
		return this
	};
	wd.prototype = p(Aa.prototype);
	wd.prototype.constructor = wd;
	wd.prototype.isLineDashedMaterial = !0;
	wd.prototype.copy = function(a) {
		Aa.prototype.copy.call(this, a);
		this.scale = a.scale;
		this.dashSize = a.dashSize;
		this.gapSize = a.gapSize;
		return this
	};
	var Qs = Ag({
			ShadowMaterial: Mf,
			SpriteMaterial: Cc,
			RawShaderMaterial: ff,
			ShaderMaterial: Ia,
			PointsMaterial: Dc,
			MeshPhysicalMaterial: Nf,
			MeshStandardMaterial: ee,
			MeshPhongMaterial: Gc,
			MeshToonMaterial: Of,
			MeshNormalMaterial: ud,
			MeshLambertMaterial: Hc,
			MeshDepthMaterial: Zd,
			MeshDistanceMaterial: $d,
			MeshBasicMaterial: Ob,
			MeshMatcapMaterial: vd,
			LineDashedMaterial: wd,
			LineBasicMaterial: Aa,
			Material: ia
		}),
		cb = {
			arraySlice: function(a, b, c) {
				return cb.isTypedArray(a) ? new a.constructor(a.subarray(b, void 0 !== c ? c : a.length)) : a.slice(b, c)
			},
			convertArray: function(a, b, c) {
				return !a ||
					!c && a.constructor === b ? a : "number" === typeof b.BYTES_PER_ELEMENT ? new b(a) : Array.prototype.slice.call(
						a)
			},
			isTypedArray: function(a) {
				return ArrayBuffer.isView(a) && !(a instanceof DataView)
			},
			getKeyframeOrder: function(a) {
				for (var b = a.length, c = Array(b), d = 0; d !== b; ++d) c[d] = d;
				c.sort(function(b, c) {
					return a[b] - a[c]
				});
				return c
			},
			sortedArray: function(a, b, c) {
				for (var d = a.length, e = new a.constructor(d), g = 0, k = 0; k !== d; ++g)
					for (var l = c[g] * b, m = 0; m !== b; ++m) e[k++] = a[l + m];
				return e
			},
			flattenJSON: function(a, b, c, d) {
				for (var e = 1, g = a[0]; void 0 !==
					g && void 0 === g[d];) g = a[e++];
				if (void 0 !== g) {
					var k = g[d];
					if (void 0 !== k)
						if (Array.isArray(k)) {
							do k = g[d], void 0 !== k && (b.push(g.time), c.push.apply(c, k)), g = a[e++]; while (void 0 !== g)
						} else if (void 0 !== k.toArray) {
						do k = g[d], void 0 !== k && (b.push(g.time), k.toArray(c, c.length)), g = a[e++]; while (void 0 !== g)
					} else {
						do k = g[d], void 0 !== k && (b.push(g.time), c.push(k)), g = a[e++]; while (void 0 !== g)
					}
				}
			}
		};
	q(jc.prototype, {
		evaluate: function(a) {
			var b = this.parameterPositions,
				c = this._cachedIndex,
				d = b[c],
				e = b[c - 1];
			a: {
				b: {
					c: {
						d: if (!(a < d)) {
							for (var g =
									c + 2;;) {
								if (void 0 === d) {
									if (a < e) break d;
									this._cachedIndex = c = b.length;
									return this.afterEnd_(c - 1, a, e)
								}
								if (c === g) break;
								e = d;
								d = b[++c];
								if (a < d) break b
							}
							d = b.length;
							break c
						}if (a >= e) break a;
						else {
							g = b[1];
							a < g && (c = 2, e = g);
							for (g = c - 2;;) {
								if (void 0 === e) return this._cachedIndex = 0, this.beforeStart_(0, a, d);
								if (c === g) break;
								d = e;
								e = b[--c - 1];
								if (a >= e) break b
							}
							d = c;
							c = 0
						}
					}
					for (; c < d;) e = c + d >>> 1,
					a < b[e] ? d = e : c = e + 1;d = b[c];e = b[c - 1];
					if (void 0 === e) return this._cachedIndex = 0,
					this.beforeStart_(0, a, d);
					if (void 0 === d) return this._cachedIndex = c = b.length,
					this.afterEnd_(c - 1, e, a)
				}
				this._cachedIndex = c;this.intervalChanged_(c, e, d)
			}
			return this.interpolate_(c, e, a, d)
		},
		settings: null,
		DefaultSettings_: {},
		getSettings_: function() {
			return this.settings || this.DefaultSettings_
		},
		copySampleValue_: function(a) {
			var b = this.resultBuffer,
				c = this.sampleValues,
				d = this.valueSize;
			a *= d;
			for (var e = 0; e !== d; ++e) b[e] = c[a + e];
			return b
		},
		interpolate_: function() {
			throw Error("call to abstract method");
		},
		intervalChanged_: function() {}
	});
	q(jc.prototype, {
		beforeStart_: jc.prototype.copySampleValue_,
		afterEnd_: jc.prototype.copySampleValue_
	});
	nk.prototype = q(p(jc.prototype), {
		constructor: nk,
		DefaultSettings_: {
			endingStart: 2400,
			endingEnd: 2400
		},
		intervalChanged_: function(a, b, c) {
			var d = this.parameterPositions,
				e = a - 2,
				g = a + 1,
				k = d[e],
				l = d[g];
			if (void 0 === k) switch (this.getSettings_().endingStart) {
				case 2401:
					e = a;
					k = 2 * b - c;
					break;
				case 2402:
					e = d.length - 2;
					k = b + d[e] - d[e + 1];
					break;
				default:
					e = a, k = c
			}
			if (void 0 === l) switch (this.getSettings_().endingEnd) {
				case 2401:
					g = a;
					l = 2 * c - b;
					break;
				case 2402:
					g = 1;
					l = c + d[1] - d[0];
					break;
				default:
					g = a - 1, l =
						b
			}
			a = .5 * (c - b);
			d = this.valueSize;
			this._weightPrev = a / (b - k);
			this._weightNext = a / (l - c);
			this._offsetPrev = e * d;
			this._offsetNext = g * d
		},
		interpolate_: function(a, b, c, d) {
			var e = this.resultBuffer,
				g = this.sampleValues,
				k = this.valueSize;
			a *= k;
			var l = a - k,
				m = this._offsetPrev,
				n = this._offsetNext,
				r = this._weightPrev,
				p = this._weightNext,
				q = (c - b) / (d - b);
			c = q * q;
			d = c * q;
			b = -r * d + 2 * r * c - r * q;
			r = (1 + r) * d + (-1.5 - 2 * r) * c + (-.5 + r) * q + 1;
			q = (-1 - p) * d + (1.5 + p) * c + .5 * q;
			p = p * d - p * c;
			for (c = 0; c !== k; ++c) e[c] = b * g[m + c] + r * g[l + c] + q * g[a + c] + p * g[n + c];
			return e
		}
	});
	gj.prototype =
		q(p(jc.prototype), {
			constructor: gj,
			interpolate_: function(a, b, c, d) {
				var e = this.resultBuffer,
					g = this.sampleValues,
					k = this.valueSize;
				a *= k;
				var l = a - k;
				b = (c - b) / (d - b);
				c = 1 - b;
				for (d = 0; d !== k; ++d) e[d] = g[l + d] * c + g[a + d] * b;
				return e
			}
		});
	hj.prototype = q(p(jc.prototype), {
		constructor: hj,
		interpolate_: function(a) {
			return this.copySampleValue_(a - 1)
		}
	});
	q(pb, {
		toJSON: function(a) {
			var b = a.constructor;
			if (void 0 !== b.toJSON) b = b.toJSON(a);
			else {
				b = {
					name: a.name,
					times: cb.convertArray(a.times, Array),
					values: cb.convertArray(a.values, Array)
				};
				var c =
					a.getInterpolation();
				c !== a.DefaultInterpolation && (b.interpolation = c)
			}
			b.type = a.ValueTypeName;
			return b
		}
	});
	q(pb.prototype, {
		constructor: pb,
		TimeBufferType: Float32Array,
		ValueBufferType: Float32Array,
		DefaultInterpolation: 2301,
		InterpolantFactoryMethodDiscrete: function(a) {
			return new hj(this.times, this.values, this.getValueSize(), a)
		},
		InterpolantFactoryMethodLinear: function(a) {
			return new gj(this.times, this.values, this.getValueSize(), a)
		},
		InterpolantFactoryMethodSmooth: function(a) {
			return new nk(this.times, this.values,
				this.getValueSize(), a)
		},
		setInterpolation: function(a) {
			switch (a) {
				case 2300:
					var b = this.InterpolantFactoryMethodDiscrete;
					break;
				case 2301:
					b = this.InterpolantFactoryMethodLinear;
					break;
				case 2302:
					b = this.InterpolantFactoryMethodSmooth
			}
			if (void 0 === b) {
				b = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
				if (void 0 === this.createInterpolant)
					if (a !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
					else throw Error(b);
				console.warn("THREE.KeyframeTrack:",
					b);
				return this
			}
			this.createInterpolant = b;
			return this
		},
		getInterpolation: function() {
			switch (this.createInterpolant) {
				case this.InterpolantFactoryMethodDiscrete:
					return 2300;
				case this.InterpolantFactoryMethodLinear:
					return 2301;
				case this.InterpolantFactoryMethodSmooth:
					return 2302
			}
		},
		getValueSize: function() {
			return this.values.length / this.times.length
		},
		shift: function(a) {
			if (0 !== a)
				for (var b = this.times, c = 0, d = b.length; c !== d; ++c) b[c] += a;
			return this
		},
		scale: function(a) {
			if (1 !== a)
				for (var b = this.times, c = 0, d = b.length; c !==
					d; ++c) b[c] *= a;
			return this
		},
		trim: function(a, b) {
			for (var c = this.times, d = c.length, e = 0, g = d - 1; e !== d && c[e] < a;) ++e;
			for (; - 1 !== g && c[g] > b;) --g;
			++g;
			if (0 !== e || g !== d) e >= g && (g = Math.max(g, 1), e = g - 1), a = this.getValueSize(), this.times = cb.arraySlice(
				c, e, g), this.values = cb.arraySlice(this.values, e * a, g * a);
			return this
		},
		validate: function() {
			var a = !0,
				b = this.getValueSize();
			0 !== b - Math.floor(b) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), a = !1);
			var c = this.times;
			b = this.values;
			var d = c.length;
			0 === d && (console.error("THREE.KeyframeTrack: Track is empty.",
				this), a = !1);
			for (var e = null, g = 0; g !== d; g++) {
				var k = c[g];
				if ("number" === typeof k && isNaN(k)) {
					console.error("THREE.KeyframeTrack: Time is not a valid number.", this, g, k);
					a = !1;
					break
				}
				if (null !== e && e > k) {
					console.error("THREE.KeyframeTrack: Out of order keys.", this, g, k, e);
					a = !1;
					break
				}
				e = k
			}
			if (void 0 !== b && cb.isTypedArray(b))
				for (g = 0, c = b.length; g !== c; ++g)
					if (d = b[g], isNaN(d)) {
						console.error("THREE.KeyframeTrack: Value is not a valid number.", this, g, d);
						a = !1;
						break
					} return a
		},
		optimize: function() {
			for (var a = this.times, b = this.values,
					c = this.getValueSize(), d = 2302 === this.getInterpolation(), e = 1, g = a.length - 1, k = 1; k < g; ++k) {
				var l = !1,
					m = a[k];
				if (m !== a[k + 1] && (1 !== k || m !== m[0]))
					if (d) l = !0;
					else {
						var n = k * c,
							p = n - c,
							q = n + c;
						for (m = 0; m !== c; ++m) {
							var u = b[n + m];
							if (u !== b[p + m] || u !== b[q + m]) {
								l = !0;
								break
							}
						}
					} if (l) {
					if (k !== e)
						for (a[e] = a[k], l = k * c, n = e * c, m = 0; m !== c; ++m) b[n + m] = b[l + m];
					++e
				}
			}
			if (0 < g) {
				a[e] = a[g];
				l = g * c;
				n = e * c;
				for (m = 0; m !== c; ++m) b[n + m] = b[l + m];
				++e
			}
			e !== a.length && (this.times = cb.arraySlice(a, 0, e), this.values = cb.arraySlice(b, 0, e * c));
			return this
		},
		clone: function() {
			var a =
				cb.arraySlice(this.times, 0),
				b = cb.arraySlice(this.values, 0);
			a = new this.constructor(this.name, a, b);
			a.createInterpolant = this.createInterpolant;
			return a
		}
	});
	Qh.prototype = q(p(pb.prototype), {
		constructor: Qh,
		ValueTypeName: "bool",
		ValueBufferType: Array,
		DefaultInterpolation: 2300,
		InterpolantFactoryMethodLinear: void 0,
		InterpolantFactoryMethodSmooth: void 0
	});
	ok.prototype = q(p(pb.prototype), {
		constructor: ok,
		ValueTypeName: "color"
	});
	Pf.prototype = q(p(pb.prototype), {
		constructor: Pf,
		ValueTypeName: "number"
	});
	ij.prototype =
		q(p(jc.prototype), {
			constructor: ij,
			interpolate_: function(a, b, c, d) {
				var e = this.resultBuffer,
					g = this.sampleValues,
					k = this.valueSize;
				a *= k;
				b = (c - b) / (d - b);
				for (c = a + k; a !== c; a += 4) vb.slerpFlat(e, 0, g, a - k, g, a, b);
				return e
			}
		});
	jj.prototype = q(p(pb.prototype), {
		constructor: jj,
		ValueTypeName: "quaternion",
		DefaultInterpolation: 2301,
		InterpolantFactoryMethodLinear: function(a) {
			return new ij(this.times, this.values, this.getValueSize(), a)
		},
		InterpolantFactoryMethodSmooth: void 0
	});
	kj.prototype = q(p(pb.prototype), {
		constructor: kj,
		ValueTypeName: "string",
		ValueBufferType: Array,
		DefaultInterpolation: 2300,
		InterpolantFactoryMethodLinear: void 0,
		InterpolantFactoryMethodSmooth: void 0
	});
	Qf.prototype = q(p(pb.prototype), {
		constructor: Qf,
		ValueTypeName: "vector"
	});
	q(Ic, {
		parse: function(a) {
			for (var b = [], c = a.tracks, d = 1 / (a.fps || 1), e = 0, g = c.length; e !== g; ++e) b.push(Vq(c[e]).scale(d));
			return new Ic(a.name, a.duration, b)
		},
		toJSON: function(a) {
			var b = [],
				c = a.tracks;
			a = {
				name: a.name,
				duration: a.duration,
				tracks: b,
				uuid: a.uuid
			};
			for (var d = 0, e = c.length; d !== e; ++d) b.push(pb.toJSON(c[d]));
			return a
		},
		CreateFromMorphTargetSequence: function(a, b, c, d) {
			for (var e = b.length, g = [], k = 0; k < e; k++) {
				var l = [],
					m = [];
				l.push((k + e - 1) % e, k, (k + 1) % e);
				m.push(0, 1, 0);
				var n = cb.getKeyframeOrder(l);
				l = cb.sortedArray(l, 1, n);
				m = cb.sortedArray(m, 1, n);
				d || 0 !== l[0] || (l.push(e), m.push(m[0]));
				g.push((new Pf(".morphTargetInfluences[" + b[k].name + "]", l, m)).scale(1 / c))
			}
			return new Ic(a, -1, g)
		},
		findByName: function(a, b) {
			var c = a;
			Array.isArray(a) || (c = a.geometry && a.geometry.animations || a.animations);
			for (a = 0; a < c.length; a++)
				if (c[a].name ===
					b) return c[a];
			return null
		},
		CreateClipsFromMorphTargetSequences: function(a, b, c) {
			for (var d = {}, e = /^([\w-]*?)([\d]+)$/, g = 0, k = a.length; g < k; g++) {
				var l = a[g],
					m = l.name.match(e);
				if (m && 1 < m.length) {
					var n = m[1];
					(m = d[n]) || (d[n] = m = []);
					m.push(l)
				}
			}
			a = [];
			for (n in d) a.push(Ic.CreateFromMorphTargetSequence(n, d[n], b, c));
			return a
		},
		parseAnimation: function(a, b) {
			if (!a) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
			var c = function(a, b, c, d, e) {
					if (0 !== c.length) {
						var g = [],
							k = [];
						cb.flattenJSON(c,
							g, k, d);
						0 !== g.length && e.push(new a(b, g, k))
					}
				},
				d = [],
				e = a.name || "default",
				g = a.length || -1,
				k = a.fps || 30;
			a = a.hierarchy || [];
			for (var l = 0; l < a.length; l++) {
				var m = a[l].keys;
				if (m && 0 !== m.length)
					if (m[0].morphTargets) {
						g = {};
						for (var n = 0; n < m.length; n++)
							if (m[n].morphTargets)
								for (var p = 0; p < m[n].morphTargets.length; p++) g[m[n].morphTargets[p]] = -1;
						for (var q in g) {
							var u = [],
								w = [];
							for (p = 0; p !== m[n].morphTargets.length; ++p) {
								var z = m[n];
								u.push(z.time);
								w.push(z.morphTarget === q ? 1 : 0)
							}
							d.push(new Pf(".morphTargetInfluence[" + q + "]", u, w))
						}
						g =
							g.length * (k || 1)
					} else n = ".bones[" + b[l].name + "]", c(Qf, n + ".position", m, "pos", d), c(jj, n + ".quaternion", m, "rot",
						d), c(Qf, n + ".scale", m, "scl", d)
			}
			return 0 === d.length ? null : new Ic(e, g, d)
		}
	});
	q(Ic.prototype, {
		resetDuration: function() {
			for (var a = 0, b = 0, c = this.tracks.length; b !== c; ++b) {
				var d = this.tracks[b];
				a = Math.max(a, d.times[d.times.length - 1])
			}
			this.duration = a;
			return this
		},
		trim: function() {
			for (var a = 0; a < this.tracks.length; a++) this.tracks[a].trim(0, this.duration);
			return this
		},
		validate: function() {
			for (var a = !0, b = 0; b < this.tracks.length; b++) a =
				a && this.tracks[b].validate();
			return a
		},
		optimize: function() {
			for (var a = 0; a < this.tracks.length; a++) this.tracks[a].optimize();
			return this
		},
		clone: function() {
			for (var a = [], b = 0; b < this.tracks.length; b++) a.push(this.tracks[b].clone());
			return new Ic(this.name, this.duration, a)
		}
	});
	var Ke = {
			enabled: !1,
			files: {},
			add: function(a, b) {
				!1 !== this.enabled && (this.files[a] = b)
			},
			get: function(a) {
				if (!1 !== this.enabled) return this.files[a]
			},
			remove: function(a) {
				delete this.files[a]
			},
			clear: function() {
				this.files = {}
			}
		},
		Wq = new ln;
	q(sa.prototype, {
		load: function() {},
		parse: function() {},
		setCrossOrigin: function(a) {
			this.crossOrigin = a;
			return this
		},
		setPath: function(a) {
			this.path = a;
			return this
		},
		setResourcePath: function(a) {
			this.resourcePath = a;
			return this
		}
	});
	var vc = {};
	Jc.prototype = q(p(sa.prototype), {
		constructor: Jc,
		load: function(a, b, c, d) {
			void 0 === a && (a = "");
			void 0 !== this.path && (a = this.path + a);
			a = this.manager.resolveURL(a);
			var e = this,
				g = Ke.get(a);
			if (void 0 !== g) return e.manager.itemStart(a), setTimeout(function() {
				b && b(g);
				e.manager.itemEnd(a)
			}, 0), g;
			if (void 0 !==
				vc[a]) vc[a].push({
				onLoad: b,
				onProgress: c,
				onError: d
			});
			else {
				var k = a.match(/^data:(.*?)(;base64)?,(.*)$/);
				if (k) {
					c = k[1];
					var l = !!k[2];
					k = k[3];
					k = decodeURIComponent(k);
					l && (k = atob(k));
					try {
						var m = (this.responseType || "").toLowerCase();
						switch (m) {
							case "arraybuffer":
							case "blob":
								var n = new Uint8Array(k.length);
								for (l = 0; l < k.length; l++) n[l] = k.charCodeAt(l);
								var p = "blob" === m ? new Blob([n.buffer], {
									type: c
								}) : n.buffer;
								break;
							case "document":
								p = (new DOMParser).parseFromString(k, c);
								break;
							case "json":
								p = JSON.parse(k);
								break;
							default:
								p =
									k
						}
						setTimeout(function() {
							b && b(p);
							e.manager.itemEnd(a)
						}, 0)
					} catch (A) {
						setTimeout(function() {
							d && d(A);
							e.manager.itemError(a);
							e.manager.itemEnd(a)
						}, 0)
					}
				} else {
					vc[a] = [];
					vc[a].push({
						onLoad: b,
						onProgress: c,
						onError: d
					});
					var q = new XMLHttpRequest;
					q.open("GET", a, !0);
					q.addEventListener("load", function(b) {
						var c = this.response;
						Ke.add(a, c);
						var d = vc[a];
						delete vc[a];
						if (200 === this.status || 0 === this.status) {
							0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
							for (var g = 0, k = d.length; g < k; g++) {
								var l = d[g];
								if (l.onLoad) l.onLoad(c)
							}
						} else {
							g = 0;
							for (k = d.length; g < k; g++)
								if (l = d[g], l.onError) l.onError(b);
							e.manager.itemError(a)
						}
						e.manager.itemEnd(a)
					}, !1);
					q.addEventListener("progress", function(b) {
						for (var c = vc[a], d = 0, e = c.length; d < e; d++) {
							var g = c[d];
							if (g.onProgress) g.onProgress(b)
						}
					}, !1);
					q.addEventListener("error", function(b) {
						var c = vc[a];
						delete vc[a];
						for (var d = 0, g = c.length; d < g; d++) {
							var k = c[d];
							if (k.onError) k.onError(b)
						}
						e.manager.itemError(a);
						e.manager.itemEnd(a)
					}, !1);
					q.addEventListener("abort", function(b) {
						var c = vc[a];
						delete vc[a];
						for (var d = 0, g = c.length; d < g; d++) {
							var k = c[d];
							if (k.onError) k.onError(b)
						}
						e.manager.itemError(a);
						e.manager.itemEnd(a)
					}, !1);
					void 0 !== this.responseType && (q.responseType = this.responseType);
					void 0 !== this.withCredentials && (q.withCredentials = this.withCredentials);
					q.overrideMimeType && q.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
					for (l in this.requestHeader) q.setRequestHeader(l, this.requestHeader[l]);
					q.send(null)
				}
				e.manager.itemStart(a);
				return q
			}
		},
		setResponseType: function(a) {
			this.responseType =
				a;
			return this
		},
		setWithCredentials: function(a) {
			this.withCredentials = a;
			return this
		},
		setMimeType: function(a) {
			this.mimeType = a;
			return this
		},
		setRequestHeader: function(a) {
			this.requestHeader = a;
			return this
		}
	});
	mn.prototype = q(p(sa.prototype), {
		constructor: mn,
		load: function(a, b, c, d) {
			var e = this,
				g = new Jc(e.manager);
			g.setPath(e.path);
			g.load(a, function(a) {
				b(e.parse(JSON.parse(a)))
			}, c, d)
		},
		parse: function(a) {
			for (var b = [], c = 0; c < a.length; c++) {
				var d = Ic.parse(a[c]);
				b.push(d)
			}
			return b
		}
	});
	nn.prototype = q(p(sa.prototype), {
		constructor: nn,
		load: function(a, b, c, d) {
			function e(e) {
				m.load(a[e], function(a) {
					a = g.parse(a, !0);
					k[e] = {
						width: a.width,
						height: a.height,
						format: a.format,
						mipmaps: a.mipmaps
					};
					n += 1;
					6 === n && (1 === a.mipmapCount && (l.minFilter = 1006), l.format = a.format, l.needsUpdate = !0, b && b(l))
				}, c, d)
			}
			var g = this,
				k = [],
				l = new be;
			l.image = k;
			var m = new Jc(this.manager);
			m.setPath(this.path);
			m.setResponseType("arraybuffer");
			if (Array.isArray(a))
				for (var n = 0, p = 0, q = a.length; p < q; ++p) e(p);
			else m.load(a, function(a) {
				a = g.parse(a, !0);
				if (a.isCubemap)
					for (var c = a.mipmaps.length /
							a.mipmapCount, d = 0; d < c; d++) {
						k[d] = {
							mipmaps: []
						};
						for (var e = 0; e < a.mipmapCount; e++) k[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + e]), k[d].format =
							a.format, k[d].width = a.width, k[d].height = a.height
					} else l.image.width = a.width, l.image.height = a.height, l.mipmaps = a.mipmaps;
				1 === a.mipmapCount && (l.minFilter = 1006);
				l.format = a.format;
				l.needsUpdate = !0;
				b && b(l)
			}, c, d);
			return l
		}
	});
	on.prototype = q(p(sa.prototype), {
		constructor: on,
		load: function(a, b, c, d) {
			var e = this,
				g = new Dg,
				k = new Jc(this.manager);
			k.setResponseType("arraybuffer");
			k.setPath(this.path);
			k.load(a, function(a) {
				if (a = e.parse(a)) void 0 !== a.image ? g.image = a.image : void 0 !== a.data && (g.image.width = a.width, g
						.image.height = a.height, g.image.data = a.data), g.wrapS = void 0 !== a.wrapS ? a.wrapS : 1001, g.wrapT =
					void 0 !== a.wrapT ? a.wrapT : 1001, g.magFilter = void 0 !== a.magFilter ? a.magFilter : 1006, g.minFilter =
					void 0 !== a.minFilter ? a.minFilter : 1008, g.anisotropy = void 0 !== a.anisotropy ? a.anisotropy : 1, void 0 !==
					a.format && (g.format = a.format), void 0 !== a.type && (g.type = a.type), void 0 !== a.mipmaps && (g.mipmaps =
						a.mipmaps), 1 === a.mipmapCount && (g.minFilter = 1006), g.needsUpdate = !0, b && b(g, a)
			}, c, d);
			return g
		}
	});
	Rf.prototype = q(p(sa.prototype), {
		constructor: Rf,
		load: function(a, b, c, d) {
			function e() {
				m.removeEventListener("load", e, !1);
				m.removeEventListener("error", g, !1);
				Ke.add(a, this);
				b && b(this);
				k.manager.itemEnd(a)
			}

			function g(b) {
				m.removeEventListener("load", e, !1);
				m.removeEventListener("error", g, !1);
				d && d(b);
				k.manager.itemError(a);
				k.manager.itemEnd(a)
			}
			void 0 !== this.path && (a = this.path + a);
			a = this.manager.resolveURL(a);
			var k =
				this,
				l = Ke.get(a);
			if (void 0 !== l) return k.manager.itemStart(a), setTimeout(function() {
				b && b(l);
				k.manager.itemEnd(a)
			}, 0), l;
			var m = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
			m.addEventListener("load", e, !1);
			m.addEventListener("error", g, !1);
			"data:" !== a.substr(0, 5) && void 0 !== this.crossOrigin && (m.crossOrigin = this.crossOrigin);
			k.manager.itemStart(a);
			m.src = a;
			return m
		}
	});
	lj.prototype = q(p(sa.prototype), {
		constructor: lj,
		load: function(a, b, c, d) {
			function e(c) {
				k.load(a[c], function(a) {
					g.images[c] = a;
					l++;
					6 === l && (g.needsUpdate = !0, b && b(g))
				}, void 0, d)
			}
			var g = new rd,
				k = new Rf(this.manager);
			k.setCrossOrigin(this.crossOrigin);
			k.setPath(this.path);
			var l = 0;
			for (c = 0; c < a.length; ++c) e(c);
			return g
		}
	});
	mj.prototype = q(p(sa.prototype), {
		constructor: mj,
		load: function(a, b, c, d) {
			var e = new pa,
				g = new Rf(this.manager);
			g.setCrossOrigin(this.crossOrigin);
			g.setPath(this.path);
			g.load(a, function(c) {
					e.image = c;
					c = 0 < a.search(/\.jpe?g($|\?)/i) || 0 === a.search(/^data:image\/jpeg/);
					e.format = c ? 1022 : 1023;
					e.needsUpdate = !0;
					void 0 !== b && b(e)
				},
				c, d);
			return e
		}
	});
	q(X.prototype, {
		getPoint: function() {
			console.warn("THREE.Curve: .getPoint() not implemented.");
			return null
		},
		getPointAt: function(a, b) {
			a = this.getUtoTmapping(a);
			return this.getPoint(a, b)
		},
		getPoints: function(a) {
			void 0 === a && (a = 5);
			for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
			return b
		},
		getSpacedPoints: function(a) {
			void 0 === a && (a = 5);
			for (var b = [], c = 0; c <= a; c++) b.push(this.getPointAt(c / a));
			return b
		},
		getLength: function() {
			var a = this.getLengths();
			return a[a.length - 1]
		},
		getLengths: function(a) {
			void 0 ===
				a && (a = this.arcLengthDivisions);
			if (this.cacheArcLengths && this.cacheArcLengths.length === a + 1 && !this.needsUpdate) return this.cacheArcLengths;
			this.needsUpdate = !1;
			var b = [],
				c = this.getPoint(0),
				d, e = 0;
			b.push(0);
			for (d = 1; d <= a; d++) {
				var g = this.getPoint(d / a);
				e += g.distanceTo(c);
				b.push(e);
				c = g
			}
			return this.cacheArcLengths = b
		},
		updateArcLengths: function() {
			this.needsUpdate = !0;
			this.getLengths()
		},
		getUtoTmapping: function(a, b) {
			var c = this.getLengths(),
				d = c.length;
			b = b ? b : a * c[d - 1];
			for (var e = 0, g = d - 1, k; e <= g;)
				if (a = Math.floor(e + (g -
						e) / 2), k = c[a] - b, 0 > k) e = a + 1;
				else if (0 < k) g = a - 1;
			else {
				g = a;
				break
			}
			a = g;
			if (c[a] === b) return a / (d - 1);
			e = c[a];
			return (a + (b - e) / (c[a + 1] - e)) / (d - 1)
		},
		getTangent: function(a) {
			var b = a - 1E-4;
			a += 1E-4;
			0 > b && (b = 0);
			1 < a && (a = 1);
			b = this.getPoint(b);
			return this.getPoint(a).clone().sub(b).normalize()
		},
		getTangentAt: function(a) {
			a = this.getUtoTmapping(a);
			return this.getTangent(a)
		},
		computeFrenetFrames: function(a, b) {
			var c = new u,
				d = [],
				e = [],
				g = [],
				k = new u,
				l = new ua,
				m;
			for (m = 0; m <= a; m++) {
				var n = m / a;
				d[m] = this.getTangentAt(n);
				d[m].normalize()
			}
			e[0] = new u;
			g[0] = new u;
			m = Number.MAX_VALUE;
			n = Math.abs(d[0].x);
			var p = Math.abs(d[0].y),
				q = Math.abs(d[0].z);
			n <= m && (m = n, c.set(1, 0, 0));
			p <= m && (m = p, c.set(0, 1, 0));
			q <= m && c.set(0, 0, 1);
			k.crossVectors(d[0], c).normalize();
			e[0].crossVectors(d[0], k);
			g[0].crossVectors(d[0], e[0]);
			for (m = 1; m <= a; m++) e[m] = e[m - 1].clone(), g[m] = g[m - 1].clone(), k.crossVectors(d[m - 1], d[m]), k.length() >
				Na && (k.normalize(), c = Math.acos(ha.clamp(d[m - 1].dot(d[m]), -1, 1)), e[m].applyMatrix4(l.makeRotationAxis(
					k, c))), g[m].crossVectors(d[m], e[m]);
			if (!0 === b)
				for (c = Math.acos(ha.clamp(e[0].dot(e[a]),
						-1, 1)), c /= a, 0 < d[0].dot(k.crossVectors(e[0], e[a])) && (c = -c), m = 1; m <= a; m++) e[m].applyMatrix4(
					l.makeRotationAxis(d[m], c * m)), g[m].crossVectors(d[m], e[m]);
			return {
				tangents: d,
				normals: e,
				binormals: g
			}
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.arcLengthDivisions = a.arcLengthDivisions;
			return this
		},
		toJSON: function() {
			var a = {
				metadata: {
					version: 4.5,
					type: "Curve",
					generator: "Curve.toJSON"
				}
			};
			a.arcLengthDivisions = this.arcLengthDivisions;
			a.type = this.type;
			return a
		},
		fromJSON: function(a) {
			this.arcLengthDivisions =
				a.arcLengthDivisions;
			return this
		}
	});
	kc.prototype = p(X.prototype);
	kc.prototype.constructor = kc;
	kc.prototype.isEllipseCurve = !0;
	kc.prototype.getPoint = function(a, b) {
		b = b || new B;
		for (var c = 2 * Math.PI, d = this.aEndAngle - this.aStartAngle, e = Math.abs(d) < Na; 0 > d;) d += c;
		for (; d > c;) d -= c;
		d < Na && (d = e ? 0 : c);
		!0 !== this.aClockwise || e || (d = d === c ? -c : d - c);
		c = this.aStartAngle + a * d;
		a = this.aX + this.xRadius * Math.cos(c);
		var g = this.aY + this.yRadius * Math.sin(c);
		0 !== this.aRotation && (c = Math.cos(this.aRotation), d = Math.sin(this.aRotation), e = a - this.aX,
			g -= this.aY, a = e * c - g * d + this.aX, g = e * d + g * c + this.aY);
		return b.set(a, g)
	};
	kc.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.aX = a.aX;
		this.aY = a.aY;
		this.xRadius = a.xRadius;
		this.yRadius = a.yRadius;
		this.aStartAngle = a.aStartAngle;
		this.aEndAngle = a.aEndAngle;
		this.aClockwise = a.aClockwise;
		this.aRotation = a.aRotation;
		return this
	};
	kc.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.aX = this.aX;
		a.aY = this.aY;
		a.xRadius = this.xRadius;
		a.yRadius = this.yRadius;
		a.aStartAngle = this.aStartAngle;
		a.aEndAngle =
			this.aEndAngle;
		a.aClockwise = this.aClockwise;
		a.aRotation = this.aRotation;
		return a
	};
	kc.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.aX = a.aX;
		this.aY = a.aY;
		this.xRadius = a.xRadius;
		this.yRadius = a.yRadius;
		this.aStartAngle = a.aStartAngle;
		this.aEndAngle = a.aEndAngle;
		this.aClockwise = a.aClockwise;
		this.aRotation = a.aRotation;
		return this
	};
	Sf.prototype = p(kc.prototype);
	Sf.prototype.constructor = Sf;
	Sf.prototype.isArcCurve = !0;
	var Gi = new u,
		dm = new nj,
		em = new nj,
		fm = new nj;
	wb.prototype = p(X.prototype);
	wb.prototype.constructor = wb;
	wb.prototype.isCatmullRomCurve3 = !0;
	wb.prototype.getPoint = function(a, b) {
		b = b || new u;
		var c = this.points,
			d = c.length;
		a *= d - (this.closed ? 0 : 1);
		var e = Math.floor(a);
		a -= e;
		this.closed ? e += 0 < e ? 0 : (Math.floor(Math.abs(e) / d) + 1) * d : 0 === a && e === d - 1 && (e = d - 2, a = 1);
		if (this.closed || 0 < e) var g = c[(e - 1) % d];
		else Gi.subVectors(c[0], c[1]).add(c[0]), g = Gi;
		var k = c[e % d];
		var l = c[(e + 1) % d];
		this.closed || e + 2 < d ? c = c[(e + 2) % d] : (Gi.subVectors(c[d - 1], c[d - 2]).add(c[d - 1]), c = Gi);
		if ("centripetal" === this.curveType || "chordal" ===
			this.curveType) {
			var m = "chordal" === this.curveType ? .5 : .25;
			d = Math.pow(g.distanceToSquared(k), m);
			e = Math.pow(k.distanceToSquared(l), m);
			m = Math.pow(l.distanceToSquared(c), m);
			1E-4 > e && (e = 1);
			1E-4 > d && (d = e);
			1E-4 > m && (m = e);
			dm.initNonuniformCatmullRom(g.x, k.x, l.x, c.x, d, e, m);
			em.initNonuniformCatmullRom(g.y, k.y, l.y, c.y, d, e, m);
			fm.initNonuniformCatmullRom(g.z, k.z, l.z, c.z, d, e, m)
		} else "catmullrom" === this.curveType && (dm.initCatmullRom(g.x, k.x, l.x, c.x, this.tension), em.initCatmullRom(g
			.y, k.y, l.y, c.y, this.tension), fm.initCatmullRom(g.z,
			k.z, l.z, c.z, this.tension));
		b.set(dm.calc(a), em.calc(a), fm.calc(a));
		return b
	};
	wb.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.points = [];
		for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
		this.closed = a.closed;
		this.curveType = a.curveType;
		this.tension = a.tension;
		return this
	};
	wb.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.points = [];
		for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
		a.closed = this.closed;
		a.curveType =
			this.curveType;
		a.tension = this.tension;
		return a
	};
	wb.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.points = [];
		for (var b = 0, c = a.points.length; b < c; b++) {
			var d = a.points[b];
			this.points.push((new u).fromArray(d))
		}
		this.closed = a.closed;
		this.curveType = a.curveType;
		this.tension = a.tension;
		return this
	};
	Kc.prototype = p(X.prototype);
	Kc.prototype.constructor = Kc;
	Kc.prototype.isCubicBezierCurve = !0;
	Kc.prototype.getPoint = function(a, b) {
		b = b || new B;
		var c = this.v0,
			d = this.v1,
			e = this.v2,
			g = this.v3;
		b.set(hf(a,
			c.x, d.x, e.x, g.x), hf(a, c.y, d.y, e.y, g.y));
		return b
	};
	Kc.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.v0.copy(a.v0);
		this.v1.copy(a.v1);
		this.v2.copy(a.v2);
		this.v3.copy(a.v3);
		return this
	};
	Kc.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.v0 = this.v0.toArray();
		a.v1 = this.v1.toArray();
		a.v2 = this.v2.toArray();
		a.v3 = this.v3.toArray();
		return a
	};
	Kc.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.v0.fromArray(a.v0);
		this.v1.fromArray(a.v1);
		this.v2.fromArray(a.v2);
		this.v3.fromArray(a.v3);
		return this
	};
	xd.prototype = p(X.prototype);
	xd.prototype.constructor = xd;
	xd.prototype.isCubicBezierCurve3 = !0;
	xd.prototype.getPoint = function(a, b) {
		b = b || new u;
		var c = this.v0,
			d = this.v1,
			e = this.v2,
			g = this.v3;
		b.set(hf(a, c.x, d.x, e.x, g.x), hf(a, c.y, d.y, e.y, g.y), hf(a, c.z, d.z, e.z, g.z));
		return b
	};
	xd.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.v0.copy(a.v0);
		this.v1.copy(a.v1);
		this.v2.copy(a.v2);
		this.v3.copy(a.v3);
		return this
	};
	xd.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.v0 = this.v0.toArray();
		a.v1 = this.v1.toArray();
		a.v2 = this.v2.toArray();
		a.v3 = this.v3.toArray();
		return a
	};
	xd.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.v0.fromArray(a.v0);
		this.v1.fromArray(a.v1);
		this.v2.fromArray(a.v2);
		this.v3.fromArray(a.v3);
		return this
	};
	Tb.prototype = p(X.prototype);
	Tb.prototype.constructor = Tb;
	Tb.prototype.isLineCurve = !0;
	Tb.prototype.getPoint = function(a, b) {
		b = b || new B;
		1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
		return b
	};
	Tb.prototype.getPointAt = function(a, b) {
		return this.getPoint(a, b)
	};
	Tb.prototype.getTangent = function() {
		return this.v2.clone().sub(this.v1).normalize()
	};
	Tb.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.v1.copy(a.v1);
		this.v2.copy(a.v2);
		return this
	};
	Tb.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.v1 = this.v1.toArray();
		a.v2 = this.v2.toArray();
		return a
	};
	Tb.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.v1.fromArray(a.v1);
		this.v2.fromArray(a.v2);
		return this
	};
	Ub.prototype = p(X.prototype);
	Ub.prototype.constructor = Ub;
	Ub.prototype.isLineCurve3 = !0;
	Ub.prototype.getPoint = function(a, b) {
		b = b || new u;
		1 === a ? b.copy(this.v2) : (b.copy(this.v2).sub(this.v1), b.multiplyScalar(a).add(this.v1));
		return b
	};
	Ub.prototype.getPointAt = function(a, b) {
		return this.getPoint(a, b)
	};
	Ub.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.v1.copy(a.v1);
		this.v2.copy(a.v2);
		return this
	};
	Ub.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.v1 = this.v1.toArray();
		a.v2 = this.v2.toArray();
		return a
	};
	Ub.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.v1.fromArray(a.v1);
		this.v2.fromArray(a.v2);
		return this
	};
	yd.prototype = p(X.prototype);
	yd.prototype.constructor = yd;
	yd.prototype.isQuadraticBezierCurve = !0;
	yd.prototype.getPoint = function(a, b) {
		b = b || new B;
		var c = this.v0,
			d = this.v1,
			e = this.v2;
		b.set(gf(a, c.x, d.x, e.x), gf(a, c.y, d.y, e.y));
		return b
	};
	yd.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.v0.copy(a.v0);
		this.v1.copy(a.v1);
		this.v2.copy(a.v2);
		return this
	};
	yd.prototype.toJSON =
		function() {
			var a = X.prototype.toJSON.call(this);
			a.v0 = this.v0.toArray();
			a.v1 = this.v1.toArray();
			a.v2 = this.v2.toArray();
			return a
		};
	yd.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.v0.fromArray(a.v0);
		this.v1.fromArray(a.v1);
		this.v2.fromArray(a.v2);
		return this
	};
	fe.prototype = p(X.prototype);
	fe.prototype.constructor = fe;
	fe.prototype.isQuadraticBezierCurve3 = !0;
	fe.prototype.getPoint = function(a, b) {
		b = b || new u;
		var c = this.v0,
			d = this.v1,
			e = this.v2;
		b.set(gf(a, c.x, d.x, e.x), gf(a, c.y, d.y, e.y), gf(a,
			c.z, d.z, e.z));
		return b
	};
	fe.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.v0.copy(a.v0);
		this.v1.copy(a.v1);
		this.v2.copy(a.v2);
		return this
	};
	fe.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.v0 = this.v0.toArray();
		a.v1 = this.v1.toArray();
		a.v2 = this.v2.toArray();
		return a
	};
	fe.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.v0.fromArray(a.v0);
		this.v1.fromArray(a.v1);
		this.v2.fromArray(a.v2);
		return this
	};
	zd.prototype = p(X.prototype);
	zd.prototype.constructor =
		zd;
	zd.prototype.isSplineCurve = !0;
	zd.prototype.getPoint = function(a, b) {
		b = b || new B;
		var c = this.points,
			d = (c.length - 1) * a;
		a = Math.floor(d);
		d -= a;
		var e = c[0 === a ? a : a - 1],
			g = c[a],
			k = c[a > c.length - 2 ? c.length - 1 : a + 1];
		c = c[a > c.length - 3 ? c.length - 1 : a + 2];
		b.set(pn(d, e.x, g.x, k.x, c.x), pn(d, e.y, g.y, k.y, c.y));
		return b
	};
	zd.prototype.copy = function(a) {
		X.prototype.copy.call(this, a);
		this.points = [];
		for (var b = 0, c = a.points.length; b < c; b++) this.points.push(a.points[b].clone());
		return this
	};
	zd.prototype.toJSON = function() {
		var a = X.prototype.toJSON.call(this);
		a.points = [];
		for (var b = 0, c = this.points.length; b < c; b++) a.points.push(this.points[b].toArray());
		return a
	};
	zd.prototype.fromJSON = function(a) {
		X.prototype.fromJSON.call(this, a);
		this.points = [];
		for (var b = 0, c = a.points.length; b < c; b++) {
			var d = a.points[b];
			this.points.push((new B).fromArray(d))
		}
		return this
	};
	var gm = Ag({
		ArcCurve: Sf,
		CatmullRomCurve3: wb,
		CubicBezierCurve: Kc,
		CubicBezierCurve3: xd,
		EllipseCurve: kc,
		LineCurve: Tb,
		LineCurve3: Ub,
		QuadraticBezierCurve: yd,
		QuadraticBezierCurve3: fe,
		SplineCurve: zd
	});
	ge.prototype =
		q(p(X.prototype), {
			constructor: ge,
			add: function(a) {
				this.curves.push(a)
			},
			closePath: function() {
				var a = this.curves[0].getPoint(0),
					b = this.curves[this.curves.length - 1].getPoint(1);
				a.equals(b) || this.curves.push(new Tb(b, a))
			},
			getPoint: function(a) {
				var b = a * this.getLength(),
					c = this.getCurveLengths();
				for (a = 0; a < c.length;) {
					if (c[a] >= b) return b = c[a] - b, a = this.curves[a], c = a.getLength(), a.getPointAt(0 === c ? 0 : 1 - b / c);
					a++
				}
				return null
			},
			getLength: function() {
				var a = this.getCurveLengths();
				return a[a.length - 1]
			},
			updateArcLengths: function() {
				this.needsUpdate = !0;
				this.cacheLengths = null;
				this.getCurveLengths()
			},
			getCurveLengths: function() {
				if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
				for (var a = [], b = 0, c = 0, d = this.curves.length; c < d; c++) b += this.curves[c].getLength(), a.push(b);
				return this.cacheLengths = a
			},
			getSpacedPoints: function(a) {
				void 0 === a && (a = 40);
				for (var b = [], c = 0; c <= a; c++) b.push(this.getPoint(c / a));
				this.autoClose && b.push(b[0]);
				return b
			},
			getPoints: function(a) {
				a = a || 12;
				for (var b = [], c, d = 0, e = this.curves; d < e.length; d++) {
					var g =
						e[d];
					g = g.getPoints(g && g.isEllipseCurve ? 2 * a : g && (g.isLineCurve || g.isLineCurve3) ? 1 : g && g.isSplineCurve ?
						a * g.points.length : a);
					for (var k = 0; k < g.length; k++) {
						var l = g[k];
						c && c.equals(l) || (b.push(l), c = l)
					}
				}
				this.autoClose && 1 < b.length && !b[b.length - 1].equals(b[0]) && b.push(b[0]);
				return b
			},
			copy: function(a) {
				X.prototype.copy.call(this, a);
				this.curves = [];
				for (var b = 0, c = a.curves.length; b < c; b++) this.curves.push(a.curves[b].clone());
				this.autoClose = a.autoClose;
				return this
			},
			toJSON: function() {
				var a = X.prototype.toJSON.call(this);
				a.autoClose = this.autoClose;
				a.curves = [];
				for (var b = 0, c = this.curves.length; b < c; b++) a.curves.push(this.curves[b].toJSON());
				return a
			},
			fromJSON: function(a) {
				X.prototype.fromJSON.call(this, a);
				this.autoClose = a.autoClose;
				this.curves = [];
				for (var b = 0, c = a.curves.length; b < c; b++) {
					var d = a.curves[b];
					this.curves.push((new gm[d.type]).fromJSON(d))
				}
				return this
			}
		});
	Ad.prototype = q(p(ge.prototype), {
		constructor: Ad,
		setFromPoints: function(a) {
			this.moveTo(a[0].x, a[0].y);
			for (var b = 1, c = a.length; b < c; b++) this.lineTo(a[b].x, a[b].y)
		},
		moveTo: function(a, b) {
			this.currentPoint.set(a, b)
		},
		lineTo: function(a, b) {
			var c = new Tb(this.currentPoint.clone(), new B(a, b));
			this.curves.push(c);
			this.currentPoint.set(a, b)
		},
		quadraticCurveTo: function(a, b, c, d) {
			a = new yd(this.currentPoint.clone(), new B(a, b), new B(c, d));
			this.curves.push(a);
			this.currentPoint.set(c, d)
		},
		bezierCurveTo: function(a, b, c, d, e, g) {
			a = new Kc(this.currentPoint.clone(), new B(a, b), new B(c, d), new B(e, g));
			this.curves.push(a);
			this.currentPoint.set(e, g)
		},
		splineThru: function(a) {
			var b = [this.currentPoint.clone()].concat(a);
			b = new zd(b);
			this.curves.push(b);
			this.currentPoint.copy(a[a.length - 1])
		},
		arc: function(a, b, c, d, e, g) {
			this.absarc(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, g)
		},
		absarc: function(a, b, c, d, e, g) {
			this.absellipse(a, b, c, c, d, e, g)
		},
		ellipse: function(a, b, c, d, e, g, k, l) {
			this.absellipse(a + this.currentPoint.x, b + this.currentPoint.y, c, d, e, g, k, l)
		},
		absellipse: function(a, b, c, d, e, g, k, l) {
			a = new kc(a, b, c, d, e, g, k, l);
			0 < this.curves.length && (b = a.getPoint(0), b.equals(this.currentPoint) || this.lineTo(b.x, b.y));
			this.curves.push(a);
			a = a.getPoint(1);
			this.currentPoint.copy(a)
		},
		copy: function(a) {
			ge.prototype.copy.call(this, a);
			this.currentPoint.copy(a.currentPoint);
			return this
		},
		toJSON: function() {
			var a = ge.prototype.toJSON.call(this);
			a.currentPoint = this.currentPoint.toArray();
			return a
		},
		fromJSON: function(a) {
			ge.prototype.fromJSON.call(this, a);
			this.currentPoint.fromArray(a.currentPoint);
			return this
		}
	});
	lc.prototype = q(p(Ad.prototype), {
		constructor: lc,
		getPointsHoles: function(a) {
			for (var b = [], c = 0, d = this.holes.length; c < d; c++) b[c] = this.holes[c].getPoints(a);
			return b
		},
		extractPoints: function(a) {
			return {
				shape: this.getPoints(a),
				holes: this.getPointsHoles(a)
			}
		},
		copy: function(a) {
			Ad.prototype.copy.call(this, a);
			this.holes = [];
			for (var b = 0, c = a.holes.length; b < c; b++) this.holes.push(a.holes[b].clone());
			return this
		},
		toJSON: function() {
			var a = Ad.prototype.toJSON.call(this);
			a.uuid = this.uuid;
			a.holes = [];
			for (var b = 0, c = this.holes.length; b < c; b++) a.holes.push(this.holes[b].toJSON());
			return a
		},
		fromJSON: function(a) {
			Ad.prototype.fromJSON.call(this, a);
			this.uuid = a.uuid;
			this.holes = [];
			for (var b = 0, c = a.holes.length; b < c; b++) {
				var d = a.holes[b];
				this.holes.push((new Ad).fromJSON(d))
			}
			return this
		}
	});
	Ba.prototype = q(p(P.prototype), {
		constructor: Ba,
		isLight: !0,
		copy: function(a) {
			P.prototype.copy.call(this, a);
			this.color.copy(a.color);
			this.intensity = a.intensity;
			return this
		},
		toJSON: function(a) {
			a = P.prototype.toJSON.call(this, a);
			a.object.color = this.color.getHex();
			a.object.intensity = this.intensity;
			void 0 !== this.groundColor && (a.object.groundColor = this.groundColor.getHex());
			void 0 !== this.distance && (a.object.distance =
				this.distance);
			void 0 !== this.angle && (a.object.angle = this.angle);
			void 0 !== this.decay && (a.object.decay = this.decay);
			void 0 !== this.penumbra && (a.object.penumbra = this.penumbra);
			void 0 !== this.shadow && (a.object.shadow = this.shadow.toJSON());
			return a
		}
	});
	oj.prototype = q(p(Ba.prototype), {
		constructor: oj,
		isHemisphereLight: !0,
		copy: function(a) {
			Ba.prototype.copy.call(this, a);
			this.groundColor.copy(a.groundColor);
			return this
		}
	});
	q(he.prototype, {
		_projScreenMatrix: new ua,
		_lightPositionWorld: new u,
		_lookTarget: new u,
		getViewportCount: function() {
			return this._viewportCount
		},
		getFrustum: function() {
			return this._frustum
		},
		updateMatrices: function(a) {
			var b = this.camera,
				c = this.matrix,
				d = this._projScreenMatrix,
				e = this._lookTarget,
				g = this._lightPositionWorld;
			g.setFromMatrixPosition(a.matrixWorld);
			b.position.copy(g);
			e.setFromMatrixPosition(a.target.matrixWorld);
			b.lookAt(e);
			b.updateMatrixWorld();
			d.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
			this._frustum.setFromMatrix(d);
			c.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
			c.multiply(b.projectionMatrix);
			c.multiply(b.matrixWorldInverse)
		},
		getViewport: function(a) {
			return this._viewports[a]
		},
		getFrameExtents: function() {
			return this._frameExtents
		},
		copy: function(a) {
			this.camera = a.camera.clone();
			this.bias = a.bias;
			this.radius = a.radius;
			this.mapSize.copy(a.mapSize);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		toJSON: function() {
			var a = {};
			0 !== this.bias && (a.bias = this.bias);
			1 !== this.radius && (a.radius = this.radius);
			if (512 !== this.mapSize.x || 512 !== this.mapSize.y) a.mapSize = this.mapSize.toArray();
			a.camera = this.camera.toJSON(!1).object;
			delete a.camera.matrix;
			return a
		}
	});
	Rh.prototype = q(p(he.prototype), {
		constructor: Rh,
		isSpotLightShadow: !0,
		updateMatrices: function(a, b, c) {
			var d = this.camera,
				e = 2 * ha.RAD2DEG * a.angle,
				g = this.mapSize.width / this.mapSize.height,
				k = a.distance || d.far;
			if (e !== d.fov || g !== d.aspect || k !== d.far) d.fov = e, d.aspect = g, d.far = k, d.updateProjectionMatrix();
			he.prototype.updateMatrices.call(this, a, b, c)
		}
	});
	Sk.prototype = q(p(Ba.prototype), {
		constructor: Sk,
		isSpotLight: !0,
		copy: function(a) {
			Ba.prototype.copy.call(this, a);
			this.distance = a.distance;
			this.angle = a.angle;
			this.penumbra = a.penumbra;
			this.decay = a.decay;
			this.target = a.target.clone();
			this.shadow = a.shadow.clone();
			return this
		}
	});
	Tk.prototype = q(p(he.prototype), {
		constructor: Tk,
		isPointLightShadow: !0,
		updateMatrices: function(a, b, c) {
			b = this.camera;
			var d = this.matrix,
				e = this._lightPositionWorld,
				g = this._lookTarget,
				k = this._projScreenMatrix;
			e.setFromMatrixPosition(a.matrixWorld);
			b.position.copy(e);
			g.copy(b.position);
			g.add(this._cubeDirections[c]);
			b.up.copy(this._cubeUps[c]);
			b.lookAt(g);
			b.updateMatrixWorld();
			d.makeTranslation(-e.x, -e.y, -e.z);
			k.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
			this._frustum.setFromMatrix(k)
		}
	});
	Uk.prototype = q(p(Ba.prototype), {
		constructor: Uk,
		isPointLight: !0,
		copy: function(a) {
			Ba.prototype.copy.call(this, a);
			this.distance = a.distance;
			this.decay = a.decay;
			this.shadow = a.shadow.clone();
			return this
		}
	});
	Lc.prototype = q(p(Vd.prototype), {
		constructor: Lc,
		isOrthographicCamera: !0,
		copy: function(a, b) {
			Vd.prototype.copy.call(this, a, b);
			this.left = a.left;
			this.right = a.right;
			this.top = a.top;
			this.bottom = a.bottom;
			this.near = a.near;
			this.far = a.far;
			this.zoom = a.zoom;
			this.view = null === a.view ? null : q({}, a.view);
			return this
		},
		setViewOffset: function(a, b, c, d, e, g) {
			null === this.view && (this.view = {
				enabled: !0,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			});
			this.view.enabled = !0;
			this.view.fullWidth = a;
			this.view.fullHeight = b;
			this.view.offsetX = c;
			this.view.offsetY = d;
			this.view.width = e;
			this.view.height = g;
			this.updateProjectionMatrix()
		},
		clearViewOffset: function() {
			null !== this.view && (this.view.enabled = !1);
			this.updateProjectionMatrix()
		},
		updateProjectionMatrix: function() {
			var a = (this.right - this.left) / (2 * this.zoom),
				b = (this.top - this.bottom) / (2 * this.zoom),
				c = (this.right + this.left) / 2,
				d = (this.top + this.bottom) / 2,
				e = c - a;
			c += a;
			a = d + b;
			b = d - b;
			if (null !== this.view && this.view.enabled) {
				c = this.zoom / (this.view.width / this.view.fullWidth);
				b = this.zoom / (this.view.height / this.view.fullHeight);
				var g = (this.right - this.left) / this.view.width;
				d = (this.top - this.bottom) / this.view.height;
				e += this.view.offsetX / c * g;
				c = e + this.view.width /
					c * g;
				a -= this.view.offsetY / b * d;
				b = a - this.view.height / b * d
			}
			this.projectionMatrix.makeOrthographic(e, c, a, b, this.near, this.far);
			this.projectionMatrixInverse.getInverse(this.projectionMatrix)
		},
		toJSON: function(a) {
			a = P.prototype.toJSON.call(this, a);
			a.object.zoom = this.zoom;
			a.object.left = this.left;
			a.object.right = this.right;
			a.object.top = this.top;
			a.object.bottom = this.bottom;
			a.object.near = this.near;
			a.object.far = this.far;
			null !== this.view && (a.object.view = q({}, this.view));
			return a
		}
	});
	Vk.prototype = q(p(he.prototype), {
		constructor: Vk,
		isDirectionalLightShadow: !0,
		updateMatrices: function(a, b, c) {
			he.prototype.updateMatrices.call(this, a, b, c)
		}
	});
	Wk.prototype = q(p(Ba.prototype), {
		constructor: Wk,
		isDirectionalLight: !0,
		copy: function(a) {
			Ba.prototype.copy.call(this, a);
			this.target = a.target.clone();
			this.shadow = a.shadow.clone();
			return this
		}
	});
	Xk.prototype = q(p(Ba.prototype), {
		constructor: Xk,
		isAmbientLight: !0
	});
	Yk.prototype = q(p(Ba.prototype), {
		constructor: Yk,
		isRectAreaLight: !0,
		copy: function(a) {
			Ba.prototype.copy.call(this, a);
			this.width =
				a.width;
			this.height = a.height;
			return this
		},
		toJSON: function(a) {
			a = Ba.prototype.toJSON.call(this, a);
			a.object.width = this.width;
			a.object.height = this.height;
			return a
		}
	});
	Zk.prototype = q(p(sa.prototype), {
		constructor: Zk,
		load: function(a, b, c, d) {
			var e = this,
				g = new Jc(e.manager);
			g.setPath(e.path);
			g.load(a, function(a) {
				b(e.parse(JSON.parse(a)))
			}, c, d)
		},
		parse: function(a) {
			function b(a) {
				void 0 === c[a] && console.warn("THREE.MaterialLoader: Undefined texture", a);
				return c[a]
			}
			var c = this.textures,
				d = new Qs[a.type];
			void 0 !== a.uuid &&
				(d.uuid = a.uuid);
			void 0 !== a.name && (d.name = a.name);
			void 0 !== a.color && d.color.setHex(a.color);
			void 0 !== a.roughness && (d.roughness = a.roughness);
			void 0 !== a.metalness && (d.metalness = a.metalness);
			void 0 !== a.sheen && (d.sheen = (new S).setHex(a.sheen));
			void 0 !== a.emissive && d.emissive.setHex(a.emissive);
			void 0 !== a.specular && d.specular.setHex(a.specular);
			void 0 !== a.shininess && (d.shininess = a.shininess);
			void 0 !== a.clearcoat && (d.clearcoat = a.clearcoat);
			void 0 !== a.clearcoatRoughness && (d.clearcoatRoughness = a.clearcoatRoughness);
			void 0 !== a.vertexColors && (d.vertexColors = a.vertexColors);
			void 0 !== a.fog && (d.fog = a.fog);
			void 0 !== a.flatShading && (d.flatShading = a.flatShading);
			void 0 !== a.blending && (d.blending = a.blending);
			void 0 !== a.combine && (d.combine = a.combine);
			void 0 !== a.side && (d.side = a.side);
			void 0 !== a.opacity && (d.opacity = a.opacity);
			void 0 !== a.transparent && (d.transparent = a.transparent);
			void 0 !== a.alphaTest && (d.alphaTest = a.alphaTest);
			void 0 !== a.depthTest && (d.depthTest = a.depthTest);
			void 0 !== a.depthWrite && (d.depthWrite = a.depthWrite);
			void 0 !== a.colorWrite && (d.colorWrite = a.colorWrite);
			void 0 !== a.stencilWrite && (d.stencilWrite = a.stencilWrite);
			void 0 !== a.stencilWriteMask && (d.stencilWriteMask = a.stencilWriteMask);
			void 0 !== a.stencilFunc && (d.stencilFunc = a.stencilFunc);
			void 0 !== a.stencilRef && (d.stencilRef = a.stencilRef);
			void 0 !== a.stencilFuncMask && (d.stencilFuncMask = a.stencilFuncMask);
			void 0 !== a.stencilFail && (d.stencilFail = a.stencilFail);
			void 0 !== a.stencilZFail && (d.stencilZFail = a.stencilZFail);
			void 0 !== a.stencilZPass && (d.stencilZPass = a.stencilZPass);
			void 0 !== a.wireframe && (d.wireframe = a.wireframe);
			void 0 !== a.wireframeLinewidth && (d.wireframeLinewidth = a.wireframeLinewidth);
			void 0 !== a.wireframeLinecap && (d.wireframeLinecap = a.wireframeLinecap);
			void 0 !== a.wireframeLinejoin && (d.wireframeLinejoin = a.wireframeLinejoin);
			void 0 !== a.rotation && (d.rotation = a.rotation);
			1 !== a.linewidth && (d.linewidth = a.linewidth);
			void 0 !== a.dashSize && (d.dashSize = a.dashSize);
			void 0 !== a.gapSize && (d.gapSize = a.gapSize);
			void 0 !== a.scale && (d.scale = a.scale);
			void 0 !== a.polygonOffset &&
				(d.polygonOffset = a.polygonOffset);
			void 0 !== a.polygonOffsetFactor && (d.polygonOffsetFactor = a.polygonOffsetFactor);
			void 0 !== a.polygonOffsetUnits && (d.polygonOffsetUnits = a.polygonOffsetUnits);
			void 0 !== a.skinning && (d.skinning = a.skinning);
			void 0 !== a.morphTargets && (d.morphTargets = a.morphTargets);
			void 0 !== a.morphNormals && (d.morphNormals = a.morphNormals);
			void 0 !== a.dithering && (d.dithering = a.dithering);
			void 0 !== a.visible && (d.visible = a.visible);
			void 0 !== a.toneMapped && (d.toneMapped = a.toneMapped);
			void 0 !== a.userData &&
				(d.userData = a.userData);
			if (void 0 !== a.uniforms)
				for (var e in a.uniforms) {
					var g = a.uniforms[e];
					d.uniforms[e] = {};
					switch (g.type) {
						case "t":
							d.uniforms[e].value = b(g.value);
							break;
						case "c":
							d.uniforms[e].value = (new S).setHex(g.value);
							break;
						case "v2":
							d.uniforms[e].value = (new B).fromArray(g.value);
							break;
						case "v3":
							d.uniforms[e].value = (new u).fromArray(g.value);
							break;
						case "v4":
							d.uniforms[e].value = (new za).fromArray(g.value);
							break;
						case "m3":
							d.uniforms[e].value = (new kb).fromArray(g.value);
						case "m4":
							d.uniforms[e].value =
								(new ua).fromArray(g.value);
							break;
						default:
							d.uniforms[e].value = g.value
					}
				}
			void 0 !== a.defines && (d.defines = a.defines);
			void 0 !== a.vertexShader && (d.vertexShader = a.vertexShader);
			void 0 !== a.fragmentShader && (d.fragmentShader = a.fragmentShader);
			if (void 0 !== a.extensions)
				for (var k in a.extensions) d.extensions[k] = a.extensions[k];
			void 0 !== a.shading && (d.flatShading = 1 === a.shading);
			void 0 !== a.size && (d.size = a.size);
			void 0 !== a.sizeAttenuation && (d.sizeAttenuation = a.sizeAttenuation);
			void 0 !== a.map && (d.map = b(a.map));
			void 0 !==
				a.matcap && (d.matcap = b(a.matcap));
			void 0 !== a.alphaMap && (d.alphaMap = b(a.alphaMap), d.transparent = !0);
			void 0 !== a.bumpMap && (d.bumpMap = b(a.bumpMap));
			void 0 !== a.bumpScale && (d.bumpScale = a.bumpScale);
			void 0 !== a.normalMap && (d.normalMap = b(a.normalMap));
			void 0 !== a.normalMapType && (d.normalMapType = a.normalMapType);
			void 0 !== a.normalScale && (e = a.normalScale, !1 === Array.isArray(e) && (e = [e, e]), d.normalScale = (new B)
				.fromArray(e));
			void 0 !== a.displacementMap && (d.displacementMap = b(a.displacementMap));
			void 0 !== a.displacementScale &&
				(d.displacementScale = a.displacementScale);
			void 0 !== a.displacementBias && (d.displacementBias = a.displacementBias);
			void 0 !== a.roughnessMap && (d.roughnessMap = b(a.roughnessMap));
			void 0 !== a.metalnessMap && (d.metalnessMap = b(a.metalnessMap));
			void 0 !== a.emissiveMap && (d.emissiveMap = b(a.emissiveMap));
			void 0 !== a.emissiveIntensity && (d.emissiveIntensity = a.emissiveIntensity);
			void 0 !== a.specularMap && (d.specularMap = b(a.specularMap));
			void 0 !== a.envMap && (d.envMap = b(a.envMap));
			void 0 !== a.envMapIntensity && (d.envMapIntensity =
				a.envMapIntensity);
			void 0 !== a.reflectivity && (d.reflectivity = a.reflectivity);
			void 0 !== a.refractionRatio && (d.refractionRatio = a.refractionRatio);
			void 0 !== a.lightMap && (d.lightMap = b(a.lightMap));
			void 0 !== a.lightMapIntensity && (d.lightMapIntensity = a.lightMapIntensity);
			void 0 !== a.aoMap && (d.aoMap = b(a.aoMap));
			void 0 !== a.aoMapIntensity && (d.aoMapIntensity = a.aoMapIntensity);
			void 0 !== a.gradientMap && (d.gradientMap = b(a.gradientMap));
			void 0 !== a.clearcoatNormalMap && (d.clearcoatNormalMap = b(a.clearcoatNormalMap));
			void 0 !==
				a.clearcoatNormalScale && (d.clearcoatNormalScale = (new B).fromArray(a.clearcoatNormalScale));
			return d
		},
		setTextures: function(a) {
			this.textures = a;
			return this
		}
	});
	var Yo = {
		decodeText: function(a) {
			if ("undefined" !== typeof TextDecoder) return (new TextDecoder).decode(a);
			for (var b = "", c = 0, d = a.length; c < d; c++) b += String.fromCharCode(a[c]);
			try {
				return decodeURIComponent(escape(b))
			} catch (e) {
				return b
			}
		},
		extractUrlBase: function(a) {
			var b = a.lastIndexOf("/");
			return -1 === b ? "./" : a.substr(0, b + 1)
		}
	};
	$k.prototype = q(p(J.prototype), {
		constructor: $k,
		isInstancedBufferGeometry: !0,
		copy: function(a) {
			J.prototype.copy.call(this, a);
			this.maxInstancedCount = a.maxInstancedCount;
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		toJSON: function() {
			var a = J.prototype.toJSON.call(this);
			a.maxInstancedCount = this.maxInstancedCount;
			a.isInstancedBufferGeometry = !0;
			return a
		}
	});
	al.prototype = q(p(F.prototype), {
		constructor: al,
		isInstancedBufferAttribute: !0,
		copy: function(a) {
			F.prototype.copy.call(this, a);
			this.meshPerAttribute = a.meshPerAttribute;
			return this
		},
		toJSON: function() {
			var a = F.prototype.toJSON.call(this);
			a.meshPerAttribute = this.meshPerAttribute;
			a.isInstancedBufferAttribute = !0;
			return a
		}
	});
	bl.prototype = q(p(sa.prototype), {
		constructor: bl,
		load: function(a, b, c, d) {
			var e = this,
				g = new Jc(e.manager);
			g.setPath(e.path);
			g.load(a, function(a) {
				b(e.parse(JSON.parse(a)))
			}, c, d)
		},
		parse: function(a) {
			var b = a.isInstancedBufferGeometry ? new $k : new J,
				c = a.data.index;
			if (void 0 !== c) {
				var d = new hm[c.type](c.array);
				b.setIndex(new F(d, 1))
			}
			c = a.data.attributes;
			for (var e in c) {
				var g =
					c[e];
				d = new hm[g.type](g.array);
				d = new(g.isInstancedBufferAttribute ? al : F)(d, g.itemSize, g.normalized);
				void 0 !== g.name && (d.name = g.name);
				b.addAttribute(e, d)
			}
			var k = a.data.morphAttributes;
			if (k)
				for (e in k) {
					var l = k[e],
						m = [];
					c = 0;
					for (var n = l.length; c < n; c++) g = l[c], d = new hm[g.type](g.array), d = new F(d, g.itemSize, g.normalized),
						void 0 !== g.name && (d.name = g.name), m.push(d);
					b.morphAttributes[e] = m
				}
			e = a.data.groups || a.data.drawcalls || a.data.offsets;
			if (void 0 !== e)
				for (c = 0, g = e.length; c !== g; ++c) d = e[c], b.addGroup(d.start, d.count,
					d.materialIndex);
			c = a.data.boundingSphere;
			void 0 !== c && (e = new u, void 0 !== c.center && e.fromArray(c.center), b.boundingSphere = new Ne(e, c.radius));
			a.name && (b.name = a.name);
			a.userData && (b.userData = a.userData);
			return b
		}
	});
	var hm = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		Uint8ClampedArray: "undefined" !== typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};
	cl.prototype =
		q(p(sa.prototype), {
			constructor: cl,
			load: function(a, b, c, d) {
				var e = this,
					g = "" === this.path ? Yo.extractUrlBase(a) : this.path;
				this.resourcePath = this.resourcePath || g;
				g = new Jc(e.manager);
				g.setPath(this.path);
				g.load(a, function(c) {
					var g = null;
					try {
						g = JSON.parse(c)
					} catch (m) {
						void 0 !== d && d(m);
						console.error("THREE:ObjectLoader: Can't parse " + a + ".", m.message);
						return
					}
					c = g.metadata;
					void 0 === c || void 0 === c.type || "geometry" === c.type.toLowerCase() ? console.error(
						"THREE.ObjectLoader: Can't load " + a) : e.parse(g, b)
				}, c, d)
			},
			parse: function(a,
				b) {
				var c = this.parseShape(a.shapes);
				c = this.parseGeometries(a.geometries, c);
				var d = this.parseImages(a.images, function() {
					void 0 !== b && b(e)
				});
				d = this.parseTextures(a.textures, d);
				d = this.parseMaterials(a.materials, d);
				var e = this.parseObject(a.object, c, d);
				a.animations && (e.animations = this.parseAnimations(a.animations));
				void 0 !== a.images && 0 !== a.images.length || void 0 === b || b(e);
				return e
			},
			parseShape: function(a) {
				var b = {};
				if (void 0 !== a)
					for (var c = 0, d = a.length; c < d; c++) {
						var e = (new lc).fromJSON(a[c]);
						b[e.uuid] = e
					}
				return b
			},
			parseGeometries: function(a, b) {
				var c = {};
				if (void 0 !== a)
					for (var d = new bl, e = 0, g = a.length; e < g; e++) {
						var k = a[e];
						switch (k.type) {
							case "PlaneGeometry":
							case "PlaneBufferGeometry":
								var l = new Fb[k.type](k.width, k.height, k.widthSegments, k.heightSegments);
								break;
							case "BoxGeometry":
							case "BoxBufferGeometry":
							case "CubeGeometry":
								l = new Fb[k.type](k.width, k.height, k.depth, k.widthSegments, k.heightSegments, k.depthSegments);
								break;
							case "CircleGeometry":
							case "CircleBufferGeometry":
								l = new Fb[k.type](k.radius, k.segments, k.thetaStart,
									k.thetaLength);
								break;
							case "CylinderGeometry":
							case "CylinderBufferGeometry":
								l = new Fb[k.type](k.radiusTop, k.radiusBottom, k.height, k.radialSegments, k.heightSegments, k.openEnded, k
									.thetaStart, k.thetaLength);
								break;
							case "ConeGeometry":
							case "ConeBufferGeometry":
								l = new Fb[k.type](k.radius, k.height, k.radialSegments, k.heightSegments, k.openEnded, k.thetaStart, k.thetaLength);
								break;
							case "SphereGeometry":
							case "SphereBufferGeometry":
								l = new Fb[k.type](k.radius, k.widthSegments, k.heightSegments, k.phiStart, k.phiLength,
									k.thetaStart, k.thetaLength);
								break;
							case "DodecahedronGeometry":
							case "DodecahedronBufferGeometry":
							case "IcosahedronGeometry":
							case "IcosahedronBufferGeometry":
							case "OctahedronGeometry":
							case "OctahedronBufferGeometry":
							case "TetrahedronGeometry":
							case "TetrahedronBufferGeometry":
								l = new Fb[k.type](k.radius, k.detail);
								break;
							case "RingGeometry":
							case "RingBufferGeometry":
								l = new Fb[k.type](k.innerRadius, k.outerRadius, k.thetaSegments, k.phiSegments, k.thetaStart, k.thetaLength);
								break;
							case "TorusGeometry":
							case "TorusBufferGeometry":
								l =
									new Fb[k.type](k.radius, k.tube, k.radialSegments, k.tubularSegments, k.arc);
								break;
							case "TorusKnotGeometry":
							case "TorusKnotBufferGeometry":
								l = new Fb[k.type](k.radius, k.tube, k.tubularSegments, k.radialSegments, k.p, k.q);
								break;
							case "TubeGeometry":
							case "TubeBufferGeometry":
								l = new Fb[k.type]((new gm[k.path.type]).fromJSON(k.path), k.tubularSegments, k.radius, k.radialSegments, k.closed);
								break;
							case "LatheGeometry":
							case "LatheBufferGeometry":
								l = new Fb[k.type](k.points, k.segments, k.phiStart, k.phiLength);
								break;
							case "PolyhedronGeometry":
							case "PolyhedronBufferGeometry":
								l =
									new Fb[k.type](k.vertices, k.indices, k.radius, k.details);
								break;
							case "ShapeGeometry":
							case "ShapeBufferGeometry":
								l = [];
								for (var m = 0, n = k.shapes.length; m < n; m++) {
									var p = b[k.shapes[m]];
									l.push(p)
								}
								l = new Fb[k.type](l, k.curveSegments);
								break;
							case "ExtrudeGeometry":
							case "ExtrudeBufferGeometry":
								l = [];
								m = 0;
								for (n = k.shapes.length; m < n; m++) p = b[k.shapes[m]], l.push(p);
								m = k.options.extrudePath;
								void 0 !== m && (k.options.extrudePath = (new gm[m.type]).fromJSON(m));
								l = new Fb[k.type](l, k.options);
								break;
							case "BufferGeometry":
							case "InstancedBufferGeometry":
								l =
									d.parse(k);
								break;
							case "Geometry":
								"THREE" in window && "LegacyJSONLoader" in THREE ? l = (new THREE.LegacyJSONLoader).parse(k, this.resourcePath)
									.geometry : console.error(
										'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
								break;
							default:
								console.warn('THREE.ObjectLoader: Unsupported geometry type "' + k.type + '"');
								continue
						}
						l.uuid = k.uuid;
						void 0 !== k.name && (l.name = k.name);
						!0 === l.isBufferGeometry && void 0 !== k.userData && (l.userData = k.userData);
						c[k.uuid] = l
					}
				return c
			},
			parseMaterials: function(a, b) {
				var c = {},
					d = {};
				if (void 0 !== a) {
					var e = new Zk;
					e.setTextures(b);
					b = 0;
					for (var g = a.length; b < g; b++) {
						var k = a[b];
						if ("MultiMaterial" === k.type) {
							for (var l = [], m = 0; m < k.materials.length; m++) {
								var n = k.materials[m];
								void 0 === c[n.uuid] && (c[n.uuid] = e.parse(n));
								l.push(c[n.uuid])
							}
							d[k.uuid] = l
						} else void 0 === c[k.uuid] && (c[k.uuid] = e.parse(k)), d[k.uuid] = c[k.uuid]
					}
				}
				return d
			},
			parseAnimations: function(a) {
				for (var b = [], c = 0; c < a.length; c++) {
					var d = a[c],
						e = Ic.parse(d);
					void 0 !== d.uuid && (e.uuid = d.uuid);
					b.push(e)
				}
				return b
			},
			parseImages: function(a, b) {
				function c(a) {
					d.manager.itemStart(a);
					return g.load(a, function() {
						d.manager.itemEnd(a)
					}, void 0, function() {
						d.manager.itemError(a);
						d.manager.itemEnd(a)
					})
				}
				var d = this,
					e = {};
				if (void 0 !== a && 0 < a.length) {
					b = new ln(b);
					var g = new Rf(b);
					g.setCrossOrigin(this.crossOrigin);
					b = 0;
					for (var k = a.length; b < k; b++) {
						var l = a[b],
							m = l.url;
						if (Array.isArray(m)) {
							e[l.uuid] = [];
							for (var n = 0, p = m.length; n < p; n++) {
								var q = m[n];
								q = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(q) ? q : d.resourcePath + q;
								e[l.uuid].push(c(q))
							}
						} else q = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l.url) ?
							l.url : d.resourcePath + l.url, e[l.uuid] = c(q)
					}
				}
				return e
			},
			parseTextures: function(a, b) {
				function c(a, b) {
					if ("number" === typeof a) return a;
					console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", a);
					return b[a]
				}
				var d = {};
				if (void 0 !== a)
					for (var e = 0, g = a.length; e < g; e++) {
						var k = a[e];
						void 0 === k.image && console.warn('THREE.ObjectLoader: No "image" specified for', k.uuid);
						void 0 === b[k.image] && console.warn("THREE.ObjectLoader: Undefined image", k.image);
						var l = Array.isArray(b[k.image]) ? new rd(b[k.image]) :
							new pa(b[k.image]);
						l.needsUpdate = !0;
						l.uuid = k.uuid;
						void 0 !== k.name && (l.name = k.name);
						void 0 !== k.mapping && (l.mapping = c(k.mapping, Rs));
						void 0 !== k.offset && l.offset.fromArray(k.offset);
						void 0 !== k.repeat && l.repeat.fromArray(k.repeat);
						void 0 !== k.center && l.center.fromArray(k.center);
						void 0 !== k.rotation && (l.rotation = k.rotation);
						void 0 !== k.wrap && (l.wrapS = c(k.wrap[0], Zo), l.wrapT = c(k.wrap[1], Zo));
						void 0 !== k.format && (l.format = k.format);
						void 0 !== k.type && (l.type = k.type);
						void 0 !== k.encoding && (l.encoding = k.encoding);
						void 0 !== k.minFilter && (l.minFilter = c(k.minFilter, $o));
						void 0 !== k.magFilter && (l.magFilter = c(k.magFilter, $o));
						void 0 !== k.anisotropy && (l.anisotropy = k.anisotropy);
						void 0 !== k.flipY && (l.flipY = k.flipY);
						void 0 !== k.premultiplyAlpha && (l.premultiplyAlpha = k.premultiplyAlpha);
						void 0 !== k.unpackAlignment && (l.unpackAlignment = k.unpackAlignment);
						d[k.uuid] = l
					}
				return d
			},
			parseObject: function(a, b, c) {
				function d(a) {
					void 0 === b[a] && console.warn("THREE.ObjectLoader: Undefined geometry", a);
					return b[a]
				}

				function e(a) {
					if (void 0 !==
						a) {
						if (Array.isArray(a)) {
							for (var b = [], d = 0, e = a.length; d < e; d++) {
								var g = a[d];
								void 0 === c[g] && console.warn("THREE.ObjectLoader: Undefined material", g);
								b.push(c[g])
							}
							return b
						}
						void 0 === c[a] && console.warn("THREE.ObjectLoader: Undefined material", a);
						return c[a]
					}
				}
				switch (a.type) {
					case "Scene":
						var g = new Bg;
						void 0 !== a.background && Dk(a.background) && (g.background = new S(a.background));
						void 0 !== a.fog && ("Fog" === a.fog.type ? g.fog = new hk(a.fog.color, a.fog.near, a.fog.far) : "FogExp2" ===
							a.fog.type && (g.fog = new gk(a.fog.color,
								a.fog.density)));
						break;
					case "PerspectiveCamera":
						g = new ab(a.fov, a.aspect, a.near, a.far);
						void 0 !== a.focus && (g.focus = a.focus);
						void 0 !== a.zoom && (g.zoom = a.zoom);
						void 0 !== a.filmGauge && (g.filmGauge = a.filmGauge);
						void 0 !== a.filmOffset && (g.filmOffset = a.filmOffset);
						void 0 !== a.view && (g.view = q({}, a.view));
						break;
					case "OrthographicCamera":
						g = new Lc(a.left, a.right, a.top, a.bottom, a.near, a.far);
						void 0 !== a.zoom && (g.zoom = a.zoom);
						void 0 !== a.view && (g.view = q({}, a.view));
						break;
					case "AmbientLight":
						g = new Xk(a.color, a.intensity);
						break;
					case "DirectionalLight":
						g = new Wk(a.color, a.intensity);
						break;
					case "PointLight":
						g = new Uk(a.color, a.intensity, a.distance, a.decay);
						break;
					case "RectAreaLight":
						g = new Yk(a.color, a.intensity, a.width, a.height);
						break;
					case "SpotLight":
						g = new Sk(a.color, a.intensity, a.distance, a.angle, a.penumbra, a.decay);
						break;
					case "HemisphereLight":
						g = new oj(a.color, a.groundColor, a.intensity);
						break;
					case "SkinnedMesh":
						console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
					case "Mesh":
						g = d(a.geometry);
						var k = e(a.material);
						g = g.bones && 0 < g.bones.length ? new $i(g, k) : new Wa(g, k);
						void 0 !== a.drawMode && g.setDrawMode(a.drawMode);
						break;
					case "LOD":
						g = new Zi;
						break;
					case "Line":
						g = new Pa(d(a.geometry), e(a.material), a.mode);
						break;
					case "LineLoop":
						g = new kk(d(a.geometry), e(a.material));
						break;
					case "LineSegments":
						g = new Ra(d(a.geometry), e(a.material));
						break;
					case "PointCloud":
					case "Points":
						g = new lk(d(a.geometry), e(a.material));
						break;
					case "Sprite":
						g = new ik(e(a.material));
						break;
					case "Group":
						g = new Hg;
						break;
					default:
						g = new P
				}
				g.uuid =
					a.uuid;
				void 0 !== a.name && (g.name = a.name);
				void 0 !== a.matrix ? (g.matrix.fromArray(a.matrix), void 0 !== a.matrixAutoUpdate && (g.matrixAutoUpdate = a.matrixAutoUpdate),
					g.matrixAutoUpdate && g.matrix.decompose(g.position, g.quaternion, g.scale)) : (void 0 !== a.position && g.position
					.fromArray(a.position), void 0 !== a.rotation && g.rotation.fromArray(a.rotation), void 0 !== a.quaternion &&
					g.quaternion.fromArray(a.quaternion), void 0 !== a.scale && g.scale.fromArray(a.scale));
				void 0 !== a.castShadow && (g.castShadow = a.castShadow);
				void 0 !==
					a.receiveShadow && (g.receiveShadow = a.receiveShadow);
				a.shadow && (void 0 !== a.shadow.bias && (g.shadow.bias = a.shadow.bias), void 0 !== a.shadow.radius && (g.shadow
						.radius = a.shadow.radius), void 0 !== a.shadow.mapSize && g.shadow.mapSize.fromArray(a.shadow.mapSize), void 0 !==
					a.shadow.camera && (g.shadow.camera = this.parseObject(a.shadow.camera)));
				void 0 !== a.visible && (g.visible = a.visible);
				void 0 !== a.frustumCulled && (g.frustumCulled = a.frustumCulled);
				void 0 !== a.renderOrder && (g.renderOrder = a.renderOrder);
				void 0 !== a.userData &&
					(g.userData = a.userData);
				void 0 !== a.layers && (g.layers.mask = a.layers);
				if (void 0 !== a.children) {
					k = a.children;
					for (var l = 0; l < k.length; l++) g.add(this.parseObject(k[l], b, c))
				}
				if ("LOD" === a.type)
					for (a = a.levels, k = 0; k < a.length; k++) {
						l = a[k];
						var m = g.getObjectByProperty("uuid", l.object);
						void 0 !== m && g.addLevel(m, l.distance)
					}
				return g
			}
		});
	var Rs = {
			UVMapping: 300,
			CubeReflectionMapping: 301,
			CubeRefractionMapping: 302,
			EquirectangularReflectionMapping: 303,
			EquirectangularRefractionMapping: 304,
			SphericalReflectionMapping: 305,
			CubeUVReflectionMapping: 306,
			CubeUVRefractionMapping: 307
		},
		Zo = {
			RepeatWrapping: 1E3,
			ClampToEdgeWrapping: 1001,
			MirroredRepeatWrapping: 1002
		},
		$o = {
			NearestFilter: 1003,
			NearestMipmapNearestFilter: 1004,
			NearestMipmapLinearFilter: 1005,
			LinearFilter: 1006,
			LinearMipmapNearestFilter: 1007,
			LinearMipmapLinearFilter: 1008
		};
	qn.prototype = q(p(sa.prototype), {
		constructor: qn,
		setOptions: function(a) {
			this.options = a;
			return this
		},
		load: function(a, b, c, d) {
			void 0 === a && (a = "");
			void 0 !== this.path && (a = this.path + a);
			a = this.manager.resolveURL(a);
			var e = this,
				g = Ke.get(a);
			if (void 0 !==
				g) return e.manager.itemStart(a), setTimeout(function() {
				b && b(g);
				e.manager.itemEnd(a)
			}, 0), g;
			fetch(a).then(function(a) {
				return a.blob()
			}).then(function(a) {
				return void 0 === e.options ? createImageBitmap(a) : createImageBitmap(a, e.options)
			}).then(function(c) {
				Ke.add(a, c);
				b && b(c);
				e.manager.itemEnd(a)
			}).catch(function(b) {
				d && d(b);
				e.manager.itemError(a);
				e.manager.itemEnd(a)
			});
			e.manager.itemStart(a)
		}
	});
	q(rn.prototype, {
		moveTo: function(a, b) {
			this.currentPath = new Ad;
			this.subPaths.push(this.currentPath);
			this.currentPath.moveTo(a,
				b)
		},
		lineTo: function(a, b) {
			this.currentPath.lineTo(a, b)
		},
		quadraticCurveTo: function(a, b, c, d) {
			this.currentPath.quadraticCurveTo(a, b, c, d)
		},
		bezierCurveTo: function(a, b, c, d, e, g) {
			this.currentPath.bezierCurveTo(a, b, c, d, e, g)
		},
		splineThru: function(a) {
			this.currentPath.splineThru(a)
		},
		toShapes: function(a, b) {
			function c(a) {
				for (var b = [], c = 0, d = a.length; c < d; c++) {
					var e = a[c],
						g = new lc;
					g.curves = e.curves;
					b.push(g)
				}
				return b
			}

			function d(a, b) {
				for (var c = b.length, d = !1, e = c - 1, g = 0; g < c; e = g++) {
					var k = b[e],
						l = b[g],
						m = l.x - k.x,
						n = l.y - k.y;
					if (Math.abs(n) >
						Na) {
						if (0 > n && (k = b[g], m = -m, l = b[e], n = -n), !(a.y < k.y || a.y > l.y))
							if (a.y === k.y) {
								if (a.x === k.x) return !0
							} else {
								e = n * (a.x - k.x) - m * (a.y - k.y);
								if (0 === e) return !0;
								0 > e || (d = !d)
							}
					} else if (a.y === k.y && (l.x <= a.x && a.x <= k.x || k.x <= a.x && a.x <= l.x)) return !0
				}
				return d
			}
			var e = Sb.isClockWise,
				g = this.subPaths;
			if (0 === g.length) return [];
			if (!0 === b) return c(g);
			b = [];
			if (1 === g.length) {
				var k = g[0];
				var l = new lc;
				l.curves = k.curves;
				b.push(l);
				return b
			}
			var m = !e(g[0].getPoints());
			m = a ? !m : m;
			l = [];
			var n = [],
				p = [],
				q = 0;
			n[q] = void 0;
			p[q] = [];
			for (var u = 0, w = g.length; u <
				w; u++) {
				k = g[u];
				var z = k.getPoints();
				var C = e(z);
				(C = a ? !C : C) ? (!m && n[q] && q++, n[q] = {
					s: new lc,
					p: z
				}, n[q].s.curves = k.curves, m && q++, p[q] = []) : p[q].push({
					h: k,
					p: z[0]
				})
			}
			if (!n[0]) return c(g);
			if (1 < n.length) {
				u = !1;
				a = [];
				e = 0;
				for (g = n.length; e < g; e++) l[e] = [];
				e = 0;
				for (g = n.length; e < g; e++)
					for (k = p[e], C = 0; C < k.length; C++) {
						m = k[C];
						q = !0;
						for (z = 0; z < n.length; z++) d(m.p, n[z].p) && (e !== z && a.push({
							froms: e,
							tos: z,
							hole: C
						}), q ? (q = !1, l[z].push(m)) : u = !0);
						q && l[e].push(m)
					}
				0 < a.length && (u || (p = l))
			}
			u = 0;
			for (e = n.length; u < e; u++)
				for (l = n[u].s, b.push(l), a =
					p[u], g = 0, k = a.length; g < k; g++) l.holes.push(a[g].h);
			return b
		}
	});
	q(sn.prototype, {
		isFont: !0,
		generateShapes: function(a, b) {
			void 0 === b && (b = 100);
			var c = [],
				d = b;
			b = this.data;
			var e = Ck ? Ck(a) : String(a).split("");
			d /= b.resolution;
			var g = (b.boundingBox.yMax - b.boundingBox.yMin + b.underlineThickness) * d;
			a = [];
			for (var k = 0, l = 0, m = 0; m < e.length; m++) {
				var n = e[m];
				if ("\n" === n) k = 0, l -= g;
				else {
					var p = n;
					n = d;
					var q = k,
						u = l,
						w = b,
						z = w.glyphs[p] || w.glyphs["?"];
					if (z) {
						p = new rn;
						if (z.o) {
							w = z._cachedOutline || (z._cachedOutline = z.o.split(" "));
							for (var C =
									0, D = w.length; C < D;) switch (w[C++]) {
								case "m":
									var B = w[C++] * n + q;
									var G = w[C++] * n + u;
									p.moveTo(B, G);
									break;
								case "l":
									B = w[C++] * n + q;
									G = w[C++] * n + u;
									p.lineTo(B, G);
									break;
								case "q":
									var F = w[C++] * n + q;
									var H = w[C++] * n + u;
									var J = w[C++] * n + q;
									var N = w[C++] * n + u;
									p.quadraticCurveTo(J, N, F, H);
									break;
								case "b":
									F = w[C++] * n + q, H = w[C++] * n + u, J = w[C++] * n + q, N = w[C++] * n + u, B = w[C++] * n + q, G = w[
										C++] * n + u, p.bezierCurveTo(J, N, B, G, F, H)
							}
						}
						n = {
							offsetX: z.ha * n,
							path: p
						}
					} else console.error('THREE.Font: character "' + p + '" does not exists in font family ' + w.familyName +
						"."), n = void 0;
					k += n.offsetX;
					a.push(n.path)
				}
			}
			b = 0;
			for (e = a.length; b < e; b++) Array.prototype.push.apply(c, a[b].toShapes());
			return c
		}
	});
	tn.prototype = q(p(sa.prototype), {
		constructor: tn,
		load: function(a, b, c, d) {
			var e = this,
				g = new Jc(this.manager);
			g.setPath(this.path);
			g.load(a, function(a) {
				try {
					var c = JSON.parse(a)
				} catch (m) {
					console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), c =
						JSON.parse(a.substring(65, a.length - 2))
				}
				a = e.parse(c);
				b && b(a)
			}, c, d)
		},
		parse: function(a) {
			return new sn(a)
		}
	});
	var wg, xn = {
		getContext: function() {
			void 0 === wg && (wg = new(window.AudioContext || window.webkitAudioContext));
			return wg
		},
		setContext: function(a) {
			wg = a
		}
	};
	dl.prototype = q(p(sa.prototype), {
		constructor: dl,
		load: function(a, b, c, d) {
			var e = new Jc(this.manager);
			e.setResponseType("arraybuffer");
			e.setPath(this.path);
			e.load(a, function(a) {
				a = a.slice(0);
				xn.getContext().decodeAudioData(a, function(a) {
					b(a)
				})
			}, c, d)
		}
	});
	q(el.prototype, {
		isSphericalHarmonics3: !0,
		set: function(a) {
			for (var b = 0; 9 > b; b++) this.coefficients[b].copy(a[b]);
			return this
		},
		zero: function() {
			for (var a = 0; 9 > a; a++) this.coefficients[a].set(0, 0, 0);
			return this
		},
		getAt: function(a, b) {
			var c = a.x,
				d = a.y;
			a = a.z;
			var e = this.coefficients;
			b.copy(e[0]).multiplyScalar(.282095);
			b.addScale(e[1], .488603 * d);
			b.addScale(e[2], .488603 * a);
			b.addScale(e[3], .488603 * c);
			b.addScale(e[4], 1.092548 * c * d);
			b.addScale(e[5], 1.092548 * d * a);
			b.addScale(e[6], .315392 * (3 * a * a - 1));
			b.addScale(e[7], 1.092548 * c * a);
			b.addScale(e[8], .546274 * (c * c - d * d));
			return b
		},
		getIrradianceAt: function(a, b) {
			var c = a.x,
				d = a.y;
			a = a.z;
			var e =
				this.coefficients;
			b.copy(e[0]).multiplyScalar(.886227);
			b.addScale(e[1], 1.023328 * d);
			b.addScale(e[2], 1.023328 * a);
			b.addScale(e[3], 1.023328 * c);
			b.addScale(e[4], .858086 * c * d);
			b.addScale(e[5], .858086 * d * a);
			b.addScale(e[6], .743125 * a * a - .247708);
			b.addScale(e[7], .858086 * c * a);
			b.addScale(e[8], .429043 * (c * c - d * d));
			return b
		},
		add: function(a) {
			for (var b = 0; 9 > b; b++) this.coefficients[b].add(a.coefficients[b]);
			return this
		},
		scale: function(a) {
			for (var b = 0; 9 > b; b++) this.coefficients[b].multiplyScalar(a);
			return this
		},
		lerp: function(a,
			b) {
			for (var c = 0; 9 > c; c++) this.coefficients[c].lerp(a.coefficients[c], b);
			return this
		},
		equals: function(a) {
			for (var b = 0; 9 > b; b++)
				if (!this.coefficients[b].equals(a.coefficients[b])) return !1;
			return !0
		},
		copy: function(a) {
			return this.set(a.coefficients)
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		fromArray: function(a, b) {
			void 0 === b && (b = 0);
			for (var c = this.coefficients, d = 0; 9 > d; d++) c[d].fromArray(a, b + 3 * d);
			return this
		},
		toArray: function(a, b) {
			void 0 === a && (a = []);
			void 0 === b && (b = 0);
			for (var c = this.coefficients,
					d = 0; 9 > d; d++) c[d].toArray(a, b + 3 * d);
			return a
		}
	});
	q(el, {
		getBasisAt: function(a, b) {
			var c = a.x,
				d = a.y;
			a = a.z;
			b[0] = .282095;
			b[1] = .488603 * d;
			b[2] = .488603 * a;
			b[3] = .488603 * c;
			b[4] = 1.092548 * c * d;
			b[5] = 1.092548 * d * a;
			b[6] = .315392 * (3 * a * a - 1);
			b[7] = 1.092548 * c * a;
			b[8] = .546274 * (c * c - d * d)
		}
	});
	Bd.prototype = q(p(Ba.prototype), {
		constructor: Bd,
		isLightProbe: !0,
		copy: function(a) {
			Ba.prototype.copy.call(this, a);
			this.sh.copy(a.sh);
			this.intensity = a.intensity;
			return this
		},
		toJSON: function(a) {
			return Ba.prototype.toJSON.call(this, a)
		}
	});
	un.prototype =
		q(p(Bd.prototype), {
			constructor: un,
			isHemisphereLightProbe: !0,
			copy: function(a) {
				Bd.prototype.copy.call(this, a);
				return this
			},
			toJSON: function(a) {
				return Bd.prototype.toJSON.call(this, a)
			}
		});
	vn.prototype = q(p(Bd.prototype), {
		constructor: vn,
		isAmbientLightProbe: !0,
		copy: function(a) {
			Bd.prototype.copy.call(this, a);
			return this
		},
		toJSON: function(a) {
			return Bd.prototype.toJSON.call(this, a)
		}
	});
	var ap = new ua,
		bp = new ua;
	q(function() {
		this.type = "StereoCamera";
		this.aspect = 1;
		this.eyeSep = .064;
		this.cameraL = new ab;
		this.cameraL.layers.enable(1);
		this.cameraL.matrixAutoUpdate = !1;
		this.cameraR = new ab;
		this.cameraR.layers.enable(2);
		this.cameraR.matrixAutoUpdate = !1;
		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		}
	}.prototype, {
		update: function(a) {
			var b = this._cache;
			if (b.focus !== a.focus || b.fov !== a.fov || b.aspect !== a.aspect * this.aspect || b.near !== a.near || b.far !==
				a.far || b.zoom !== a.zoom || b.eyeSep !== this.eyeSep) {
				b.focus = a.focus;
				b.fov = a.fov;
				b.aspect = a.aspect * this.aspect;
				b.near = a.near;
				b.far = a.far;
				b.zoom = a.zoom;
				b.eyeSep =
					this.eyeSep;
				var c = a.projectionMatrix.clone(),
					d = b.eyeSep / 2,
					e = d * b.near / b.focus,
					g = b.near * Math.tan(ha.DEG2RAD * b.fov * .5) / b.zoom;
				bp.elements[12] = -d;
				ap.elements[12] = d;
				d = -g * b.aspect + e;
				var k = g * b.aspect + e;
				c.elements[0] = 2 * b.near / (k - d);
				c.elements[8] = (k + d) / (k - d);
				this.cameraL.projectionMatrix.copy(c);
				d = -g * b.aspect - e;
				k = g * b.aspect - e;
				c.elements[0] = 2 * b.near / (k - d);
				c.elements[8] = (k + d) / (k - d);
				this.cameraR.projectionMatrix.copy(c)
			}
			this.cameraL.matrixWorld.copy(a.matrixWorld).multiply(bp);
			this.cameraR.matrixWorld.copy(a.matrixWorld).multiply(ap)
		}
	});
	q(fl.prototype, {
		start: function() {
			this.oldTime = this.startTime = ("undefined" === typeof performance ? Date : performance).now();
			this.elapsedTime = 0;
			this.running = !0
		},
		stop: function() {
			this.getElapsedTime();
			this.autoStart = this.running = !1
		},
		getElapsedTime: function() {
			this.getDelta();
			return this.elapsedTime
		},
		getDelta: function() {
			var a = 0;
			if (this.autoStart && !this.running) return this.start(), 0;
			if (this.running) {
				var b = ("undefined" === typeof performance ? Date : performance).now();
				a = (b - this.oldTime) / 1E3;
				this.oldTime = b;
				this.elapsedTime +=
					a
			}
			return a
		}
	});
	var cc = new u,
		cp = new vb,
		Ss = new u,
		jd = new u;
	wn.prototype = q(p(P.prototype), {
		constructor: wn,
		getInput: function() {
			return this.gain
		},
		removeFilter: function() {
			null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination),
				this.gain.connect(this.context.destination), this.filter = null);
			return this
		},
		getFilter: function() {
			return this.filter
		},
		setFilter: function(a) {
			null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) :
				this.gain.disconnect(this.context.destination);
			this.filter = a;
			this.gain.connect(this.filter);
			this.filter.connect(this.context.destination);
			return this
		},
		getMasterVolume: function() {
			return this.gain.gain.value
		},
		setMasterVolume: function(a) {
			this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
			return this
		},
		updateMatrixWorld: function(a) {
			P.prototype.updateMatrixWorld.call(this, a);
			a = this.context.listener;
			var b = this.up;
			this.timeDelta = this._clock.getDelta();
			this.matrixWorld.decompose(cc, cp, Ss);
			jd.set(0,
				0, -1).applyQuaternion(cp);
			if (a.positionX) {
				var c = this.context.currentTime + this.timeDelta;
				a.positionX.linearRampToValueAtTime(cc.x, c);
				a.positionY.linearRampToValueAtTime(cc.y, c);
				a.positionZ.linearRampToValueAtTime(cc.z, c);
				a.forwardX.linearRampToValueAtTime(jd.x, c);
				a.forwardY.linearRampToValueAtTime(jd.y, c);
				a.forwardZ.linearRampToValueAtTime(jd.z, c);
				a.upX.linearRampToValueAtTime(b.x, c);
				a.upY.linearRampToValueAtTime(b.y, c);
				a.upZ.linearRampToValueAtTime(b.z, c)
			} else a.setPosition(cc.x, cc.y, cc.z), a.setOrientation(jd.x,
				jd.y, jd.z, b.x, b.y, b.z)
		}
	});
	Tf.prototype = q(p(P.prototype), {
		constructor: Tf,
		getOutput: function() {
			return this.gain
		},
		setNodeSource: function(a) {
			this.hasPlaybackControl = !1;
			this.sourceType = "audioNode";
			this.source = a;
			this.connect();
			return this
		},
		setMediaElementSource: function(a) {
			this.hasPlaybackControl = !1;
			this.sourceType = "mediaNode";
			this.source = this.context.createMediaElementSource(a);
			this.connect();
			return this
		},
		setMediaStreamSource: function(a) {
			this.hasPlaybackControl = !1;
			this.sourceType = "mediaStreamNode";
			this.source =
				this.context.createMediaStreamSource(a);
			this.connect();
			return this
		},
		setBuffer: function(a) {
			this.buffer = a;
			this.sourceType = "buffer";
			this.autoplay && this.play();
			return this
		},
		play: function() {
			if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
			else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
			else {
				var a = this.context.createBufferSource();
				a.buffer = this.buffer;
				a.loop = this.loop;
				a.onended = this.onEnded.bind(this);
				this.startTime = this.context.currentTime;
				a.start(this.startTime, this.offset, this.duration);
				this.isPlaying = !0;
				this.source = a;
				this.setDetune(this.detune);
				this.setPlaybackRate(this.playbackRate);
				return this.connect()
			}
		},
		pause: function() {
			if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
			else return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context
				.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this
		},
		stop: function() {
			if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
			else return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this
		},
		connect: function() {
			if (0 < this.filters.length) {
				this.source.connect(this.filters[0]);
				for (var a = 1, b = this.filters.length; a < b; a++) this.filters[a - 1].connect(this.filters[a]);
				this.filters[this.filters.length - 1].connect(this.getOutput())
			} else this.source.connect(this.getOutput());
			return this
		},
		disconnect: function() {
			if (0 < this.filters.length) {
				this.source.disconnect(this.filters[0]);
				for (var a = 1, b = this.filters.length; a <
					b; a++) this.filters[a - 1].disconnect(this.filters[a]);
				this.filters[this.filters.length - 1].disconnect(this.getOutput())
			} else this.source.disconnect(this.getOutput());
			return this
		},
		getFilters: function() {
			return this.filters
		},
		setFilters: function(a) {
			a || (a = []);
			!0 === this.isPlaying ? (this.disconnect(), this.filters = a, this.connect()) : this.filters = a;
			return this
		},
		setDetune: function(a) {
			this.detune = a;
			if (void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune,
				this.context.currentTime,
				.01), this
		},
		getDetune: function() {
			return this.detune
		},
		getFilter: function() {
			return this.getFilters()[0]
		},
		setFilter: function(a) {
			return this.setFilters(a ? [a] : [])
		},
		setPlaybackRate: function(a) {
			if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
			else return this.playbackRate = a, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate,
				this.context.currentTime, .01), this
		},
		getPlaybackRate: function() {
			return this.playbackRate
		},
		onEnded: function() {
			this.isPlaying = !1
		},
		getLoop: function() {
			return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) :
				this.loop
		},
		setLoop: function(a) {
			if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
			else return this.loop = a, !0 === this.isPlaying && (this.source.loop = this.loop), this
		},
		getVolume: function() {
			return this.gain.gain.value
		},
		setVolume: function(a) {
			this.gain.gain.setTargetAtTime(a, this.context.currentTime, .01);
			return this
		}
	});
	var wc = new u,
		dp =
		new vb,
		Ts = new u,
		kd = new u;
	yn.prototype = q(p(Tf.prototype), {
		constructor: yn,
		getOutput: function() {
			return this.panner
		},
		getRefDistance: function() {
			return this.panner.refDistance
		},
		setRefDistance: function(a) {
			this.panner.refDistance = a;
			return this
		},
		getRolloffFactor: function() {
			return this.panner.rolloffFactor
		},
		setRolloffFactor: function(a) {
			this.panner.rolloffFactor = a;
			return this
		},
		getDistanceModel: function() {
			return this.panner.distanceModel
		},
		setDistanceModel: function(a) {
			this.panner.distanceModel = a;
			return this
		},
		getMaxDistance: function() {
			return this.panner.maxDistance
		},
		setMaxDistance: function(a) {
			this.panner.maxDistance = a;
			return this
		},
		setDirectionalCone: function(a, b, c) {
			this.panner.coneInnerAngle = a;
			this.panner.coneOuterAngle = b;
			this.panner.coneOuterGain = c;
			return this
		},
		updateMatrixWorld: function(a) {
			P.prototype.updateMatrixWorld.call(this, a);
			if (!0 !== this.hasPlaybackControl || !1 !== this.isPlaying)
				if (this.matrixWorld.decompose(wc, dp, Ts), kd.set(0, 0, 1).applyQuaternion(dp), a = this.panner, a.positionX) {
					var b = this.context.currentTime +
						this.listener.timeDelta;
					a.positionX.linearRampToValueAtTime(wc.x, b);
					a.positionY.linearRampToValueAtTime(wc.y, b);
					a.positionZ.linearRampToValueAtTime(wc.z, b);
					a.orientationX.linearRampToValueAtTime(kd.x, b);
					a.orientationY.linearRampToValueAtTime(kd.y, b);
					a.orientationZ.linearRampToValueAtTime(kd.z, b)
				} else a.setPosition(wc.x, wc.y, wc.z), a.setOrientation(kd.x, kd.y, kd.z)
		}
	});
	q(zn.prototype, {
		getFrequencyData: function() {
			this.analyser.getByteFrequencyData(this.data);
			return this.data
		},
		getAverageFrequency: function() {
			for (var a =
					0, b = this.getFrequencyData(), c = 0; c < b.length; c++) a += b[c];
			return a / b.length
		}
	});
	q(An.prototype, {
		accumulate: function(a, b) {
			var c = this.buffer,
				d = this.valueSize;
			a = a * d + d;
			var e = this.cumulativeWeight;
			if (0 === e) {
				for (e = 0; e !== d; ++e) c[a + e] = c[e];
				e = b
			} else e += b, this._mixBufferRegion(c, a, 0, b / e, d);
			this.cumulativeWeight = e
		},
		apply: function(a) {
			var b = this.valueSize,
				c = this.buffer;
			a = a * b + b;
			var d = this.cumulativeWeight,
				e = this.binding;
			this.cumulativeWeight = 0;
			1 > d && this._mixBufferRegion(c, a, 3 * b, 1 - d, b);
			d = b;
			for (var g = b + b; d !== g; ++d)
				if (c[d] !==
					c[d + b]) {
					e.setValue(c, a);
					break
				}
		},
		saveOriginalState: function() {
			var a = this.buffer,
				b = this.valueSize,
				c = 3 * b;
			this.binding.getValue(a, c);
			for (var d = b; d !== c; ++d) a[d] = a[c + d % b];
			this.cumulativeWeight = 0
		},
		restoreOriginalState: function() {
			this.binding.setValue(this.buffer, 3 * this.valueSize)
		},
		_select: function(a, b, c, d, e) {
			if (.5 <= d)
				for (d = 0; d !== e; ++d) a[b + d] = a[c + d]
		},
		_slerp: function(a, b, c, d) {
			vb.slerpFlat(a, b, a, b, a, c, d)
		},
		_lerp: function(a, b, c, d, e) {
			for (var g = 1 - d, k = 0; k !== e; ++k) {
				var l = b + k;
				a[l] = a[l] * g + a[c + k] * d
			}
		}
	});
	var Us = /[\[\]\.:\/]/g,
		Vs = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
		Ws = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
		Xs = /(WCOD+)?/.source.replace("WCOD", Vs),
		Ys = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
		Zs = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
		$s = new RegExp("^" + Ws + Xs + Ys + Zs + "$"),
		at = ["material", "materials", "bones"];
	q(Bn.prototype, {
		getValue: function(a, b) {
			this.bind();
			var c = this._bindings[this._targetGroup.nCachedObjects_];
			void 0 !== c && c.getValue(a, b)
		},
		setValue: function(a,
			b) {
			for (var c = this._bindings, d = this._targetGroup.nCachedObjects_, e = c.length; d !== e; ++d) c[d].setValue(a,
				b)
		},
		bind: function() {
			for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].bind()
		},
		unbind: function() {
			for (var a = this._bindings, b = this._targetGroup.nCachedObjects_, c = a.length; b !== c; ++b) a[b].unbind()
		}
	});
	q(xb, {
		Composite: Bn,
		create: function(a, b, c) {
			return a && a.isAnimationObjectGroup ? new xb.Composite(a, b, c) : new xb(a, b, c)
		},
		sanitizeNodeName: function(a) {
			return a.replace(/\s/g,
				"_").replace(Us, "")
		},
		parseTrackName: function(a) {
			var b = $s.exec(a);
			if (!b) throw Error("PropertyBinding: Cannot parse trackName: " + a);
			b = {
				nodeName: b[2],
				objectName: b[3],
				objectIndex: b[4],
				propertyName: b[5],
				propertyIndex: b[6]
			};
			var c = b.nodeName && b.nodeName.lastIndexOf(".");
			if (void 0 !== c && -1 !== c) {
				var d = b.nodeName.substring(c + 1); - 1 !== at.indexOf(d) && (b.nodeName = b.nodeName.substring(0, c), b.objectName =
					d)
			}
			if (null === b.propertyName || 0 === b.propertyName.length) throw Error(
				"PropertyBinding: can not parse propertyName from trackName: " +
				a);
			return b
		},
		findNode: function(a, b) {
			if (!b || "" === b || "root" === b || "." === b || -1 === b || b === a.name || b === a.uuid) return a;
			if (a.skeleton) {
				var c = a.skeleton.getBoneByName(b);
				if (void 0 !== c) return c
			}
			return a.children && (a = function g(a) {
				for (var c = 0; c < a.length; c++) {
					var e = a[c];
					if (e.name === b || e.uuid === b || (e = g(e.children))) return e
				}
				return null
			}(a.children)) ? a : null
		}
	});
	q(xb.prototype, {
		_getValue_unavailable: function() {},
		_setValue_unavailable: function() {},
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
		GetterByBindingType: [function(a, b) {
			a[b] = this.node[this.propertyName]
		}, function(a, b) {
			for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) a[b++] = c[d]
		}, function(a, b) {
			a[b] = this.resolvedProperty[this.propertyIndex]
		}, function(a, b) {
			this.resolvedProperty.toArray(a, b)
		}],
		SetterByBindingTypeAndVersioning: [
			[function(a, b) {
				this.targetObject[this.propertyName] = a[b]
			}, function(a, b) {
				this.targetObject[this.propertyName] = a[b];
				this.targetObject.needsUpdate = !0
			}, function(a, b) {
				this.targetObject[this.propertyName] = a[b];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}],
			[function(a, b) {
				for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++]
			}, function(a, b) {
				for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
				this.targetObject.needsUpdate = !0
			}, function(a, b) {
				for (var c = this.resolvedProperty, d = 0, e = c.length; d !== e; ++d) c[d] = a[b++];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}],
			[function(a, b) {
				this.resolvedProperty[this.propertyIndex] = a[b]
			}, function(a,
				b) {
				this.resolvedProperty[this.propertyIndex] = a[b];
				this.targetObject.needsUpdate = !0
			}, function(a, b) {
				this.resolvedProperty[this.propertyIndex] = a[b];
				this.targetObject.matrixWorldNeedsUpdate = !0
			}],
			[function(a, b) {
				this.resolvedProperty.fromArray(a, b)
			}, function(a, b) {
				this.resolvedProperty.fromArray(a, b);
				this.targetObject.needsUpdate = !0
			}, function(a, b) {
				this.resolvedProperty.fromArray(a, b);
				this.targetObject.matrixWorldNeedsUpdate = !0
			}]
		],
		getValue: function(a, b) {
			this.bind();
			this.getValue(a, b)
		},
		setValue: function(a,
			b) {
			this.bind();
			this.setValue(a, b)
		},
		bind: function() {
			var a = this.node,
				b = this.parsedPath,
				c = b.objectName,
				d = b.propertyName,
				e = b.propertyIndex;
			a || (this.node = a = xb.findNode(this.rootNode, b.nodeName) || this.rootNode);
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
			if (a) {
				if (c) {
					var g = b.objectIndex;
					switch (c) {
						case "materials":
							if (!a.material) {
								console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								return
							}
							if (!a.material.materials) {
								console.error(
									"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
									this);
								return
							}
							a = a.material.materials;
							break;
						case "bones":
							if (!a.skeleton) {
								console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
								return
							}
							a = a.skeleton.bones;
							for (c = 0; c < a.length; c++)
								if (a[c].name === g) {
									g = c;
									break
								} break;
						default:
							if (void 0 === a[c]) {
								console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
								return
							}
							a = a[c]
					}
					if (void 0 !== g) {
						if (void 0 === a[g]) {
							console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
								this, a);
							return
						}
						a = a[g]
					}
				}
				g = a[d];
				if (void 0 === g) console.error("THREE.PropertyBinding: Trying to update property for track: " + b.nodeName +
					"." + d + " but it wasn't found.", a);
				else {
					b = this.Versioning.None;
					this.targetObject = a;
					void 0 !== a.needsUpdate ? b = this.Versioning.NeedsUpdate : void 0 !== a.matrixWorldNeedsUpdate && (b = this.Versioning
						.MatrixWorldNeedsUpdate);
					c = this.BindingType.Direct;
					if (void 0 !== e) {
						if ("morphTargetInfluences" === d) {
							if (!a.geometry) {
								console.error(
									"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
									this);
								return
							}
							if (a.geometry.isBufferGeometry) {
								if (!a.geometry.morphAttributes) {
									console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
										this);
									return
								}
								for (c = 0; c < this.node.geometry.morphAttributes.position.length; c++)
									if (a.geometry.morphAttributes.position[c].name === e) {
										e = c;
										break
									}
							} else {
								if (!a.geometry.morphTargets) {
									console.error(
										"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.",
										this);
									return
								}
								for (c = 0; c < this.node.geometry.morphTargets.length; c++)
									if (a.geometry.morphTargets[c].name === e) {
										e = c;
										break
									}
							}
						}
						c = this.BindingType.ArrayElement;
						this.resolvedProperty = g;
						this.propertyIndex = e
					} else void 0 !== g.fromArray && void 0 !== g.toArray ? (c = this.BindingType.HasFromToArray, this.resolvedProperty =
							g) : Array.isArray(g) ? (c = this.BindingType.EntireArray, this.resolvedProperty = g) : this.propertyName =
						d;
					this.getValue = this.GetterByBindingType[c];
					this.setValue = this.SetterByBindingTypeAndVersioning[c][b]
				}
			} else console.error("THREE.PropertyBinding: Trying to update node for track: " +
				this.path + " but it wasn't found.")
		},
		unbind: function() {
			this.node = null;
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound
		}
	});
	q(xb.prototype, {
		_getValue_unbound: xb.prototype.getValue,
		_setValue_unbound: xb.prototype.setValue
	});
	q(function() {
		this.uuid = ha.generateUUID();
		this._objects = Array.prototype.slice.call(arguments);
		this.nCachedObjects_ = 0;
		var a = {};
		this._indicesByUUID = a;
		for (var b = 0, c = arguments.length; b !== c; ++b) a[arguments[b].uuid] = b;
		this._paths = [];
		this._parsedPaths = [];
		this._bindings = [];
		this._bindingsIndicesByPath = {};
		var d = this;
		this.stats = {
			objects: {
				get total() {
					return d._objects.length
				},
				get inUse() {
					return this.total - d.nCachedObjects_
				}
			},
			get bindingsPerObject() {
				return d._bindings.length
			}
		}
	}.prototype, {
		isAnimationObjectGroup: !0,
		add: function() {
			for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._paths, g =
					this._parsedPaths, k = this._bindings, l = k.length, m = void 0, n = 0, p = arguments.length; n !== p; ++n) {
				var q = arguments[n],
					u = q.uuid,
					w = d[u];
				if (void 0 === w) {
					w = b++;
					d[u] =
						w;
					a.push(q);
					u = 0;
					for (var z = l; u !== z; ++u) k[u].push(new xb(q, e[u], g[u]))
				} else if (w < c) {
					m = a[w];
					var C = --c;
					z = a[C];
					d[z.uuid] = w;
					a[w] = z;
					d[u] = C;
					a[C] = q;
					u = 0;
					for (z = l; u !== z; ++u) {
						var D = k[u],
							B = D[w];
						D[w] = D[C];
						void 0 === B && (B = new xb(q, e[u], g[u]));
						D[C] = B
					}
				} else a[w] !== m && console.error(
					"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes."
				)
			}
			this.nCachedObjects_ = c
		},
		remove: function() {
			for (var a = this._objects, b = this.nCachedObjects_,
					c = this._indicesByUUID, d = this._bindings, e = d.length, g = 0, k = arguments.length; g !== k; ++g) {
				var l = arguments[g],
					m = l.uuid,
					n = c[m];
				if (void 0 !== n && n >= b) {
					var p = b++,
						q = a[p];
					c[q.uuid] = n;
					a[n] = q;
					c[m] = p;
					a[p] = l;
					l = 0;
					for (m = e; l !== m; ++l) {
						q = d[l];
						var u = q[n];
						q[n] = q[p];
						q[p] = u
					}
				}
			}
			this.nCachedObjects_ = b
		},
		uncache: function() {
			for (var a = this._objects, b = a.length, c = this.nCachedObjects_, d = this._indicesByUUID, e = this._bindings,
					g = e.length, k = 0, l = arguments.length; k !== l; ++k) {
				var m = arguments[k].uuid,
					n = d[m];
				if (void 0 !== n)
					if (delete d[m], n < c) {
						m =
							--c;
						var p = a[m],
							q = --b,
							u = a[q];
						d[p.uuid] = n;
						a[n] = p;
						d[u.uuid] = m;
						a[m] = u;
						a.pop();
						p = 0;
						for (u = g; p !== u; ++p) {
							var w = e[p],
								z = w[q];
							w[n] = w[m];
							w[m] = z;
							w.pop()
						}
					} else
						for (q = --b, u = a[q], d[u.uuid] = n, a[n] = u, a.pop(), p = 0, u = g; p !== u; ++p) w = e[p], w[n] = w[q],
							w.pop()
			}
			this.nCachedObjects_ = c
		},
		subscribe_: function(a, b) {
			var c = this._bindingsIndicesByPath,
				d = c[a],
				e = this._bindings;
			if (void 0 !== d) return e[d];
			var g = this._paths,
				k = this._parsedPaths,
				l = this._objects,
				m = this.nCachedObjects_,
				n = Array(l.length);
			d = e.length;
			c[a] = d;
			g.push(a);
			k.push(b);
			e.push(n);
			c = m;
			for (d = l.length; c !== d; ++c) n[c] = new xb(l[c], a, b);
			return n
		},
		unsubscribe_: function(a) {
			var b = this._bindingsIndicesByPath,
				c = b[a];
			if (void 0 !== c) {
				var d = this._paths,
					e = this._parsedPaths,
					g = this._bindings,
					k = g.length - 1,
					l = g[k];
				b[a[k]] = c;
				g[c] = l;
				g.pop();
				e[c] = e[k];
				e.pop();
				d[c] = d[k];
				d.pop()
			}
		}
	});
	q(Cn.prototype, {
		play: function() {
			this._mixer._activateAction(this);
			return this
		},
		stop: function() {
			this._mixer._deactivateAction(this);
			return this.reset()
		},
		reset: function() {
			this.paused = !1;
			this.enabled = !0;
			this.time = 0;
			this._loopCount = -1;
			this._startTime = null;
			return this.stopFading().stopWarping()
		},
		isRunning: function() {
			return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(
				this)
		},
		isScheduled: function() {
			return this._mixer._isActiveAction(this)
		},
		startAt: function(a) {
			this._startTime = a;
			return this
		},
		setLoop: function(a, b) {
			this.loop = a;
			this.repetitions = b;
			return this
		},
		setEffectiveWeight: function(a) {
			this.weight = a;
			this._effectiveWeight = this.enabled ? a : 0;
			return this.stopFading()
		},
		getEffectiveWeight: function() {
			return this._effectiveWeight
		},
		fadeIn: function(a) {
			return this._scheduleFading(a, 0, 1)
		},
		fadeOut: function(a) {
			return this._scheduleFading(a, 1, 0)
		},
		crossFadeFrom: function(a, b, c) {
			a.fadeOut(b);
			this.fadeIn(b);
			if (c) {
				c = this._clip.duration;
				var d = a._clip.duration,
					e = c / d;
				a.warp(1, d / c, b);
				this.warp(e, 1, b)
			}
			return this
		},
		crossFadeTo: function(a, b, c) {
			return a.crossFadeFrom(this, b, c)
		},
		stopFading: function() {
			var a = this._weightInterpolant;
			null !== a && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(a));
			return this
		},
		setEffectiveTimeScale: function(a) {
			this.timeScale =
				a;
			this._effectiveTimeScale = this.paused ? 0 : a;
			return this.stopWarping()
		},
		getEffectiveTimeScale: function() {
			return this._effectiveTimeScale
		},
		setDuration: function(a) {
			this.timeScale = this._clip.duration / a;
			return this.stopWarping()
		},
		syncWith: function(a) {
			this.time = a.time;
			this.timeScale = a.timeScale;
			return this.stopWarping()
		},
		halt: function(a) {
			return this.warp(this._effectiveTimeScale, 0, a)
		},
		warp: function(a, b, c) {
			var d = this._mixer,
				e = d.time,
				g = this._timeScaleInterpolant,
				k = this.timeScale;
			null === g && (this._timeScaleInterpolant =
				g = d._lendControlInterpolant());
			d = g.parameterPositions;
			g = g.sampleValues;
			d[0] = e;
			d[1] = e + c;
			g[0] = a / k;
			g[1] = b / k;
			return this
		},
		stopWarping: function() {
			var a = this._timeScaleInterpolant;
			null !== a && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(a));
			return this
		},
		getMixer: function() {
			return this._mixer
		},
		getClip: function() {
			return this._clip
		},
		getRoot: function() {
			return this._localRoot || this._mixer._root
		},
		_update: function(a, b, c, d) {
			if (this.enabled) {
				var e = this._startTime;
				if (null !== e) {
					b = (a - e) * c;
					if (0 > b || 0 === c) return;
					this._startTime = null;
					b *= c
				}
				b *= this._updateTimeScale(a);
				c = this._updateTime(b);
				a = this._updateWeight(a);
				if (0 < a) {
					b = this._interpolants;
					e = this._propertyBindings;
					for (var g = 0, k = b.length; g !== k; ++g) b[g].evaluate(c), e[g].accumulate(d, a)
				}
			} else this._updateWeight(a)
		},
		_updateWeight: function(a) {
			var b = 0;
			if (this.enabled) {
				b = this.weight;
				var c = this._weightInterpolant;
				if (null !== c) {
					var d = c.evaluate(a)[0];
					b *= d;
					a > c.parameterPositions[1] && (this.stopFading(), 0 === d && (this.enabled = !1))
				}
			}
			return this._effectiveWeight =
				b
		},
		_updateTimeScale: function(a) {
			var b = 0;
			if (!this.paused) {
				b = this.timeScale;
				var c = this._timeScaleInterpolant;
				if (null !== c) {
					var d = c.evaluate(a)[0];
					b *= d;
					a > c.parameterPositions[1] && (this.stopWarping(), 0 === b ? this.paused = !0 : this.timeScale = b)
				}
			}
			return this._effectiveTimeScale = b
		},
		_updateTime: function(a) {
			var b = this.time + a,
				c = this._clip.duration,
				d = this.loop,
				e = this._loopCount,
				g = 2202 === d;
			if (0 === a) return -1 === e ? b : g && 1 === (e & 1) ? c - b : b;
			if (2200 === d) a: {
				if (-1 === e && (this._loopCount = 0, this._setEndings(!0, !0, !1)), b >= c) b = c;
				else if (0 >
					b) b = 0;
				else {
					this.time = b;
					break a
				}
				this.clampWhenFinished ? this.paused = !0 : this.enabled = !1;this.time = b;this._mixer.dispatchEvent({
					type: "finished",
					action: this,
					direction: 0 > a ? -1 : 1
				})
			}
			else {
				-1 === e && (0 <= a ? (e = 0, this._setEndings(!0, 0 === this.repetitions, g)) : this._setEndings(0 === this.repetitions,
					!0, g));
				if (b >= c || 0 > b) {
					d = Math.floor(b / c);
					b -= c * d;
					e += Math.abs(d);
					var k = this.repetitions - e;
					0 >= k ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = b = 0 < a ? c : 0, this._mixer
						.dispatchEvent({
							type: "finished",
							action: this,
							direction: 0 < a ? 1 : -1
						})) : (1 === k ? (a = 0 > a, this._setEndings(a, !a, g)) : this._setEndings(!1, !1, g), this._loopCount = e,
						this.time = b, this._mixer.dispatchEvent({
							type: "loop",
							action: this,
							loopDelta: d
						}))
				} else this.time = b;
				if (g && 1 === (e & 1)) return c - b
			}
			return b
		},
		_setEndings: function(a, b, c) {
			var d = this._interpolantSettings;
			c ? (d.endingStart = 2401, d.endingEnd = 2401) : (d.endingStart = a ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402,
				d.endingEnd = b ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
		},
		_scheduleFading: function(a, b, c) {
			var d = this._mixer,
				e = d.time,
				g = this._weightInterpolant;
			null === g && (this._weightInterpolant = g = d._lendControlInterpolant());
			d = g.parameterPositions;
			g = g.sampleValues;
			d[0] = e;
			g[0] = b;
			d[1] = e + a;
			g[1] = c;
			return this
		}
	});
	Dn.prototype = q(p(nb.prototype), {
		constructor: Dn,
		_bindAction: function(a, b) {
			var c = a._localRoot || this._root,
				d = a._clip.tracks,
				e = d.length,
				g = a._propertyBindings;
			a = a._interpolants;
			var k = c.uuid,
				l = this._bindingsByRootAndName,
				m = l[k];
			void 0 === m && (m = {}, l[k] = m);
			for (l = 0; l !== e; ++l) {
				var n = d[l],
					p = n.name,
					q = m[p];
				if (void 0 === q) {
					q = g[l];
					if (void 0 !==
						q) {
						null === q._cacheIndex && (++q.referenceCount, this._addInactiveBinding(q, k, p));
						continue
					}
					q = new An(xb.create(c, p, b && b._propertyBindings[l].binding.parsedPath), n.ValueTypeName, n.getValueSize());
					++q.referenceCount;
					this._addInactiveBinding(q, k, p)
				}
				g[l] = q;
				a[l].resultBuffer = q.buffer
			}
		},
		_activateAction: function(a) {
			if (!this._isActiveAction(a)) {
				if (null === a._cacheIndex) {
					var b = (a._localRoot || this._root).uuid,
						c = a._clip.uuid,
						d = this._actionsByClip[c];
					this._bindAction(a, d && d.knownActions[0]);
					this._addInactiveAction(a,
						c, b)
				}
				b = a._propertyBindings;
				c = 0;
				for (d = b.length; c !== d; ++c) {
					var e = b[c];
					0 === e.useCount++ && (this._lendBinding(e), e.saveOriginalState())
				}
				this._lendAction(a)
			}
		},
		_deactivateAction: function(a) {
			if (this._isActiveAction(a)) {
				for (var b = a._propertyBindings, c = 0, d = b.length; c !== d; ++c) {
					var e = b[c];
					0 === --e.useCount && (e.restoreOriginalState(), this._takeBackBinding(e))
				}
				this._takeBackAction(a)
			}
		},
		_initMemoryManager: function() {
			this._actions = [];
			this._nActiveActions = 0;
			this._actionsByClip = {};
			this._bindings = [];
			this._nActiveBindings =
				0;
			this._bindingsByRootAndName = {};
			this._controlInterpolants = [];
			this._nActiveControlInterpolants = 0;
			var a = this;
			this.stats = {
				actions: {
					get total() {
						return a._actions.length
					},
					get inUse() {
						return a._nActiveActions
					}
				},
				bindings: {
					get total() {
						return a._bindings.length
					},
					get inUse() {
						return a._nActiveBindings
					}
				},
				controlInterpolants: {
					get total() {
						return a._controlInterpolants.length
					},
					get inUse() {
						return a._nActiveControlInterpolants
					}
				}
			}
		},
		_isActiveAction: function(a) {
			a = a._cacheIndex;
			return null !== a && a < this._nActiveActions
		},
		_addInactiveAction: function(a, b, c) {
			var d = this._actions,
				e = this._actionsByClip,
				g = e[b];
			void 0 === g ? (g = {
				knownActions: [a],
				actionByRoot: {}
			}, a._byClipCacheIndex = 0, e[b] = g) : (b = g.knownActions, a._byClipCacheIndex = b.length, b.push(a));
			a._cacheIndex = d.length;
			d.push(a);
			g.actionByRoot[c] = a
		},
		_removeInactiveAction: function(a) {
			var b = this._actions,
				c = b[b.length - 1],
				d = a._cacheIndex;
			c._cacheIndex = d;
			b[d] = c;
			b.pop();
			a._cacheIndex = null;
			b = a._clip.uuid;
			c = this._actionsByClip;
			d = c[b];
			var e = d.knownActions,
				g = e[e.length - 1],
				k = a._byClipCacheIndex;
			g._byClipCacheIndex = k;
			e[k] = g;
			e.pop();
			a._byClipCacheIndex = null;
			delete d.actionByRoot[(a._localRoot || this._root).uuid];
			0 === e.length && delete c[b];
			this._removeInactiveBindingsForAction(a)
		},
		_removeInactiveBindingsForAction: function(a) {
			a = a._propertyBindings;
			for (var b = 0, c = a.length; b !== c; ++b) {
				var d = a[b];
				0 === --d.referenceCount && this._removeInactiveBinding(d)
			}
		},
		_lendAction: function(a) {
			var b = this._actions,
				c = a._cacheIndex,
				d = this._nActiveActions++,
				e = b[d];
			a._cacheIndex = d;
			b[d] = a;
			e._cacheIndex = c;
			b[c] = e
		},
		_takeBackAction: function(a) {
			var b =
				this._actions,
				c = a._cacheIndex,
				d = --this._nActiveActions,
				e = b[d];
			a._cacheIndex = d;
			b[d] = a;
			e._cacheIndex = c;
			b[c] = e
		},
		_addInactiveBinding: function(a, b, c) {
			var d = this._bindingsByRootAndName,
				e = d[b],
				g = this._bindings;
			void 0 === e && (e = {}, d[b] = e);
			e[c] = a;
			a._cacheIndex = g.length;
			g.push(a)
		},
		_removeInactiveBinding: function(a) {
			var b = this._bindings,
				c = a.binding,
				d = c.rootNode.uuid;
			c = c.path;
			var e = this._bindingsByRootAndName,
				g = e[d],
				k = b[b.length - 1];
			a = a._cacheIndex;
			k._cacheIndex = a;
			b[a] = k;
			b.pop();
			delete g[c];
			0 === Ha(g).length && delete e[d]
		},
		_lendBinding: function(a) {
			var b = this._bindings,
				c = a._cacheIndex,
				d = this._nActiveBindings++,
				e = b[d];
			a._cacheIndex = d;
			b[d] = a;
			e._cacheIndex = c;
			b[c] = e
		},
		_takeBackBinding: function(a) {
			var b = this._bindings,
				c = a._cacheIndex,
				d = --this._nActiveBindings,
				e = b[d];
			a._cacheIndex = d;
			b[d] = a;
			e._cacheIndex = c;
			b[c] = e
		},
		_lendControlInterpolant: function() {
			var a = this._controlInterpolants,
				b = this._nActiveControlInterpolants++,
				c = a[b];
			void 0 === c && (c = new gj(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer),
				c.__cacheIndex = b, a[b] = c);
			return c
		},
		_takeBackControlInterpolant: function(a) {
			var b = this._controlInterpolants,
				c = a.__cacheIndex,
				d = --this._nActiveControlInterpolants,
				e = b[d];
			a.__cacheIndex = d;
			b[d] = a;
			e.__cacheIndex = c;
			b[c] = e
		},
		_controlInterpolantsResultBuffer: new Float32Array(1),
		clipAction: function(a, b) {
			var c = b || this._root,
				d = c.uuid;
			c = "string" === typeof a ? Ic.findByName(c, a) : a;
			a = null !== c ? c.uuid : a;
			var e = this._actionsByClip[a],
				g = null;
			if (void 0 !== e) {
				g = e.actionByRoot[d];
				if (void 0 !== g) return g;
				g = e.knownActions[0];
				null === c && (c = g._clip)
			}
			if (null === c) return null;
			b = new Cn(this, c, b);
			this._bindAction(b, g);
			this._addInactiveAction(b, a, d);
			return b
		},
		existingAction: function(a, b) {
			var c = b || this._root;
			b = c.uuid;
			c = "string" === typeof a ? Ic.findByName(c, a) : a;
			a = this._actionsByClip[c ? c.uuid : a];
			return void 0 !== a ? a.actionByRoot[b] || null : null
		},
		stopAllAction: function() {
			for (var a = this._actions, b = this._nActiveActions, c = this._bindings, d = this._nActiveBindings, e = this._nActiveBindings =
					this._nActiveActions = 0; e !== b; ++e) a[e].reset();
			for (e = 0; e !==
				d; ++e) c[e].useCount = 0;
			return this
		},
		update: function(a) {
			a *= this.timeScale;
			for (var b = this._actions, c = this._nActiveActions, d = this.time += a, e = Lg(a), g = this._accuIndex ^= 1, k =
					0; k !== c; ++k) b[k]._update(d, a, e, g);
			a = this._bindings;
			b = this._nActiveBindings;
			for (k = 0; k !== b; ++k) a[k].apply(g);
			return this
		},
		setTime: function(a) {
			for (var b = this.time = 0; b < this._actions.length; b++) this._actions[b].time = 0;
			return this.update(a)
		},
		getRoot: function() {
			return this._root
		},
		uncacheClip: function(a) {
			var b = this._actions;
			a = a.uuid;
			var c = this._actionsByClip,
				d = c[a];
			if (void 0 !== d) {
				d = d.knownActions;
				for (var e = 0, g = d.length; e !== g; ++e) {
					var k = d[e];
					this._deactivateAction(k);
					var l = k._cacheIndex,
						m = b[b.length - 1];
					k._cacheIndex = null;
					k._byClipCacheIndex = null;
					m._cacheIndex = l;
					b[l] = m;
					b.pop();
					this._removeInactiveBindingsForAction(k)
				}
				delete c[a]
			}
		},
		uncacheRoot: function(a) {
			a = a.uuid;
			var b = this._actionsByClip;
			for (d in b) {
				var c = b[d].actionByRoot[a];
				void 0 !== c && (this._deactivateAction(c), this._removeInactiveAction(c))
			}
			var d = this._bindingsByRootAndName[a];
			if (void 0 !== d)
				for (var e in d) a =
					d[e], a.restoreOriginalState(), this._removeInactiveBinding(a)
		},
		uncacheAction: function(a, b) {
			a = this.existingAction(a, b);
			null !== a && (this._deactivateAction(a), this._removeInactiveAction(a))
		}
	});
	gl.prototype.clone = function() {
		return new gl(void 0 === this.value.clone ? this.value : this.value.clone())
	};
	En.prototype = q(p(gc.prototype), {
		constructor: En,
		isInstancedInterleavedBuffer: !0,
		copy: function(a) {
			gc.prototype.copy.call(this, a);
			this.meshPerAttribute = a.meshPerAttribute;
			return this
		}
	});
	q(function(a, b, c, d) {
		this.ray =
			new wf(a, b);
		this.near = c || 0;
		this.far = d || Infinity;
		this.camera = null;
		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: {
				threshold: 1
			},
			Sprite: {}
		};
		ja(this.params, {
			PointCloud: {
				get: function() {
					console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
					return this.Points
				}
			}
		})
	}.prototype, {
		linePrecision: 1,
		set: function(a, b) {
			this.ray.set(a, b)
		},
		setFromCamera: function(a, b) {
			b && b.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(b.matrixWorld), this.ray.direction.set(a.x,
						a.y, .5).unproject(b).sub(this.ray.origin).normalize(),
					this.camera = b) : b && b.isOrthographicCamera ? (this.ray.origin.set(a.x, a.y, (b.near + b.far) / (b.near - b
					.far)).unproject(b), this.ray.direction.set(0, 0, -1).transformDirection(b.matrixWorld), this.camera = b) :
				console.error("THREE.Raycaster: Unsupported camera type.")
		},
		intersectObject: function(a, b, c) {
			c = c || [];
			hl(a, this, c, b);
			c.sort(Fn);
			return c
		},
		intersectObjects: function(a, b, c) {
			c = c || [];
			if (!1 === Array.isArray(a)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
				c;
			for (var d = 0, e = a.length; d <
				e; d++) hl(a[d], this, c, b);
			c.sort(Fn);
			return c
		}
	});
	q(function(a, b, c) {
		this.radius = void 0 !== a ? a : 1;
		this.phi = void 0 !== b ? b : 0;
		this.theta = void 0 !== c ? c : 0;
		return this
	}.prototype, {
		set: function(a, b, c) {
			this.radius = a;
			this.phi = b;
			this.theta = c;
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.radius = a.radius;
			this.phi = a.phi;
			this.theta = a.theta;
			return this
		},
		makeSafe: function() {
			this.phi = Math.max(1E-6, Math.min(Math.PI - 1E-6, this.phi));
			return this
		},
		setFromVector3: function(a) {
			return this.setFromCartesianCoords(a.x,
				a.y, a.z)
		},
		setFromCartesianCoords: function(a, b, c) {
			this.radius = Math.sqrt(a * a + b * b + c * c);
			0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(a, c), this.phi = Math.acos(ha.clamp(b /
				this.radius, -1, 1)));
			return this
		}
	});
	q(function(a, b, c) {
		this.radius = void 0 !== a ? a : 1;
		this.theta = void 0 !== b ? b : 0;
		this.y = void 0 !== c ? c : 0;
		return this
	}.prototype, {
		set: function(a, b, c) {
			this.radius = a;
			this.theta = b;
			this.y = c;
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.radius = a.radius;
			this.theta =
				a.theta;
			this.y = a.y;
			return this
		},
		setFromVector3: function(a) {
			return this.setFromCartesianCoords(a.x, a.y, a.z)
		},
		setFromCartesianCoords: function(a, b, c) {
			this.radius = Math.sqrt(a * a + c * c);
			this.theta = Math.atan2(a, c);
			this.y = b;
			return this
		}
	});
	var ep = new B;
	q(Gn.prototype, {
		set: function(a, b) {
			this.min.copy(a);
			this.max.copy(b);
			return this
		},
		setFromPoints: function(a) {
			this.makeEmpty();
			for (var b = 0, c = a.length; b < c; b++) this.expandByPoint(a[b]);
			return this
		},
		setFromCenterAndSize: function(a, b) {
			b = ep.copy(b).multiplyScalar(.5);
			this.min.copy(a).sub(b);
			this.max.copy(a).add(b);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.min.copy(a.min);
			this.max.copy(a.max);
			return this
		},
		makeEmpty: function() {
			this.min.x = this.min.y = Infinity;
			this.max.x = this.max.y = -Infinity;
			return this
		},
		isEmpty: function() {
			return this.max.x < this.min.x || this.max.y < this.min.y
		},
		getCenter: function(a) {
			void 0 === a && (console.warn("THREE.Box2: .getCenter() target is now required"), a = new B);
			return this.isEmpty() ? a.set(0, 0) :
				a.addVectors(this.min, this.max).multiplyScalar(.5)
		},
		getSize: function(a) {
			void 0 === a && (console.warn("THREE.Box2: .getSize() target is now required"), a = new B);
			return this.isEmpty() ? a.set(0, 0) : a.subVectors(this.max, this.min)
		},
		expandByPoint: function(a) {
			this.min.min(a);
			this.max.max(a);
			return this
		},
		expandByVector: function(a) {
			this.min.sub(a);
			this.max.add(a);
			return this
		},
		expandByScalar: function(a) {
			this.min.addScalar(-a);
			this.max.addScalar(a);
			return this
		},
		containsPoint: function(a) {
			return a.x < this.min.x || a.x >
				this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
		},
		containsBox: function(a) {
			return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y
		},
		getParameter: function(a, b) {
			void 0 === b && (console.warn("THREE.Box2: .getParameter() target is now required"), b = new B);
			return b.set((a.x - this.min.x) / (this.max.x - this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y))
		},
		intersectsBox: function(a) {
			return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
		},
		clampPoint: function(a,
			b) {
			void 0 === b && (console.warn("THREE.Box2: .clampPoint() target is now required"), b = new B);
			return b.copy(a).clamp(this.min, this.max)
		},
		distanceToPoint: function(a) {
			return ep.copy(a).clamp(this.min, this.max).sub(a).length()
		},
		intersect: function(a) {
			this.min.max(a.min);
			this.max.min(a.max);
			return this
		},
		union: function(a) {
			this.min.min(a.min);
			this.max.max(a.max);
			return this
		},
		translate: function(a) {
			this.min.add(a);
			this.max.add(a);
			return this
		},
		equals: function(a) {
			return a.min.equals(this.min) && a.max.equals(this.max)
		}
	});
	var fp = new u,
		Hi = new u;
	q(Hn.prototype, {
		set: function(a, b) {
			this.start.copy(a);
			this.end.copy(b);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		},
		copy: function(a) {
			this.start.copy(a.start);
			this.end.copy(a.end);
			return this
		},
		getCenter: function(a) {
			void 0 === a && (console.warn("THREE.Line3: .getCenter() target is now required"), a = new u);
			return a.addVectors(this.start, this.end).multiplyScalar(.5)
		},
		delta: function(a) {
			void 0 === a && (console.warn("THREE.Line3: .delta() target is now required"),
				a = new u);
			return a.subVectors(this.end, this.start)
		},
		distanceSq: function() {
			return this.start.distanceToSquared(this.end)
		},
		distance: function() {
			return this.start.distanceTo(this.end)
		},
		at: function(a, b) {
			void 0 === b && (console.warn("THREE.Line3: .at() target is now required"), b = new u);
			return this.delta(b).multiplyScalar(a).add(this.start)
		},
		closestPointToPointParameter: function(a, b) {
			fp.subVectors(a, this.start);
			Hi.subVectors(this.end, this.start);
			a = Hi.dot(Hi);
			a = Hi.dot(fp) / a;
			b && (a = ha.clamp(a, 0, 1));
			return a
		},
		closestPointToPoint: function(a,
			b, c) {
			a = this.closestPointToPointParameter(a, b);
			void 0 === c && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), c = new u);
			return this.delta(c).multiplyScalar(a).add(this.start)
		},
		applyMatrix4: function(a) {
			this.start.applyMatrix4(a);
			this.end.applyMatrix4(a);
			return this
		},
		equals: function(a) {
			return a.start.equals(this.start) && a.end.equals(this.end)
		}
	});
	Rg.prototype = p(P.prototype);
	Rg.prototype.constructor = Rg;
	Rg.prototype.isImmediateRenderObject = !0;
	var Qd = new u,
		Le = new u,
		im = new kb,
		bt = ["a",
			"b", "c"
		];
	Uf.prototype = p(Ra.prototype);
	Uf.prototype.constructor = Uf;
	Uf.prototype.update = function() {
		this.object.updateMatrixWorld(!0);
		im.getNormalMatrix(this.object.matrixWorld);
		var a = this.object.matrixWorld,
			b = this.geometry.attributes.position,
			c = this.object.geometry;
		if (c && c.isGeometry)
			for (var d = c.vertices, e = c.faces, g = c = 0, k = e.length; g < k; g++)
				for (var l = e[g], m = 0, n = l.vertexNormals.length; m < n; m++) {
					var p = l.vertexNormals[m];
					Qd.copy(d[l[bt[m]]]).applyMatrix4(a);
					Le.copy(p).applyMatrix3(im).normalize().multiplyScalar(this.size).add(Qd);
					b.setXYZ(c, Qd.x, Qd.y, Qd.z);
					c += 1;
					b.setXYZ(c, Le.x, Le.y, Le.z);
					c += 1
				} else if (c && c.isBufferGeometry)
					for (d = c.attributes.position, e = c.attributes.normal, m = c = 0, n = d.count; m < n; m++) Qd.set(d.getX(m), d
							.getY(m), d.getZ(m)).applyMatrix4(a), Le.set(e.getX(m), e.getY(m), e.getZ(m)), Le.applyMatrix3(im).normalize()
						.multiplyScalar(this.size).add(Qd), b.setXYZ(c, Qd.x, Qd.y, Qd.z), c += 1, b.setXYZ(c, Le.x, Le.y, Le.z), c +=
						1;
		b.needsUpdate = !0
	};
	var gp = new u;
	Vf.prototype = p(P.prototype);
	Vf.prototype.constructor = Vf;
	Vf.prototype.dispose = function() {
		this.cone.geometry.dispose();
		this.cone.material.dispose()
	};
	Vf.prototype.update = function() {
		this.light.updateMatrixWorld();
		var a = this.light.distance ? this.light.distance : 1E3,
			b = a * Math.tan(this.light.angle);
		this.cone.scale.set(b, b, a);
		gp.setFromMatrixPosition(this.light.target.matrixWorld);
		this.cone.lookAt(gp);
		void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
	};
	var xc = new u,
		Ii = new ua,
		jm = new ua;
	Sg.prototype = p(Ra.prototype);
	Sg.prototype.constructor = Sg;
	Sg.prototype.updateMatrixWorld =
		function(a) {
			var b = this.bones,
				c = this.geometry,
				d = c.getAttribute("position");
			jm.getInverse(this.root.matrixWorld);
			for (var e = 0, g = 0; e < b.length; e++) {
				var k = b[e];
				k.parent && k.parent.isBone && (Ii.multiplyMatrices(jm, k.matrixWorld), xc.setFromMatrixPosition(Ii), d.setXYZ(g,
					xc.x, xc.y, xc.z), Ii.multiplyMatrices(jm, k.parent.matrixWorld), xc.setFromMatrixPosition(Ii), d.setXYZ(g + 1,
					xc.x, xc.y, xc.z), g += 2)
			}
			c.getAttribute("position").needsUpdate = !0;
			P.prototype.updateMatrixWorld.call(this, a)
		};
	Wf.prototype = p(Wa.prototype);
	Wf.prototype.constructor =
		Wf;
	Wf.prototype.dispose = function() {
		this.geometry.dispose();
		this.material.dispose()
	};
	Wf.prototype.update = function() {
		void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
	};
	Xf.prototype = p(Pa.prototype);
	Xf.prototype.constructor = Xf;
	Xf.prototype.update = function() {
		this.scale.set(.5 * this.light.width, .5 * this.light.height, 1);
		if (void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color);
		else {
			this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
			var a = this.material.color,
				b = Math.max(a.r, a.g, a.b);
			1 < b && a.multiplyScalar(1 / b);
			this.children[0].material.color.copy(this.material.color)
		}
	};
	Xf.prototype.dispose = function() {
		this.geometry.dispose();
		this.material.dispose();
		this.children[0].geometry.dispose();
		this.children[0].material.dispose()
	};
	var ct = new u,
		hp = new S,
		ip = new S;
	Yf.prototype = p(P.prototype);
	Yf.prototype.constructor = Yf;
	Yf.prototype.dispose = function() {
		this.children[0].geometry.dispose();
		this.children[0].material.dispose()
	};
	Yf.prototype.update =
		function() {
			var a = this.children[0];
			if (void 0 !== this.color) this.material.color.set(this.color);
			else {
				var b = a.geometry.getAttribute("color");
				hp.copy(this.light.color);
				ip.copy(this.light.groundColor);
				for (var c = 0, d = b.count; c < d; c++) {
					var e = c < d / 2 ? hp : ip;
					b.setXYZ(c, e.r, e.g, e.b)
				}
				b.needsUpdate = !0
			}
			a.lookAt(ct.setFromMatrixPosition(this.light.matrixWorld).negate())
		};
	Zf.prototype = p(Wa.prototype);
	Zf.prototype.constructor = Zf;
	Zf.prototype.dispose = function() {
		this.geometry.dispose();
		this.material.dispose()
	};
	Zf.prototype.onBeforeRender =
		function() {
			this.position.copy(this.lightProbe.position);
			this.scale.set(1, 1, 1).multiplyScalar(this.size);
			this.material.uniforms.intensity.value = this.lightProbe.intensity
		};
	il.prototype = q(p(Ra.prototype), {
		constructor: il,
		copy: function(a) {
			Ra.prototype.copy.call(this, a);
			this.geometry.copy(a.geometry);
			this.material.copy(a.material);
			return this
		},
		clone: function() {
			return (new this.constructor).copy(this)
		}
	});
	jl.prototype = p(Ra.prototype);
	jl.prototype.constructor = jl;
	$f.prototype = p(Pa.prototype);
	$f.prototype.constructor =
		$f;
	$f.prototype.update = function() {
		function a(a, b, d, e) {
			d = (b - a) / d;
			w.setXYZ(m, 0, 0, 0);
			n++;
			for (p = a; p < b; p += d) q = m + n, w.setXYZ(q, Math.sin(p) * c, 0, Math.cos(p) * c), w.setXYZ(q + 1, Math.sin(
				Math.min(p + d, b)) * c, 0, Math.cos(Math.min(p + d, b)) * c), w.setXYZ(q + 2, 0, 0, 0), n += 3;
			u.addGroup(m, n, e);
			m += n;
			n = 0
		}
		var b = this.audio,
			c = this.range,
			d = this.divisionsInnerAngle,
			e = this.divisionsOuterAngle,
			g = ha.degToRad(b.panner.coneInnerAngle);
		b = ha.degToRad(b.panner.coneOuterAngle);
		var k = g / 2,
			l = b / 2,
			m = 0,
			n = 0,
			p, q, u = this.geometry,
			w = u.attributes.position;
		u.clearGroups();
		a(-l, -k, e, 0);
		a(-k, k, d, 1);
		a(k, l, e, 0);
		w.needsUpdate = !0;
		g === b && (this.material[0].visible = !1)
	};
	$f.prototype.dispose = function() {
		this.geometry.dispose();
		this.material[0].dispose();
		this.material[1].dispose()
	};
	var Me = new u,
		Xj = new u,
		jp = new kb;
	Tg.prototype = p(Ra.prototype);
	Tg.prototype.constructor = Tg;
	Tg.prototype.update = function() {
		this.object.updateMatrixWorld(!0);
		jp.getNormalMatrix(this.object.matrixWorld);
		var a = this.object.matrixWorld,
			b = this.geometry.attributes.position,
			c = this.object.geometry,
			d = c.vertices;
		c = c.faces;
		for (var e = 0, g = 0, k = c.length; g < k; g++) {
			var l = c[g],
				m = l.normal;
			Me.copy(d[l.a]).add(d[l.b]).add(d[l.c]).divideScalar(3).applyMatrix4(a);
			Xj.copy(m).applyMatrix3(jp).normalize().multiplyScalar(this.size).add(Me);
			b.setXYZ(e, Me.x, Me.y, Me.z);
			e += 1;
			b.setXYZ(e, Xj.x, Xj.y, Xj.z);
			e += 1
		}
		b.needsUpdate = !0
	};
	var kp = new u,
		Ji = new u,
		lp = new u;
	Ug.prototype = p(P.prototype);
	Ug.prototype.constructor = Ug;
	Ug.prototype.dispose = function() {
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose()
	};
	Ug.prototype.update = function() {
		kp.setFromMatrixPosition(this.light.matrixWorld);
		Ji.setFromMatrixPosition(this.light.target.matrixWorld);
		lp.subVectors(Ji, kp);
		this.lightPlane.lookAt(Ji);
		void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) :
			(this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color));
		this.targetLine.lookAt(Ji);
		this.targetLine.scale.z = lp.length()
	};
	var Vg = new u,
		Ya = new Vd;
	Sh.prototype = p(Ra.prototype);
	Sh.prototype.constructor = Sh;
	Sh.prototype.update = function() {
		var a = this.geometry,
			b = this.pointMap;
		Ya.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
		Da("c", b, a, Ya, 0, 0, -1);
		Da("t", b, a, Ya, 0, 0, 1);
		Da("n1", b, a, Ya, -1, -1, -1);
		Da("n2", b, a, Ya, 1, -1, -1);
		Da("n3", b, a, Ya, -1, 1, -1);
		Da("n4", b, a, Ya, 1, 1, -1);
		Da("f1", b, a, Ya, -1, -1, 1);
		Da("f2", b, a, Ya, 1, -1, 1);
		Da("f3", b, a, Ya, -1, 1, 1);
		Da("f4", b, a, Ya, 1, 1, 1);
		Da("u1", b, a, Ya, .7, 1.1, -1);
		Da("u2", b, a, Ya, -.7, 1.1, -1);
		Da("u3",
			b, a, Ya, 0, 2, -1);
		Da("cf1", b, a, Ya, -1, 0, 1);
		Da("cf2", b, a, Ya, 1, 0, 1);
		Da("cf3", b, a, Ya, 0, -1, 1);
		Da("cf4", b, a, Ya, 0, 1, 1);
		Da("cn1", b, a, Ya, -1, 0, -1);
		Da("cn2", b, a, Ya, 1, 0, -1);
		Da("cn3", b, a, Ya, 0, -1, -1);
		Da("cn4", b, a, Ya, 0, 1, -1);
		a.getAttribute("position").needsUpdate = !0
	};
	var Ki = new Sd;
	Mc.prototype = p(Ra.prototype);
	Mc.prototype.constructor = Mc;
	Mc.prototype.update = function(a) {
		void 0 !== a && console.warn("THREE.BoxHelper: .update() has no longer arguments.");
		void 0 !== this.object && Ki.setFromObject(this.object);
		if (!Ki.isEmpty()) {
			a =
				Ki.min;
			var b = Ki.max,
				c = this.geometry.attributes.position,
				d = c.array;
			d[0] = b.x;
			d[1] = b.y;
			d[2] = b.z;
			d[3] = a.x;
			d[4] = b.y;
			d[5] = b.z;
			d[6] = a.x;
			d[7] = a.y;
			d[8] = b.z;
			d[9] = b.x;
			d[10] = a.y;
			d[11] = b.z;
			d[12] = b.x;
			d[13] = b.y;
			d[14] = a.z;
			d[15] = a.x;
			d[16] = b.y;
			d[17] = a.z;
			d[18] = a.x;
			d[19] = a.y;
			d[20] = a.z;
			d[21] = b.x;
			d[22] = a.y;
			d[23] = a.z;
			c.needsUpdate = !0;
			this.geometry.computeBoundingSphere()
		}
	};
	Mc.prototype.setFromObject = function(a) {
		this.object = a;
		this.update();
		return this
	};
	Mc.prototype.copy = function(a) {
		Ra.prototype.copy.call(this, a);
		this.object =
			a.object;
		return this
	};
	Mc.prototype.clone = function() {
		return (new this.constructor).copy(this)
	};
	Th.prototype = p(Ra.prototype);
	Th.prototype.constructor = Th;
	Th.prototype.updateMatrixWorld = function(a) {
		var b = this.box;
		b.isEmpty() || (b.getCenter(this.position), b.getSize(this.scale), this.scale.multiplyScalar(.5), P.prototype.updateMatrixWorld
			.call(this, a))
	};
	Uh.prototype = p(Pa.prototype);
	Uh.prototype.constructor = Uh;
	Uh.prototype.updateMatrixWorld = function(a) {
		var b = -this.plane.constant;
		1E-8 > Math.abs(b) && (b = 1E-8);
		this.scale.set(.5 *
			this.size, .5 * this.size, b);
		this.children[0].material.side = 0 > b ? 1 : 0;
		this.lookAt(this.plane.normal);
		P.prototype.updateMatrixWorld.call(this, a)
	};
	var mp = new u,
		Vh, kl;
	Cd.prototype = p(P.prototype);
	Cd.prototype.constructor = Cd;
	Cd.prototype.setDirection = function(a) {
		.99999 < a.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > a.y ? this.quaternion.set(1, 0, 0, 0) : (mp.set(a.z, 0,
			-a.x).normalize(), this.quaternion.setFromAxisAngle(mp, Math.acos(a.y)))
	};
	Cd.prototype.setLength = function(a, b, c) {
		void 0 === b && (b = .2 * a);
		void 0 === c && (c = .2 * b);
		this.line.scale.set(1, Math.max(1E-4, a - b), 1);
		this.line.updateMatrix();
		this.cone.scale.set(c, b, c);
		this.cone.position.y = a;
		this.cone.updateMatrix()
	};
	Cd.prototype.setColor = function(a) {
		this.line.material.color.set(a);
		this.cone.material.color.set(a)
	};
	Cd.prototype.copy = function(a) {
		P.prototype.copy.call(this, a, !1);
		this.line.copy(a.line);
		this.cone.copy(a.cone);
		return this
	};
	Cd.prototype.clone = function() {
		return (new this.constructor).copy(this)
	};
	ll.prototype = p(Ra.prototype);
	ll.prototype.constructor = ll;
	X.create =
		function(a, b) {
			a.prototype = p(X.prototype);
			a.prototype.constructor = a;
			a.prototype.getPoint = b;
			return a
		};
	q(ge.prototype, {
		createPointsGeometry: function(a) {
			console.warn(
				"THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
			);
			a = this.getPoints(a);
			return this.createGeometry(a)
		},
		createSpacedPointsGeometry: function(a) {
			console.warn(
				"THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
			);
			a = this.getSpacedPoints(a);
			return this.createGeometry(a)
		},
		createGeometry: function(a) {
			console.warn(
				"THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."
			);
			for (var b = new R, c = 0, d = a.length; c < d; c++) {
				var e = a[c];
				b.vertices.push(new u(e.x, e.y, e.z || 0))
			}
			return b
		}
	});
	q(Ad.prototype, {
		fromPoints: function(a) {
			console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
			this.setFromPoints(a)
		}
	});
	(function(a) {
		console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
		wb.call(this, a);
		this.type = "catmullrom";
		this.closed = !0
	}).prototype = p(wb.prototype);
	(function(a) {
		console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
		wb.call(this, a);
		this.type = "catmullrom"
	}).prototype = p(wb.prototype);
	Jn.prototype = p(wb.prototype);
	q(Jn.prototype, {
		initFromArray: function() {
			console.error("THREE.Spline: .initFromArray() has been removed.")
		},
		getControlPointsArray: function() {
			console.error("THREE.Spline: .getControlPointsArray() has been removed.")
		},
		reparametrizeByArcLength: function() {
			console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
		}
	});
	il.prototype.setColors = function() {
		console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
	};
	Sg.prototype.update = function() {
		console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
	};
	q(sa.prototype, {
		extractUrlBase: function(a) {
			console.warn(
				"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
			return Yo.extractUrlBase(a)
		}
	});
	sa.Handlers = {
		add: function() {
			console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
		},
		get: function() {
			console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
		}
	};
	q(cl.prototype, {
		setTexturePath: function(a) {
			console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
			return this.setResourcePath(a)
		}
	});
	q(Gn.prototype, {
		center: function(a) {
			console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
			return this.getCenter(a)
		},
		empty: function() {
			console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
			return this.isEmpty()
		},
		isIntersectionBox: function(a) {
			console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
			return this.intersectsBox(a)
		},
		size: function(a) {
			console.warn("THREE.Box2: .size() has been renamed to .getSize().");
			return this.getSize(a)
		}
	});
	q(Sd.prototype, {
		center: function(a) {
			console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
			return this.getCenter(a)
		},
		empty: function() {
			console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
			return this.isEmpty()
		},
		isIntersectionBox: function(a) {
			console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
			return this.intersectsBox(a)
		},
		isIntersectionSphere: function(a) {
			console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
			return this.intersectsSphere(a)
		},
		size: function(a) {
			console.warn("THREE.Box3: .size() has been renamed to .getSize().");
			return this.getSize(a)
		}
	});
	Hn.prototype.center = function(a) {
		console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
		return this.getCenter(a)
	};
	q(ha, {
		random16: function() {
			console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
			return Math.random()
		},
		nearestPowerOfTwo: function(a) {
			console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
			return ha.floorPowerOfTwo(a)
		},
		nextPowerOfTwo: function(a) {
			console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
			return ha.ceilPowerOfTwo(a)
		}
	});
	q(kb.prototype, {
		flattenToArrayOffset: function(a,
			b) {
			console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
			return this.toArray(a, b)
		},
		multiplyVector3: function(a) {
			console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
			return a.applyMatrix3(this)
		},
		multiplyVector3Array: function() {
			console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
		},
		applyToBuffer: function(a) {
			console.warn(
				"THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
			return this.applyToBufferAttribute(a)
		},
		applyToVector3Array: function() {
			console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
		}
	});
	q(ua.prototype, {
		extractPosition: function(a) {
			console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
			return this.copyPosition(a)
		},
		flattenToArrayOffset: function(a, b) {
			console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
			return this.toArray(a, b)
		},
		getPosition: function() {
			console.warn(
				"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
			return (new u).setFromMatrixColumn(this, 3)
		},
		setRotationFromQuaternion: function(a) {
			console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
			return this.makeRotationFromQuaternion(a)
		},
		multiplyToArray: function() {
			console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
		},
		multiplyVector3: function(a) {
			console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
			return a.applyMatrix4(this)
		},
		multiplyVector4: function(a) {
			console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
			return a.applyMatrix4(this)
		},
		multiplyVector3Array: function() {
			console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
		},
		rotateAxis: function(a) {
			console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
			a.transformDirection(this)
		},
		crossVector: function(a) {
			console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
			return a.applyMatrix4(this)
		},
		translate: function() {
			console.error("THREE.Matrix4: .translate() has been removed.")
		},
		rotateX: function() {
			console.error("THREE.Matrix4: .rotateX() has been removed.")
		},
		rotateY: function() {
			console.error("THREE.Matrix4: .rotateY() has been removed.")
		},
		rotateZ: function() {
			console.error("THREE.Matrix4: .rotateZ() has been removed.")
		},
		rotateByAxis: function() {
			console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
		},
		applyToBuffer: function(a) {
			console.warn(
				"THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.");
			return this.applyToBufferAttribute(a)
		},
		applyToVector3Array: function() {
			console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
		},
		makeFrustum: function(a, b, c, d, e, g) {
			console.warn(
				"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."
			);
			return this.makePerspective(a, b, d, c, e, g)
		}
	});
	Wd.prototype.isIntersectionLine = function(a) {
		console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
		return this.intersectsLine(a)
	};
	vb.prototype.multiplyVector3 =
		function(a) {
			console.warn(
				"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."
			);
			return a.applyQuaternion(this)
		};
	q(wf.prototype, {
		isIntersectionBox: function(a) {
			console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
			return this.intersectsBox(a)
		},
		isIntersectionPlane: function(a) {
			console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
			return this.intersectsPlane(a)
		},
		isIntersectionSphere: function(a) {
			console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
			return this.intersectsSphere(a)
		}
	});
	q(ob.prototype, {
		area: function() {
			console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
			return this.getArea()
		},
		barycoordFromPoint: function(a, b) {
			console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
			return this.getBarycoord(a, b)
		},
		midpoint: function(a) {
			console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
			return this.getMidpoint(a)
		},
		normal: function(a) {
			console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
			return this.getNormal(a)
		},
		plane: function(a) {
			console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
			return this.getPlane(a)
		}
	});
	q(ob, {
		barycoordFromPoint: function(a, b, c, d, e) {
			console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
			return ob.getBarycoord(a, b, c, d, e)
		},
		normal: function(a, b, c, d) {
			console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
			return ob.getNormal(a, b, c, d)
		}
	});
	q(lc.prototype, {
		extractAllPoints: function(a) {
			console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
			return this.extractPoints(a)
		},
		extrude: function(a) {
			console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
			return new Jf(this, a)
		},
		makeGeometry: function(a) {
			console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
			return new Kf(this, a)
		}
	});
	q(B.prototype, {
		fromAttribute: function(a, b, c) {
			console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
			return this.fromBufferAttribute(a, b, c)
		},
		distanceToManhattan: function(a) {
			console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
			return this.manhattanDistanceTo(a)
		},
		lengthManhattan: function() {
			console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
			return this.manhattanLength()
		}
	});
	q(u.prototype, {
		setEulerFromRotationMatrix: function() {
			console.error(
				"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
		},
		setEulerFromQuaternion: function() {
			console.error(
				"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
		},
		getPositionFromMatrix: function(a) {
			console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
			return this.setFromMatrixPosition(a)
		},
		getScaleFromMatrix: function(a) {
			console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
			return this.setFromMatrixScale(a)
		},
		getColumnFromMatrix: function(a, b) {
			console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
			return this.setFromMatrixColumn(b,
				a)
		},
		applyProjection: function(a) {
			console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
			return this.applyMatrix4(a)
		},
		fromAttribute: function(a, b, c) {
			console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
			return this.fromBufferAttribute(a, b, c)
		},
		distanceToManhattan: function(a) {
			console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
			return this.manhattanDistanceTo(a)
		},
		lengthManhattan: function() {
			console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
			return this.manhattanLength()
		}
	});
	q(za.prototype, {
		fromAttribute: function(a, b, c) {
			console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
			return this.fromBufferAttribute(a, b, c)
		},
		lengthManhattan: function() {
			console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
			return this.manhattanLength()
		}
	});
	q(R.prototype, {
		computeTangents: function() {
			console.error("THREE.Geometry: .computeTangents() has been removed.")
		},
		computeLineDistances: function() {
			console.error(
				"THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
		}
	});
	q(P.prototype, {
		getChildByName: function(a) {
			console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
			return this.getObjectByName(a)
		},
		renderDepth: function() {
			console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
		},
		translate: function(a, b) {
			console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
			return this.translateOnAxis(b, a)
		},
		getWorldRotation: function() {
			console.error(
				"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead."
			)
		}
	});
	ja(P.prototype, {
		eulerOrder: {
			get: function() {
				console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
				return this.rotation.order
			},
			set: function(a) {
				console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
				this.rotation.order = a
			}
		},
		useQuaternion: {
			get: function() {
				console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
			},
			set: function() {
				console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
			}
		}
	});
	ja(Zi.prototype, {
		objects: {
			get: function() {
				console.warn("THREE.LOD: .objects has been renamed to .levels.");
				return this.levels
			}
		}
	});
	Object.defineProperty(jk.prototype, "useVertexTexture", {
		get: function() {
			console.warn("THREE.Skeleton: useVertexTexture has been removed.")
		},
		set: function() {
			console.warn("THREE.Skeleton: useVertexTexture has been removed.")
		}
	});
	$i.prototype.initBones = function() {
		console.error("THREE.SkinnedMesh: initBones() has been removed.")
	};
	Object.defineProperty(X.prototype, "__arcLengthDivisions", {
		get: function() {
			console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
			return this.arcLengthDivisions
		},
		set: function(a) {
			console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
			this.arcLengthDivisions = a
		}
	});
	ab.prototype.setLens = function(a, b) {
		console.warn(
			"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.");
		void 0 !== b && (this.filmGauge = b);
		this.setFocalLength(a)
	};
	ja(Ba.prototype, {
		onlyShadow: {
			set: function() {
				console.warn("THREE.Light: .onlyShadow has been removed.")
			}
		},
		shadowCameraFov: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
				this.shadow.camera.fov = a
			}
		},
		shadowCameraLeft: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
				this.shadow.camera.left = a
			}
		},
		shadowCameraRight: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
				this.shadow.camera.right = a
			}
		},
		shadowCameraTop: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
				this.shadow.camera.top = a
			}
		},
		shadowCameraBottom: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
				this.shadow.camera.bottom = a
			}
		},
		shadowCameraNear: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
				this.shadow.camera.near = a
			}
		},
		shadowCameraFar: {
			set: function(a) {
				console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
				this.shadow.camera.far = a
			}
		},
		shadowCameraVisible: {
			set: function() {
				console.warn(
					"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead."
				)
			}
		},
		shadowBias: {
			set: function(a) {
				console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
				this.shadow.bias = a
			}
		},
		shadowDarkness: {
			set: function() {
				console.warn("THREE.Light: .shadowDarkness has been removed.")
			}
		},
		shadowMapWidth: {
			set: function(a) {
				console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
				this.shadow.mapSize.width = a
			}
		},
		shadowMapHeight: {
			set: function(a) {
				console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
				this.shadow.mapSize.height = a
			}
		}
	});
	ja(F.prototype, {
		length: {
			get: function() {
				console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
				return this.array.length
			}
		}
	});
	q(F.prototype, {
		copyIndicesArray: function() {
			console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
		},
		setArray: function(a) {
			console.warn(
				"THREE.BufferAttribute: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
			);
			this.count = void 0 !== a ? a.length / this.itemSize : 0;
			this.array = a;
			return this
		}
	});
	q(J.prototype, {
		addIndex: function(a) {
			console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
			this.setIndex(a)
		},
		addDrawCall: function(a, b, c) {
			void 0 !== c && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
			console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
			this.addGroup(a, b)
		},
		clearDrawCalls: function() {
			console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
			this.clearGroups()
		},
		computeTangents: function() {
			console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
		},
		computeOffsets: function() {
			console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
		}
	});
	ja(J.prototype, {
		drawcalls: {
			get: function() {
				console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
				return this.groups
			}
		},
		offsets: {
			get: function() {
				console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
				return this.groups
			}
		}
	});
	q(gc.prototype, {
		setArray: function(a) {
			console.warn(
				"THREE.InterleavedBuffer: .setArray has been deprecated. Use BufferGeometry .setAttribute to replace/resize attribute buffers"
			);
			this.count = void 0 !== a ? a.length / this.stride : 0;
			this.array = a;
			return this
		}
	});
	q(de.prototype, {
		getArrays: function() {
			console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
		},
		addShapeList: function() {
			console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
		},
		addShape: function() {
			console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
		}
	});
	ja(gl.prototype, {
		dynamic: {
			set: function() {
				console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
			}
		},
		onUpdate: {
			value: function() {
				console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
				return this
			}
		}
	});
	ja(ia.prototype, {
		wrapAround: {
			get: function() {
				console.warn("THREE.Material: .wrapAround has been removed.")
			},
			set: function() {
				console.warn("THREE.Material: .wrapAround has been removed.")
			}
		},
		overdraw: {
			get: function() {
				console.warn("THREE.Material: .overdraw has been removed.")
			},
			set: function() {
				console.warn("THREE.Material: .overdraw has been removed.")
			}
		},
		wrapRGB: {
			get: function() {
				console.warn("THREE.Material: .wrapRGB has been removed.");
				return new S
			}
		},
		shading: {
			get: function() {
				console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
			},
			set: function(a) {
				console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
				this.flatShading = 1 === a
			}
		},
		stencilMask: {
			get: function() {
				console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
				return this.stencilFuncMask
			},
			set: function(a) {
				console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
				this.stencilFuncMask = a
			}
		}
	});
	ja(Gc.prototype, {
		metal: {
			get: function() {
				console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
				return !1
			},
			set: function() {
				console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
			}
		}
	});
	ja(Ia.prototype, {
		derivatives: {
			get: function() {
				console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
				return this.extensions.derivatives
			},
			set: function(a) {
				console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
				this.extensions.derivatives = a
			}
		}
	});
	q(Xm.prototype, {
		clearTarget: function(a, b, c, d) {
			console.warn(
				"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
			this.setRenderTarget(a);
			this.clear(b, c, d)
		},
		animate: function(a) {
			console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
			this.setAnimationLoop(a)
		},
		getCurrentRenderTarget: function() {
			console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
			return this.getRenderTarget()
		},
		getMaxAnisotropy: function() {
			console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
			return this.capabilities.getMaxAnisotropy()
		},
		getPrecision: function() {
			console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
			return this.capabilities.precision
		},
		resetGLState: function() {
			console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
			return this.state.reset()
		},
		supportsFloatTextures: function() {
			console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
			return this.extensions.get("OES_texture_float")
		},
		supportsHalfFloatTextures: function() {
			console.warn(
				"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
			return this.extensions.get("OES_texture_half_float")
		},
		supportsStandardDerivatives: function() {
			console.warn(
				"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
			return this.extensions.get("OES_standard_derivatives")
		},
		supportsCompressedTextureS3TC: function() {
			console.warn(
				"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
			);
			return this.extensions.get("WEBGL_compressed_texture_s3tc")
		},
		supportsCompressedTexturePVRTC: function() {
			console.warn(
				"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
			);
			return this.extensions.get("WEBGL_compressed_texture_pvrtc")
		},
		supportsBlendMinMax: function() {
			console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
			return this.extensions.get("EXT_blend_minmax")
		},
		supportsVertexTextures: function() {
			console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
			return this.capabilities.vertexTextures
		},
		supportsInstancedArrays: function() {
			console.warn(
				"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
			return this.extensions.get("ANGLE_instanced_arrays")
		},
		enableScissorTest: function(a) {
			console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
			this.setScissorTest(a)
		},
		initMaterial: function() {
			console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
		},
		addPrePlugin: function() {
			console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
		},
		addPostPlugin: function() {
			console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
		},
		updateShadowMap: function() {
			console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
		},
		setFaceCulling: function() {
			console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
		},
		allocTextureUnit: function() {
			console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
		},
		setTexture: function() {
			console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
		},
		setTexture2D: function() {
			console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
		},
		setTextureCube: function() {
			console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
		},
		getActiveMipMapLevel: function() {
			console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
			return this.getActiveMipmapLevel()
		}
	});
	ja(Xm.prototype, {
		shadowMapEnabled: {
			get: function() {
				return this.shadowMap.enabled
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
				this.shadowMap.enabled = a
			}
		},
		shadowMapType: {
			get: function() {
				return this.shadowMap.type
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
				this.shadowMap.type = a
			}
		},
		shadowMapCullFace: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
			}
		},
		context: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
				return this.getContext()
			}
		}
	});
	ja(Qm.prototype, {
		cullFace: {
			get: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
			}
		},
		renderReverseSided: {
			get: function() {
				console.warn(
					"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn(
					"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
			}
		},
		renderSingleSided: {
			get: function() {
				console.warn(
					"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
			},
			set: function() {
				console.warn(
					"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
			}
		}
	});
	ja(ec.prototype, {
		activeCubeFace: {
			set: function() {
				console.warn(
					"THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget()."
				)
			}
		},
		activeMipMapLevel: {
			set: function() {
				console.warn(
					"THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget()."
				)
			}
		}
	});
	ja(Oa.prototype, {
		wrapS: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
				return this.texture.wrapS
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
				this.texture.wrapS = a
			}
		},
		wrapT: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
				return this.texture.wrapT
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
				this.texture.wrapT = a
			}
		},
		magFilter: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
				return this.texture.magFilter
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
				this.texture.magFilter = a
			}
		},
		minFilter: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
				return this.texture.minFilter
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
				this.texture.minFilter = a
			}
		},
		anisotropy: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
				return this.texture.anisotropy
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
				this.texture.anisotropy = a
			}
		},
		offset: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
				return this.texture.offset
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
				this.texture.offset = a
			}
		},
		repeat: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
				return this.texture.repeat
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
				this.texture.repeat = a
			}
		},
		format: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
				return this.texture.format
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
				this.texture.format = a
			}
		},
		type: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
				return this.texture.type
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
				this.texture.type = a
			}
		},
		generateMipmaps: {
			get: function() {
				console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
				return this.texture.generateMipmaps
			},
			set: function(a) {
				console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
				this.texture.generateMipmaps = a
			}
		}
	});
	ja(fk.prototype, {
		standing: {
			set: function() {
				console.warn("THREE.WebVRManager: .standing has been removed.")
			}
		},
		userHeight: {
			set: function() {
				console.warn("THREE.WebVRManager: .userHeight has been removed.")
			}
		}
	});
	Tf.prototype.load = function(a) {
		console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
		var b = this;
		(new dl).load(a, function(a) {
			b.setBuffer(a)
		});
		return this
	};
	zn.prototype.getData = function() {
		console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
		return this.getFrequencyData()
	};
	Oe.prototype.updateCubeMap = function(a, b) {
		console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
		return this.update(a, b)
	};
	rc.crossOrigin = void 0;
	rc.loadTexture = function(a,
		b, c, d) {
		console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
		var e = new mj;
		e.setCrossOrigin(this.crossOrigin);
		a = e.load(a, c, void 0, d);
		b && (a.mapping = b);
		return a
	};
	rc.loadTextureCube = function(a, b, c, d) {
		console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
		var e = new lj;
		e.setCrossOrigin(this.crossOrigin);
		a = e.load(a, c, void 0, d);
		b && (a.mapping = b);
		return a
	};
	rc.loadCompressedTexture = function() {
		console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
	};
	rc.loadCompressedTextureCube = function() {
		console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
	};
	"undefined" !== typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
		detail: {
			revision: "109"
		}
	}));
	var ld = {
		uniforms: {
			tDiffuse: {
				value: null
			},
			opacity: {
				value: 1
			}
		},
		vertexShader: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
		fragmentShader: "uniform float opacity;\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tgl_FragColor = opacity * texel;\n}"
	};
	q(db.prototype, {
		setSize: function() {},
		render: function() {
			console.error("THREE.Pass: .render() must be implemented in derived pass.")
		}
	});
	db.FullScreenQuad = function() {
		var a = new Lc(-1, 1, 1, -1, 0, 1),
			b = new Xd(2, 2),
			c = function(a) {
				this._mesh = new Wa(b, a)
			};
		Object.defineProperty(c.prototype, "material", {
			get: function() {
				return this._mesh.material
			},
			set: function(a) {
				this._mesh.material = a
			}
		});
		q(c.prototype, {
			render: function(b) {
				b.render(this._mesh, a)
			}
		});
		return c
	}();
	var Li = function(a, b) {
		db.call(this);
		this.textureID = void 0 !==
			b ? b : "tDiffuse";
		a instanceof Ia ? (this.uniforms = a.uniforms, this.material = a) : a && (this.uniforms = Ee.clone(a.uniforms),
			this.material = new Ia({
				defines: q({}, a.defines),
				uniforms: this.uniforms,
				vertexShader: a.vertexShader,
				fragmentShader: a.fragmentShader
			}));
		this.fsQuad = new db.FullScreenQuad(this.material)
	};
	Li.prototype = q(p(db.prototype), {
		constructor: Li,
		render: function(a, b, c) {
			this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = c.texture);
			this.fsQuad.material = this.material;
			this.renderToScreen ? a.setRenderTarget(null) :
				(a.setRenderTarget(b), this.clear && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil));
			this.fsQuad.render(a)
		}
	});
	var xg = function(a, b) {
		db.call(this);
		this.scene = a;
		this.camera = b;
		this.clear = !0;
		this.inverse = this.needsSwap = !1
	};
	xg.prototype = q(p(db.prototype), {
		constructor: xg,
		render: function(a, b, c) {
			var d = a.getContext(),
				e = a.state;
			e.buffers.color.setMask(!1);
			e.buffers.depth.setMask(!1);
			e.buffers.color.setLocked(!0);
			e.buffers.depth.setLocked(!0);
			if (this.inverse) {
				var g = 0;
				var k = 1
			} else g = 1, k = 0;
			e.buffers.stencil.setTest(!0);
			e.buffers.stencil.setOp(d.REPLACE, d.REPLACE, d.REPLACE);
			e.buffers.stencil.setFunc(d.ALWAYS, g, 4294967295);
			e.buffers.stencil.setClear(k);
			e.buffers.stencil.setLocked(!0);
			a.setRenderTarget(c);
			this.clear && a.clear();
			a.render(this.scene, this.camera);
			a.setRenderTarget(b);
			this.clear && a.clear();
			a.render(this.scene, this.camera);
			e.buffers.color.setLocked(!1);
			e.buffers.depth.setLocked(!1);
			e.buffers.stencil.setLocked(!1);
			e.buffers.stencil.setFunc(d.EQUAL, 1, 4294967295);
			e.buffers.stencil.setOp(d.KEEP, d.KEEP, d.KEEP);
			e.buffers.stencil.setLocked(!0)
		}
	});
	var km = function() {
		db.call(this);
		this.needsSwap = !1
	};
	km.prototype = p(db.prototype);
	q(km.prototype, {
		render: function(a) {
			a.state.buffers.stencil.setLocked(!1);
			a.state.buffers.stencil.setTest(!1)
		}
	});
	var np = function(a, b) {
		this.renderer = a;
		void 0 === b ? (b = a.getSize(new B), this._pixelRatio = a.getPixelRatio(), this._width = b.width, this._height = b
			.height, b = new Oa(this._width * this._pixelRatio, this._height * this._pixelRatio, {
				minFilter: 1006,
				magFilter: 1006,
				format: 1023,
				stencilBuffer: !1
			}),
			b.texture.name = "EffectComposer.rt1") : (this._pixelRatio = 1, this._width = b.width, this._height = b.height);
		this.renderTarget1 = b;
		this.renderTarget2 = b.clone();
		this.renderTarget2.texture.name = "EffectComposer.rt2";
		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;
		this.renderToScreen = !0;
		this.passes = [];
		void 0 === ld && console.error("THREE.EffectComposer relies on CopyShader");
		void 0 === Li && console.error("THREE.EffectComposer relies on ShaderPass");
		this.copyPass = new Li(ld);
		this.clock = new fl
	};
	q(np.prototype, {
		swapBuffers: function() {
			var a = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = a
		},
		addPass: function(a) {
			this.passes.push(a);
			a.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio)
		},
		insertPass: function(a, b) {
			this.passes.splice(b, 0, a)
		},
		isLastEnabledPass: function(a) {
			for (a += 1; a < this.passes.length; a++)
				if (this.passes[a].enabled) return !1;
			return !0
		},
		render: function(a) {
			void 0 === a && (a = this.clock.getDelta());
			var b = this.renderer.getRenderTarget(),
				c = !1,
				d, e = this.passes.length;
			for (d = 0; d <
				e; d++) {
				var g = this.passes[d];
				if (!1 !== g.enabled) {
					g.renderToScreen = this.renderToScreen && this.isLastEnabledPass(d);
					g.render(this.renderer, this.writeBuffer, this.readBuffer, a, c);
					if (g.needsSwap) {
						if (c) {
							var k = this.renderer.getContext(),
								l = this.renderer.state.buffers.stencil;
							l.setFunc(k.NOTEQUAL, 1, 4294967295);
							this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, a);
							l.setFunc(k.EQUAL, 1, 4294967295)
						}
						this.swapBuffers()
					}
					void 0 !== xg && (g instanceof xg ? c = !0 : g instanceof km && (c = !1))
				}
			}
			this.renderer.setRenderTarget(b)
		},
		reset: function(a) {
			void 0 === a && (a = this.renderer.getSize(new B), this._pixelRatio = this.renderer.getPixelRatio(), this._width =
				a.width, this._height = a.height, a = this.renderTarget1.clone(), a.setSize(this._width * this._pixelRatio,
					this._height * this._pixelRatio));
			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.renderTarget1 = a;
			this.renderTarget2 = a.clone();
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2
		},
		setSize: function(a, b) {
			this._width = a;
			this._height = b;
			a = this._width * this._pixelRatio;
			b = this._height * this._pixelRatio;
			this.renderTarget1.setSize(a, b);
			this.renderTarget2.setSize(a, b);
			for (var c = 0; c < this.passes.length; c++) this.passes[c].setSize(a, b)
		},
		setPixelRatio: function(a) {
			this._pixelRatio = a;
			this.setSize(this._width, this._height)
		}
	});
	var op = function() {
		this.needsSwap = this.enabled = !0;
		this.renderToScreen = this.clear = !1
	};
	q(op.prototype, {
		setSize: function() {},
		render: function() {
			console.error("THREE.Pass: .render() must be implemented in derived pass.")
		}
	});
	op.FullScreenQuad = function() {
		var a =
			new Lc(-1, 1, 1, -1, 0, 1),
			b = new Xd(2, 2),
			c = function(a) {
				this._mesh = new Wa(b, a)
			};
		Object.defineProperty(c.prototype, "material", {
			get: function() {
				return this._mesh.material
			},
			set: function(a) {
				this._mesh.material = a
			}
		});
		q(c.prototype, {
			render: function(b) {
				b.render(this._mesh, a)
			}
		});
		return c
	}();
	var th = function(a, b, c, d, e) {
		db.call(this);
		this.scene = a;
		this.camera = b;
		this.overrideMaterial = c;
		this.clearColor = d;
		this.clearAlpha = void 0 !== e ? e : 0;
		this.clear = !0;
		this.needsSwap = this.clearDepth = !1
	};
	th.prototype = q(p(db.prototype), {
		constructor: th,
		render: function(a, b, c) {
			b = a.autoClear;
			a.autoClear = !1;
			this.scene.overrideMaterial = this.overrideMaterial;
			if (this.clearColor) {
				var d = a.getClearColor().getHex();
				var e = a.getClearAlpha();
				a.setClearColor(this.clearColor, this.clearAlpha)
			}
			this.clearDepth && a.clearDepth();
			a.setRenderTarget(this.renderToScreen ? null : c);
			this.clear && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
			a.render(this.scene, this.camera);
			this.clearColor && a.setClearColor(d, e);
			this.scene.overrideMaterial = null;
			a.autoClear = b
		}
	});
	var uh = {
			defines: {
				SMAA_THRESHOLD: "0.1"
			},
			uniforms: {
				tDiffuse: {
					value: null
				},
				resolution: {
					value: new B(1 / 1024, 1 / 512)
				}
			},
			vertexShader: "uniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 3 ];\nvoid SMAAEdgeDetectionVS( vec2 texcoord ) {\n\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0,  1.0 );\n\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4(  1.0, 0.0, 0.0, -1.0 );\n\tvOffset[ 2 ] = texcoord.xyxy + resolution.xyxy * vec4( -2.0, 0.0, 0.0,  2.0 );\n}\nvoid main() {\n\tvUv = uv;\n\tSMAAEdgeDetectionVS( vUv );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			fragmentShader: "uniform sampler2D tDiffuse;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 3 ];\nvec4 SMAAColorEdgeDetectionPS( vec2 texcoord, vec4 offset[3], sampler2D colorTex ) {\n\tvec2 threshold = vec2( SMAA_THRESHOLD, SMAA_THRESHOLD );\n\tvec4 delta;\n\tvec3 C = texture2D( colorTex, texcoord ).rgb;\n\tvec3 Cleft = texture2D( colorTex, offset[0].xy ).rgb;\n\tvec3 t = abs( C - Cleft );\n\tdelta.x = max( max( t.r, t.g ), t.b );\n\tvec3 Ctop = texture2D( colorTex, offset[0].zw ).rgb;\n\tt = abs( C - Ctop );\n\tdelta.y = max( max( t.r, t.g ), t.b );\n\tvec2 edges = step( threshold, delta.xy );\n\tif ( dot( edges, vec2( 1.0, 1.0 ) ) == 0.0 )\n\t\tdiscard;\n\tvec3 Cright = texture2D( colorTex, offset[1].xy ).rgb;\n\tt = abs( C - Cright );\n\tdelta.z = max( max( t.r, t.g ), t.b );\n\tvec3 Cbottom  = texture2D( colorTex, offset[1].zw ).rgb;\n\tt = abs( C - Cbottom );\n\tdelta.w = max( max( t.r, t.g ), t.b );\n\tfloat maxDelta = max( max( max( delta.x, delta.y ), delta.z ), delta.w );\n\tvec3 Cleftleft  = texture2D( colorTex, offset[2].xy ).rgb;\n\tt = abs( C - Cleftleft );\n\tdelta.z = max( max( t.r, t.g ), t.b );\n\tvec3 Ctoptop = texture2D( colorTex, offset[2].zw ).rgb;\n\tt = abs( C - Ctoptop );\n\tdelta.w = max( max( t.r, t.g ), t.b );\n\tmaxDelta = max( max( maxDelta, delta.z ), delta.w );\n\tedges.xy *= step( 0.5 * maxDelta, delta.xy );\n\treturn vec4( edges, 0.0, 0.0 );\n}\nvoid main() {\n\tgl_FragColor = SMAAColorEdgeDetectionPS( vUv, vOffset, tDiffuse );\n}"
		},
		dt = {
			SMAA_MAX_SEARCH_STEPS: "8",
			SMAA_AREATEX_MAX_DISTANCE: "16",
			SMAA_AREATEX_PIXEL_SIZE: "( 1.0 / vec2( 160.0, 560.0 ) )",
			SMAA_AREATEX_SUBTEX_SIZE: "( 1.0 / 7.0 )"
		},
		et = {
			tDiffuse: {
				value: null
			},
			tArea: {
				value: null
			},
			tSearch: {
				value: null
			},
			resolution: {
				value: new B(1 / 1024, 1 / 512)
			}
		},
		ft = {
			tDiffuse: {
				value: null
			},
			tColor: {
				value: null
			},
			resolution: {
				value: new B(1 / 1024, 1 / 512)
			}
		},
		lm = function(a, b) {
			db.call(this);
			this.edgesRT = new Oa(a, b, {
				depthBuffer: !1,
				stencilBuffer: !1,
				generateMipmaps: !1,
				minFilter: 1006,
				format: 1022
			});
			this.edgesRT.texture.name =
				"SMAAPass.edges";
			this.weightsRT = new Oa(a, b, {
				depthBuffer: !1,
				stencilBuffer: !1,
				generateMipmaps: !1,
				minFilter: 1006,
				format: 1023
			});
			this.weightsRT.texture.name = "SMAAPass.weights";
			var c = this,
				d = new Image;
			d.src = this.getAreaTexture();
			d.onload = function() {
				c.areaTexture.needsUpdate = !0
			};
			this.areaTexture = new pa;
			this.areaTexture.name = "SMAAPass.area";
			this.areaTexture.image = d;
			this.areaTexture.format = 1022;
			this.areaTexture.minFilter = 1006;
			this.areaTexture.generateMipmaps = !1;
			this.areaTexture.flipY = !1;
			d = new Image;
			d.src = this.getSearchTexture();
			d.onload = function() {
				c.searchTexture.needsUpdate = !0
			};
			this.searchTexture = new pa;
			this.searchTexture.name = "SMAAPass.search";
			this.searchTexture.image = d;
			this.searchTexture.magFilter = 1003;
			this.searchTexture.minFilter = 1003;
			this.searchTexture.generateMipmaps = !1;
			this.searchTexture.flipY = !1;
			void 0 === uh && console.error("SMAAPass relies on SMAAShader");
			this.uniformsEdges = Ee.clone(uh.uniforms);
			this.uniformsEdges.resolution.value.set(1 / a, 1 / b);
			this.materialEdges = new Ia({
				defines: q({}, uh.defines),
				uniforms: this.uniformsEdges,
				vertexShader: uh.vertexShader,
				fragmentShader: uh.fragmentShader
			});
			this.uniformsWeights = Ee.clone(et);
			this.uniformsWeights.resolution.value.set(1 / a, 1 / b);
			this.uniformsWeights.tDiffuse.value = this.edgesRT.texture;
			this.uniformsWeights.tArea.value = this.areaTexture;
			this.uniformsWeights.tSearch.value = this.searchTexture;
			this.materialWeights = new Ia({
				defines: q({}, dt),
				uniforms: this.uniformsWeights,
				vertexShader: "uniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 3 ];\nvarying vec2 vPixcoord;\nvoid SMAABlendingWeightCalculationVS( vec2 texcoord ) {\n\tvPixcoord = texcoord / resolution;\n\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.25, 0.125, 1.25, 0.125 );\n\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( -0.125, 0.25, -0.125, -1.25 );\n\tvOffset[ 2 ] = vec4( vOffset[ 0 ].xz, vOffset[ 1 ].yw ) + vec4( -2.0, 2.0, -2.0, 2.0 ) * resolution.xxyy * float( SMAA_MAX_SEARCH_STEPS );\n}\nvoid main() {\n\tvUv = uv;\n\tSMAABlendingWeightCalculationVS( vUv );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
				fragmentShader: "#define SMAASampleLevelZeroOffset( tex, coord, offset ) texture2D( tex, coord + float( offset ) * resolution, 0.0 )\nuniform sampler2D tDiffuse;\nuniform sampler2D tArea;\nuniform sampler2D tSearch;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[3];\nvarying vec2 vPixcoord;\n#if __VERSION__ == 100\nvec2 round( vec2 x ) {\n\treturn sign( x ) * floor( abs( x ) + 0.5 );\n}\n#endif\nfloat SMAASearchLength( sampler2D searchTex, vec2 e, float bias, float scale ) {\n\te.r = bias + e.r * scale;\n\treturn 255.0 * texture2D( searchTex, e, 0.0 ).r;\n}\nfloat SMAASearchXLeft( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\tvec2 e = vec2( 0.0, 1.0 );\n\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\n\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\ttexcoord -= vec2( 2.0, 0.0 ) * resolution;\n\t\tif ( ! ( texcoord.x > end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t}\n\ttexcoord.x += 0.25 * resolution.x;\n\ttexcoord.x += resolution.x;\n\ttexcoord.x += 2.0 * resolution.x;\n\ttexcoord.x -= resolution.x * SMAASearchLength(searchTex, e, 0.0, 0.5);\n\treturn texcoord.x;\n}\nfloat SMAASearchXRight( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\tvec2 e = vec2( 0.0, 1.0 );\n\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\n\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\ttexcoord += vec2( 2.0, 0.0 ) * resolution;\n\t\tif ( ! ( texcoord.x < end && e.g > 0.8281 && e.r == 0.0 ) ) break;\n\t}\n\ttexcoord.x -= 0.25 * resolution.x;\n\ttexcoord.x -= resolution.x;\n\ttexcoord.x -= 2.0 * resolution.x;\n\ttexcoord.x += resolution.x * SMAASearchLength( searchTex, e, 0.5, 0.5 );\n\treturn texcoord.x;\n}\nfloat SMAASearchYUp( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\tvec2 e = vec2( 1.0, 0.0 );\n\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\n\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\ttexcoord += vec2( 0.0, 2.0 ) * resolution;\n\t\tif ( ! ( texcoord.y > end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t}\n\ttexcoord.y -= 0.25 * resolution.y;\n\ttexcoord.y -= resolution.y;\n\ttexcoord.y -= 2.0 * resolution.y;\n\ttexcoord.y += resolution.y * SMAASearchLength( searchTex, e.gr, 0.0, 0.5 );\n\treturn texcoord.y;\n}\nfloat SMAASearchYDown( sampler2D edgesTex, sampler2D searchTex, vec2 texcoord, float end ) {\n\tvec2 e = vec2( 1.0, 0.0 );\n\tfor ( int i = 0; i < SMAA_MAX_SEARCH_STEPS; i ++ ) {\n\t\te = texture2D( edgesTex, texcoord, 0.0 ).rg;\n\t\ttexcoord -= vec2( 0.0, 2.0 ) * resolution;\n\t\tif ( ! ( texcoord.y < end && e.r > 0.8281 && e.g == 0.0 ) ) break;\n\t}\n\ttexcoord.y += 0.25 * resolution.y;\n\ttexcoord.y += resolution.y;\n\ttexcoord.y += 2.0 * resolution.y;\n\ttexcoord.y -= resolution.y * SMAASearchLength( searchTex, e.gr, 0.5, 0.5 );\n\treturn texcoord.y;\n}\nvec2 SMAAArea( sampler2D areaTex, vec2 dist, float e1, float e2, float offset ) {\n\tvec2 texcoord = float( SMAA_AREATEX_MAX_DISTANCE ) * round( 4.0 * vec2( e1, e2 ) ) + dist;\n\ttexcoord = SMAA_AREATEX_PIXEL_SIZE * texcoord + ( 0.5 * SMAA_AREATEX_PIXEL_SIZE );\n\ttexcoord.y += SMAA_AREATEX_SUBTEX_SIZE * offset;\n\treturn texture2D( areaTex, texcoord, 0.0 ).rg;\n}\nvec4 SMAABlendingWeightCalculationPS( vec2 texcoord, vec2 pixcoord, vec4 offset[ 3 ], sampler2D edgesTex, sampler2D areaTex, sampler2D searchTex, ivec4 subsampleIndices ) {\n\tvec4 weights = vec4( 0.0, 0.0, 0.0, 0.0 );\n\tvec2 e = texture2D( edgesTex, texcoord ).rg;\n\tif ( e.g > 0.0 ) {\n\t\tvec2 d;\n\t\tvec2 coords;\n\t\tcoords.x = SMAASearchXLeft( edgesTex, searchTex, offset[ 0 ].xy, offset[ 2 ].x );\n\t\tcoords.y = offset[ 1 ].y;\n\t\td.x = coords.x;\n\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).r;\n\t\tcoords.x = SMAASearchXRight( edgesTex, searchTex, offset[ 0 ].zw, offset[ 2 ].y );\n\t\td.y = coords.x;\n\t\td = d / resolution.x - pixcoord.x;\n\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\t\tcoords.y -= 1.0 * resolution.y;\n\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 1, 0 ) ).r;\n\t\tweights.rg = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.y ) );\n\t}\n\tif ( e.r > 0.0 ) {\n\t\tvec2 d;\n\t\tvec2 coords;\n\t\tcoords.y = SMAASearchYUp( edgesTex, searchTex, offset[ 1 ].xy, offset[ 2 ].z );\n\t\tcoords.x = offset[ 0 ].x;\n\t\td.x = coords.y;\n\t\tfloat e1 = texture2D( edgesTex, coords, 0.0 ).g;\n\t\tcoords.y = SMAASearchYDown( edgesTex, searchTex, offset[ 1 ].zw, offset[ 2 ].w );\n\t\td.y = coords.y;\n\t\td = d / resolution.y - pixcoord.y;\n\t\tvec2 sqrt_d = sqrt( abs( d ) );\n\t\tcoords.y -= 1.0 * resolution.y;\n\t\tfloat e2 = SMAASampleLevelZeroOffset( edgesTex, coords, ivec2( 0, 1 ) ).g;\n\t\tweights.ba = SMAAArea( areaTex, sqrt_d, e1, e2, float( subsampleIndices.x ) );\n\t}\n\treturn weights;\n}\nvoid main() {\n\tgl_FragColor = SMAABlendingWeightCalculationPS( vUv, vPixcoord, vOffset, tDiffuse, tArea, tSearch, ivec4( 0.0 ) );\n}"
			});
			this.uniformsBlend = Ee.clone(ft);
			this.uniformsBlend.resolution.value.set(1 / a, 1 / b);
			this.uniformsBlend.tDiffuse.value = this.weightsRT.texture;
			this.materialBlend = new Ia({
				uniforms: this.uniformsBlend,
				vertexShader: "uniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 2 ];\nvoid SMAANeighborhoodBlendingVS( vec2 texcoord ) {\n\tvOffset[ 0 ] = texcoord.xyxy + resolution.xyxy * vec4( -1.0, 0.0, 0.0, 1.0 );\n\tvOffset[ 1 ] = texcoord.xyxy + resolution.xyxy * vec4( 1.0, 0.0, 0.0, -1.0 );\n}\nvoid main() {\n\tvUv = uv;\n\tSMAANeighborhoodBlendingVS( vUv );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
				fragmentShader: "uniform sampler2D tDiffuse;\nuniform sampler2D tColor;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvarying vec4 vOffset[ 2 ];\nvec4 SMAANeighborhoodBlendingPS( vec2 texcoord, vec4 offset[ 2 ], sampler2D colorTex, sampler2D blendTex ) {\n\tvec4 a;\n\ta.xz = texture2D( blendTex, texcoord ).xz;\n\ta.y = texture2D( blendTex, offset[ 1 ].zw ).g;\n\ta.w = texture2D( blendTex, offset[ 1 ].xy ).a;\n\tif ( dot(a, vec4( 1.0, 1.0, 1.0, 1.0 )) < 1e-5 ) {\n\t\treturn texture2D( colorTex, texcoord, 0.0 );\n\t} else {\n\t\tvec2 offset;\n\t\toffset.x = a.a > a.b ? a.a : -a.b;\n\t\toffset.y = a.g > a.r ? -a.g : a.r;\n\t\tif ( abs( offset.x ) > abs( offset.y )) {\n\t\t\toffset.y = 0.0;\n\t\t} else {\n\t\t\toffset.x = 0.0;\n\t\t}\n\t\tvec4 C = texture2D( colorTex, texcoord, 0.0 );\n\t\ttexcoord += sign( offset ) * resolution;\n\t\tvec4 Cop = texture2D( colorTex, texcoord, 0.0 );\n\t\tfloat s = abs( offset.x ) > abs( offset.y ) ? abs( offset.x ) : abs( offset.y );\n\t\tC.xyz = pow(C.xyz, vec3(2.2));\n\t\tCop.xyz = pow(Cop.xyz, vec3(2.2));\n\t\tvec4 mixed = mix(C, Cop, s);\n\t\tmixed.xyz = pow(mixed.xyz, vec3(1.0 / 2.2));\n\t\treturn mixed;\n\t}\n}\nvoid main() {\n\tgl_FragColor = SMAANeighborhoodBlendingPS( vUv, vOffset, tColor, tDiffuse );\n}"
			});
			this.needsSwap = !1;
			this.fsQuad = new db.FullScreenQuad(null)
		};
	lm.prototype = q(p(db.prototype), {
		constructor: lm,
		render: function(a, b, c) {
			this.uniformsEdges.tDiffuse.value = c.texture;
			this.fsQuad.material = this.materialEdges;
			a.setRenderTarget(this.edgesRT);
			this.clear && a.clear();
			this.fsQuad.render(a);
			this.fsQuad.material = this.materialWeights;
			a.setRenderTarget(this.weightsRT);
			this.clear && a.clear();
			this.fsQuad.render(a);
			this.uniformsBlend.tColor.value = c.texture;
			this.fsQuad.material = this.materialBlend;
			this.renderToScreen ?
				a.setRenderTarget(null) : (a.setRenderTarget(b), this.clear && a.clear());
			this.fsQuad.render(a)
		},
		setSize: function(a, b) {
			this.edgesRT.setSize(a, b);
			this.weightsRT.setSize(a, b);
			this.materialEdges.uniforms.resolution.value.set(1 / a, 1 / b);
			this.materialWeights.uniforms.resolution.value.set(1 / a, 1 / b);
			this.materialBlend.uniforms.resolution.value.set(1 / a, 1 / b)
		},
		getAreaTexture: function() {
			return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAIAAACOVPcQAACBeklEQVR42u39W4xlWXrnh/3WWvuciIzMrKxrV8/0rWbY0+SQFKcb4owIkSIFCjY9AC1BT/LYBozRi+EX+cV+8IMsYAaCwRcBwjzMiw2jAWtgwC8WR5Q8mDFHZLNHTarZGrLJJllt1W2qKrsumZWZcTvn7L3W54e1vrXX3vuciLPPORFR1XE2EomorB0nVuz//r71re/y/1eMvb4Cb3N11xV/PP/2v4UBAwJG/7H8urx6/25/Gf8O5hypMQ0EEEQwAqLfoN/Z+97f/SW+/NvcgQk4sGBJK6H7N4PFVL+K+e0N11yNfkKvwUdwdlUAXPHHL38oa15f/i/46Ih6SuMSPmLAYAwyRKn7dfMGH97jaMFBYCJUgotIC2YAdu+LyW9vvubxAP8kAL8H/koAuOKP3+q6+xGnd5kdYCeECnGIJViwGJMAkQKfDvB3WZxjLKGh8VSCCzhwEWBpMc5/kBbjawT4HnwJfhr+pPBIu7uu+OOTo9vsmtQcniMBGkKFd4jDWMSCRUpLjJYNJkM+IRzQ+PQvIeAMTrBS2LEiaiR9b/5PuT6Ap/AcfAFO4Y3dA3DFH7/VS+M8k4baEAQfMI4QfbVDDGIRg7GKaIY52qAjTAgTvGBAPGIIghOCYAUrGFNgzA7Q3QhgCwfwAnwe5vDejgG44o/fbm1C5ZlYQvQDARPAIQGxCWBM+wWl37ZQESb4gImexGMDouhGLx1Cst0Saa4b4AqO4Hk4gxo+3DHAV/nx27p3JziPM2pVgoiia5MdEzCGULprIN7gEEeQ5IQxEBBBQnxhsDb5auGmAAYcHMA9eAAz8PBol8/xij9+C4Djlim4gJjWcwZBhCBgMIIYxGAVIkH3ZtcBuLdtRFMWsPGoY9rN+HoBji9VBYdwD2ZQg4cnO7OSq/z4rU5KKdwVbFAjNojCQzTlCLPFSxtamwh2jMUcEgg2Wm/6XgErIBhBckQtGN3CzbVacERgCnfgLswhnvqf7QyAq/z4rRZm1YglYE3affGITaZsdIe2FmMIpnOCap25I6jt2kCwCW0D1uAD9sZctNGXcQIHCkINDQgc78aCr+zjtw3BU/ijdpw3zhCwcaONwBvdeS2YZKkJNJsMPf2JKEvC28RXxxI0ASJyzQCjCEQrO4Q7sFArEzjZhaFc4cdv+/JFdKULM4px0DfUBI2hIsy06BqLhGTQEVdbfAIZXYMPesq6VoCHICzUyjwInO4Y411//LYLs6TDa9wvg2CC2rElgAnpTBziThxaL22MYhzfkghz6GAs2VHbbdM91VZu1MEEpupMMwKyVTb5ij9+u4VJG/5EgEMMmFF01cFai3isRbKbzb+YaU/MQbAm2XSMoUPAmvZzbuKYRIFApbtlrfFuUGd6vq2hXNnH78ZLh/iFhsQG3T4D1ib7k5CC6vY0DCbtrohgLEIClXiGtl10zc0CnEGIhhatLBva7NP58Tvw0qE8yWhARLQ8h4+AhQSP+I4F5xoU+VilGRJs6wnS7ruti/4KvAY/CfdgqjsMy4pf8fodQO8/gnuX3f/3xi3om1/h7THr+co3x93PP9+FBUfbNUjcjEmhcrkT+8K7ml7V10Jo05mpIEFy1NmCJWx9SIKKt+EjAL4Ez8EBVOB6havuT/rByPvHXK+9zUcfcbb254+9fydJknYnRr1oGfdaiAgpxu1Rx/Rek8KISftx3L+DfsLWAANn8Hvw0/AFeAGO9DFV3c6D+CcWbL8Dj9e7f+T1k8AZv/d7+PXWM/Z+VvdCrIvuAKO09RpEEQJM0Ci6+B4xhTWr4cZNOvhktabw0ta0rSJmqz3Yw5/AKXwenod7cAhTmBSPKf6JBdvH8IP17h95pXqw50/+BFnj88fev4NchyaK47OPhhtI8RFSvAfDSNh0Ck0p2gLxGkib5NJj/JWCr90EWQJvwBzO4AHcgztwAFN1evHPUVGwfXON+0debT1YeGON9Yy9/63X+OguiwmhIhQhD7l4sMqlG3D86Suc3qWZ4rWjI1X7u0Ytw6x3rIMeIOPDprfe2XzNgyj6PahhBjO4C3e6puDgXrdg+/5l948vF3bqwZetZ+z9Rx9zdIY5pInPK4Nk0t+l52xdK2B45Qd87nM8fsD5EfUhIcJcERw4RdqqH7Yde5V7m1vhNmtedkz6EDzUMF/2jJYWbC+4fzzA/Y+/8PPH3j9dcBAPIRP8JLXd5BpAu03aziOL3VVHZzz3CXWDPWd+SH2AnxIqQoTZpo9Ckc6HIrFbAbzNmlcg8Ag8NFDDAhbJvTBZXbC94P7t68EXfv6o+21gUtPETU7bbkLxvNKRFG2+KXzvtObonPP4rBvsgmaKj404DlshFole1Glfh02fE7bYR7dZ82oTewIBGn1Md6CG6YUF26X376oevOLzx95vhUmgblI6LBZwTCDY7vMq0op5WVXgsObOXJ+1x3qaBl9j1FeLxbhU9w1F+Wiba6s1X/TBz1LnUfuYDi4r2C69f1f14BWfP+p+W2GFKuC9phcELMYRRLur9DEZTUdEH+iEqWdaM7X4WOoPGI+ZYD2+wcQ+y+ioHUZ9dTDbArzxmi/bJI9BND0Ynd6lBdve/butBw8+f/T9D3ABa3AG8W3VPX4hBin+bj8dMMmSpp5pg7fJ6xrBFE2WQQEWnV8Qg3FbAWzYfM1rREEnmvkN2o1+acG2d/9u68GDzx91v3mAjb1zkpqT21OipPKO0b9TO5W0nTdOmAQm0TObts3aBKgwARtoPDiCT0gHgwnbArzxmtcLc08HgF1asN0C4Ms/fvD5I+7PhfqyXE/b7RbbrGyRQRT9ARZcwAUmgdoz0ehJ9Fn7QAhUjhDAQSw0bV3T3WbNa59jzmiP6GsWbGXDX2ytjy8+f9T97fiBPq9YeLdBmyuizZHaqXITnXiMUEEVcJ7K4j3BFPurtB4bixW8wTpweL8DC95szWMOqucFYGsWbGU7p3TxxxefP+r+oTVktxY0v5hbq3KiOKYnY8ddJVSBxuMMVffNbxwIOERShst73HZ78DZrHpmJmH3K6sGz0fe3UUj0eyRrSCGTTc+rjVNoGzNSv05srAxUBh8IhqChiQgVNIIBH3AVPnrsnXQZbLTm8ammv8eVXn/vWpaTem5IXRlt+U/LA21zhSb9cye6jcOfCnOwhIAYXAMVTUNV0QhVha9xjgA27ODJbLbmitt3tRN80lqG6N/khgot4ZVlOyO4WNg3OIMzhIZQpUEHieg2im6F91hB3I2tubql6BYNN9Hj5S7G0G2tahslBWKDnOiIvuAEDzakDQKDNFQT6gbn8E2y4BBubM230YIpBnDbMa+y3dx0n1S0BtuG62lCCXwcY0F72T1VRR3t2ONcsmDjbmzNt9RFs2LO2hQNyb022JisaI8rAWuw4HI3FuAIhZdOGIcdjLJvvObqlpqvWTJnnQbyi/1M9O8UxWhBs//H42I0q1Yb/XPGONzcmm+ri172mHKvZBpHkJaNJz6v9jxqiklDj3U4CA2ugpAaYMWqNXsdXbmJNd9egCnJEsphXNM+MnK3m0FCJ5S1kmJpa3DgPVbnQnPGWIDspW9ozbcO4K/9LkfaQO2KHuqlfFXSbdNzcEcwoqNEFE9zcIXu9/6n/ym/BC/C3aJLzEKPuYVlbFnfhZ8kcWxV3dbv4bKl28566wD+8C53aw49lTABp9PWbsB+knfc/Li3eVizf5vv/xmvnPKg5ihwKEwlrcHqucuVcVOxEv8aH37E3ZqpZypUulrHEtIWKUr+txHg+ojZDGlwnqmkGlzcVi1dLiNSJiHjfbRNOPwKpx9TVdTn3K05DBx4psIk4Ei8aCkJahRgffk4YnEXe07T4H2RR1u27E6wfQsBDofUgjFUFnwC2AiVtA+05J2zpiDK2Oa0c5fmAecN1iJzmpqFZxqYBCYhFTCsUNEmUnIcZ6aEA5rQVhEywG6w7HSW02XfOoBlQmjwulOFQAg66SvJblrTEX1YtJ3uG15T/BH1OfOQeuR8g/c0gdpT5fx2SKbs9EfHTKdM8A1GaJRHLVIwhcGyydZsbifAFVKl5EMKNU2Hryo+06BeTgqnxzYjThVySDikbtJPieco75lYfKAJOMEZBTjoITuWHXXZVhcUDIS2hpiXHV9Ku4u44bN5OYLDOkJo8w+xJSMbhBRHEdEs9JZUCkQrPMAvaHyLkxgkEHxiNkx/x2YB0mGsQ8EUWj/stW5YLhtS5SMu+/YBbNPDCkGTUybN8krRLBGPlZkVOA0j+a1+rkyQKWGaPHPLZOkJhioQYnVZ2hS3zVxMtgC46KuRwbJNd9nV2PHgb36F194ecf/Yeu2vAFe5nm/bRBFrnY4BauE8ERmZRFUn0k8hbftiVYSKMEme2dJCJSCGYAlNqh87bXOPdUkGy24P6d1ll21MBqqx48Fvv8ZHH8HZFY7j/uAq1xMJUFqCSUlJPmNbIiNsmwuMs/q9CMtsZsFO6SprzCS1Z7QL8xCQClEelpjTduDMsmWD8S1PT152BtvmIGvUeDA/yRn83u/x0/4qxoPHjx+PXY9pqX9bgMvh/Nz9kpP4pOe1/fYf3axUiMdHLlPpZCNjgtNFAhcHEDxTumNONhHrBduW+vOyY++70WWnPXj98eA4kOt/mj/5E05l9+O4o8ePx67HFqyC+qSSnyselqjZGaVK2TadbFLPWAQ4NBhHqDCCV7OTpo34AlSSylPtIdd2AJZlyzYQrDJ5lcWGNceD80CunPLGGzsfD+7wRb95NevJI5docQ3tgCyr5bGnyaPRlmwNsFELViOOx9loebGNq2moDOKpHLVP5al2cymWHbkfzGXL7kfRl44H9wZy33tvt+PB/Xnf93e+nh5ZlU18wCiRUa9m7kib9LYuOk+hudQNbxwm0AQqbfloimaB2lM5fChex+ylMwuTbfmXQtmWlenZljbdXTLuOxjI/fDDHY4Hjx8/Hrse0zXfPFxbUN1kKqSCCSk50m0Ajtx3ub9XHBKHXESb8iO6E+qGytF4nO0OG3SXzbJlhxBnKtKyl0NwybjvYCD30aMdjgePHz8eu56SVTBbgxJMliQ3Oauwg0QHxXE2Ez/EIReLdQj42Gzb4CLS0YJD9xUx7bsi0vJi5mUbW1QzL0h0PFk17rtiIPfJk52MB48fPx67npJJwyrBa2RCCQRTbGZSPCxTPOiND4G2pYyOQ4h4jINIJh5wFU1NFZt+IsZ59LSnDqBjZ2awbOku+yInunLcd8VA7rNnOxkPHj9+PGY9B0MWJJNozOJmlglvDMXDEozdhQWbgs/U6oBanGzLrdSNNnZFjOkmbi5bNt1lX7JLLhn3vXAg9/h4y/Hg8ePHI9dzQMEkWCgdRfYykYKnkP7D4rIujsujaKPBsB54vE2TS00ccvFY/Tth7JXeq1hz+qgVy04sAJawTsvOknHfCwdyT062HA8eP348Zj0vdoXF4pilKa2BROed+9fyw9rWRXeTFXESMOanvDZfJuJaSXouQdMdDJZtekZcLLvEeK04d8m474UDuaenW44Hjx8/Xns9YYqZpszGWB3AN/4VHw+k7WSFtJ3Qicuqb/NlVmgXWsxh570xg2UwxUw3WfO6B5nOuO8aA7lnZxuPB48fPx6znm1i4bsfcbaptF3zNT78eFPtwi1OaCNOqp1x3zUGcs/PN++AGD1+fMXrSVm2baTtPhPahbPhA71wIHd2bXzRa69nG+3CraTtPivahV/55tXWg8fyRY/9AdsY8VbSdp8V7cKrrgdfM//z6ILQFtJ2nxHtwmuoB4/kf74+gLeRtvvMaBdeSz34+vifx0YG20jbfTa0C6+tHrwe//NmOG0L8EbSdp8R7cLrrQe/996O+ai3ujQOskpTNULa7jOjXXj99eCd8lHvoFiwsbTdZ0a78PrrwTvlo966pLuRtB2fFe3Cm6oHP9kNH/W2FryxtN1nTLvwRurBO+Kj3pWXHidtx2dFu/Bm68Fb81HvykuPlrb7LGkX3mw9eGs+6h1Y8MbSdjegXcguQLjmevDpTQLMxtJ2N6NdyBZu9AbrwVvwUW+LbteULUpCdqm0HTelXbhNPe8G68Gb8lFvVfYfSNuxvrTdTWoXbozAzdaDZzfkorOj1oxVxlIMlpSIlpLrt8D4hrQL17z+c3h6hU/wv4Q/utps4+bm+6P/hIcf0JwQ5oQGPBL0eKPTYEXTW+eL/2DKn73J9BTXYANG57hz1cEMviVf/4tf5b/6C5pTQkMIWoAq7hTpOJjtAM4pxKu5vg5vXeUrtI09/Mo/5H+4z+Mp5xULh7cEm2QbRP2tFIKR7WM3fPf/jZ3SWCqLM2l4NxID5zB72HQXv3jj/8mLR5xXNA5v8EbFQEz7PpRfl1+MB/hlAN65qgDn3wTgH13hK7T59bmP+NIx1SHHU84nLOITt3iVz8mNO+lPrjGAnBFqmioNn1mTyk1ta47R6d4MrX7tjrnjYUpdUbv2rVr6YpVfsGG58AG8Ah9eyUN8CX4WfgV+G8LVWPDGb+Zd4cU584CtqSbMKxauxTg+dyn/LkVgA+IR8KHtejeFKRtTmLLpxN6mYVLjYxwXf5x2VofiZcp/lwKk4wGOpYDnoIZPdg/AAbwMfx0+ge9dgZvYjuqKe4HnGnykYo5TvJbG0Vj12JagRhwKa44H95ShkZa5RyLGGdfYvG7aw1TsF6iapPAS29mNS3NmsTQZCmgTzFwgL3upCTgtBTRwvGMAKrgLn4evwin8+afJRcff+8izUGUM63GOOuAs3tJkw7J4kyoNreqrpO6cYLQeFUd7TTpr5YOTLc9RUUogUOVJQ1GYJaFLAW0oTmKyYS46ZooP4S4EON3xQ5zC8/CX4CnM4c1PE8ApexpoYuzqlP3d4S3OJP8ZDK7cKWNaTlqmgDiiHwl1YsE41w1zT4iRTm3DBqxvOUsbMKKDa/EHxagtnta072ejc3DOIh5ojvh8l3tk1JF/AV6FU6jh3U8HwEazLgdCLYSQ+MYiAI2ltomkzttUb0gGHdSUUgsIYjTzLG3mObX4FBRaYtpDVNZrih9TgTeYOBxsEnN1gOCTM8Bsw/ieMc75w9kuAT6A+/AiHGvN/+Gn4KRkiuzpNNDYhDGFndWRpE6SVfm8U5bxnSgVV2jrg6JCKmneqey8VMFgq2+AM/i4L4RUbfSi27lNXZ7R7W9RTcq/q9fk4Xw3AMQd4I5ifAZz8FcVtm9SAom/dyN4lczJQW/kC42ZrHgcCoIf1oVMKkVItmMBi9cOeNHGLqOZk+QqQmrbc5YmYgxELUUN35z2iohstgfLIFmcMV7s4CFmI74L9+EFmGsi+tGnAOD4Yk9gIpo01Y4cA43BWGygMdr4YZekG3OBIUXXNukvJS8tqa06e+lSDCtnqqMFu6hWHXCF+WaYt64m9QBmNxi7Ioy7D+fa1yHw+FMAcPt7SysFLtoG4PXAk7JOA3aAxBRqUiAdU9Yp5lK3HLSRFtOim0sa8euEt08xvKjYjzeJ2GU7YawexrnKI9tmobInjFXCewpwriY9+RR4aaezFhMhGCppKwom0ChrgFlKzyPKkGlTW1YQrE9HJqu8hKGgMc6hVi5QRq0PZxNfrYNgE64utmRv6KKHRpxf6VDUaOvNP5jCEx5q185My/7RKz69UQu2im5k4/eownpxZxNLwiZ1AZTO2ZjWjkU9uaB2HFn6Q3u0JcsSx/qV9hTEApRzeBLDJQXxYmTnq7bdLa3+uqFrxLJ5w1TehnNHx5ECvCh2g2c3hHH5YsfdaSKddztfjQ6imKFGSyFwlLzxEGPp6r5IevVjk1AMx3wMqi1NxDVjLBiPs9tbsCkIY5we5/ML22zrCScFxnNtzsr9Wcc3CnD+pYO+4VXXiDE0oc/vQQ/fDK3oPESJMYXNmJa/DuloJZkcTpcYE8lIH8Dz8DJMiynNC86Mb2lNaaqP/+L7f2fcE/yP7/Lde8xfgSOdMxvOixZf/9p3+M4hT1+F+zApxg9XfUvYjc8qX2lfOOpK2gNRtB4flpFu9FTKCp2XJRgXnX6olp1zyYjTKJSkGmLE2NjUr1bxFM4AeAAHBUFIeSLqXR+NvH/M9fOnfHzOD2vCSyQJKzfgsCh+yi/Mmc35F2fUrw7miW33W9hBD1vpuUojFphIyvg7aTeoymDkIkeW3XLHmguMzbIAJejN6B5MDrhipE2y6SoFRO/AK/AcHHZHNIfiWrEe/C6cr3f/yOvrQKB+zMM55/GQdLDsR+ifr5Fiuu+/y+M78LzOE5dsNuXC3PYvYWd8NXvphLSkJIasrlD2/HOqQ+RjcRdjKTGWYhhVUm4yxlyiGPuMsZR7sMCHUBeTuNWA7if+ifXgc/hovftHXs/DV+Fvwe+f8shzMiMcweFgBly3//vwJfg5AN4450fn1Hd1Rm1aBLu22Dy3y3H2+OqMemkbGZ4jozcDjJf6596xOLpC0eMTHbKnxLxH27uZ/bMTGs2jOaMOY4m87CfQwF0dw53oa1k80JRuz/XgS+8fX3N9Af4qPIMfzKgCp4H5TDGe9GGeFPzSsZz80SlPTxXjgwJmC45njzgt2vbQ4b4OAdUK4/vWhO8d8v6EE8fMUsfakXbPpFJeLs2ubM/qdm/la3WP91uWhxXHjoWhyRUq2iJ/+5mA73zwIIo+LoZ/SgvIRjAd1IMvvn98PfgOvAJfhhm8scAKVWDuaRaK8aQ9f7vuPDH6Bj47ZXau7rqYJ66mTDwEDU6lLbCjCK0qTXyl5mnDoeNRxanj3FJbaksTk0faXxHxLrssgPkWB9LnA/MFleXcJozzjwsUvUG0X/QCve51qkMDXp9mtcyOy3rwBfdvVJK7D6/ACSzg3RoruIq5UDeESfEmVclDxnniU82vxMLtceD0hGZWzBNPMM/jSPne2OVatiTKUpY5vY7gc0LdUAWeWM5tH+O2I66AOWw9xT2BuyRVLGdoDHUsVRXOo/c+ZdRXvFfnxWyIV4upFLCl9eAL7h8Zv0QH8Ry8pA2cHzQpGesctVA37ZtklBTgHjyvdSeKY/RZw/kJMk0Y25cSNRWSigQtlULPTw+kzuJPeYEkXjQRpoGZobYsLF79pyd1dMRHInbgFTZqNLhDqiIsTNpoex2WLcy0/X6rHcdMMQvFSd5dWA++4P7xv89deACnmr36uGlL69bRCL6BSZsS6c0TU2TKK5gtWCzgAOOwQcurqk9j8whvziZSMLcq5hbuwBEsYjopUBkqw1yYBGpLA97SRElEmx5MCInBY5vgLk94iKqSWmhIGmkJ4Bi9m4L645J68LyY4wsFYBfUg5feP/6gWWm58IEmKQM89hq7KsZNaKtP5TxxrUZZVkNmMJtjbKrGxLNEbHPJxhqy7lAmbC32ZqeF6lTaknRWcYaFpfLUBh/rwaQycCCJmW15Kstv6jRHyJFry2C1ahkkIW0LO75s61+owxK1y3XqweX9m5YLM2DPFeOjn/iiqCKJ+yKXF8t5Yl/kNsqaSCryxPq5xWTFIaP8KSW0RYxqupaUf0RcTNSSdJZGcKYdYA6kdtrtmyBckfKXwqk0pHpUHlwWaffjNRBYFPUDWa8e3Lt/o0R0CdisKDM89cX0pvRHEfM8ca4t0s2Xx4kgo91MPQJ/0c9MQYq0co8MBh7bz1fio0UUHLR4aAIOvOmoYO6kwlEVODSSTliWtOtH6sPkrtctF9ZtJ9GIerBskvhdVS5cFNv9s1BU0AbdUgdK4FG+dRnjFmDTzniRMdZO1QhzMK355vigbdkpz9P6qjUGE5J2qAcXmwJ20cZUiAD0z+pGMx6xkzJkmEf40Hr4qZfVg2XzF9YOyoV5BjzVkUJngKf8lgNYwKECEHrCNDrWZzMlflS3yBhr/InyoUgBc/lKT4pxVrrC6g1YwcceK3BmNxZcAtz3j5EIpqguh9H6wc011YN75cKDLpFDxuwkrPQmUwW4KTbj9mZTwBwLq4aQMUZbHm1rylJ46dzR0dua2n3RYCWZsiHROeywyJGR7mXKlpryyCiouY56sFkBWEnkEB/raeh/Sw4162KeuAxMQpEkzy5alMY5wamMsWKKrtW2WpEWNnReZWONKWjrdsKZarpFjqCslq773PLmEhM448Pc3+FKr1+94vv/rfw4tEcu+lKTBe4kZSdijBrykwv9vbCMPcLQTygBjzVckSLPRVGslqdunwJ4oegtFOYb4SwxNgWLCmD7T9kVjTv5YDgpo0XBmN34Z/rEHp0sgyz7lngsrm4lvMm2Mr1zNOJYJ5cuxuQxwMGJq/TP5emlb8fsQBZviK4t8hFL+zbhtlpwaRSxQRWfeETjuauPsdGxsBVdO7nmP4xvzSoT29pRl7kGqz+k26B3Oy0YNV+SXbbQas1ctC/GarskRdFpKczVAF1ZXnLcpaMuzVe6lZ2g/1ndcvOVgRG3sdUAY1bKD6achijMPdMxV4muKVorSpiDHituH7rSTs7n/4y5DhRXo4FVBN4vO/zbAcxhENzGbHCzU/98Mcx5e7a31kWjw9FCe/zNeYyQjZsWb1uc7U33pN4Mji6hCLhivqfa9Ss6xLg031AgfesA/l99m9fgvnaF9JoE6bYKmkGNK3aPbHB96w3+DnxFm4hs0drLsk7U8kf/N/CvwQNtllna0rjq61sH8L80HAuvwH1tvBy2ChqWSCaYTaGN19sTvlfzFD6n+iKTbvtayfrfe9ueWh6GJFoxLdr7V72a5ZpvHcCPDzma0wTO4EgbLyedxstO81n57LYBOBzyfsOhUKsW1J1BB5vr/tz8RyqOFylQP9Tvst2JALsC5lsH8PyQ40DV4ANzYa4dedNiKNR1s+x2wwbR7q4/4cTxqEk4LWDebfisuo36JXLiWFjOtLrlNWh3K1rRS4xvHcDNlFnNmWBBAl5SWaL3oPOfnvbr5pdjVnEaeBJSYjuLEkyLLsWhKccadmOphZkOPgVdalj2QpSmfOsADhMWE2ZBu4+EEJI4wKTAuCoC4xwQbWXBltpxbjkXJtKxxabo9e7tyhlgb6gNlSbUpMh+l/FaqzVwewGu8BW1Zx7pTpQDJUjb8tsUTW6+GDXbMn3mLbXlXJiGdggxFAoUrtPS3wE4Nk02UZG2OOzlk7fRs7i95QCLo3E0jtrjnM7SR3uS1p4qtS2nJ5OwtQVHgOvArLBFijZUV9QtSl8dAY5d0E0hM0w3HS2DpIeB6m/A1+HfhJcGUq4sOxH+x3f5+VO+Ds9rYNI7zPXOYWPrtf8bYMx6fuOAX5jzNR0PdsuON+X1f7EERxMJJoU6GkTEWBvVolVlb5lh3tKCg6Wx1IbaMDdJ+9sUCc5KC46hKGCk3IVOS4TCqdBNfUs7Kd4iXf2RjnT/LLysJy3XDcHLh/vde3x8DoGvwgsa67vBk91G5Pe/HbOe7xwym0NXbtiuuDkGO2IJDh9oQvJ4cY4vdoqLDuoH9Zl2F/ofsekn8lkuhIlhQcffUtSjytFyp++p6NiE7Rqx/lodgKVoceEp/CP4FfjrquZaTtj2AvH5K/ywpn7M34K/SsoYDAdIN448I1/0/wveW289T1/lX5xBzc8N5IaHr0XMOQdHsIkDuJFifj20pBm5jzwUv9e2FhwRsvhAbalCIuIw3bhJihY3p6nTFFIZgiSYjfTf3aXuOjmeGn4bPoGvwl+CFzTRczBIuHBEeImHc37/lGfwZR0cXzVDOvaKfNHvwe+suZ771K/y/XcBlsoN996JpBhoE2toYxOznNEOS5TJc6Id5GEXLjrWo+LEWGNpPDU4WAwsIRROu+1vM+0oW37z/MBN9kqHnSArwPfgFJ7Cq/Ai3Ie7g7ncmI09v8sjzw9mzOAEXoIHxURueaAce5V80f/DOuuZwHM8vsMb5wBzOFWM7wymTXPAEvm4vcFpZ2ut0VZRjkiP2MlmLd6DIpbGSiHOjdnUHN90hRYmhTnmvhzp1iKDNj+b7t5hi79lWGwQ+HN9RsfFMy0FXbEwhfuczKgCbyxYwBmcFhhvo/7a44v+i3XWcwDP86PzpGQYdWh7csP5dBvZ1jNzdxC8pBGuxqSW5vw40nBpj5JhMwvOzN0RWqERHMr4Lv1kWX84xLR830G3j6yqZ1a8UstTlW+qJPOZ+sZ7xZPKTJLhiNOAFd6tk+jrTH31ncLOxid8+nzRb128HhUcru/y0Wn6iT254YPC6FtVSIMoW2sk727AhvTtrWKZTvgsmckfXYZWeNRXx/3YQ2OUxLDrbHtN11IwrgXT6c8dATDwLniYwxzO4RzuQqTKSC5gAofMZ1QBK3zQ4JWobFbcvJm87FK+6JXrKahLn54m3p+McXzzYtP8VF/QpJuh1OwieElEoI1pRxPS09FBrkq2tWCU59+HdhNtTIqKm8EBrw2RTOEDpG3IKo2Y7mFdLm3ZeVjYwVw11o/oznceMve4CgMfNym/utA/d/ILMR7gpXzRy9eDsgLcgbs8O2Va1L0zzIdwGGemTBuwROHeoMShkUc7P+ISY3KH5ZZeWqO8mFTxQYeXTNuzvvK5FGPdQfuu00DwYFY9dyhctEt+OJDdnucfpmyhzUJzfsJjr29l8S0bXBfwRS9ZT26tmMIdZucch5ZboMz3Nio3nIOsYHCGoDT4kUA9MiXEp9Xsui1S8th/kbWIrMBxDGLodWUQIWcvnXy+9M23xPiSMOiRPqM+YMXkUN3gXFrZJwXGzUaMpJfyRS9ZT0lPe8TpScuRlbMHeUmlaKDoNuy62iWNTWNFYjoxFzuJs8oR+RhRx7O4SVNSXpa0ZJQ0K1LAHDQ+D9IepkMXpcsq5EVCvClBUIzDhDoyKwDw1Lc59GbTeORivugw1IcuaEOaGWdNm+Ps5fQ7/tm0DjMegq3yM3vb5j12qUId5UZD2oxDSEWOZMSqFl/W+5oynWDa/aI04tJRQ2eTXusg86SQVu/nwSYwpW6wLjlqIzwLuxGIvoAvul0PS+ZNz0/akp/pniO/8JDnGyaCkzbhl6YcqmK/69prxPqtpx2+Km9al9sjL+rwMgHw4jE/C8/HQ3m1vBuL1fldbzd8mOueVJ92syqdEY4KJjSCde3mcRw2TA6szxedn+zwhZMps0XrqEsiUjnC1hw0TELC2Ek7uAAdzcheXv1BYLagspxpzSAoZZUsIzIq35MnFQ9DOrlNB30jq3L4pkhccKUAA8/ocvN1Rzx9QyOtERs4CVsJRK/DF71kPYrxYsGsm6RMh4cps5g1DOmM54Ly1ii0Hd3Y/BMk8VWFgBVmhqrkJCPBHAolwZaWzLR9Vb7bcWdX9NyUYE+uB2BKfuaeBUcjDljbYVY4DdtsVWvzRZdWnyUzDpjNl1Du3aloAjVJTNDpcIOVVhrHFF66lLfJL1zJr9PQ2nFJSBaKoDe+sAvLufZVHVzYh7W0h/c6AAZ+7Tvj6q9j68G/cTCS/3n1vLKHZwNi+P+pS0WkZNMBMUl+LDLuiE4omZy71r3UFMwNJV+VJ/GC5ixVUkBStsT4gGKh0Gm4Oy3qvq7Lbmq24nPdDuDR9deR11XzP4vFu3TYzfnIyiSVmgizUYGqkIXNdKTY9pgb9D2Ix5t0+NHkVzCdU03suWkkVZAoCONCn0T35gAeW38de43mf97sMOpSvj4aa1KYUm58USI7Wxxes03bAZdRzk6UtbzMaCQ6IxO0dy7X+XsjoD16hpsBeGz9dfzHj+R/Hp8nCxZRqkEDTaCKCSywjiaoMJ1TITE9eg7Jqnq8HL6gDwiZb0u0V0Rr/rmvqjxKuaLCX7ZWXTvAY+uvm3z8CP7nzVpngqrJpZKwWnCUjIviYVlirlGOzPLI3SMVyp/elvBUjjDkNhrtufFFErQ8pmdSlbK16toBHlt/HV8uHMX/vEGALkV3RJREiSlopxwdMXOZPLZ+ix+kAHpMKIk8UtE1ygtquttwxNhphrIZ1IBzjGF3IIGxGcBj6q8bHJBG8T9vdsoWrTFEuebEZuVxhhClH6P5Zo89OG9fwHNjtNQTpD0TG9PJLEYqvEY6Rlxy+ZZGfL0Aj62/bnQCXp//eeM4KzfQVJbgMQbUjlMFIm6TpcfWlZje7NBSV6IsEVmumWIbjiloUzQX9OzYdo8L1wjw2PrrpimONfmfNyzKklrgnEkSzT5QWYQW40YShyzqsRmMXbvVxKtGuYyMKaU1ugenLDm5Ily4iT14fP11Mx+xJv+zZ3MvnfdFqxU3a1W/FTB4m3Qfsyc1XUcdVhDeUDZXSFHHLQj/Y5jtC7ZqM0CXGwB4bP11i3LhOvzPGygYtiUBiwQV/4wFO0majijGsafHyRLu0yG6q35cL1rOpVxr2s5cM2jJYMCdc10Aj6q/blRpWJ//+dmm5psMl0KA2+AFRx9jMe2WbC4jQxnikd4DU8TwUjRVacgdlhmr3bpddzuJ9zXqr2xnxJfzP29RexdtjDVZqzkqa6PyvcojGrfkXiJ8SEtml/nYskicv0ivlxbqjemwUjMw5evdg8fUX9nOiC/lf94Q2i7MURk9nW1MSj5j8eAyV6y5CN2S6qbnw3vdA1Iwq+XOSCl663udN3IzLnrt+us25cI1+Z83SXQUldqQq0b5XOT17bGpLd6ssN1VMPf8c+jG8L3NeCnMdF+Ra3fRa9dft39/LuZ/3vwHoHrqGmQFafmiQw6eyzMxS05K4bL9uA+SKUQzCnSDkqOGokXyJvbgJ/BHI+qvY69//4rl20NsmK2ou2dTsyIALv/91/8n3P2Aao71WFGi8KKv1fRC5+J67Q/507/E/SOshqN5TsmYIjVt+kcjAx98iz/4SaojbIV1rexE7/C29HcYD/DX4a0rBOF5VTu7omsb11L/AWcVlcVZHSsqGuXLLp9ha8I//w3Mv+T4Ew7nTBsmgapoCrNFObIcN4pf/Ob/mrvHTGqqgAupL8qWjWPS9m/31jAe4DjA+4+uCoQoT/zOzlrNd3qd4SdphFxsUvYwGWbTWtISc3wNOWH+kHBMfc6kpmpwPgHWwqaSUG2ZWWheYOGQGaHB+eQ/kn6b3pOgLV+ODSn94wDvr8Bvb70/LLuiPPEr8OGVWfDmr45PZyccEmsVXZGe1pRNX9SU5+AVQkNTIVPCHF/jGmyDC9j4R9LfWcQvfiETmgMMUCMN1uNCakkweZsowdYobiMSlnKA93u7NzTXlSfe+SVbfnPQXmg9LpYAQxpwEtONyEyaueWM4FPjjyjG3uOaFmBTWDNgBXGEiQpsaWhnAqIijB07Dlsy3fUGeP989xbWkyf+FF2SNEtT1E0f4DYYVlxFlbaSMPIRMk/3iMU5pME2SIWJvjckciebkQuIRRyhUvkHg/iUljG5kzVog5hV7vIlCuBrmlhvgPfNHQM8lCf+FEGsYbMIBC0qC9a0uuy2wLXVbLBaP5kjHokCRxapkQyzI4QEcwgYHRZBp+XEFTqXFuNVzMtjXLJgX4gAid24Hjwc4N3dtVSe+NNiwTrzH4WVUOlDobUqr1FuAgYllc8pmzoVrELRHSIW8ViPxNy4xwjBpyR55I6J220qQTZYR4guvUICJiSpr9gFFle4RcF/OMB7BRiX8sSfhpNSO3lvEZCQfLUVTKT78Ek1LRLhWN+yLyTnp8qWUZ46b6vxdRGXfHVqx3eI75YaLa4iNNiK4NOW7wPW6lhbSOF9/M9qw8e/aoB3d156qTzxp8pXx5BKAsYSTOIIiPkp68GmTq7sZtvyzBQaRLNxIZ+paozHWoLFeExIhRBrWitHCAHrCF7/thhD8JhYz84wg93QRV88wLuLY8zF8sQ36qF1J455bOlgnELfshKVxYOXKVuKx0jaj22sczTQqPqtV/XDgpswmGTWWMSDw3ssyUunLLrVPGjYRsH5ggHeHSWiV8kT33ycFSfMgkoOK8apCye0J6VW6GOYvffgU9RWsukEi2kUV2nl4dOYUzRik9p7bcA4ggdJ53LxKcEe17B1R8eqAd7dOepV8sTXf5lhejoL85hUdhDdknPtKHFhljOT+bdq0hxbm35p2nc8+Ja1Iw+tJykgp0EWuAAZYwMVwac5KzYMslhvgHdHRrxKnvhTYcfKsxTxtTETkjHO7rr3zjoV25lAQHrqpV7bTiy2aXMmUhTBnKS91jhtR3GEoF0oLnWhWNnYgtcc4N0FxlcgT7yz3TgNIKkscx9jtV1ZKpWW+Ub1tc1eOv5ucdgpx+FJy9pgbLE7xDyXb/f+hLHVGeitHOi6A7ybo3sF8sS7w7cgdk0nJaOn3hLj3uyD0Zp5pazFIUXUpuTTU18d1EPkDoX8SkmWTnVIozEdbTcZjoqxhNHf1JrSS/AcvHjZ/SMHhL/7i5z+POsTUh/8BvNfYMTA8n+yU/MlTZxSJDRStqvEuLQKWwDctMTQogUDyQRoTQG5Kc6oQRE1yV1jCA7ri7jdZyK0sYTRjCR0Hnnd+y7nHxNgTULqw+8wj0mQKxpYvhjm9uSUxg+TTy7s2GtLUGcywhXSKZN275GsqlclX90J6bRI1aouxmgL7Q0Nen5ziM80SqMIo8cSOo+8XplT/5DHNWsSUr/6lLN/QQ3rDyzLruEW5enpf7KqZoShEduuSFOV7DLX7Ye+GmXb6/hnNNqKsVXuMDFpb9Y9eH3C6NGEzuOuI3gpMH/I6e+zDiH1fXi15t3vA1czsLws0TGEtmPEJdiiFPwlwKbgLHAFk4P6ZyPdymYYHGE0dutsChQBl2JcBFlrEkY/N5bQeXQ18gjunuMfMfsBlxJSx3niO485fwO4fGD5T/+3fPQqkneWVdwnw/3bMPkW9Wbqg+iC765Zk+xcT98ibKZc2EdgHcLoF8cSOo/Oc8fS+OyEULF4g4sJqXVcmfMfsc7A8v1/yfGXmL9I6Fn5pRwZhsPv0TxFNlAfZCvG+Oohi82UC5f/2IsJo0cTOm9YrDoKhFPEUr/LBYTUNht9zelHXDqwfPCIw4owp3mOcIQcLttWXFe3VZ/j5H3cIc0G6oPbCR+6Y2xF2EC5cGUm6wKC5tGEzhsWqw5hNidUiKX5gFWE1GXh4/Qplw4sVzOmx9QxU78g3EF6wnZlEN4FzJ1QPSLEZz1KfXC7vd8ssGdIbNUYpVx4UapyFUHzJoTOo1McSkeNn1M5MDQfs4qQuhhX5vQZFw8suwWTcyYTgioISk2YdmkhehG4PkE7w51inyAGGaU+uCXADabGzJR1fn3lwkty0asIo8cROm9Vy1g0yDxxtPvHDAmpu+PKnM8Ix1wwsGw91YJqhteaWgjYBmmQiebmSpwKKzE19hx7jkzSWOm66oPbzZ8Yj6kxVSpYjVAuvLzYMCRo3oTQecOOjjgi3NQ4l9K5/hOGhNTdcWVOTrlgYNkEXINbpCkBRyqhp+LdRB3g0OU6rMfW2HPCFFMV9nSp+uB2woepdbLBuJQyaw/ZFysXrlXwHxI0b0LovEkiOpXGA1Ijagf+KUNC6rKNa9bQnLFqYNkEnMc1uJrg2u64ELPBHpkgWbmwKpJoDhMwNbbGzAp7Yg31wS2T5rGtzit59PrKhesWG550CZpHEzpv2NGRaxlNjbMqpmEIzygJqQfjypycs2pg2cS2RY9r8HUqkqdEgKTWtWTKoRvOBPDYBltja2SO0RGjy9UHtxwRjA11ujbKF+ti5cIR9eCnxUg6owidtyoU5tK4NLji5Q3HCtiyF2IqLGYsHViOXTXOYxucDqG0HyttqYAKqYo3KTY1ekyDXRAm2AWh9JmsVh/ccg9WJ2E8YjG201sPq5ULxxX8n3XLXuMInbft2mk80rRGjCGctJ8/GFdmEQ9Ug4FlE1ll1Y7jtiraqm5Fe04VV8lvSVBL8hiPrfFVd8+7QH3Qbu2ipTVi8cvSGivc9cj8yvH11YMHdNSERtuOslM97feYFOPKzGcsI4zW0YGAbTAOaxCnxdfiYUmVWslxiIblCeAYr9VYR1gM7GmoPrilunSxxeT3DN/2eBQ9H11+nk1adn6VK71+5+Jfct4/el10/7KBZfNryUunWSCPxPECk1rdOv1WVSrQmpC+Tl46YD3ikQYcpunSQgzVB2VHFhxHVGKDgMEY5GLlQnP7FMDzw7IacAWnO6sBr12u+XanW2AO0wQ8pknnFhsL7KYIqhkEPmEXFkwaN5KQphbkUmG72wgw7WSm9RiL9QT925hkjiVIIhphFS9HKI6/8QAjlpXqg9W2C0apyaVDwKQwrwLY3j6ADR13ZyUNByQXHQu6RY09Hu6zMqXRaNZGS/KEJs0cJEe9VH1QdvBSJv9h09eiRmy0V2uJcqHcShcdvbSNg5fxkenkVprXM9rDVnX24/y9MVtncvbKY706anNl3ASll9a43UiacVquXGhvq4s2FP62NGKfQLIQYu9q1WmdMfmUrDGt8eDS0cXozH/fjmUH6Jruvm50hBDSaEU/2Ru2LEN/dl006TSc/g7tfJERxGMsgDUEr104pfWH9lQaN+M4KWQjwZbVc2rZVNHsyHal23wZtIs2JJqtIc/WLXXRFCpJkfE9jvWlfFbsNQ9pP5ZBS0zKh4R0aMFj1IjTcTnvi0Zz2rt7NdvQb2mgbju1plsH8MmbnEk7KbK0b+wC2iy3aX3szW8xeZvDwET6hWZYwqTXSSG+wMETKum0Dq/q+x62gt2ua2ppAo309TRk9TPazfV3qL9H8z7uhGqGqxNVg/FKx0HBl9OVUORn8Q8Jx9gFttGQUDr3tzcXX9xGgN0EpzN9mdZ3GATtPhL+CjxFDmkeEU6x56kqZRusLzALXVqkCN7zMEcqwjmywDQ6OhyUe0Xao1Qpyncrg6wKp9XfWDsaZplElvQ/b3sdweeghorwBDlHzgk1JmMc/wiERICVy2VJFdMjFuLQSp3S0W3+sngt2njwNgLssFGVQdJ0tu0KH4ky1LW4yrbkuaA6Iy9oz/qEMMXMMDWyIHhsAyFZc2peV9hc7kiKvfULxCl9iddfRK1f8kk9qvbdOoBtOg7ZkOZ5MsGrSHsokgLXUp9y88smniwWyuFSIRVmjplga3yD8Uij5QS1ZiM4U3Qw5QlSm2bXjFe6jzzBFtpg+/YBbLAWG7OPynNjlCw65fukGNdkJRf7yM1fOxVzbxOJVocFoYIaGwH22mIQkrvu1E2nGuebxIgW9U9TSiukPGU+Lt++c3DJPKhyhEEbXCQLUpae2exiKy6tMPe9mDRBFCEMTWrtwxN8qvuGnt6MoihKWS5NSyBhbH8StXoAz8PLOrRgLtOT/+4vcu+7vDLnqNvztOq7fmd8sMmY9Xzn1zj8Dq8+XVdu2Nv0IIySgEdQo3xVHps3Q5i3fLFsV4aiqzAiBhbgMDEd1uh8qZZ+lwhjkgokkOIv4xNJmyncdfUUzgB4oFMBtiu71Xumpz/P+cfUP+SlwFExwWW62r7b+LSPxqxn/gvMZ5z9C16t15UbNlq+jbGJtco7p8wbYlL4alSyfWdeuu0j7JA3JFNuVAwtst7F7FhWBbPFNKIUORndWtLraFLmMu7KFVDDOzqkeaiN33YAW/r76wR4XDN/yN1z7hejPau06EddkS/6XThfcz1fI/4K736fO48vlxt2PXJYFaeUkFS8U15XE3428xdtn2kc8GQlf1vkIaNRRnOMvLTWrZbElEHeLWi1o0dlKPAh1MVgbbVquPJ5+Cr8LU5/H/+I2QlHIU2ClXM9G8v7Rr7oc/hozfUUgsPnb3D+I+7WF8kNO92GY0SNvuxiE+2Bt8prVJTkzE64sfOstxuwfxUUoyk8VjcTlsqe2qITSFoSj6Epd4KsT6BZOWmtgE3hBfir8IzZDwgV4ZTZvD8VvPHERo8v+vL1DASHTz/i9OlKueHDjK5Rnx/JB1Vb1ioXdBra16dmt7dgik10yA/FwJSVY6XjA3oy4SqM2frqDPPSRMex9qs3XQtoWxMj7/Er8GWYsXgjaVz4OYumP2+9kbxvny/6kvWsEBw+fcb5bInc8APdhpOSs01tEqIkoiZjbAqKMruLbJYddHuHFRIyJcbdEdbl2sVLaySygunutBg96Y2/JjKRCdyHV+AEFtTvIpbKIXOamknYSiB6KV/0JetZITgcjjk5ZdaskBtWO86UF0ap6ozGXJk2WNiRUlCPFir66lzdm/SLSuK7EUdPz8f1z29Skq6F1fXg8+5UVR6bszncP4Tn4KUkkdJ8UFCY1zR1i8RmL/qQL3rlei4THG7OODlnKko4oI01kd3CaM08Ia18kC3GNoVaO9iDh+hWxSyTXFABXoau7Q6q9OxYg/OVEMw6jdbtSrJ9cBcewGmaZmg+bvkUnUUaGr+ZfnMH45Ivevl61hMcXsxYLFTu1hTm2zViCp7u0o5l+2PSUh9bDj6FgYypufBDhqK2+oXkiuHFHR3zfj+9PtA8oR0xnqX8qn+sx3bFODSbbF0X8EUvWQ8jBIcjo5bRmLOljDNtcqNtOe756h3l0VhKa9hDd2l1eqmsnh0MNMT/Cqnx6BInumhLT8luljzQ53RiJeA/0dxe5NK0o2fA1+GLXr6eNQWHNUOJssQaTRlGpLHKL9fD+IrQzTOMZS9fNQD4AnRNVxvTdjC+fJdcDDWQcyB00B0t9BDwTxXgaAfzDZ/DBXzRnfWMFRwuNqocOmX6OKNkY63h5n/fFcB28McVHqnXZVI27K0i4rDLNE9lDKV/rT+udVbD8dFFu2GGZ8mOt0kAXcoX3ZkIWVtw+MNf5NjR2FbivROHmhV1/pj2egv/fMGIOWTIWrV3Av8N9imV9IWml36H6cUjqEWNv9aNc+veb2sH46PRaHSuMBxvtW+twxctq0z+QsHhux8Q7rCY4Ct8lqsx7c6Sy0dl5T89rIeEuZKoVctIk1hNpfavER6yyH1Vvm3MbsUHy4ab4hWr/OZPcsRBphnaV65/ZcdYPNNwsjN/djlf9NqCw9U5ExCPcdhKxUgLSmfROpLp4WSUr8ojdwbncbvCf+a/YzRaEc6QOvXcGO256TXc5Lab9POvB+AWY7PigWYjzhifbovuunzRawsO24ZqQQAqguBtmpmPB7ysXJfyDDaV/aPGillgz1MdQg4u5MYaEtBNNHFjkRlSpd65lp4hd2AVPTfbV7FGpyIOfmNc/XVsPfg7vzaS/3nkvLL593ANLvMuRMGpQIhiF7kUEW9QDpAUbTWYBcbp4WpacHHY1aacqQyjGZS9HI3yCBT9kUZJhVOD+zUDvEH9ddR11fzPcTDQ5TlgB0KwqdXSavk9BC0pKp0WmcuowSw07VXmXC5guzSa4p0UvRw2lbDiYUx0ExJJRzWzi6Gm8cnEkfXXsdcG/M/jAJa0+bmCgdmQ9CYlNlSYZOKixmRsgiFxkrmW4l3KdFKv1DM8tk6WxPYJZhUUzcd8Kdtgrw/gkfXXDT7+avmfVak32qhtkg6NVdUS5wgkru1YzIkSduTW1FDwVWV3JQVJVuieTc0y4iDpFwc7/BvSalvKdQM8sv662cevz/+8sQVnjVAT0W2wLllw1JiMhJRxgDjCjLQsOzSFSgZqx7lAW1JW0e03yAD3asC+GD3NbQhbe+mN5GXH1F83KDOM4n/e5JIuH4NpdQARrFPBVptUNcjj4cVMcFSRTE2NpR1LEYbYMmfWpXgP9KejaPsLUhuvLCsVXznAG9dfx9SR1ud/3hZdCLHb1GMdPqRJgqDmm76mHbvOXDtiO2QPUcKo/TWkQ0i2JFXpBoo7vij1i1Lp3ADAo+qvG3V0rM//vFnnTE4hxd5Ka/Cor5YEdsLVJyKtDgVoHgtW11pWSjolPNMnrlrVj9Fv2Qn60twMwKPqr+N/wvr8z5tZcDsDrv06tkqyzESM85Ycv6XBWA2birlNCXrI6VbD2lx2L0vQO0QVTVVLH4SE67fgsfVXv8n7sz7/85Z7cMtbE6f088wSaR4kCkCm10s6pKbJhfqiUNGLq+0gLWC6eUAZFPnLjwqtKd8EwGvWX59t7iPW4X/eAN1svgRVSY990YZg06BD1ohLMtyFTI4pKTJsS9xREq9EOaPWiO2gpms7397x6nQJkbh+Fz2q/rqRROX6/M8bJrqlVW4l6JEptKeUFuMYUbtCQ7CIttpGc6MY93x1r1vgAnRXvY5cvwWPqb9uWQm+lP95QxdNMeWhOq1x0Db55C7GcUv2ZUuN6n8iKzsvOxibC//Yfs9Na8r2Rlz02vXXDT57FP/zJi66/EJSmsJKa8QxnoqW3VLQ+jZVUtJwJ8PNX1NQCwfNgdhhHD9on7PdRdrdGPF28rJr1F+3LBdeyv+8yYfLoMYet1vX4upNAjVvwOUWnlNXJXlkzk5Il6kqeoiL0C07qno+/CYBXq/+utlnsz7/Mzvy0tmI4zm4ag23PRN3t/CWryoUVJGm+5+K8RJ0V8Hc88/XHUX/HfiAq7t+BH+x6v8t438enWmdJwFA6ZINriLGKv/95f8lT9/FnyA1NMVEvQyaXuu+gz36f/DD73E4pwqpLcvm/o0Vle78n//+L/NPvoefp1pTJye6e4A/D082FERa5/opeH9zpvh13cNm19/4v/LDe5xMWTi8I0Ta0qKlK27AS/v3/r+/x/2GO9K2c7kVMonDpq7//jc5PKCxeNPpFVzaRr01wF8C4Pu76hXuX18H4LduTr79guuFD3n5BHfI+ZRFhY8w29TYhbbLi/bvBdqKE4fUgg1pBKnV3FEaCWOWyA+m3WpORZr/j+9TKJtW8yBTF2/ZEODI9/QavHkVdGFp/Pjn4Q+u5hXapsP5sOH+OXXA1LiKuqJxiMNbhTkbdJTCy4llEt6NnqRT4dhg1V3nbdrm6dYMecA1yTOL4PWTE9L5VzPFlLBCvlG58AhehnN4uHsAYinyJ+AZ/NkVvELbfOBUuOO5syBIEtiqHU1k9XeISX5bsimrkUUhnGDxourN8SgUsCZVtKyGbyGzHXdjOhsAvOAswSRyIBddRdEZWP6GZhNK/yjwew9ehBo+3jEADu7Ay2n8mDc+TS7awUHg0OMzR0LABhqLD4hJEh/BEGyBdGlSJoXYXtr+3HS4ijzVpgi0paWXtdruGTknXBz+11qT1Q2inxaTzQCO46P3lfLpyS4fou2PH/PupwZgCxNhGlj4IvUuWEsTkqMWm6i4xCSMc9N1RDQoCVcuGItJ/MRWefais+3synowi/dESgJjkilnWnBTGvRWmaw8oR15257t7CHmCf8HOn7cwI8+NQBXMBEmAa8PMRemrNCEhLGEhDQKcGZWS319BX9PFBEwGTbRBhLbDcaV3drFcDqk5kCTd2JF1Wp0HraqBx8U0wwBTnbpCadwBA/gTH/CDrcCs93LV8E0YlmmcyQRQnjBa8JESmGUfIjK/7fkaDJpmD2QptFNVJU1bbtIAjjWQizepOKptRjbzR9Kag6xZmMLLjHOtcLT3Tx9o/0EcTT1XN3E45u24AiwEypDJXihKjQxjLprEwcmRKclaDNZCVqr/V8mYWyFADbusiY5hvgFoU2vio49RgJLn5OsReRFN6tabeetiiy0V7KFHT3HyZLx491u95sn4K1QQSPKM9hNT0wMVvAWbzDSVdrKw4zRjZMyJIHkfq1VAVCDl/bUhNKlGq0zGr05+YAceXVPCttVk0oqjVwMPt+BBefx4yPtGVkUsqY3CHDPiCM5ngupUwCdbkpd8kbPrCWHhkmtIKLEetF2499eS1jZlIPGYnlcPXeM2KD9vLS0bW3ktYNqUllpKLn5ZrsxlIzxvDu5eHxzGLctkZLEY4PgSOg2IUVVcUONzUDBEpRaMoXNmUc0tFZrTZquiLyKxrSm3DvIW9Fil+AkhXu5PhEPx9mUNwqypDvZWdKlhIJQY7vn2OsnmBeOWnYZ0m1iwbbw1U60by5om47iHRV6fOgzjMf/DAZrlP40Z7syxpLK0lJ0gqaAK1c2KQKu7tabTXkLFz0sCftuwX++MyNeNn68k5Buq23YQhUh0SNTJa1ioQ0p4nUG2y0XilF1JqODqdImloPS4Bp111DEWT0jJjVv95uX9BBV7eB3bUWcu0acSVM23YZdd8R8UbQUxJ9wdu3oMuhdt929ME+mh6JXJ8di2RxbTi6TbrDquqV4aUKR2iwT6aZbyOwEXN3DUsWr8Hn4EhwNyHuXHh7/pdaUjtR7vnDh/d8c9xD/s5f501eQ1+CuDiCvGhk1AN/4Tf74RfxPwD3toLarR0zNtsnPzmS64KIRk861dMWCU8ArasG9T9H0ZBpsDGnjtAOM2+/LuIb2iIUGXNgl5ZmKD/Tw8TlaAuihaFP5yrw18v4x1898zIdP+DDAX1bM3GAMvPgRP/cJn3zCW013nrhHkrITyvYuwOUkcHuKlRSW5C6rzIdY4ppnF7J8aAJbQepgbJYBjCY9usGXDKQxq7RZfh9eg5d1UHMVATRaD/4BHK93/1iAgYZ/+jqPn8Dn4UExmWrpa3+ZOK6MvM3bjwfzxNWA2dhs8+51XHSPJiaAhGSpWevEs5xHLXcEGFXYiCONySH3fPWq93JIsBiSWvWyc3CAN+EcXoT7rCSANloPPoa31rt/5PUA/gp8Q/jDD3hyrjzlR8VkanfOvB1XPubt17vzxAfdSVbD1pzAnfgyF3ycadOTOTXhpEUoLC1HZyNGW3dtmjeXgr2r56JNmRwdNNWaQVBddd6rh4MhviEB9EFRD/7RGvePvCbwAL4Mx/D6M541hHO4D3e7g6PafdcZVw689z7NGTwo5om7A8sPhccT6qKcl9NJl9aM/9kX+e59Hh1yPqGuCCZxuITcsmNaJ5F7d0q6J3H48TO1/+M57085q2icdu2U+W36Ldllz9Agiv4YGljoEN908EzvDOrBF98/vtJwCC/BF2AG75xxEmjmMIcjxbjoaxqOK3/4hPOZzhMPBpYPG44CM0dTVm1LjLtUWWVz1Bcf8tEx0zs8O2A2YVHRxKYOiy/aOVoAaMu0i7ubu43njjmd4ibMHU1sIDHaQNKrZND/FZYdk54oCXetjq7E7IVl9eAL7t+oHnwXXtLx44czzoRFHBztYVwtH1d+NOMkupZ5MTM+gUmq90X+Bh9zjRlmaQ+m7YMqUL/veemcecAtOJ0yq1JnVlN27di2E0+Klp1tAJ4KRw1eMI7aJjsO3R8kPSI3fUFXnIOfdQe86sIIVtWDL7h//Ok6vj8vwDk08NEcI8zz7OhBy+WwalzZeZ4+0XniRfst9pAJqQHDGLzVQ2pheZnnv1OWhwO43/AgcvAEXEVVpa4db9sGvNK8wjaENHkfFQ4Ci5i7dqnQlPoLQrHXZDvO3BIXZbJOBrOaEbML6sFL798I4FhKihjHMsPjBUZYCMFr6nvaArxqXPn4lCa+cHfSa2cP27g3Z3ziYTRrcbQNGLQmGF3F3cBdzzzX7AILx0IB9rbwn9kx2G1FW3Inic+ZLIsVvKR8Zwfj0l1fkqo8LWY1M3IX14OX3r9RKTIO+d9XzAI8qRPGPn/4NC2n6o4rN8XJ82TOIvuVA8zLKUHRFgBCetlDZlqR1gLKjS39xoE7Bt8UvA6BxuEDjU3tFsEijgA+615tmZkXKqiEENrh41iLDDZNq4pKTWR3LZfnos81LOuNa15cD956vLMsJd1rqYp51gDUQqMYm2XsxnUhD2jg1DM7SeuJxxgrmpfISSXVIJIS5qJJSvJPEQ49DQTVIbYWJ9QWa/E2+c/oPK1drmC7WSfJRNKBO5Yjvcp7Gc3dmmI/Xh1kDTEuiSnWqQf37h+fTMhGnDf6dsS8SQfQWlqqwXXGlc/PEZ/SC5mtzIV0nAshlQdM/LvUtYutrEZ/Y+EAFtq1k28zQhOwLr1AIeANzhF8t9qzTdZf2qRKO6MWE9ohBYwibbOmrFtNmg3mcS+tB28xv2uKd/agYCvOP+GkSc+0lr7RXzyufL7QbkUpjLjEWFLqOIkAGu2B0tNlO9Eau2W1qcOUvVRgKzypKIQZ5KI3q0MLzqTNRYqiZOqmtqloIRlmkBHVpHmRYV6/HixbO6UC47KOFJnoMrVyr7wYz+SlW6GUaghYbY1I6kkxA2W1fSJokUdSh2LQ1GAimRGm0MT+uu57H5l7QgOWxERpO9moLRPgTtquWCfFlGlIjQaRly9odmzMOWY+IBO5tB4sW/0+VWGUh32qYk79EidWKrjWuiLpiVNGFWFRJVktyeXWmbgBBzVl8anPuXyNJlBJOlKLTgAbi/EYHVHxWiDaVR06GnHQNpJcWcK2jJtiCfG2sEHLzuI66sGrMK47nPIInPnu799935aOK2cvmvubrE38ZzZjrELCmXM2hM7UcpXD2oC3+ECVp7xtIuxptJ0jUr3sBmBS47TVxlvJ1Sqb/E0uLdvLj0lLr29ypdd/eMX3f6lrxGlKwKQxEGvw0qHbkbwrF3uHKwVENbIV2wZ13kNEF6zD+x24aLNMfDTCbDPnEikZFyTNttxWBXDaBuM8KtI2rmaMdUY7cXcUPstqTGvBGSrFWIpNMfbdea990bvAOC1YX0qbc6smDS1mPxSJoW4fwEXvjMmhlijDRq6qale6aJEuFGoppYDoBELQzLBuh/mZNx7jkinv0EtnUp50lO9hbNK57lZaMAWuWR5Yo9/kYwcYI0t4gWM47Umnl3YmpeBPqSyNp3K7s2DSAS/39KRuEN2bS4xvowV3dFRMx/VFcp2Yp8w2nTO9hCXtHG1kF1L4KlrJr2wKfyq77R7MKpFKzWlY9UkhYxyHWW6nBWPaudvEAl3CGcNpSXPZ6R9BbBtIl6cHL3gIBi+42CYXqCx1gfGWe7Ap0h3luyXdt1MKy4YUT9xSF01G16YEdWsouW9mgDHd3veyA97H+Ya47ZmEbqMY72oPztCGvK0onL44AvgC49saZKkWRz4veWljE1FHjbRJaWv6ZKKtl875h4CziFCZhG5rx7tefsl0aRT1bMHZjm8dwL/6u7wCRysaQblQoG5yAQN5zpatMNY/+yf8z+GLcH/Qn0iX2W2oEfXP4GvwQHuIL9AYGnaO3zqAX6946nkgqZNnUhx43DIdQtMFeOPrgy/y3Yd85HlJWwjLFkU3kFwq28xPnuPhMWeS+tDLV9Otllq7pQCf3uXJDN9wFDiUTgefHaiYbdfi3b3u8+iY6TnzhgehI1LTe8lcd7s1wJSzKbahCRxKKztTLXstGAiu3a6rPuQs5pk9TWAan5f0BZmGf7Ylxzzk/A7PAs4QPPPAHeFQ2hbFHszlgZuKZsJcUmbDC40sEU403cEjczstOEypa+YxevL4QBC8oRYqWdK6b7sK25tfE+oDZgtOQ2Jg8T41HGcBE6fTWHn4JtHcu9S7uYgU5KSCkl/mcnq+5/YBXOEr6lCUCwOTOM1taOI8mSxx1NsCXBEmLKbMAg5MkwbLmpBaFOPrNSlO2HnLiEqW3tHEwd8AeiQLmn+2gxjC3k6AxREqvKcJbTEzlpLiw4rNZK6oJdidbMMGX9FULKr0AkW+2qDEPBNNm5QAt2Ik2nftNWHetubosHLo2nG4vQA7GkcVCgVCgaDixHqo9UUn1A6OshapaNR/LPRYFV8siT1cCtJE0k/3WtaNSuUZYKPnsVIW0xXWnMUxq5+En4Kvw/MqQmVXnAXj9Z+9zM98zM/Agy7F/qqj2Nh67b8HjFnPP3iBn/tkpdzwEJX/whIcQUXOaikeliCRGUk7tiwF0rItwMEhjkZ309hikFoRAmLTpEXWuHS6y+am/KB/fM50aLEhGnSMwkpxzOov4H0AvgovwJ1iGzDLtJn/9BU+fAINfwUe6FHSLhu83viV/+/HrOePX+STT2B9uWGbrMHHLldRBlhS/CJQmcRxJFqZica01XixAZsYiH1uolZxLrR/SgxVIJjkpQP4PE9sE59LKLr7kltSBogS5tyszzH8Fvw8/AS8rNOg0xUS9fIaHwb+6et8Q/gyvKRjf5OusOzGx8evA/BP4IP11uN/grca5O0lcsPLJ5YjwI4QkJBOHa0WdMZYGxPbh2W2nR9v3WxEWqgp/G3+6VZbRLSAAZ3BhdhAaUL33VUSw9yjEsvbaQ9u4A/gGXwZXoEHOuU1GSj2chf+Mo+f8IcfcAxfIKVmyunRbYQVnoevwgfw3TXXcw++xNuP4fhyueEUNttEduRVaDttddoP0eSxLe2LENk6itYxlrxBNBYrNNKSQmeaLcm9c8UsaB5WyO6675yyQIAWSDpBVoA/gxmcwEvwoDv0m58UE7gHn+fJOa8/Ywan8EKRfjsopF83eCglX/Sfr7OeaRoQfvt1CGvIDccH5BCvw1sWIzRGC/66t0VTcLZQZtm6PlAasbOJ9iwWtUo7biktTSIPxnR24jxP1ZKaqq+2RcXM9OrBAm/AAs7hDJ5bNmGb+KIfwCs8a3jnjBrOFeMjHSCdbKr+2uOLfnOd9eiA8Hvvwwq54VbP2OqwkB48Ytc4YEOiH2vTXqodabfWEOzso4qxdbqD5L6tbtNPECqbhnA708DZH4QOJUXqScmUlks7Ot6FBuZw3n2mEbaUX7kDzxHOOQk8nKWMzAzu6ZZ8sOFw4RK+6PcuXo9tB4SbMz58ApfKDXf3szjNIIbGpD5TKTRxGkEMLjLl+K3wlWXBsCUxIDU+jbOiysESqAy1MGUJpXgwbTWzNOVEziIXZrJ+VIztl1PUBxTSo0dwn2bOmfDRPD3TRTGlfbCJvO9KvuhL1hMHhB9wPuPRLGHcdOWG2xc0U+5bQtAJT0nRTewXL1pgk2+rZAdeWmz3jxAqfNQQdzTlbF8uJ5ecEIWvTkevAHpwz7w78QujlD/Lr491bD8/1vhM2yrUQRrWXNQY4fGilfctMWYjL72UL/qS9eiA8EmN88nbNdour+PBbbAjOjIa4iBhfFg6rxeKdEGcL6p3EWR1Qq2Qkhs2DrnkRnmN9tG2EAqmgPw6hoL7Oza7B+3SCrR9tRftko+Lsf2F/mkTndN2LmzuMcKTuj/mX2+4Va3ki16+nnJY+S7MefpkidxwnV+4wkXH8TKnX0tsYzYp29DOOoSW1nf7nTh2akYiWmcJOuTidSaqESrTYpwjJJNVGQr+rLI7WsqerHW6Kp/oM2pKuV7T1QY9gjqlZp41/WfKpl56FV/0kvXQFRyeQ83xaTu5E8p5dNP3dUF34ihyI3GSpeCsywSh22ZJdWto9winhqifb7VRvgktxp13vyjrS0EjvrRfZ62uyqddSWaWYlwTPAtJZ2oZ3j/Sgi/mi+6vpzesfAcWNA0n8xVyw90GVFGuZjTXEQy+6GfLGLMLL523f5E0OmxVjDoOuRiH91RKU+vtoCtH7TgmvBLvtFXWLW15H9GTdVw8ow4IlRLeHECN9ym1e9K0I+Cbnhgv4Yu+aD2HaQJ80XDqOzSGAV4+4yCqBxrsJAX6ZTIoX36QnvzhhzzMfFW2dZVLOJfo0zbce5OvwXMFaZ81mOnlTVXpDZsQNuoYWveketKb5+6JOOsgX+NTm7H49fUTlx+WLuWL7qxnOFh4BxpmJx0p2gDzA/BUARuS6phR+pUsY7MMboAHx5xNsSVfVZcYSwqCKrqon7zM+8ecCkeS4nm3rINuaWvVNnMRI1IRpxTqx8PZUZ0Br/UEduo3B3hNvmgZfs9gQPj8vIOxd2kndir3awvJ6BLvoUuOfFWNYB0LR1OQJoUySKb9IlOBx74q1+ADC2G6rOdmFdJcD8BkfualA+BdjOOzP9uUhGUEX/TwhZsUduwRr8wNuXKurCixLBgpQI0mDbJr9dIqUuV+92ngkJZ7xduCk2yZKbfWrH1VBiTg9VdzsgRjW3CVXCvAwDd+c1z9dWw9+B+8MJL/eY15ZQ/HqvTwVdsZn5WQsgRRnMaWaecu3jFvMBEmgg+FJFZsnSl0zjB9OqPYaBD7qmoVyImFvzi41usesV0julaAR9dfR15Xzv9sEruRDyk1nb+QaLU67T885GTls6YgcY+UiMa25M/pwGrbCfzkvR3e0jjtuaFtnwuagHTSb5y7boBH119HXhvwP487jJLsLJ4XnUkHX5sLbS61dpiAXRoZSCrFJ+EjpeU3puVfitngYNo6PJrAigKktmwjyQdZpfq30mmtulaAx9Zfx15Xzv+cyeuiBFUs9zq8Kq+XB9a4PVvph3GV4E3y8HENJrN55H1X2p8VyqSKwVusJDKzXOZzplWdzBUFK9e+B4+uv468xvI/b5xtSAkBHQaPvtqWzllVvEOxPbuiE6+j2pvjcKsbvI7txnRErgfH7LdXqjq0IokKzga14GzQ23SSbCQvO6r+Or7SMIr/efOkkqSdMnj9mBx2DRsiY29Uj6+qK9ZrssCKaptR6HKURdwUYeUWA2kPzVKQO8ku2nU3Anhs/XWkBx3F/7wJtCTTTIKftthue1ty9xvNYLY/zo5KSbIuKbXpbEdSyeRyYdAIwKY2neyoc3+k1XUaufYga3T9daMUx/r8z1s10ITknIO0kuoMt+TB8jK0lpayqqjsJ2qtXAYwBU932zinimgmd6mTRDnQfr88q36NAI+tv24E8Pr8zxtasBqx0+xHH9HhlrwsxxNUfKOHQaZBITNf0uccj8GXiVmXAuPEAKSdN/4GLHhs/XWj92dN/uetNuBMnVR+XWDc25JLjo5Mg5IZIq226tmCsip2zZliL213YrTlL2hcFjpCduyim3M7/eB16q/blQsv5X/esDRbtJeabLIosWy3ycavwLhtxdWzbMmHiBTiVjJo6lCLjXZsi7p9PEPnsq6X6wd4bP11i0rD5fzPm/0A6brrIsllenZs0lCJlU4abakR59enZKrKe3BZihbTxlyZ2zl1+g0wvgmA166/bhwDrcn/7Ddz0eWZuJvfSESug6NzZsox3Z04FIxz0mUjMwVOOVTq1CQ0AhdbBGVdjG/CgsfUX7esJl3K/7ytWHRv683praW/8iDOCqWLLhpljDY1ZpzK75QiaZoOTpLKl60auHS/97oBXrv+umU9+FL+5+NtLFgjqVLCdbmj7pY5zPCPLOHNCwXGOcLquOhi8CmCWvbcuO73XmMUPab+ug3A6/A/78Bwe0bcS2+tgHn4J5pyS2WbOck0F51Vq3LcjhLvZ67p1ABbaL2H67bg78BfjKi/jr3+T/ABV3ilLmNXTI2SpvxWBtt6/Z//D0z/FXaGbSBgylzlsEGp+5//xrd4/ae4d8DUUjlslfIYS3t06HZpvfQtvv0N7AHWqtjP2pW08QD/FLy//da38vo8PNlKHf5y37Dxdfe/oj4kVIgFq3koLReSR76W/bx//n9k8jonZxzWTANVwEniDsg87sOSd/z7//PvMp3jQiptGVWFX2caezzAXwfgtzYUvbr0iozs32c3Uge7varH+CNE6cvEYmzbPZ9hMaYDdjK4V2iecf6EcEbdUDVUARda2KzO/JtCuDbNQB/iTeL0EG1JSO1jbXS+nLxtPMDPw1fh5+EPrgSEKE/8Gry5A73ui87AmxwdatyMEBCPNOCSKUeRZ2P6Myb5MRvgCHmA9ywsMifU+AYXcB6Xa5GibUC5TSyerxyh0j6QgLVpdyhfArRTTLqQjwe4HOD9s92D4Ap54odXAPBWLAwB02igG5Kkc+piN4lvODIFGAZgT+EO4Si1s7fjSR7vcQETUkRm9O+MXyo9OYhfe4xt9STQ2pcZRLayCV90b4D3jR0DYAfyxJ+eywg2IL7NTMXna7S/RpQ63JhWEM8U41ZyQGjwsVS0QBrEKLu8xwZsbi4wLcCT+OGidPIOCe1PiSc9Qt+go+vYqB7cG+B9d8cAD+WJPz0Am2gxXgU9IneOqDpAAXOsOltVuMzpdakJXrdPCzXiNVUpCeOos5cxnpQT39G+XVLhs1osQVvJKPZyNq8HDwd4d7pNDuWJPxVX7MSzqUDU6gfadKiNlUFTzLeFHHDlzO4kpa7aiKhBPGKwOqxsBAmYkOIpipyXcQSPlRTf+Tii0U3EJGaZsDER2qoB3h2hu0qe+NNwUooYU8y5mILbJe6OuX+2FTKy7bieTDAemaQyQ0CPthljSWO+xmFDIYiESjM5xKd6Ik5lvLq5GrQ3aCMLvmCA9wowLuWJb9xF59hVVP6O0CrBi3ZjZSNOvRy+I6klNVRJYRBaEzdN+imiUXQ8iVF8fsp+W4JXw7WISW7fDh7lptWkCwZ4d7QTXyBPfJMYK7SijjFppGnlIVJBJBYj7eUwtiP1IBXGI1XCsjNpbjENVpSAJ2hq2LTywEly3hUYazt31J8w2+aiLx3g3fohXixPfOMYm6zCGs9LVo9MoW3MCJE7R5u/WsOIjrqBoHUO0bJE9vxBpbhsd3+Nb4/vtPCZ4oZYCitNeYuC/8UDvDvy0qvkiW/cgqNqRyzqSZa/s0mqNGjtKOoTm14zZpUauiQgVfqtQiZjq7Q27JNaSK5ExRcrGCXO1FJYh6jR6CFqK7bZdQZ4t8g0rSlPfP1RdBtqaa9diqtzJkQ9duSryi2brQXbxDwbRUpFMBHjRj8+Nt7GDKgvph9okW7LX47gu0SpGnnFQ1S1lYldOsC7hYteR574ZuKs7Ei1lBsfdz7IZoxzzCVmmVqaSySzQbBVAWDek+N4jh9E/4VqZrJjPwiv9BC1XcvOWgO8275CVyBPvAtTVlDJfZkaZGU7NpqBogAj/xEHkeAuJihWYCxGN6e8+9JtSegFXF1TrhhLGP1fak3pebgPz192/8gB4d/6WT7+GdYnpH7hH/DJzzFiYPn/vjW0SgNpTNuPIZoAEZv8tlGw4+RLxy+ZjnKa5NdFoC7UaW0aduoYse6+bXg1DLg6UfRYwmhGEjqPvF75U558SANrElK/+MdpXvmqBpaXOa/MTZaa1DOcSiLaw9j0NNNst3c+63c7EKTpkvKHzu6bPbP0RkuHAVcbRY8ijP46MIbQeeT1mhA+5PV/inyDdQipf8LTvMXbwvoDy7IruDNVZKTfV4CTSRUYdybUCnGU7KUTDxLgCknqUm5aAW6/1p6eMsOYsphLzsHrE0Y/P5bQedx1F/4yPHnMB3/IOoTU9+BL8PhtjuFKBpZXnYNJxTuv+2XqolKR2UQgHhS5novuxVySJhBNRF3SoKK1XZbbXjVwWNyOjlqWJjrWJIy+P5bQedyldNScP+HZ61xKSK3jyrz+NiHG1hcOLL/+P+PDF2gOkekKGiNWKgJ+8Z/x8Iv4DdQHzcpZyF4v19I27w9/yPGDFQvmEpKtqv/TLiWMfn4sofMm9eAH8Ao0zzh7h4sJqYtxZd5/D7hkYPneDzl5idlzNHcIB0jVlQ+8ULzw/nc5/ojzl2juE0apD7LRnJxe04dMz2iOCFNtGFpTuXA5AhcTRo8mdN4kz30nVjEC4YTZQy4gpC7GlTlrePKhGsKKgeXpCYeO0MAd/GH7yKQUlXPLOasOH3FnSphjHuDvEu4gB8g66oNbtr6eMbFIA4fIBJkgayoXriw2XEDQPJrQeROAlY6aeYOcMf+IVYTU3XFlZufMHinGywaW3YLpObVBAsbjF4QJMsVUSayjk4voPsHJOQfPWDhCgDnmDl6XIRerD24HsGtw86RMHOLvVSHrKBdeVE26gKB5NKHzaIwLOmrqBWJYZDLhASG16c0Tn+CdRhWDgWXnqRZUTnPIHuMJTfLVpkoYy5CzylHVTGZMTwkGAo2HBlkQplrJX6U+uF1wZz2uwS1SQ12IqWaPuO4baZaEFBdukksJmkcTOm+YJSvoqPFzxFA/YUhIvWxcmSdPWTWwbAKVp6rxTtPFUZfKIwpzm4IoMfaYQLWgmlG5FME2gdBgm+J7J+rtS/XBbaVLsR7bpPQnpMFlo2doWaVceHk9+MkyguZNCJ1He+kuHTWyQAzNM5YSUg/GlTk9ZunAsg1qELVOhUSAK0LABIJHLKbqaEbHZLL1VA3VgqoiOKXYiS+HRyaEKgsfIqX64HYWbLRXy/qWoylIV9gudL1OWBNgBgTNmxA6b4txDT4gi3Ri7xFSLxtXpmmYnzAcWDZgY8d503LFogz5sbonDgkKcxGsWsE1OI+rcQtlgBBCSOKD1mtqYpIU8cTvBmAT0yZe+zUzeY92fYjTtGipXLhuR0ePoHk0ofNWBX+lo8Z7pAZDk8mEw5L7dVyZZoE/pTewbI6SNbiAL5xeygW4xPRuLCGbhcO4RIeTMFYHEJkYyEO9HmJfXMDEj/LaH781wHHZEtqSQ/69UnGpzH7LKIAZEDSPJnTesJTUa+rwTepI9dLJEawYV+ZkRn9g+QirD8vF8Mq0jFQ29js6kCS3E1+jZIhgPNanHdHFqFvPJLHqFwQqbIA4jhDxcNsOCCQLDomaL/dr5lyJaJU6FxPFjO3JOh3kVMcROo8u+C+jo05GjMF3P3/FuDLn5x2M04xXULPwaS6hBYki+MrMdZJSgPHlcB7nCR5bJ9Kr5ACUn9jk5kivdd8tk95SOGrtqu9lr2IhK65ZtEl7ZKrp7DrqwZfRUSN1el7+7NJxZbywOC8neNKTch5vsTEMNsoCCqHBCqIPRjIPkm0BjvFODGtto99rCl+d3wmHkW0FPdpZtC7MMcVtGFQjJLX5bdQ2+x9ypdc313uj8xlsrfuLgWXz1cRhZvJYX0iNVBRcVcmCXZs6aEf3RQF2WI/TcCbKmGU3IOoDJGDdDub0+hYckt6PlGu2BcxmhbTdj/klhccLGJMcqRjMJP1jW2ETqLSWJ/29MAoORluJ+6LPffBZbi5gqi5h6catQpmOT7/OFf5UorRpLzCqcMltBLhwd1are3kztrSzXO0LUbXRQcdLh/RdSZ+swRm819REDrtqzC4es6Gw4JCKlSnjYVpo0xeq33PrADbFLL3RuCmObVmPN+24kfa+AojDuM4umKe2QwCf6EN906HwjujaitDs5o0s1y+k3lgbT2W2i7FJdnwbLXhJUBq/9liTctSmFC/0OqUinb0QddTWamtjbHRFuWJJ6NpqZ8vO3fZJ37Db+2GkaPYLGHs7XTTdiFQJ68SkVJFVmY6McR5UycflNCsccHFaV9FNbR4NttLxw4pQ7wJd066Z0ohVbzihaxHVExd/ay04oxUKWt+AsdiQ9OUyZ2krzN19IZIwafSTFgIBnMV73ADj7V/K8u1MaY2sJp2HWm0f41tqwajEvdHWOJs510MaAqN4aoSiPCXtN2KSi46dUxHdaMquar82O1x5jqhDGvqmoE9LfxcY3zqA7/x3HA67r9ZG4O6Cuxu12/+TP+eLP+I+HErqDDCDVmBDO4larujNe7x8om2rMug0MX0rL1+IWwdwfR+p1TNTyNmVJ85ljWzbWuGv8/C7HD/izjkHNZNYlhZcUOKVzKFUxsxxN/kax+8zPWPSFKw80rJr9Tizyj3o1gEsdwgWGoxPezDdZ1TSENE1dLdNvuKL+I84nxKesZgxXVA1VA1OcL49dFlpFV5yJMhzyCmNQ+a4BqusPJ2bB+xo8V9u3x48VVIEPS/mc3DvAbXyoYr6VgDfh5do5hhHOCXMqBZUPhWYbWZECwVJljLgMUWOCB4MUuMaxGNUQDVI50TQ+S3kFgIcu2qKkNSHVoM0SHsgoZxP2d5HH8B9woOk4x5bPkKtAHucZsdykjxuIpbUrSILgrT8G7G5oCW+K0990o7E3T6AdW4TilH5kDjds+H64kS0mz24grtwlzDHBJqI8YJQExotPvoC4JBq0lEjjQkyBZ8oH2LnRsQ4Hu1QsgDTJbO8fQDnllitkxuVskoiKbRF9VwzMDvxHAdwB7mD9yCplhHFEyUWHx3WtwCbSMMTCUCcEmSGlg4gTXkHpZXWQ7kpznK3EmCHiXInqndkQjunG5kxTKEeGye7jWz9cyMR2mGiFQ15ENRBTbCp+Gh86vAyASdgmJq2MC6hoADQ3GosP0QHbnMHjyBQvQqfhy/BUbeHd5WY/G/9LK/8Ka8Jd7UFeNWEZvzPb458Dn8DGLOe3/wGL/4xP+HXlRt+M1PE2iLhR8t+lfgxsuh7AfO2AOf+owWhSZRYQbd622hbpKWKuU+XuvNzP0OseRDa+mObgDHJUSc/pKx31QdKffQ5OIJpt8GWjlgTwMc/w5MPCR/yl1XC2a2Yut54SvOtMev55Of45BOat9aWG27p2ZVORRvnEk1hqWMVUmqa7S2YtvlIpspuF1pt0syuZS2NV14mUidCSfzQzg+KqvIYCMljIx2YK2AO34fX4GWdu5xcIAb8MzTw+j/lyWM+Dw/gjs4GD6ehNgA48kX/AI7XXM/XAN4WHr+9ntywqoCakCqmKP0rmQrJJEErG2Upg1JObr01lKQy4jskWalKYfJ/EDLMpjNSHFEUAde2fltaDgmrNaWQ9+AAb8I5vKjz3L1n1LriB/BXkG/wwR9y/oRX4LlioHA4LzP2inzRx/DWmutRweFjeP3tNeSGlaE1Fde0OS11yOpmbIp2u/jF1n2RRZviJM0yBT3IZl2HWImKjQOxIyeU325b/qWyU9Moj1o07tS0G7qJDoGHg5m8yeCxMoEH8GU45tnrNM84D2l297DQ9t1YP7jki/7RmutRweEA77/HWXOh3HCxkRgldDQkAjNTMl2Iloc1qN5JfJeeTlyTRzxURTdn1Ixv2uKjs12AbdEWlBtmVdk2k7FFwj07PCZ9XAwW3dG+8xKzNFr4EnwBZpy9Qzhh3jDXebBpYcpuo4fQ44u+fD1dweEnHzI7v0xuuOALRUV8rXpFyfSTQYkhd7IHm07jpyhlkCmI0ALYqPTpUxXS+z4jgDj1Pflvmz5ecuItpIBxyTHpSTGWd9g1ApfD/bvwUhL4nT1EzqgX7cxfCcNmb3mPL/qi9SwTHJ49oj5ZLjccbTG3pRmlYi6JCG0mQrAt1+i2UXTZ2dv9IlQpN5naMYtviaXlTrFpoMsl3bOAFEa8sqPj2WCMrx3Yjx99qFwO59Aw/wgx+HlqNz8oZvA3exRDvuhL1jMQHPaOJ0+XyA3fp1OfM3qObEVdhxjvynxNMXQV4+GJyvOEFqeQBaIbbO7i63rpxCltdZShPFxkjM2FPVkn3TG+Rp9pO3l2RzFegGfxGDHIAh8SteR0C4HopXzRF61nheDw6TFN05Ebvq8M3VKKpGjjO6r7nhudTEGMtYM92HTDaR1FDMXJ1eThsbKfywyoWwrzRSXkc51flG3vIid62h29bIcFbTGhfV+faaB+ohj7dPN0C2e2lC96+XouFByen9AsunLDJZ9z7NExiUc0OuoYW6UZkIyx2YUR2z6/TiRjyKMx5GbbjLHvHuf7YmtKghf34LJfx63Yg8vrvN2zC7lY0x0tvKezo4HmGYDU+Gab6dFL+KI761lDcNifcjLrrr9LWZJctG1FfU1uwhoQE22ObjdfkSzY63CbU5hzs21WeTddH2BaL11Gi7lVdlxP1nkxqhnKhVY6knS3EPgVGg1JpN5cP/hivujOelhXcPj8HC/LyI6MkteVjlolBdMmF3a3DbsuAYhL44dxzthWSN065xxUd55Lmf0wRbOYOqH09/o9WbO2VtFdaMb4qBgtFJoT1SqoN8wPXMoXLb3p1PUEhxfnnLzGzBI0Ku7FxrKsNJj/8bn/H8fPIVOd3rfrklUB/DOeO+nkghgSPzrlPxluCMtOnDL4Yml6dK1r3vsgMxgtPOrMFUZbEUbTdIzii5beq72G4PD0DKnwjmBULUVFmy8t+k7fZ3pKc0Q4UC6jpVRqS9Umv8bxw35flZVOU1X7qkjnhZlsMbk24qQ6Hz7QcuL6sDC0iHHki96Uh2UdvmgZnjIvExy2TeJdMDZNSbdZyAHe/Yd1xsQhHiKzjh7GxQ4yqMPaywPkjMamvqrYpmO7Knad+ZQC5msCuAPWUoxrxVhrGv7a+KLXFhyONdTMrZ7ke23qiO40ZJUyzgYyX5XyL0mV7NiUzEs9mjtbMN0dERqwyAJpigad0B3/zRV7s4PIfXSu6YV/MK7+OrYe/JvfGMn/PHJe2fyUdtnFrKRNpXV0Y2559aWPt/G4BlvjTMtXlVIWCnNyA3YQBDmYIodFz41PvXPSa6rq9lWZawZ4dP115HXV/M/tnFkkrBOdzg6aP4pID+MZnTJ1SuuB6iZlyiox4HT2y3YBtkUKWooacBQUDTpjwaDt5poBHl1/HXltwP887lKKXxNUEyPqpGTyA699UqY/lt9yGdlUKra0fFWS+36iylVWrAyd7Uw0CZM0z7xKTOduznLIjG2Hx8cDPLb+OvK6Bv7n1DYci4CxUuRxrjBc0bb4vD3rN5Zz36ntLb83eVJIB8LiIzCmn6SMPjlX+yNlTjvIGjs+QzHPf60Aj62/jrzG8j9vYMFtm1VoRWCJdmw7z9N0t+c8cxZpPeK4aTRicS25QhrVtUp7U578chk4q04Wx4YoQSjFryUlpcQ1AbxZ/XVMknIU//OGl7Q6z9Zpxi0+3yFhSkjUDpnCIUhLWVX23KQ+L9vKvFKI0ZWFQgkDLvBoylrHNVmaw10zwCPrr5tlodfnf94EWnQ0lFRWy8pW9LbkLsyUVDc2NSTHGDtnD1uMtchjbCeb1mpxFP0YbcClhzdLu6lfO8Bj6q+bdT2sz/+8SZCV7VIxtt0DUn9L7r4cLYWDSXnseEpOGFuty0qbOVlS7NNzs5FOGJUqQpl2Q64/yBpZf90sxbE+//PGdZ02HSipCbmD6NItmQ4Lk5XUrGpDMkhbMm2ZVheNYV+VbUWTcv99+2NyX1VoafSuC+AN6q9bFIMv5X/eagNWXZxEa9JjlMwNWb00akGUkSoepp1/yRuuqHGbUn3UdBSTxBU6SEVklzWRUkPndVvw2PrrpjvxOvzPmwHc0hpmq82npi7GRro8dXp0KXnUQmhZbRL7NEVp1uuZmO45vuzKsHrktS3GLWXODVjw+vXXLYx4Hf7njRPd0i3aoAGX6W29GnaV5YdyDj9TFkakje7GHYzDoObfddHtOSpoi2SmzJHrB3hM/XUDDEbxP2/oosszcRlehWXUvzHv4TpBVktHqwenFo8uLVmy4DKLa5d3RtLrmrM3aMFr1183E4sewf+85VWeg1c5ag276NZrM9IJVNcmLEvDNaV62aq+14IAOGFsBt973Ra8Xv11YzXwNfmft7Jg2oS+XOyoC8/cwzi66Dhmgk38kUmP1CUiYWOX1bpD2zWXt2FCp7uq8703APAa9dfNdscR/M/bZLIyouVxqJfeWvG9Je+JVckHQ9+CI9NWxz+blX/KYYvO5n2tAP/vrlZ7+8/h9y+9qeB/Hnt967e5mevX10rALDWK//FaAT5MXdBXdP0C/BAes792c40H+AiAp1e1oH8HgH94g/Lttx1gp63op1eyoM/Bvw5/G/7xFbqJPcCXnmBiwDPb/YKO4FX4OjyCb289db2/Noqicw4i7N6TVtoz8tNwDH+8x/i6Ae7lmaQVENzJFb3Di/BFeAwz+Is9SjeQySpPqbLFlNmyz47z5a/AF+AYFvDmHqibSXTEzoT4Gc3OALaqAP4KPFUJ6n+1x+rGAM6Zd78bgJ0a8QN4GU614vxwD9e1Amy6CcskNrczLx1JIp6HE5UZD/DBHrFr2oNlgG4Odv226BodoryjGJ9q2T/AR3vQrsOCS0ctXZi3ruLlhpFDJYl4HmYtjQCP9rhdn4suySLKDt6wLcC52h8xPlcjju1fn+yhuw4LZsAGUuo2b4Fx2UwQu77uqRHXGtg92aN3tQCbFexc0uk93vhTXbct6y7MulLycoUljx8ngDMBg1tvJjAazpEmOtxlzclvj1vQf1Tx7QlPDpGpqgtdSKz/d9/hdy1vTfFHSmC9dGDZbLiezz7Ac801HirGZsWjydfZyPvHXL/Y8Mjzg8BxTZiuwKz4Eb8sBE9zznszmjvFwHKPIWUnwhqfVRcd4Ck0K6ate48m1oOfrX3/yOtvAsJ8zsPAM89sjnddmuLuDPjX9Bu/L7x7xpMzFk6nWtyQfPg278Gn4Aekz2ZgOmU9eJ37R14vwE/BL8G3aibCiWMWWDQ0ZtkPMnlcGeAu/Ag+8ZyecU5BPuy2ILD+sQqyZhAKmn7XZd+jIMTN9eBL7x95xVLSX4On8EcNlXDqmBlqS13jG4LpmGbkF/0CnOi3H8ETOIXzmnmtb0a16Tzxj1sUvQCBiXZGDtmB3KAefPH94xcUa/6vwRn80GOFyjEXFpba4A1e8KQfFF+259tx5XS4egYn8fQsLGrqGrHbztr+uByTahWuL1NUGbDpsnrwBfePPwHHIf9X4RnM4Z2ABWdxUBlqQ2PwhuDxoS0vvqB1JzS0P4h2nA/QgTrsJFn+Y3AOjs9JFC07CGWX1oNX3T/yHOzgDjwPn1PM3g9Jk9lZrMEpxnlPmBbjyo2+KFXRU52TJM/2ALcY57RUzjObbjqxVw++4P6RAOf58pcVsw9Daje3htriYrpDOonre3CudSe6bfkTEgHBHuDiyu5MCsc7BHhYDx7ePxLjqigXZsw+ijMHFhuwBmtoTPtOxOrTvYJDnC75dnUbhfwu/ZW9AgYd+peL68HD+0emKquiXHhWjJg/UrkJYzuiaL3E9aI/ytrCvAd4GcYZMCkSQxfUg3v3j8c4e90j5ZTPdvmJJGHnOCI2nHS8081X013pHuBlV1gB2MX1YNmWLHqqGN/TWmG0y6clJWthxNUl48q38Bi8vtMKyzzpFdSDhxZ5WBA5ZLt8Jv3895DduBlgbPYAj8C4B8hO68FDkoh5lydC4FiWvBOVqjYdqjiLv92t8yPDjrDaiHdUD15qkSURSGmXJwOMSxWAXYwr3zaAufJ66l+94vv3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/wHuD9tQd4f+0B3l97gPfXHuD9tQd4f+0B3l97gG8LwP8G/AL8O/A5OCq0Ys2KIdv/qOIXG/4mvFAMF16gZD+2Xvu/B8as5+8bfllWyg0zaNO5bfXj6vfhhwD86/Aq3NfRS9t9WPnhfnvCIw/CT8GLcFTMnpntdF/z9V+PWc/vWoIH+FL3Znv57PitcdGP4R/C34avw5fgRVUInCwbsn1yyA8C8zm/BH8NXoXnVE6wVPjdeCI38kX/3+Ct9dbz1pTmHFRu+Hm4O9Ch3clr99negxfwj+ER/DR8EV6B5+DuQOnTgUw5rnkY+FbNU3gNXh0o/JYTuWOvyBf9FvzX663HH/HejO8LwAl8Hl5YLTd8q7sqA3wbjuExfAFegQdwfyDoSkWY8swzEf6o4Qyewefg+cHNbqMQruSL/u/WWc+E5g7vnnEXgDmcDeSGb/F4cBcCgT+GGRzDU3hZYburAt9TEtHgbM6JoxJ+6NMzzTcf6c2bycv2+KK/f+l6LBzw5IwfqZJhA3M472pWT/ajKxnjv4AFnMEpnBTPND6s2J7qHbPAqcMK74T2mZ4VGB9uJA465It+/eL1WKhYOD7xHOkr1ajK7d0C4+ke4Hy9qXZwpgLr+Znm/uNFw8xQOSy8H9IzjUrd9+BIfenYaylf9FsXr8fBAadnPIEDna8IBcwlxnuA0/Wv6GAWPd7dDIKjMdSWueAsBj4M7TOd06qBbwDwKr7oleuxMOEcTuEZTHWvDYUO7aHqAe0Bbq+HEFRzOz7WVoTDQkVds7A4sIIxfCQdCefFRoIOF/NFL1mPab/nvOakSL/Q1aFtNpUb/nFOVX6gzyg/1nISyDfUhsokIzaBR9Kxm80s5mK+6P56il1jXic7nhQxsxSm3OwBHl4fFdLqi64nDQZvqE2at7cWAp/IVvrN6/BFL1mPhYrGMBfOi4PyjuSGf6wBBh7p/FZTghCNWGgMzlBbrNJoPJX2mW5mwZfyRffXo7OFi5pZcS4qZUrlViptrXtw+GQoyhDPS+ANjcGBNRiLCQDPZPMHuiZfdFpPSTcQwwKYdRNqpkjm7AFeeT0pJzALgo7g8YYGrMHS0iocy+YTm2vyRUvvpXCIpQ5pe666TJrcygnScUf/p0NDs/iAI/nqDHC8TmQT8x3NF91l76oDdQGwu61Z6E0ABv7uO1dbf/37Zlv+Zw/Pbh8f1s4Avur6657/+YYBvur6657/+YYBvur6657/+YYBvur6657/+aYBvuL6657/+VMA8FXWX/f8zzcN8BXXX/f8zzcNMFdbf93zP38KLPiK6697/uebtuArrr/u+Z9vGmCusP6653/+1FjwVdZf9/zPN7oHX339dc//fNMu+irrr3v+50+Bi+Zq6697/uebA/jz8Pudf9ht/fWv517J/XUzAP8C/BAeX9WCDrUpZ3/dEMBxgPcfbtTVvsYV5Yn32u03B3Ac4P3b8I+vxNBKeeL9dRMAlwO83959qGO78sT769oB7g3w/vGVYFzKE++v6wV4OMD7F7tckFkmT7y/rhHgpQO8b+4Y46XyxPvrugBeNcB7BRiX8sT767oAvmCA9woAHsoT76+rBJjLBnh3txOvkifeX1dswZcO8G6N7sXyxPvr6i340gHe3TnqVfLE++uKAb50gHcXLnrX8sR7gNdPRqwzwLu7Y/FO5Yn3AK9jXCMGeHdgxDuVJ75VAI8ljP7PAb3/RfjcZfePHBB+79dpfpH1CanN30d+mT1h9GqAxxJGM5LQeeQ1+Tb+EQJrElLb38VHQ94TRq900aMIo8cSOo+8Dp8QfsB8zpqE1NO3OI9Zrj1h9EV78PqE0WMJnUdeU6E+Jjyk/hbrEFIfeWbvId8H9oTRFwdZaxJGvziW0Hn0gqYB/wyZ0PwRlxJST+BOw9m77Amj14ii1yGM/txYQudN0qDzGe4EqfA/5GJCagsHcPaEPWH0esekSwmjRxM6b5JEcZ4ww50ilvAOFxBSx4yLW+A/YU8YvfY5+ALC6NGEzhtmyZoFZoarwBLeZxUhtY4rc3bKnjB6TKJjFUHzJoTOozF2YBpsjcyxDgzhQ1YRUse8+J4wenwmaylB82hC5w0zoRXUNXaRBmSMQUqiWSWkLsaVqc/ZE0aPTFUuJWgeTei8SfLZQeMxNaZSIzbII4aE1Nmr13P2hNHjc9E9guYNCZ032YlNwESMLcZiLQHkE4aE1BFg0yAR4z1h9AiAGRA0jyZ03tyIxWMajMPWBIsxYJCnlITU5ShiHYdZ94TR4wCmSxg9jtB5KyPGYzymAYexWEMwAPIsAdYdV6aObmNPGD0aYLoEzaMJnTc0Ygs+YDw0GAtqxBjkuP38bMRWCHn73xNGjz75P73WenCEJnhwyVe3AEe8TtKdJcYhBl97wuhNAObK66lvD/9J9NS75v17wuitAN5fe4D31x7g/bUHeH/tAd5fe4D3AO+vPcD7aw/w/toDvL/2AO+vPcD7aw/w/toDvAd4f/24ABzZ8o+KLsSLS+Pv/TqTb3P4hKlQrTGh+fbIBT0Axqznnb+L/V2mb3HkN5Mb/nEHeK7d4IcDld6lmDW/iH9E+AH1MdOw/Jlu2T1xNmY98sv4wHnD7D3uNHu54WUuOsBTbQuvBsPT/UfzNxGYzwkP8c+Yz3C+r/i6DcyRL/rZ+utRwWH5PmfvcvYEt9jLDS/bg0/B64DWKrQM8AL8FPwS9beQCe6EMKNZYJol37jBMy35otdaz0Bw2H/C2Smc7+WGB0HWDELBmOByA3r5QONo4V+DpzR/hFS4U8wMW1PXNB4TOqYz9urxRV++ntWCw/U59Ty9ebdWbrgfRS9AYKKN63ZokZVygr8GZ/gfIhZXIXPsAlNjPOLBby5c1eOLvmQ9lwkOy5x6QV1j5TYqpS05JtUgUHUp5toHGsVfn4NX4RnMCe+AxTpwmApTYxqMxwfCeJGjpXzRF61nbcHhUBPqWze9svwcHJ+S6NPscKrEjug78Dx8Lj3T8D4YxGIdxmJcwhi34fzZUr7olevZCw5vkOhoClq5zBPZAnygD/Tl9EzDh6kl3VhsHYcDEb+hCtJSvuiV69kLDm+WycrOTArHmB5/VYyP6jOVjwgGawk2zQOaTcc1L+aLXrKeveDwZqlKrw8U9Y1p66uK8dEzdYwBeUQAY7DbyYNezBfdWQ97weEtAKYQg2xJIkuveAT3dYeLGH+ShrWNwZgN0b2YL7qznr3g8JYAo5bQBziPjx7BPZ0d9RCQp4UZbnFdzBddor4XHN4KYMrB2qHFRIzzcLAHQZ5the5ovui94PCWAPefaYnxIdzRwdHCbuR4B+tbiy96Lzi8E4D7z7S0mEPd+eqO3cT53Z0Y8SV80XvB4Z0ADJi/f7X113f+7p7/+UYBvur6657/+YYBvur6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+aYBvuL6657/+VMA8FXWX/f8z58OgK+y/rrnf75RgLna+uue//lTA/CV1V/3/M837aKvvv6653++UQvmauuve/7nTwfAV1N/3fM/fzr24Cuuv+75nz8FFnxl9dc9//MOr/8/glixwRuUfM4AAAAASUVORK5CYII="
		},
		getSearchTexture: function() {
			return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEIAAAAhCAAAAABIXyLAAAAAOElEQVRIx2NgGAWjYBSMglEwEICREYRgFBZBqDCSLA2MGPUIVQETE9iNUAqLR5gIeoQKRgwXjwAAGn4AtaFeYLEAAAAASUVORK5CYII="
		}
	});
	var yg = {
			shaderID: "luminosityHighPass",
			uniforms: {
				tDiffuse: {
					value: null
				},
				luminosityThreshold: {
					value: 1
				},
				smoothWidth: {
					value: 1
				},
				defaultColor: {
					value: new S(0)
				},
				defaultOpacity: {
					value: 0
				}
			},
			vertexShader: "varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
			fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec3 defaultColor;\nuniform float defaultOpacity;\nuniform float luminosityThreshold;\nuniform float smoothWidth;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texel = texture2D( tDiffuse, vUv );\n\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\tfloat v = dot( texel.xyz, luma );\n\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\tgl_FragColor = mix( outputColor, texel, alpha );\n}"
		},
		md = function(a, b, c, d) {
			db.call(this);
			this.strength = void 0 !== b ? b : 1;
			this.radius = c;
			this.threshold = d;
			this.resolution = void 0 !== a ? new B(a.x, a.y) : new B(256, 256);
			this.clearColor = new S(0, 0, 0);
			var e = {
				minFilter: 1006,
				magFilter: 1006,
				format: 1023
			};
			this.renderTargetsHorizontal = [];
			this.renderTargetsVertical = [];
			this.nMips = 5;
			a = Math.round(this.resolution.x / 2);
			c = Math.round(this.resolution.y / 2);
			this.renderTargetBright = new Oa(a, c, e);
			this.renderTargetBright.texture.name = "UnrealBloomPass.bright";
			this.renderTargetBright.texture.generateMipmaps = !1;
			for (var g = 0; g < this.nMips; g++) {
				var k = new Oa(a, c, e);
				k.texture.name = "UnrealBloomPass.h" + g;
				k.texture.generateMipmaps = !1;
				this.renderTargetsHorizontal.push(k);
				k = new Oa(a, c, e);
				k.texture.name = "UnrealBloomPass.v" + g;
				k.texture.generateMipmaps = !1;
				this.renderTargetsVertical.push(k);
				a = Math.round(a / 2);
				c = Math.round(c / 2)
			}
			void 0 === yg && console.error("UnrealBloomPass relies on LuminosityHighPassShader");
			this.highPassUniforms = Ee.clone(yg.uniforms);
			this.highPassUniforms.luminosityThreshold.value = d;
			this.highPassUniforms.smoothWidth.value =
				.01;
			this.materialHighPassFilter = new Ia({
				uniforms: this.highPassUniforms,
				vertexShader: yg.vertexShader,
				fragmentShader: yg.fragmentShader,
				defines: {}
			});
			this.separableBlurMaterials = [];
			d = [3, 5, 7, 9, 11];
			a = Math.round(this.resolution.x / 2);
			c = Math.round(this.resolution.y / 2);
			for (g = 0; g < this.nMips; g++) this.separableBlurMaterials.push(this.getSeperableBlurMaterial(d[g])), this.separableBlurMaterials[
				g].uniforms.texSize.value = new B(a, c), a = Math.round(a / 2), c = Math.round(c / 2);
			this.compositeMaterial = this.getCompositeMaterial(this.nMips);
			this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture;
			this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture;
			this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture;
			this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture;
			this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture;
			this.compositeMaterial.uniforms.bloomStrength.value = b;
			this.compositeMaterial.uniforms.bloomRadius.value =
				.1;
			this.compositeMaterial.needsUpdate = !0;
			this.compositeMaterial.uniforms.bloomFactors.value = [1, .8, .6, .4, .2];
			this.bloomTintColors = [new u(1, 1, 1), new u(1, 1, 1), new u(1, 1, 1), new u(1, 1, 1), new u(1, 1, 1)];
			this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
			void 0 === ld && console.error("UnrealBloomPass relies on CopyShader");
			this.copyUniforms = Ee.clone(ld.uniforms);
			this.copyUniforms.opacity.value = 1;
			this.materialCopy = new Ia({
				uniforms: this.copyUniforms,
				vertexShader: ld.vertexShader,
				fragmentShader: ld.fragmentShader,
				blending: 2,
				depthTest: !1,
				depthWrite: !1,
				transparent: !0
			});
			this.enabled = !0;
			this.needsSwap = !1;
			this.oldClearColor = new S;
			this.oldClearAlpha = 1;
			this.basic = new Ob;
			this.fsQuad = new db.FullScreenQuad(null)
		};
	md.prototype = q(p(db.prototype), {
		constructor: md,
		dispose: function() {
			for (var a = 0; a < this.renderTargetsHorizontal.length; a++) this.renderTargetsHorizontal[a].dispose();
			for (a = 0; a < this.renderTargetsVertical.length; a++) this.renderTargetsVertical[a].dispose();
			this.renderTargetBright.dispose()
		},
		setSize: function(a, b) {
			a =
				Math.round(a / 2);
			b = Math.round(b / 2);
			this.renderTargetBright.setSize(a, b);
			for (var c = 0; c < this.nMips; c++) this.renderTargetsHorizontal[c].setSize(a, b), this.renderTargetsVertical[c]
				.setSize(a, b), this.separableBlurMaterials[c].uniforms.texSize.value = new B(a, b), a = Math.round(a / 2), b =
				Math.round(b / 2)
		},
		render: function(a, b, c, d, e) {
			this.oldClearColor.copy(a.getClearColor());
			this.oldClearAlpha = a.getClearAlpha();
			b = a.autoClear;
			a.autoClear = !1;
			a.setClearColor(this.clearColor, 0);
			e && a.state.buffers.stencil.setTest(!1);
			this.renderToScreen &&
				(this.fsQuad.material = this.basic, this.basic.map = c.texture, a.setRenderTarget(null), a.clear(), this.fsQuad
					.render(a));
			this.highPassUniforms.tDiffuse.value = c.texture;
			this.highPassUniforms.luminosityThreshold.value = this.threshold;
			this.fsQuad.material = this.materialHighPassFilter;
			a.setRenderTarget(this.renderTargetBright);
			a.clear();
			this.fsQuad.render(a);
			d = this.renderTargetBright;
			for (var g = 0; g < this.nMips; g++) this.fsQuad.material = this.separableBlurMaterials[g], this.separableBlurMaterials[
					g].uniforms.colorTexture.value =
				d.texture, this.separableBlurMaterials[g].uniforms.direction.value = md.BlurDirectionX, a.setRenderTarget(this.renderTargetsHorizontal[
					g]), a.clear(), this.fsQuad.render(a), this.separableBlurMaterials[g].uniforms.colorTexture.value = this.renderTargetsHorizontal[
					g].texture, this.separableBlurMaterials[g].uniforms.direction.value = md.BlurDirectionY, a.setRenderTarget(
					this.renderTargetsVertical[g]), a.clear(), this.fsQuad.render(a), d = this.renderTargetsVertical[g];
			this.fsQuad.material = this.compositeMaterial;
			this.compositeMaterial.uniforms.bloomStrength.value =
				this.strength;
			this.compositeMaterial.uniforms.bloomRadius.value = this.radius;
			this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors;
			a.setRenderTarget(this.renderTargetsHorizontal[0]);
			a.clear();
			this.fsQuad.render(a);
			this.fsQuad.material = this.materialCopy;
			this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture;
			e && a.state.buffers.stencil.setTest(!0);
			this.renderToScreen ? a.setRenderTarget(null) : a.setRenderTarget(c);
			this.fsQuad.render(a);
			a.setClearColor(this.oldClearColor,
				this.oldClearAlpha);
			a.autoClear = b
		},
		getSeperableBlurMaterial: function(a) {
			return new Ia({
				defines: {
					KERNEL_RADIUS: a,
					SIGMA: a
				},
				uniforms: {
					colorTexture: {
						value: null
					},
					texSize: {
						value: new B(.5, .5)
					},
					direction: {
						value: new B(.5, .5)
					}
				},
				vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
				fragmentShader: "#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"
			})
		},
		getCompositeMaterial: function(a) {
			return new Ia({
				defines: {
					NUM_MIPS: a
				},
				uniforms: {
					blurTexture1: {
						value: null
					},
					blurTexture2: {
						value: null
					},
					blurTexture3: {
						value: null
					},
					blurTexture4: {
						value: null
					},
					blurTexture5: {
						value: null
					},
					dirtTexture: {
						value: null
					},
					bloomStrength: {
						value: 1
					},
					bloomFactors: {
						value: null
					},
					bloomTintColors: {
						value: null
					},
					bloomRadius: {
						value: 0
					}
				},
				vertexShader: "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
				fragmentShader: "varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"
			})
		}
	});
	md.BlurDirectionX = new B(1, 0);
	md.BlurDirectionY = new B(0, 1);
	var gt = function(a) {
		function b(a) {
			Xa(this, b);
			return Zb(this, (b.__proto__ || Yb(b)).call(this, a))
		}
		$b(b, a);
		jb(b, [{
			key: "initialize",
			value: function(a) {
				var b = a.camera,
					c = a.renderer;
				if (!this._initialize) {
					this.scene = a.scene;
					this.camera = b;
					this.renderer = c;
					a = this.options.passes;
					this._initialize = !0;
					this.renderScene = new th(this.scene, this.camera);
					b = new np(this.renderer);
					b.addPass(this.renderScene);
					this.passes = [];
					if (a)
						for (var g = 0; g < a.length; g++) {
							var k = a[g],
								l = void 0;
							switch (k.name) {
								case "unrealBloom":
									l = new md(new da.Vector2(window.innerWidth, window.innerHeight), 1.5, .4, .85);
									break;
								case "SMAA":
									l = new lm(window.innerWidth * c.getPixelRatio(), window.innerHeight * c.getPixelRatio())
							}
							if (l) {
								for (var m in k) l[m] = k[m];
								b.addPass(l)
							}
						}
					this.composer = b
				}
			}
		}, {
			key: "addRender",
			value: function(a) {
				this.renderScene && this.renderScene.addRender(a)
			}
		}, {
			key: "render",
			value: function() {
				this.composer.render(this.scene, this.camera)
			}
		}]);
		return b
	}(Pl);
	md.prototype.getSeperableBlurMaterial = function(a) {
		return new da.ShaderMaterial({
			defines: {
				KERNEL_RADIUS: a,
				SIGMA: a
			},
			uniforms: {
				colorTexture: {
					value: null
				},
				texSize: {
					value: new da.Vector2(.5, .5)
				},
				direction: {
					value: new da.Vector2(.5, .5)
				}
			},
			vertexShader: "varying vec2 vUv;\n            void main() {\n                vUv = uv;\n                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n            }",
			fragmentShader: "#include <common>            varying vec2 vUv;\n            uniform sampler2D colorTexture;\n            uniform vec2 texSize;            uniform vec2 direction;                        float gaussianPdf(in float x, in float sigma) {                return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;            }            void main() {\n                vec2 invSize = 1.0 / texSize;                float fSigma = float(SIGMA);                float weightSum = gaussianPdf(0.0, fSigma);                vec4 diffuseSum = texture2D( colorTexture, vUv).rgba * weightSum;                for( int i = 1; i < KERNEL_RADIUS; i ++ ) {                    float x = float(i);                    float w = gaussianPdf(x, fSigma);                    vec2 uvOffset = direction * invSize * x;                    vec4 sample1 = texture2D( colorTexture, vUv + uvOffset).rgba;                    vec4 sample2 = texture2D( colorTexture, vUv - uvOffset).rgba;                    diffuseSum += (sample1 + sample2) * w;                    weightSum += 2.0 * w;                }                gl_FragColor = vec4(diffuseSum/weightSum);\n            }"
		})
	};
	th.prototype.addRender = function(a) {
		this.renderCbk = a
	};
	th.prototype.render = function(a, b, c) {
		b = a.autoClear;
		a.autoClear = !1;
		this.scene.overrideMaterial = this.overrideMaterial;
		if (this.clearColor) {
			var d = a.getClearColor().getHex();
			var e = a.getClearAlpha();
			a.setClearColor(this.clearColor, this.clearAlpha)
		}
		this.clearDepth && a.clearDepth();
		a.setRenderTarget(this.renderToScreen ? null : c);
		this.clear && a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil);
		a.render(this.scene, this.camera);
		this.renderCbk && this.renderCbk();
		this.clearColor && a.setClearColor(d, e);
		this.scene.overrideMaterial = null;
		a.autoClear = b
	};
	var ht = function(a) {
			function b(a) {
				Xa(this, b);
				a = Zb(this, (b.__proto__ || Yb(b)).call(this, a));
				a.time = 0;
				a.autoUpdate = !0;
				return a
			}
			$b(b, a);
			jb(b, [{
				key: "getDefaultOptions",
				value: function() {
					return {
						totalRadian: Math.PI,
						color: 16711680,
						radius: 50,
						step: .1
					}
				}
			}, {
				key: "initialize",
				value: function(a) {
					this.threeLayer = a;
					this.addOverlay()
				}
			}, {
				key: "onChanged",
				value: function(a, b) {
					this.threeLayer && (this.removeOverlay(), this.addOverlay())
				}
			}, {
				key: "onDestroy",
				value: function() {
					this.removeOverlay()
				}
			}, {
				key: "render",
				value: function() {
					this.time += this.options.step / 10;
					1 < this.time && (this.time = 0);
					for (var a = this.shapeMarker.children, b = 0; b < a.length; b++) a[b].material.uniforms.periodRatio.value =
						this.time
				}
			}, {
				key: "removeOverlay",
				value: function() {
					this.threeLayer.remove(this.shapeMarker)
				}
			}, {
				key: "addOverlay",
				value: function() {
					this.shapeMarker = new da.Group;
					for (var a = this.threeLayer, b = this.getData(), e = 0; e < b.length; e++) {
						var g = a.normizedPoint(b[e].geometry.coordinates);
						g = this.create3dCanvasRipple({
							originalData: b[e],
							normizedData: g
						});
						this.shapeMarker.add(g)
					}
					a.add(this.shapeMarker)
				}
			}, {
				key: "create3dCanvasRipple",
				value: function(a) {
					var b = this.options,
						c = b.totalRadian,
						g = b.color;
					b = b.size;
					var k = a.originalData;
					a = a.normizedData;
					"[object Function]" === Object.prototype.toString.call(g) && (g = g(k));
					b = "[object Function]" === Object.prototype.toString.call(b) ? b(k) : Number(b);
					k = {
						totalRadian: {
							type: "f",
							value: c
						},
						glowColor: {
							type: "c",
							value: new da.Color(g)
						},
						radius: {
							type: "f",
							value: b
						},
						periodRatio: {
							type: "f",
							value: 0
						}
					};
					g = new da.Geometry;
					for (var l =
							c / (b / 2), m = l; m <= c; m += l) {
						var n = b * Math.sin(m),
							p = b * Math.cos(m);
						g.vertices.push(new da.Vector3(0, 0, m / c));
						g.vertices.push(new da.Vector3(p, n, m / c))
					}
					c = 0;
					for (b = g.vertices.length; c < b - 2; ++c) g.faces.push(new da.Face3(c, c + 1, c + 3));
					c = new da.ShaderMaterial({
						uniforms: k,
						vertexShader: "varying vec4 vFragColor;varying vec4 vPosition;uniform float radius;uniform float totalRadian;uniform float periodRatio;uniform vec3 glowColor;void main(){float radian=radians(360.0*periodRatio);float s=sin(radian);float c=cos(radian);vec2 rotatedPostion=vec2(position.x*s+position.y*c,position.y*s-position.x*c);gl_Position=projectionMatrix*modelViewMatrix*vec4(rotatedPostion,0,1.0);vFragColor=vec4(glowColor,pow(position.z,1.3));}",
						fragmentShader: "varying vec4 vFragColor;void main(){gl_FragColor=vFragColor;}",
						blending: da.NormalBlending,
						transparent: !0,
						depthWrite: !1
					});
					c = new da.Mesh(g, c);
					c.position.set(a[0], a[1], a[2] || 0);
					return c
				}
			}]);
			return b
		}(Pl),
		pp = ta(function(a, b) {
			(function() {
				function c() {
					this.positions = [];
					this.previous = [];
					this.next = [];
					this.side = [];
					this.width = [];
					this.indices_array = [];
					this.uvs = [];
					this.counters = [];
					this.geometry = new g.BufferGeometry;
					this.widthCallback = null;
					this.matrixWorld = new g.Matrix4
				}

				function d(a, b, c, d, e) {
					a =
						a.subarray || a.slice ? a : a.buffer;
					c = c.subarray || c.slice ? c : c.buffer;
					a = b ? a.subarray ? a.subarray(b, e && b + e) : a.slice(b, e && b + e) : a;
					if (c.set) c.set(a, d);
					else
						for (b = 0; b < a.length; b++) c[b + d] = a[b];
					return c
				}

				function e(a) {
					g.ShaderMaterial.call(this, {
						uniforms: q({}, g.UniformsLib.fog, {
							lineWidth: {
								value: 1
							},
							map: {
								value: null
							},
							useMap: {
								value: 0
							},
							alphaMap: {
								value: null
							},
							useAlphaMap: {
								value: 0
							},
							color: {
								value: new g.Color(16777215)
							},
							opacity: {
								value: 1
							},
							resolution: {
								value: new g.Vector2(1, 1)
							},
							sizeAttenuation: {
								value: 1
							},
							near: {
								value: 1
							},
							far: {
								value: 1
							},
							dashArray: {
								value: 0
							},
							dashOffset: {
								value: 0
							},
							dashRatio: {
								value: .5
							},
							useDash: {
								value: 0
							},
							visibility: {
								value: 1
							},
							alphaTest: {
								value: 0
							},
							repeat: {
								value: new g.Vector2(1, 1)
							}
						}),
						vertexShader: g.ShaderChunk.meshline_vert,
						fragmentShader: g.ShaderChunk.meshline_frag
					});
					this.type = "MeshLineMaterial";
					ja(this, {
						lineWidth: {
							enumerable: !0,
							get: function() {
								return this.uniforms.lineWidth.value
							},
							set: function(a) {
								this.uniforms.lineWidth.value = a
							}
						},
						map: {
							enumerable: !0,
							get: function() {
								return this.uniforms.map.value
							},
							set: function(a) {
								this.uniforms.map.value =
									a
							}
						},
						useMap: {
							enumerable: !0,
							get: function() {
								return this.uniforms.useMap.value
							},
							set: function(a) {
								this.uniforms.useMap.value = a
							}
						},
						alphaMap: {
							enumerable: !0,
							get: function() {
								return this.uniforms.alphaMap.value
							},
							set: function(a) {
								this.uniforms.alphaMap.value = a
							}
						},
						useAlphaMap: {
							enumerable: !0,
							get: function() {
								return this.uniforms.useAlphaMap.value
							},
							set: function(a) {
								this.uniforms.useAlphaMap.value = a
							}
						},
						color: {
							enumerable: !0,
							get: function() {
								return this.uniforms.color.value
							},
							set: function(a) {
								this.uniforms.color.value = a
							}
						},
						opacity: {
							enumerable: !0,
							get: function() {
								return this.uniforms.opacity.value
							},
							set: function(a) {
								this.uniforms.opacity.value = a
							}
						},
						resolution: {
							enumerable: !0,
							get: function() {
								return this.uniforms.resolution.value
							},
							set: function(a) {
								this.uniforms.resolution.value.copy(a)
							}
						},
						sizeAttenuation: {
							enumerable: !0,
							get: function() {
								return this.uniforms.sizeAttenuation.value
							},
							set: function(a) {
								this.uniforms.sizeAttenuation.value = a
							}
						},
						near: {
							enumerable: !0,
							get: function() {
								return this.uniforms.near.value
							},
							set: function(a) {
								this.uniforms.near.value = a
							}
						},
						far: {
							enumerable: !0,
							get: function() {
								return this.uniforms.far.value
							},
							set: function(a) {
								this.uniforms.far.value = a
							}
						},
						dashArray: {
							enumerable: !0,
							get: function() {
								return this.uniforms.dashArray.value
							},
							set: function(a) {
								this.uniforms.dashArray.value = a;
								this.useDash = 0 !== a ? 1 : 0
							}
						},
						dashOffset: {
							enumerable: !0,
							get: function() {
								return this.uniforms.dashOffset.value
							},
							set: function(a) {
								this.uniforms.dashOffset.value = a
							}
						},
						dashRatio: {
							enumerable: !0,
							get: function() {
								return this.uniforms.dashRatio.value
							},
							set: function(a) {
								this.uniforms.dashRatio.value = a
							}
						},
						useDash: {
							enumerable: !0,
							get: function() {
								return this.uniforms.useDash.value
							},
							set: function(a) {
								this.uniforms.useDash.value = a
							}
						},
						visibility: {
							enumerable: !0,
							get: function() {
								return this.uniforms.visibility.value
							},
							set: function(a) {
								this.uniforms.visibility.value = a
							}
						},
						alphaTest: {
							enumerable: !0,
							get: function() {
								return this.uniforms.alphaTest.value
							},
							set: function(a) {
								this.uniforms.alphaTest.value = a
							}
						},
						repeat: {
							enumerable: !0,
							get: function() {
								return this.uniforms.repeat.value
							},
							set: function(a) {
								this.uniforms.repeat.value.copy(a)
							}
						}
					});
					this.setValues(a)
				}
				var g = "undefined" !== typeof vh && Bo || this.THREE;
				if (!g) throw Error("MeshLine requires three.js");
				c.prototype.setMatrixWorld = function(a) {
					this.matrixWorld = a
				};
				c.prototype.setGeometry = function(a, b) {
					this.widthCallback = b;
					this.positions = [];
					this.counters = [];
					if (a instanceof g.Geometry)
						for (var c = 0; c < a.vertices.length; c++) {
							var d = a.vertices[c];
							b = c / a.vertices.length;
							this.positions.push(d.x, d.y, d.z);
							this.positions.push(d.x, d.y, d.z);
							this.counters.push(b);
							this.counters.push(b)
						}
					if (a instanceof Float32Array ||
						a instanceof Array)
						for (c = 0; c < a.length; c += 3) b = c / a.length, this.positions.push(a[c], a[c + 1], a[c + 2]), this.positions
							.push(a[c], a[c + 1], a[c + 2]), this.counters.push(b), this.counters.push(b);
					this.process()
				};
				c.prototype.raycast = function() {
					var a = new g.Matrix4,
						b = new g.Ray,
						c = new g.Sphere;
					return function(d, e) {
						var k = d.linePrecision;
						k *= k;
						var l = this.geometry;
						null === l.boundingSphere && l.computeBoundingSphere();
						c.copy(l.boundingSphere);
						c.applyMatrix4(this.matrixWorld);
						if (!1 !== d.ray.intersectSphere(c)) {
							a.getInverse(this.matrixWorld);
							b.copy(d.ray).applyMatrix4(a);
							var m = new g.Vector3,
								n = new g.Vector3,
								p = new g.Vector3,
								q = new g.Vector3,
								r = this instanceof g.LineSegments ? 2 : 1;
							if (l instanceof g.BufferGeometry) {
								var u = l.index,
									B = l.attributes;
								if (null !== u) {
									l = u.array;
									B = B.position.array;
									u = 0;
									for (var H = l.length - 1; u < H; u += r) {
										var F = l[u + 1];
										m.fromArray(B, 3 * l[u]);
										n.fromArray(B, 3 * F);
										F = b.distanceSqToSegment(m, n, q, p);
										F > k || (q.applyMatrix4(this.matrixWorld), F = d.ray.origin.distanceTo(q), F < d.near || F > d.far || e
											.push({
												distance: F,
												point: p.clone().applyMatrix4(this.matrixWorld),
												index: u,
												face: null,
												faceIndex: null,
												object: this
											}))
									}
								} else
									for (B = B.position.array, u = 0, H = B.length / 3 - 1; u < H; u += r) m.fromArray(B, 3 * u), n.fromArray(
										B, 3 * u + 3), F = b.distanceSqToSegment(m, n, q, p), F > k || (q.applyMatrix4(this.matrixWorld), F = d
										.ray.origin.distanceTo(q), F < d.near || F > d.far || e.push({
											distance: F,
											point: p.clone().applyMatrix4(this.matrixWorld),
											index: u,
											face: null,
											faceIndex: null,
											object: this
										}))
							} else if (l instanceof g.Geometry)
								for (m = l.vertices, n = m.length, u = 0; u < n - 1; u += r) F = b.distanceSqToSegment(m[u], m[u + 1], q,
									p), F > k || (q.applyMatrix4(this.matrixWorld),
									F = d.ray.origin.distanceTo(q), F < d.near || F > d.far || e.push({
										distance: F,
										point: p.clone().applyMatrix4(this.matrixWorld),
										index: u,
										face: null,
										faceIndex: null,
										object: this
									}))
						}
					}
				}();
				c.prototype.compareV3 = function(a, b) {
					a *= 6;
					b *= 6;
					return this.positions[a] === this.positions[b] && this.positions[a + 1] === this.positions[b + 1] && this.positions[
						a + 2] === this.positions[b + 2]
				};
				c.prototype.copyV3 = function(a) {
					a *= 6;
					return [this.positions[a], this.positions[a + 1], this.positions[a + 2]]
				};
				c.prototype.process = function() {
					var a = this.positions.length /
						6;
					this.previous = [];
					this.next = [];
					this.side = [];
					this.width = [];
					this.indices_array = [];
					this.uvs = [];
					for (var b = 0; b < a; b++) this.side.push(1), this.side.push(-1);
					for (b = 0; b < a; b++) {
						var c = this.widthCallback ? this.widthCallback(b / (a - 1)) : 1;
						this.width.push(c);
						this.width.push(c)
					}
					for (b = 0; b < a; b++) this.uvs.push(b / (a - 1), 0), this.uvs.push(b / (a - 1), 1);
					c = this.compareV3(0, a - 1) ? this.copyV3(a - 2) : this.copyV3(0);
					this.previous.push(c[0], c[1], c[2]);
					this.previous.push(c[0], c[1], c[2]);
					for (b = 0; b < a - 1; b++) c = this.copyV3(b), this.previous.push(c[0],
						c[1], c[2]), this.previous.push(c[0], c[1], c[2]);
					for (b = 1; b < a; b++) c = this.copyV3(b), this.next.push(c[0], c[1], c[2]), this.next.push(c[0], c[1], c[2]);
					c = this.compareV3(a - 1, 0) ? this.copyV3(1) : this.copyV3(a - 1);
					this.next.push(c[0], c[1], c[2]);
					this.next.push(c[0], c[1], c[2]);
					for (b = 0; b < a - 1; b++) c = 2 * b, this.indices_array.push(c, c + 1, c + 2), this.indices_array.push(c + 2,
						c + 1, c + 3);
					this.attributes ? (this.attributes.position.copyArray(new Float32Array(this.positions)), this.attributes.position
						.needsUpdate = !0, this.attributes.previous.copyArray(new Float32Array(this.previous)),
						this.attributes.previous.needsUpdate = !0, this.attributes.next.copyArray(new Float32Array(this.next)), this
						.attributes.next.needsUpdate = !0, this.attributes.side.copyArray(new Float32Array(this.side)), this.attributes
						.side.needsUpdate = !0, this.attributes.width.copyArray(new Float32Array(this.width)), this.attributes.width
						.needsUpdate = !0, this.attributes.uv.copyArray(new Float32Array(this.uvs)), this.attributes.uv.needsUpdate = !
						0, this.attributes.index.copyArray(new Uint16Array(this.indices_array)), this.attributes.index.needsUpdate = !
						0) : this.attributes = {
						position: new g.BufferAttribute(new Float32Array(this.positions), 3),
						previous: new g.BufferAttribute(new Float32Array(this.previous), 3),
						next: new g.BufferAttribute(new Float32Array(this.next), 3),
						side: new g.BufferAttribute(new Float32Array(this.side), 1),
						width: new g.BufferAttribute(new Float32Array(this.width), 1),
						uv: new g.BufferAttribute(new Float32Array(this.uvs), 2),
						index: new g.BufferAttribute(new Uint16Array(this.indices_array), 1),
						counters: new g.BufferAttribute(new Float32Array(this.counters),
							1)
					};
					this.geometry.addAttribute("position", this.attributes.position);
					this.geometry.addAttribute("previous", this.attributes.previous);
					this.geometry.addAttribute("next", this.attributes.next);
					this.geometry.addAttribute("side", this.attributes.side);
					this.geometry.addAttribute("width", this.attributes.width);
					this.geometry.addAttribute("uv", this.attributes.uv);
					this.geometry.addAttribute("counters", this.attributes.counters);
					this.geometry.setIndex(this.attributes.index)
				};
				c.prototype.advance = function(a) {
					var b =
						this.attributes.position.array,
						c = this.attributes.next.array,
						e = b.length;
					d(b, 0, this.attributes.previous.array, 0, e);
					d(b, 6, b, 0, e - 6);
					b[e - 6] = a.x;
					b[e - 5] = a.y;
					b[e - 4] = a.z;
					b[e - 3] = a.x;
					b[e - 2] = a.y;
					b[e - 1] = a.z;
					d(b, 6, c, 0, e - 6);
					c[e - 6] = a.x;
					c[e - 5] = a.y;
					c[e - 4] = a.z;
					c[e - 3] = a.x;
					c[e - 2] = a.y;
					c[e - 1] = a.z;
					this.attributes.position.needsUpdate = !0;
					this.attributes.previous.needsUpdate = !0;
					this.attributes.next.needsUpdate = !0
				};
				g.ShaderChunk.meshline_vert = ["", g.ShaderChunk.logdepthbuf_pars_vertex, g.ShaderChunk.fog_pars_vertex,
					"\r\nattribute vec3 previous;\r\nattribute vec3 next;\r\nattribute float side;\r\nattribute float width;\r\nattribute float counters;\r\n\r\nuniform vec2 resolution;\r\nuniform float lineWidth;\r\nuniform vec3 color;\r\nuniform float opacity;\r\nuniform float near;\r\nuniform float far;\r\nuniform float sizeAttenuation;\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\nvarying float vCounters;\r\n\r\nvec2 fix( vec4 i, float aspect ) {\r\n\r\n    vec2 res = i.xy / i.w;\r\n    res.x *= aspect;\r\n\t vCounters = counters;\r\n    return res;\r\n\r\n}\r\n\r\nvoid main() {\r\n\r\n    float aspect = resolution.x / resolution.y;\r\n    float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);\r\n\r\n    vColor = vec4( color, opacity );\r\n    vUV = uv;\r\n\r\n    mat4 m = projectionMatrix * modelViewMatrix;\r\n    vec4 finalPosition = m * vec4( position, 1.0 );\r\n    vec4 prevPos = m * vec4( previous, 1.0 );\r\n    vec4 nextPos = m * vec4( next, 1.0 );\r\n\r\n    vec2 currentP = fix( finalPosition, aspect );\r\n    vec2 prevP = fix( prevPos, aspect );\r\n    vec2 nextP = fix( nextPos, aspect );\r\n\r\n    float pixelWidth = finalPosition.w * pixelWidthRatio;\r\n    float w = 1.8 * pixelWidth * lineWidth * width;\r\n\r\n    if( sizeAttenuation == 1. ) {\r\n        w = 1.8 * lineWidth * width;\r\n    }\r\n\r\n    vec2 dir;\r\n    if( nextP == currentP ) dir = normalize( currentP - prevP );\r\n    else if( prevP == currentP ) dir = normalize( nextP - currentP );\r\n    else {\r\n        vec2 dir1 = normalize( currentP - prevP );\r\n        vec2 dir2 = normalize( nextP - currentP );\r\n        dir = normalize( dir1 + dir2 );\r\n\r\n        vec2 perp = vec2( -dir1.y, dir1.x );\r\n        vec2 miter = vec2( -dir.y, dir.x );\r\n        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );\r\n\r\n    }\r\n\r\n    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;\r\n    vec2 normal = vec2( -dir.y, dir.x );\r\n    normal.x /= aspect;\r\n    normal *= .5 * w;\r\n\r\n    vec4 offset = vec4( normal * side, 0.0, 1.0 );\r\n    finalPosition.xy += offset.xy;\r\n\r\n    gl_Position = finalPosition;\r\n",
					g.ShaderChunk.logdepthbuf_vertex, g.ShaderChunk.fog_vertex &&
					"    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", g.ShaderChunk.fog_vertex, "}"
				].join("\r\n");
				g.ShaderChunk.meshline_frag = ["", g.ShaderChunk.fog_pars_fragment, g.ShaderChunk.logdepthbuf_pars_fragment,
					"\r\nuniform sampler2D map;\r\nuniform sampler2D alphaMap;\r\nuniform float useMap;\r\nuniform float useAlphaMap;\r\nuniform float useDash;\r\nuniform float dashArray;\r\nuniform float dashOffset;\r\nuniform float dashRatio;\r\nuniform float visibility;\r\nuniform float alphaTest;\r\nuniform vec2 repeat;\r\n\r\nvarying vec2 vUV;\r\nvarying vec4 vColor;\r\nvarying float vCounters;\r\n\r\nvoid main() {\r\n",
					g.ShaderChunk.logdepthbuf_fragment,
					"\r\n    vec4 c = vColor;\r\n    if( useMap == 1. ) c *= texture2D( map, vUV * repeat );\r\n    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat ).a;\r\n    if( c.a < alphaTest ) discard;\r\n    if( useDash == 1. ){\r\n        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));\r\n    }\r\n    gl_FragColor = c;\r\n    gl_FragColor.a *= step(vCounters, visibility);\r\n",
					g.ShaderChunk.fog_fragment, "}"
				].join("\r\n");
				e.prototype =
					p(g.ShaderMaterial.prototype);
				e.prototype.constructor = e;
				e.prototype.isMeshLineMaterial = !0;
				e.prototype.copy = function(a) {
					g.ShaderMaterial.prototype.copy.call(this, a);
					this.lineWidth = a.lineWidth;
					this.map = a.map;
					this.useMap = a.useMap;
					this.alphaMap = a.alphaMap;
					this.useAlphaMap = a.useAlphaMap;
					this.color.copy(a.color);
					this.opacity = a.opacity;
					this.resolution.copy(a.resolution);
					this.sizeAttenuation = a.sizeAttenuation;
					this.near = a.near;
					this.far = a.far;
					this.dashArray.copy(a.dashArray);
					this.dashOffset.copy(a.dashOffset);
					this.dashRatio.copy(a.dashRatio);
					this.useDash = a.useDash;
					this.visibility = a.visibility;
					this.alphaTest = a.alphaTest;
					this.repeat.copy(a.repeat);
					return this
				};
				a.exports && (b = a.exports = {
					MeshLine: c,
					MeshLineMaterial: e
				});
				b.MeshLine = c;
				b.MeshLineMaterial = e
			}).call(Kn)
		}),
		it = pp.MeshLine,
		jt = pp.MeshLineMaterial,
		kt = function(a) {
			function b(a) {
				Xa(this, b);
				a = Zb(this, (b.__proto__ || Yb(b)).call(this, a));
				a.staticDashArray = 2;
				a.time = 0;
				a.autoUpdate = !0;
				return a
			}
			$b(b, a);
			jb(b, [{
				key: "getDefaultOptions",
				value: function() {
					return {
						color: 16777215,
						textureColor: 16777215,
						textureWidth: 10,
						textureLength: 30,
						step: .1
					}
				}
			}, {
				key: "initialize",
				value: function(a) {
					this.threeLayer = a;
					this.addOverlay()
				}
			}, {
				key: "onChanged",
				value: function(a, b) {
					this.threeLayer && (this.removeOverlay(), this.addOverlay())
				}
			}, {
				key: "onDestroy",
				value: function() {
					this.removeOverlay()
				}
			}, {
				key: "render",
				value: function() {
					var a = this.getOptions(),
						b = a.textureWidth,
						e = a.style;
					a = a.step / 10;
					this.time += a;
					2 < this.time && (this.time = 0);
					for (var g = this.flyLine.children, k = 0; k < g.length; k++) {
						var l = g[k],
							m = l.hash;
						l.children[0].material.uniforms.lineWidth.value =
							b * (1 + .2 * Math.sin(5 * this.time));
						l.children[0].material.uniforms.dashOffset.value = "chaos" === e ? l.children[0].material.uniforms.dashOffset
							.value - a : (this.staticDashArray + m) * (1 - this.time / 2)
					}
				}
			}, {
				key: "removeOverlay",
				value: function() {
					this.threeLayer.remove(this.flyLine)
				}
			}, {
				key: "addOverlay",
				value: function() {
					var a = this;
					this.flyLine = new da.Group;
					var b = this.threeLayer,
						e = new da.TextureLoader,
						g = this.getData();
					e.load(
						"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFkAAABZCAQAAAD/AkAkAAAACXBIWXMAAAsTAAALEwEAmpwYAAADGWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjaY2BgnuDo4uTKJMDAUFBUUuQe5BgZERmlwH6egY2BmYGBgYGBITG5uMAxIMCHgYGBIS8/L5UBA3y7xsDIwMDAcFnX0cXJlYE0wJpcUFTCwMBwgIGBwSgltTiZgYHhCwMDQ3p5SUEJAwNjDAMDg0hSdkEJAwNjAQMDg0h2SJAzAwNjCwMDE09JakUJAwMDg3N+QWVRZnpGiYKhpaWlgmNKflKqQnBlcUlqbrGCZ15yflFBflFiSWoKAwMD1A4GBgYGXpf8EgX3xMw8BUNTVQYqg4jIKAX08EGIIUByaVEZhMXIwMDAIMCgxeDHUMmwiuEBozRjFOM8xqdMhkwNTJeYNZgbme+y2LDMY2VmzWa9yubEtoldhX0mhwBHJycrZzMXM1cbNzf3RB4pnqW8xryH+IL5nvFXCwgJrBZ0E3wk1CisKHxYJF2UV3SrWJw4p/hWiRRJYcmjUhXSutJPZObIhsoJyp2V71HwUeRVvKA0RTlKRUnltepWtUZ1Pw1Zjbea+7QmaqfqWOsK6b7SO6I/36DGMMrI0ljS+LfJPdPDZivM+y0qLBOtfKwtbFRtRexY7L7aP3e47XjB6ZjzXpetruvdVrov9VjkudBrgfdCn8W+y/xW+a8P2Bq4N+hY8PmQW6HPwr5EMEUKRilFG8e4xUbF5cW3JMxO3Jx0Nvl5KlOaXLpNRlRmVdas7D059/KY8tULfAqLi2YXHy55WyZR7lJRWDmv6mz131q9uvj6SQ3HGn83G7Skt85ru94h2Ond1d59uJehz76/bsK+if8nO05pnXpiOu+M4JmzZj2aozW3ZN6+BVwLwxYtXvxxqcOyCcsfrjRe1br65lrddU3rb2402NSx+cFWq21Tt3/Y6btr1R6Oven7jh9QP9h56PURv6Obj4ufqD355LT3mS3nZM+3X/h0Ke7yqasW15bdEL3ZeuvrnfS7N+/7PDjwyPTx6qeKz2a+EHzZ9Zr5Td3bn+9LP3z6VPD53de8b+9+5P/88Lv4z7d/Vf//AwAqvx2K829RWwAAOGtpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+Cjx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIgogICAgICAgICAgICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgICAgICAgICAgIHhtbG5zOnBob3Rvc2hvcD0iaHR0cDovL25zLmFkb2JlLmNvbS9waG90b3Nob3AvMS4wLyIKICAgICAgICAgICAgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iCiAgICAgICAgICAgIHhtbG5zOnN0RXZ0PSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VFdmVudCMiCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTcgKE1hY2ludG9zaCk8L3htcDpDcmVhdG9yVG9vbD4KICAgICAgICAgPHhtcDpDcmVhdGVEYXRlPjIwMTktMDYtMjdUMTk6MzE6MTUrMDg6MDA8L3htcDpDcmVhdGVEYXRlPgogICAgICAgICA8eG1wOk1vZGlmeURhdGU+MjAxOS0wOC0xOVQxNjo1Nzo1MCswODowMDwveG1wOk1vZGlmeURhdGU+CiAgICAgICAgIDx4bXA6TWV0YWRhdGFEYXRlPjIwMTktMDgtMTlUMTY6NTc6NTArMDg6MDA8L3htcDpNZXRhZGF0YURhdGU+CiAgICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2UvcG5nPC9kYzpmb3JtYXQ+CiAgICAgICAgIDxwaG90b3Nob3A6Q29sb3JNb2RlPjE8L3Bob3Rvc2hvcDpDb2xvck1vZGU+CiAgICAgICAgIDxwaG90b3Nob3A6SUNDUHJvZmlsZT5Eb3QgR2FpbiAxNSU8L3Bob3Rvc2hvcDpJQ0NQcm9maWxlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjQ5MmI1NTQ1LWIwNmQtNGI0Yi1iMWExLTZiN2NiNzExNzA5MjwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo0OTJiNTU0NS1iMDZkLTRiNGItYjFhMS02YjdjYjcxMTcwOTI8L3htcE1NOkRvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+eG1wLmRpZDo0OTJiNTU0NS1iMDZkLTRiNGItYjFhMS02YjdjYjcxMTcwOTI8L3htcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkhpc3Rvcnk+CiAgICAgICAgICAgIDxyZGY6U2VxPgogICAgICAgICAgICAgICA8cmRmOmxpIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmFjdGlvbj5jcmVhdGVkPC9zdEV2dDphY3Rpb24+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDppbnN0YW5jZUlEPnhtcC5paWQ6NDkyYjU1NDUtYjA2ZC00YjRiLWIxYTEtNmI3Y2I3MTE3MDkyPC9zdEV2dDppbnN0YW5jZUlEPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6d2hlbj4yMDE5LTA2LTI3VDE5OjMxOjE1KzA4OjAwPC9zdEV2dDp3aGVuPgogICAgICAgICAgICAgICAgICA8c3RFdnQ6c29mdHdhcmVBZ2VudD5BZG9iZSBQaG90b3Nob3AgQ0MgMjAxNyAoTWFjaW50b3NoKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT42NTUzNTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+ODk8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+ODk8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PnHlyVkAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAFaZJREFUeNp8W+1661prZAA5p2/v/1p7tgUz/cFakuzsNnkS24ktITR8DYD/GMxMBrP1KLPHKzOZ/frLvPp6Dwyw61+QYDJIZmaC7PF1n88M66yfx/ybJPOYsI9jmT0+Oh/EdaDPA5rJAJhBj9/rIzJgPqL1bskgm++Pc9jHGbDOa7/E3RLlp5DfmsRDxPvKr8/D3EwADGbA0rQM12ckmDBaltmIrP3q0qT+cgc+FXW/ys833B9+iq1vPWC+4QaDw8zcDJBtaDwv1wSTltCSTDAR0kPj+Dr/8yL2830P8hspf8PalxZ8C2uOLTw2kjFalwESYKPTEXppV0aDCTQTIdMH1L70igdE5yu//4Cv3/r4nxx+iXqLDvgCxbY/2KjepC32aBuUjJBRbgRsXunW5aft4Bdk8qlX/MWGb7sVLAzmdgmNuMR1wAwuAz6RtLyGJMwPIQnNQJtL1gaby3ic+xPlWGaw7sN/vozPHq7lcW23qG4OwOXucsAcwIVr4PtwkBYoTEYTZTSJRslaMhpF4/zXfsmCDyNcWH4CHr88r+YOY4nocAvAwoEA1gUMSC6RsR3FdnIyM1KQLeE4jzCpzY1Go8FofMaG572+Bc/9Qh9Af3pec/lo12FhjoCbu9tcwBL7FhmQ+fOeUTKTgqLJaVK7jGoCBESYINgtygXRbzdgpnFyf/vHdV+XuIjRsDncY/7isC24wy5obAuEli8esSXRpBYRaiM9SFob5WibyAMjOD7E/hoZH1r+hPuy38GqW8AtsAUNC3N3OOYCFrpH4AsaWwKN8ZlE0UQ3SnLRqXYKRrQMENQGg8x4h3d8uV6MlvEVPNYlALAwt4AjRmTM7/0Y5h5wwHxp3AwY32wmAXJRbiIFGkWESCLUbECSqwlAbfB9d2E9Tz+ThHmW9itzsB3htrhuYYGEeyAsPCzcEQh3C/fRuAHumOC9QspybyGZkbKmRCMJquVwBWvFTwikRvSRpudGfUbhlRb9zZkYLt0OJMIDgXS3hHuM8AgPuDsCMPgyQ8dHdjAYNm+lk9QSmKG2gqt7h6O+RJyUiib8cr0aJ4dHzjZeWBdSEQgkHIn0gHtauiMjlp7dw5fvcIfDAML3aWQmkSZSFJ2imsFGC3QvIiAQhkDvezOGC/WkrvhMPn+nHbLxt+YIpA0E0sID4Yn0hPsSGbEEjhiRxwQXtsa5mShRbJrUbAUazpCjCThdMCO0sOwmsxCs4Lch3v45n3nbupmh8b2xvEUiEUhkBA6Eh4cnwtMHGBHLCBFu8jBd2JCZSDNSTJLd3iTam0XQDYSD5mbY0fwKHCEz23C5DTHtKyWSL1Sm+QiGwAiYSE8PT2SEH+6eHhFwRDoC8Bhv4ZdzHz2LEkmqg+xuVTvc2qtg0Py4QHlZCjS7ywHciNadyd2Fy8oWYqKcBdLCEoEDgfTDM9IDGekRR4SHu4enuzvcHYA7VtSUzEyUtJBMdnd70629regBOGGYdHqlq6Nwn0TKzFp6Bpb8cnGwOxwvLxFpGYERNz3j8Mj0wyPSwyMGKg6PFVLCDBSwcwtRarLZHt7sdu8qoL2BGoO9sU9zSXdNKaEfr8b8LqHHXa0ot9xYWvrh6elHBI7MET7SM0fkDF8AWVJvxz5hz0i2ktUaHbd7lzkBx0TqJULLRVv1iplMoAA3gXfISz2Dx0ovcXuDGDNDDpbj8CMz0o/IyIzIiMgFEB+B4bi0IJoosilFNaNZ3eUInO04hS2JDHKj+bYByelwk7TqnOXT8i5Che3cDLaEHm/sGaPbIzKPyEw/MjPjiMjwjIhwj4CHb0+3Y99AuUgyqtUVKA+Uw88yQ8NMFps2EAWBCsgIV5hsMH1BJe9cHG4ud7cdhgOBiEB6IiLz8BH4yCMyjojjyPTMiMj0CIfHhBOs9GqULDLIZkd3R5dXAeeuHc1k1qsMkGxii4wWJsjcJIG70sKN5VUSjdm5uYeF5/qdcXh4+hHHCJxHHpl5RB6ZGbEBDXfE5MwTyKzFlpLd1dnVZ5nDDYKjtiu0pUWFkG2iO2Nr12Q0H++hncnJYOZT2K8kPnYm4TmojiMyMjIzM17HEZnHK/OIyDzS48gY/wy4G4Cdc7JJsburq70B93IAqB3QzQSdclq2QBA5gjp6qh2XRKxCJy+BAVhgR7wV/5AeEZE+ZnbEEUe88jgyXkceR+aRkXkc602DZphjDJ+kwGJ3dTDrbINX2MqrYcOCTb5Ho6iEnHQPUoQQlMkIN+oBDAiAlnoc22e4X143xkNkxnHkccRxHJmv10bIOI8jgHB3X/XfpEStYHd21+ko4HTAzl0ValyKgp2YtIlKEIQjnJyLc0k+BW1ePs6Hi5iEc+fEK+WMHUQiMyMHwT/HcRz5Oo7MjHxFhke6e2L5ZmsjpV5aPt0bqyIwrKKbkESGjLmqbRKNQJvDBbhgbpwS7Sa4lvu/yk/Il8COGCfnGeED5SOP15FHvn6OzNdxHEeMz8t4BZDuAGgwjrvQu7urw6sc70UjDKlIUQeVkhgtVzC85RYKJxshocUxaDl6ar/F+wDaNXP4VCCOxIJGhI9vyPHFR74yj9dxjLYj8xUZrwiECzE0kGRFMbv63e7nHH3oI711TMrEIMnw9NFvINBwjLtc3IloPjFwp/jbS47wq2r2cI/JHWJ9HbeWX0fmkT/Hz5HHT74y/Ge7Z5+kCGojqzPOPvqPT2B0mCgZqSS7GQwFgwFHOunuCrS5hTUgx7I1AZDSDDDIfQmNxbqtGmPgsUAxITojI+OVmcfxc/wcr/w5/skjjzgyPPyY9NXcWuLJiurw081g/06FRErsg8ruFNmd3h6RbLkHR8vAIBnyeZywOmwRVmWMuXFwwH1xFAFf+YNHICImVOdx5E8cmcdP/uTrOPIVR7wiw1c9ZZI1g2T3n45aJK/1oIEkg+HpjXR6RLT7VO2Ll1q1PAHaUDo7X8aDhbDNuWHy3yXs+omcZCKOmDTjyP+KV/7kz3HEP3nkMQkHHDCa6dSri2/fJzAjmaKioyKj82hGBr1HNYH2YacGRTcD5dYGc1PqpjHGJndyBKyE3d3DxkMvPx3pERlx5JGvfB3HkfHP8cpX/GTEy+FhhBmZOv2gD+xANZkSWQxmM8/2SQMjvFaR4E5350iyhBa07pEsr3YBFiJgbu5L4NH3KNknho+G4xUZR/xELLFf+U++BtFze0AjWz/xpwwOmcSUkcWMV3Qwu9PPVaEvNsTducC5uEBoSbcSVeRiDQbR0Lobi6ryGyaOjeqpU33iS2S84oifeOVPvo6fCH9FuLuZGUmdbQgsUo6lI4sDitPdERHtiEFEBAEX/BITO5++mb6V4m9OfneW1u3wpeNlj4jROOArIEasciV9BM945SvC5+Y1TwFmPoQcO1+shbBBbnjMkVEBmJk7Yun5EhaAAFeP0Dlk1BS5Uyn64wp9E8c+iam7Y1jQQI7GwyP9le6ZEf/kT8yFAKaTwQmzzWR7+BGHv90nrHvA4RFYDg1Y53b0k62eltZWLXJfyTxeNPzie9e1TtPpOuCUSz4AwcDkiMTg+zXe2doOnc02FSOS3enliKx0dyz9Yt3bUYsmNl4qG/F360iyCSXP5o92i8zcdlAEYIttm/QAudKROWQMvwiPQPhg29wQMoZS7YeXJ05f3K87Eg9q1zEeZXWH8GjE2ePZIr4spw36kPtJfq5i/bogzIVwHXtALnMD0sMcB2KVYgZTGLxVi+DYDmkljhftv06L3X/7e8vy4r6H79OSFZsv+W5hTfJxkdJbJZuyNAujfCU86z7FZSCr5IHFZdy7Gfs8C/RsdMs2IWP2aMzBzHGzqqabEMOjcfHRTVktUcOQ8uvfNJ+WiMF63tLrrcJql8h4t09sMUGP7iLtq521OnKXAhdpmFcTXA/qbxEJplUPaeozrdrSbJ1PXB2FVstkbLWCRrPpL5VqsolpklCCWty1rMYZzNH3swdAtUiyD3t7ElwPAnof0VaJK9JkEqlNC4qiJOP8sVQ66YwGrNwPtMiT1SebZMtIlVqQqdWi9crqqEsvsinxpKtJj6fUujtSl2o3QhYHeLcZNeXjCFuiyGLrVChVHVEsRp9QKYJttNabZxerTxaLRbV6Lo7klE27zSYZOefSOuMWZ2l0qTmxbooWCHRRrKsXOt1Qradzm2VkF0V1sbqrPPrtY9MMajiVU83qP3X2WWcXyWapmy3Otbe2klfXVVwiTwvZlr7Gw1Gme7jhmpDYGsbc9pXbSpKaPbVcd5NqvjsYxTgZ7YiFq2Z4AJBa50Cjz57f766ev3WTJdFGfo7sxrmzW88myGYQgpueSegGhNaboMuuuPHaHDqwSZI13E80m+8OnO4w0Mza2sPHpGmD5j911r/17ndVn11d3SRr+GZqHVQcYteoMZy5lN0Dt82l5uXJ1ryEVktxVZskxWZsRHR3d/WxhP5TCYdDZYt5r2ZMbKRRLXbxT737Xe86+11njc7fXV3VQzBeX2PVdtnPnjDQNkUzS9NMTNieS+FNh2C6+ZSa0Wyxu8nuPjv6LA/UCfhwglDrUMbZ6YBbG9QsVZ/97n/Ps99n97vO6q7uZnV3s2rfui01L3dEexjjaBXKzeJhT6XYoj/oNLKnK6MmR1DWGd5V5e5xBv7HrcZfkj/qzsir9psDNM9+19l/6l1/zj911nm+q+rskZnkxgnVTUnLkZsuYHNNzQwnZ9MWdNudZmE1b3XBdx41FEpXhZe7n+7l+NdMbtSLzYyjI9Y8iVHFJvnu7nef55/6t8466yzWWV3dVQvavdwHbVz2CD2a5vIcazomtbyFBA3wJbVCVIuaW9bdaB+Bq8JR7jPscAXbF5XdFetqJo1iS6o+eXbVu97979nnn/Ndf6r6rKqqrupmVxd7hB5gWLP1cLGXtVli+QvtMZqWy0msHhKaJWewu7vc345yR6OA90qwKLGz+Ipoj3SbxFRtI8J7HF2966z3edZ51nme1XVWn8PitorN7lJbs9kTBGzpeY2eDDBmLMwIiEZQAo3WCrELwWaQ3ajwdrh7Tda5CgOa5bRNKyoysk7ffWyJakrvLladfZ5nvavOd73rfZ7nAvRApBewx+mTJRnVo+UJxPMs70C9yEiaSCO6I8mGq7vgQgXaqxfpbYun5/KfFRkV4eHpWlpeHWCSZ1dXnd1V9T7f53n22edZ3X2yu7pY7LEXUW0t3t8bsLjNb/SsPXGyQOFNR9NZNmA4+64jxkUuQJHNiIx0D0c4sHLagYxGpu6qs6rfZ53vqrPOs/qcK2GxOXgme+VKrbYl8uWCd6tyD4StcTB3giLpzYIz0PRqOGrxgDi1+03U8D8e5Rnu4YZ0rjSgJYkn1c2zq7vOqgXj8+xzIL2/VSrOT2tFw0kgV0TcM5+rgymjiBYwV+iCoGCtAtD7rry12TFKZDa7IzJqdXjeU9+sONBNsavZZ/eYXJ1nnb1+94riA40BxuiYNKqtbfrxxG7vTOw2GkS4hDYX1XRra4COlncBsIbt0mYnzSGJHRGnD0ERfndXR881gZ7d3ed4tz7PlXCclwkuR8diT3ZrC9P2GJCyR0OYcBsnB7Wv3r1KoKMMZjUd8Z3tWcpEZZKd4RGIXETNbgtwZcHj2tndxd6BZFvkJB0nWxsYrakJOJndGm3l1wAlJtGeVGE1WawFeSMWVYqzH2OKE0ZJdgyrEhE1zIzv0nGC7OTETTZZVcWu4gSRc4Hi7OLJnjpgw2L5jdb2yruH/Si+OTWxj18GIGfHEAMFW6SH9rwQqWxmsDticWvYdMrMm9nOsMgmW6xJhqq7z64qVp1cJvdwc2W9vre4tOcIyWMMhoK7WnBY071sWkEQaG4NM1iNyBkyOplBZ/TQozdNdZWPU8JM6O/mFpm14kt18WT1ElulW8+3V37MF+XHCLkw/6baYKVFdNH2NIetxN8psvsIRjM8ejP9j/G+Paezq9spZap5pZ19srpHYI6oZa1Ws3TnzrwnyvE9dIaBx9AMvYpCOLipj5ndXPmgK6VgINLX8NlquQ+fDKNJEKf62klmTy5RrVrBo3SyVGyeavbWsvXyGbv4e45cP6aUqUl9DYY9ET2j0zZu3Q9Z7FAaMzqiQDgsws1W4+vXONTyAWQ1VexuTiq0DE/b9ErNtrLmwvFzmPICxp7J0BJ6QCtYY5rHtnl/SuZUBkmnh0dHOEfH6HgQmct1ThE3Kd3S9DKyFTpO9nJwrbZSkVZaI4BG8ZMI03Po7LoW3hsLMgPlBtHCSCTWaLrTyPDwNaKGxZ3vhYKlhB0CV4U0WZIukY1dap7iaJhtVNnkFz3ziPqY9sXXbNFGDC/Wy9ws2cO1IdxmstRaKaIVcsZw/Vy9lSd9uga4hmhaVc7ibqZ4alsA0XJuorXauByc9LEF8TGLj8eA3/jBx17ORTfRnCa2AmJ7gMLM2vIxeo01gI/LN+9Wn6jJ05o9RRMHu+TyFSt/611A4UFfXljGx1ztRSZyDY2NrsylcJl6WtQEEaKXwnpNjOPS8T2oKswgsMjhQ0T1ZKSDWbaNppd+t8jg9hPfO0SJ7xWiazzcekhlaQh5GAVCTdBH6FKA0663Nctx0c8SIK7CQTRT06wlEkU9wsWIv7XbIvre7nmOd9rnyPXvlRObdE+LrpZJ7iEhjGzEjGuir24sNPw+9uQSNsO30XxNXJA7fxgPbFdCb42VUfwet1/zGJ8O5GvwVpeLkZkEJxFGhbtRjT3UczVv71n8Ndp+i0wN57uL0Kk4JmjsNIxDMeE55fvtzzYwPveiHrtRspYgBWQutzCZGxlr2CTQM7lsV+9qxtqvPHxF1E1Qa1Eq4vTfd0Y8hekeaMdjOQdfC3Wpryn8z2lhTbI0qwQTzsIodwkIcQYcgXZA7qaZZ7Hd1ZdwM93CKokok/UIP+5MmtrDiC8Rn6s5q9/3n79un/3an1nDldPftpltXmtHPr2bq21jeGxPXATwVOOPzZ2pmvfuzipJv8/8uSR5TXDZx5Lg5z7j5UeknvE6iDMdOZdgFt0j/AxPb/PDpLh7FO6Kgqv8nDpee9VIF6/5+z5/ozmfzRN97d19LdPxGuXknq4iZsTbXPdILx5belrUju4Ghj1McUjL5yba54oZ7HvtzAz//X+sUX3uUD5S1Onir2GeGUPY3a61NfCx1DQdAU3nzO5a7lrk0u9lLvs/1+c+Fo5kn5b6uaH0EF97j3YXXuYyAQ5TC4+moi5k6OpxbSH3LOfXeuS3NN9Lt2b41LL+HwP8vaE2c1UDib0KamsrZAbbLye3auEb07haCb/vrv3l2ccm4H++vPG3cL/2Vr83AlcIkeBrTck+VLXjmO5+gX5tHeO5D/Crg/25Hpr4tVpsX3smf19ctAc7MHMR40rus16a0d7Ffu6ufK6c2od/+BtYbif3vwMADydd0XelVe4AAAAASUVORK5CYII=",
						function(c) {
							for (var d = 0; d < g.length; d++) {
								var e = g[d].geometry.coordinates.map(function(a) {
									return new(Function.prototype.bind.apply(da.Vector3, [null].concat(Eo(b.normizedPoint(a)))))
								});
								e = a.createFlyLine({
									originalData: g[d],
									curveData: e,
									texture: c
								});
								a.flyLine.add(e)
							}
							b.add(a.flyLine)
						})
				}
			}, {
				key: "createFlyLine",
				value: function(a) {
					var b = this.options,
						c = b.color,
						g = b.textureColor,
						k = b.textureWidth,
						l = a.originalData,
						m = a.curveData;
					a = a.texture;
					var n = Math.random();
					b = Math.min(1, 1 - b.textureLength / 100);
					b = Math.max(0, b);
					"[object Function]" ===
					Object.prototype.toString.call(c) && (c = c(l));
					"[object Function]" === Object.prototype.toString.call(g) && (g = g(l));
					l = new da.Geometry;
					l.vertices = m;
					l.verticesNeedUpdate = !0;
					c = new da.LineBasicMaterial({
						linewidth: 1,
						color: new da.Color(c),
						blending: da.AdditiveBlending,
						depthTest: !0,
						depthWrite: !1,
						transparent: !0,
						opacity: .3,
						linecap: "round",
						linejoin: "round"
					});
					c = new da.Line(l, c);
					c.renderDepth = !1;
					c.hash = n;
					l = new it;
					for (var p = new da.Geometry, q = 0; q < m.length; q++) {
						var u = m[q];
						p.vertices.push(new da.Vector3(u.x, u.y, u.z))
					}
					l.setGeometry(p,
						function(a) {
							return 1 - a
						});
					g = new jt({
						map: a,
						useMap: !0,
						color: new da.Color(g),
						opacity: 1,
						dashArray: this.staticDashArray + n,
						dashOffset: 0,
						dashRatio: b,
						sizeAttenuation: !0,
						lineWidth: k,
						depthWrite: !1,
						depthTest: !0,
						alphaTest: !1,
						transparent: !0,
						blending: da.AdditiveBlending,
						side: da.DoubleSide
					});
					g = new da.Mesh(l.geometry, g);
					c.add(g);
					return c
				}
			}]);
			return b
		}(Pl);
	yc.THREE = da;
	yc.PostProcessing = gt;
	yc.FanLayer = ht;
	yc.FlyLineLayer = kt;
	yc.ThreeLayer = Go;
	Object.defineProperty(yc, "__esModule", {
		value: !0
	})
});
